# Seguridad de Github

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de Github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## ¿Qué es Github?

(De [aquí](https://kinsta.com/knowledgebase/what-is-github/)) En términos generales, **GitHub es un sitio web y un servicio basado en la nube que ayuda a los desarrolladores a almacenar y administrar su código, así como a rastrear y controlar los cambios en su código**.

### Información básica

{% content-ref url="basic-github-information.md" %}
[basic-github-information.md](basic-github-information.md)
{% endcontent-ref %}

## Recon externo

Los repositorios de Github se pueden configurar como públicos, privados e internos.

* **Privado** significa que **solo** las personas de la **organización** podrán acceder a ellos.
* **Interno** significa que **solo** las personas de la **empresa** (una empresa puede tener varias organizaciones) podrán acceder a él.
* **Público** significa que **todo internet** podrá acceder a él.

En caso de que conozcas el **usuario, repositorio u organización que deseas atacar**, puedes usar **dorks de Github** para encontrar información confidencial o buscar **filtraciones de información confidencial en cada repositorio**.

### Dorks de Github

Github permite **buscar algo especificando como alcance un usuario, un repositorio o una organización**. Por lo tanto, con una lista de cadenas que van a aparecer cerca de información confidencial, puedes **buscar fácilmente información confidencial potencial en tu objetivo**.

Herramientas (cada herramienta contiene su lista de dorks):

* [https://github.com/obheda12/GitDorker](https://github.com/obheda12/GitDorker) ([Lista de dorks](https://github.com/obheda12/GitDorker/tree/master/Dorks))
* [https://github.com/techgaun/github-dorks](https://github.com/techgaun/github-dorks) ([Lista de dorks](https://github.com/techgaun/github-dorks/blob/master/github-dorks.txt))
* [https://github.com/hisxo/gitGraber](https://github.com/hisxo/gitGraber) ([Lista de dorks](https://github.com/hisxo/gitGraber/tree/master/wordlists))

### Filtraciones de Github

Ten en cuenta que los dorks de Github también están destinados a buscar filtraciones utilizando opciones de búsqueda de Github. Esta sección está dedicada a aquellas herramientas que **descargarán cada repositorio y buscarán información confidencial en ellos** (incluso verificando cierta profundidad de confirmaciones).

Herramientas (cada herramienta contiene su lista de expresiones regulares):

* [https://github.com/zricethezav/gitleaks](https://github.com/zricethezav/gitleaks)
* [https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)
* [https://github.com/eth0izzle/shhgit](https://github.com/eth0izzle/shhgit)
* [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob)
* [https://github.com/anshumanbh/git-all-secrets](https://github.com/anshumanbh/git-all-secrets)
* [https://github.com/kootenpv/gittyleaks](https://github.com/kootenpv/gittyleaks)
* [https://github.com/awslabs/git-secrets](https://github.com/awslabs/git-secrets)

{% hint style="warning" %}
Cuando busques filtraciones en un repositorio y ejecutes algo como `git log -p`, ¡no olvides que puede haber **otras ramas con otras confirmaciones** que contengan secretos!
{% endhint %}

### Forks externos

Es posible **comprometer repositorios abusando de las solicitudes de extracción**. Para saber si un repositorio es vulnerable, principalmente necesitas leer las configuraciones yaml de Github Actions. [**Más información sobre esto a continuación**](./#execution-from-a-external-fork).

## Fortalecimiento de la organización

### Privilegios de los miembros

Hay algunos **privilegios predeterminados** que se pueden asignar a los **miembros** de la organización. Estos se pueden controlar desde la página `https://github.com/organizations/<org_name>/settings/member_privileges` o desde la [**API de Organizaciones**](https://docs.github.com/en/rest/orgs/orgs).

* **Permisos base**: Los miembros tendrán los permisos Ninguno/Lectura/escritura/Administrador sobre los repositorios de la organización. Se recomienda **Ninguno** o **Lectura**.
* **Creación de repositorios bifurcados**: Si no es necesario, es mejor **no permitir** a los miembros bifurcar los repositorios de la organización.
* **Creación de páginas**: Si no es necesario, es mejor **no permitir** a los miembros publicar páginas desde los repositorios de la organización. Si es necesario, puedes permitir crear páginas públicas o privadas.
* **Solicitudes de acceso a integraciones**: Con esto habilitado, los colaboradores externos podrán solicitar acceso para que las aplicaciones de GitHub o OAuth accedan a esta organización y sus recursos. Por lo general, se necesita, pero si no, es mejor deshabilitarlo.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Cambio de visibilidad del repositorio**: Si está habilitado, los **miembros** con permisos de **administrador** para el **repositorio** podrán **cambiar su visibilidad**. Si está deshabilitado, solo los propietarios de la organización pueden cambiar las visibilidades del repositorio. Si **no** quieres que las personas hagan cosas **públicas**, asegúrate de que esto esté **deshabilitado**.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Eliminación y transferencia de repositorios**: Si está habilitado, los miembros con permisos de **administrador** para el repositorio podrán **eliminar** o **transferir** repositorios **públicos y privados**.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Permitir que los miembros creen equipos**: Si está habilitado, cualquier **miembro** de la organización podrá **crear** nuevos **equipos**. Si está deshabilitado, solo los propietarios de la organización pueden crear nuevos equipos. Es mejor tener esto deshabilitado.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Se pueden configurar más cosas** en esta página, pero las anteriores son las más relacionadas con la seguridad.

### Configuración de acciones

Se pueden configurar varias opciones de seguridad relacionadas con las acciones desde la página `https://github.com/organizations/<org_name>/settings/actions`.

{% hint style="info" %}
Ten en cuenta que todas estas configuraciones también se pueden establecer en cada repositorio de forma independiente.
{% endhint %}

* **Políticas
### Con credenciales de usuario

Si ya tienes credenciales de un usuario dentro de una organización, puedes **iniciar sesión** y verificar qué **roles de organización y empresa tienes**, si eres un miembro crudo, verificar qué **permisos tienen los miembros crudos**, en qué **grupos** estás, qué **permisos tienes** sobre qué **repositorios** y **cómo están protegidos los repositorios**.

Ten en cuenta que **se puede usar 2FA**, por lo que solo podrás acceder a esta información si también puedes **pasar esa verificación**.

{% hint style="info" %}
Ten en cuenta que si **logras robar la cookie `user_session`** (actualmente configurada con SameSite: Lax), puedes **suplantar completamente al usuario** sin necesidad de credenciales o 2FA.
{% endhint %}

Revisa la sección a continuación sobre [**bypasses de protección de rama**](./#bypass-de-protección-de-rama) en caso de que sea útil.

### Con clave SSH de usuario

Github permite que los **usuarios** establezcan **claves SSH** que se utilizarán como **método de autenticación para implementar código** en su nombre (no se aplica 2FA).

Con esta clave, puedes realizar **cambios en los repositorios donde el usuario tiene algunos privilegios**, sin embargo, no puedes usarla para acceder a la API de Github para enumerar el entorno. Sin embargo, puedes obtener **configuraciones locales** para obtener información sobre los repositorios y el usuario al que tienes acceso:

```bash
# Ir a la carpeta del repositorio
# Obtener la configuración del repositorio y el nombre de usuario y correo electrónico actual
git config --list
```

Si el usuario ha configurado su nombre de usuario como su nombre de usuario de Github, puedes acceder a las **claves públicas que ha establecido** en su cuenta en _https://github.com/\<github\_username>.keys_, puedes verificar esto para confirmar que la clave privada que encontraste se puede usar.

Las **claves SSH** también se pueden establecer en los repositorios como **claves de implementación**. Cualquier persona con acceso a esta clave podrá **lanzar proyectos desde un repositorio**. Por lo general, en un servidor con diferentes claves de implementación, el archivo local **`~/.ssh/config`** te dará información sobre la clave relacionada.

#### Claves GPG

Como se explica [**aquí**](broken-reference/), a veces es necesario firmar los commits o podrías ser descubierto.

Verifica localmente si el usuario actual tiene alguna clave con:

```shell
gpg --list-secret-keys --keyid-format=long
```

### Con token de usuario

Para obtener una introducción sobre [**tokens de usuario, verifica la información básica**](basic-github-information.md#personal-access-tokens).

Se puede usar un token de usuario **en lugar de una contraseña** para Git sobre HTTPS, o se puede usar para [**autenticarse en la API mediante autenticación básica**](https://docs.github.com/v3/auth/#basic-authentication). Dependiendo de los privilegios adjuntos, es posible que pueda realizar diferentes acciones.

Un token de usuario se ve así: `ghp_EfHnQFcFHX6fGIu5mpduvRiYR584kK0dX123`

### Con aplicación Oauth

Para obtener una introducción sobre [**aplicaciones Oauth de Github, verifica la información básica**](basic-github-information.md#oauth-applications).

Un atacante podría crear una **aplicación Oauth maliciosa** para acceder a datos / acciones privilegiados de los usuarios que los aceptan, probablemente como parte de una campaña de phishing.

Estos son los [alcances que una aplicación Oauth puede solicitar](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps). Siempre se debe verificar los alcances solicitados antes de aceptarlos.

Además, como se explica en la información básica, **las organizaciones pueden otorgar / denegar acceso a aplicaciones de terceros** a información / repositorios / acciones relacionados con la organización.

### Con aplicación Github

Para obtener una introducción sobre [**aplicaciones de Github, verifica la información básica**](basic-github-information.md#github-applications).

Un atacante podría crear una **aplicación Github maliciosa** para acceder a datos / acciones privilegiados de los usuarios que los aceptan, probablemente como parte de una campaña de phishing.

Además, como se explica en la información básica, **las organizaciones pueden otorgar / denegar acceso a aplicaciones de terceros** a información / repositorios / acciones relacionados con la organización.

## Abusando de Github Action

Para obtener una introducción sobre [**Github Actions, verifica la información básica**](basic-github-information.md#github-actions).

En caso de que puedas **ejecutar acciones de Github arbitrarias** en un **repositorio**, puedes **robar los secretos de ese repositorio**.

### Ejecución desde la creación del repositorio

En caso de que los miembros de una organización puedan **crear nuevos repositorios** y puedas ejecutar acciones de Github, puedes **crear un nuevo repositorio y robar los secretos establecidos a nivel de organización**.

### Ejecución desde una nueva rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una acción de Github** configurada, puedes **modificarla**, **cargar** el contenido y luego **ejecutar esa acción desde la nueva rama**. De esta manera, puedes **filtrar secretos a nivel de repositorio y organización** (pero necesitas saber cómo se llaman).

Puedes hacer que la acción modificada sea ejecutable **manualmente**, cuando se **crea una solicitud de extracción** o cuando se **envía algún código** (dependiendo de cuán ruidoso quieras ser):

```yaml
on:
  workflow_dispatch: # Ejecutar manualmente
  pull_request: # Ejecutar cuando se crea una solicitud de extracción a una rama
    branches:
      - master
  push: # Ejecutar cuando se realiza un push a una rama
    branches:
      - current_branch_name

# Usa '**' en lugar de un nombre de rama para activar la acción en todas las ramas
```

### Ejecución desde un fork externo

Si un repositorio está utilizando acciones de Github, un atacante podría **crear una solicitud de extracción desde un repositorio bifurcado** inyectando **código malicioso** en el **flujo de trabajo** de Github, y podría **comprometer el repositorio de Github** de esa manera.

#### `pull_request`

El desencadenador de flujo de trabajo **`pull_request`** por defecto **evita los permisos de escritura** y el **acceso a secretos** en el repositorio de destino. Además, por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** deberá **aprobar** la **ejecución** del flujo de trabajo:

<figure><img src="../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la limitación **predeterminada** es para **contribuyentes de primera vez**, podrías contribuir **solucionando un error válido** y luego enviar **otras solicitudes de extracción para abusar de tus nuevos privilegios de `pull_request`**.

**Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminó su cuenta.~~
{% endhint %}

Sin embargo, para **evitar** la **compromiso** del **repositorio** a través de **`pull_request`**, esto se menciona en la [**documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepción de `GITHUB_TOKEN`, **no se pasan secretos al runner** cuando se activa un flujo de trabajo desde un repositorio bifurcado. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en las solicitudes de extracción **de los repositorios bifurcados**.

Un atacante podría modificar la definición de la Acción de Github para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podrá robar secretos o sobrescribir el repositorio debido a las limitaciones mencionadas.

Sin embargo, incluso si la acción no menciona Artefactos, ¿podría modificar un Artefacto del repositorio cambiando la acción?? (TODO).

{% hint style="danger" %}
**Sí, si el atacante cambia en la PR la acción de Github que se activará, su Acción de Github será la que se usará y no la del repositorio de origen.**
{% endhint %}

_Sin embargo, enviar una nueva acción que se activa en pull\_request no se activará._
#### **`pull_request_target`**

Sin embargo, el desencadenador de flujo de trabajo **`pull_request_target`** tiene **permiso de escritura** en el repositorio de destino y **acceso a secretos** (y no solicita permiso).

Tenga en cuenta que el desencadenador de flujo de trabajo **`pull_request_target`** se ejecuta en el contexto base y no en el proporcionado por el PR (para no ejecutar código no confiable). Para obtener más información sobre `pull_request_target`, [**consulte la documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\
Además, para obtener más información sobre este uso peligroso específico, consulte este [**post del blog de Github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Puede parecer que debido a que el flujo de trabajo ejecutado es el definido en la base y no en el PR, es seguro usar **`pull_request_target`**, pero hay algunos casos en los que no lo es.

#### Inyección de script a través de variables controladas por el atacante

Github establece [variables de entorno predeterminadas](https://docs.github.com/en/actions/learn-github-actions/environment-variables) y si se utilizan contextos, [incluye más](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context). Si alguno de esos **valores** se utiliza en un lugar **peligroso** dentro del flujo de trabajo y puede ser **controlado por el atacante**, podría producirse una **inyección de comandos**.\
Esta vulnerabilidad también se [**explica más adelante en esta publicación**](./#understanding-the-risk-of-script-injections).

#### Ejecución de checkout no confiable

Si la víctima está usando **`pull_request`** o similar para desencadenar la acción, no se aceptará ningún PR de un fork **hasta que sea aprobado específicamente**. La acción se ejecutará entonces en el contexto del PR (bueno porque eso significa que ejecutará el código dentro del fork de PR), pero **alguien debe aprobarlo primero**.

Si la víctima configuró el checkout para usar explícitamente el desencadenador **`pull_request_target`**, siempre se ejecutará, pero utilizando el código del repositorio base (no el del PR), por lo que el atacante no puede controlar el código ejecutado.\
Sin embargo, si la acción tiene un **checkout explícito de PR** que **obtendrá el código del PR** (y no de la base), se utilizará el código controlado por el atacante. Por ejemplo (ver línea 12 donde se descarga el código PR):

```yaml
# INSEGURO. Proporcionado solo como ejemplo.
on:
  pull_request_target

jobs:
  build:
    name: Build and test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        ref: ${{ github.event.pull_request.head.sha }}

    - uses: actions/setup-node@v1
    - run: |
        npm install
        npm build

    - uses: completely/fakeaction@v2
      with:
        arg1: ${{ secrets.supersecret }}

    - uses: fakerepo/comment-on-pr@v1
      with:
        message: |
          Thank you!
```

El código potencialmente **no confiable se está ejecutando durante `npm install` o `npm build`** ya que los scripts de compilación y los paquetes de referencia están controlados por el autor del PR.

{% hint style="danger" %}
Si la acción se ejecuta en un runner autohospedado, el atacante podría ser capaz de comprometerlo aún más.
{% endhint %}

Un dork de Github para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml`, sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acción está configurada de manera insegura (como usar condicionales sobre quién es el actor que genera el PR).

### Inyección/Backdoor de Github Action

En caso de que de alguna manera haya logrado **infiltrarse dentro de una Github Action**, si puede escalar privilegios, puede **robar secretos de los procesos donde se han establecido secretos**. En algunos casos, ni siquiera es necesario escalar privilegios.

```bash
cat /proc/<proc_number>/environ
cat /proc/*/environ | grep -i secret #Suponiendo que el nombre de la variable de entorno contiene "secret"
```

### Acceso de Github Action a AWS y GCP a través de OIDC

Consulte las siguientes páginas:

{% content-ref url="../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Información sensible en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de acciones y **evitar mostrarlos**, **otros datos sensibles** que podrían haberse generado en la ejecución de la acción no se ocultarán. Por ejemplo, un JWT firmado con un valor secreto no se ocultará a menos que se [configure específicamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

### GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se da por **defecto** permisos de lectura y **escritura** **al repositorio**. Este token es el mismo que usará una **aplicación de Github**, por lo que puede acceder a los mismos endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github debería lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que permita el acceso **entre repositorios** dentro de GitHub, para que un repositorio pueda acceder a otros repositorios internos usando el `GITHUB_TOKEN`.
{% endhint %}

Puede ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Tenga en cuenta que el token **caduca después de que se completa el trabajo**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puede hacer con este token:

```bash
# Merge PR
curl -X PUT \
    https://api.github.com
#### Ejemplo de ataque de inyección de script <a href="#example-of-a-script-injection-attack" id="example-of-a-script-injection-attack"></a>

Un ataque de inyección de script puede ocurrir directamente dentro del script en línea de un flujo de trabajo. En el siguiente ejemplo, una acción utiliza una **expresión para probar la validez del título de una solicitud de extracción**, pero también agrega el riesgo de inyección de script:

```yaml
      - name: Check PR title
        run: |
          title="${{ github.event.pull_request.title }}"
          if [[ $title =~ ^octocat ]]; then
          echo "PR title starts with 'octocat'"
          exit 0
          else
          echo "PR title did not start with 'octocat'"
          exit 1
          fi
```

Antes de que se ejecute el script de shell, las expresiones dentro de `${{ }}` se **evalúan** y luego se sustituyen por los valores resultantes, lo que puede hacerlo **vulnerable a la inyección de comandos de shell**.

Para inyectar comandos en este flujo de trabajo, el atacante podría crear una solicitud de extracción con un título de `a"; ls $GITHUB_WORKSPACE"`:

![Ejemplo de inyección de script en el título de la solicitud de extracción](https://docs.github.com/assets/cb-24920/images/help/images/example-script-injection-pr-title.png)

En este ejemplo, el carácter `"` se utiliza para interrumpir la declaración `title="${{ github.event.pull_request.title }}"`, permitiendo que se ejecute el comando `ls` en el runner. Puede ver la salida del comando `ls` en el registro:

![Ejemplo de resultado de inyección de script](https://docs.github.com/assets/cb-28350/images/help/images/example-script-injection-result.png)

### Acceso a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si está inyectando contenido en un script, es interesante saber cómo puede acceder a secretos:

* Si el secreto o token se establece en una **variable de entorno**, se puede acceder directamente a través del entorno usando **`printenv`**.
* Si el secreto se utiliza **directamente en una expresión**, el script de shell generado se almacena **en disco** y es accesible.
*   Para una **acción personalizada**, el riesgo puede variar según cómo un programa esté utilizando el secreto que obtuvo del **argumento**:

    ```
    uses: fakeaction/publish@v3
    with:
        key: ${{ secrets.PUBLISH_KEY }}
    ```

### Abuso de runners autohospedados

La forma de encontrar qué **Acciones de Github se están ejecutando en infraestructura no-Github** es buscar `runs-on: self-hosted` en la configuración yaml de la Acción de Github.

Los runners **autohospedados** podrían tener acceso a **información extra sensible**, a otros **sistemas de red** (¿puntos finales vulnerables en la red? ¿servicio de metadatos?) o, aunque esté aislado y destruido, **más de una acción podría ejecutarse al mismo tiempo** y la malintencionada podría **robar los secretos** de la otra.

### Envenenamiento de caché

Usar la acción de Git [**action/cache**](https://github.com/actions/cache) en cualquier CI ejecutará dos pasos: un paso tendrá lugar durante la **ejecución** del proceso cuando se llama y el otro tendrá lugar después del **flujo de trabajo** (si la acción de ejecución devolvió un cache-miss).

* **Acción de ejecución** - se utiliza para buscar y recuperar la caché. La búsqueda se realiza utilizando la clave de caché, y el resultado es una caché-hit (éxito, se encontraron datos en la caché) o una caché-miss. Si se encuentra, los archivos y directorios se recuperan de la caché para su uso activo. Si el resultado es una caché-miss, los archivos y directorios deseados se descargan como si fuera la primera vez que se llaman.
* **Acción posterior al flujo de trabajo** - se utiliza para guardar la caché. Si el resultado de la llamada de caché en la acción de ejecución devuelve una caché-miss, esta acción guardará el estado actual de los directorios que queremos cachear con la clave proporcionada. Esta acción se produce automáticamente y no necesita ser llamada explícitamente.

Las **restricciones de acceso** proporcionan **aislamiento de caché** y seguridad al crear un **límite lógico entre diferentes ramas** _(por ejemplo: una caché creada para la rama **Feature-A** \[con la base principal] no sería accesible para una solicitud de extracción para la rama **Feature-B** \[con la base principal])_.

La acción de caché primero busca aciertos de caché para una clave y restaura las claves en la rama que contiene la **ejecución del flujo de trabajo**. Si no hay aciertos en la rama actual, la acción de caché busca la clave y restaura las claves en la rama principal y las ramas ascendentes.

El acceso a una caché está limitado por rama (actual y principal), lo que significa que se proporciona acceso a todos los **flujos de trabajo** en todas las **ejecuciones** de dicha rama.

Otro dato importante es que GitHub no permite modificaciones una vez que se han enviado las entradas: las entradas de caché son registros de solo lectura.

Utilizamos un ejemplo de CI que incluía dos flujos de trabajo. Este ejemplo muestra cómo un ataque puede pivotar desde un flujo de trabajo de baja permisión a uno de alta permisión.

* **Flujo de trabajo de prueba unitaria** que ejecuta herramientas de prueba unitaria y cobertura de código. Suponemos que una de las herramientas es maliciosa o vulnerable a la ejecución remota de código. El flujo de trabajo no necesita usar la acción de Git **action/cache**. Cualquier flujo de trabajo puede acceder a la caché.
* **Flujo de trabajo de lanzamiento** que construye y lanza el artefacto de la aplicación. Este flujo de trabajo utiliza una caché para optimizar el uso de las dependencias de Golang.

El flujo de trabajo de **prueba unitaria** utiliza una acción maliciosa que agrega una entrada de caché con contenido malicioso cambiando una biblioteca de registro de Golang (**go.uber.org/zap@v1**) para agregar la cadena 'BAD library' a la descripción del artefacto de la aplicación.

A continuación, el flujo de trabajo de **lanzamiento** utiliza esta entrada de caché envenenada. Como resultado, el código malicioso se inyecta en el binario y la imagen de Golang construida. La caché permanece envenenada hasta que se descarta la clave de entrada (generalmente desencadenada por actualizaciones de dependencias). La misma caché envenenada afectará a cualquier otro **flujo de trabajo**, **ejecución** y **rama secundaria** que utilice la misma clave de caché.

En la prueba que realizamos, logramos inyectar la cadena 'BAD library' en la descripción de la imagen:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

Esto fue en la versión 0.4.1. A continuación, actualizamos la etiqueta y reconstruimos la imagen varias veces, y observamos que 'Bad library' seguía en la descripción.

Esta técnica fue tomada de [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

### Envenenamiento de artefactos

Hay varias acciones de Github que permiten **descargar artefactos de otros repositorios**. Estos otros repositorios suelen tener una acción de Github para **subir el artefacto** que luego se descargará.\
Si la **acción de Github** del repositorio que carga el artefacto permite el **`pull_request`** o **`pull_request_target`** (usando el código del atacante), un atacante podrá activar la acción que cargará un artefacto creado a partir de su código, por lo que cualquier otro repositorio que descargue y ejecute el último artefacto será comprometido.

{% hint style="info" %}
Como se mencionó en una sección de esta publicación, las **`pull_requests`** suelen **requerir una aprobación manual** de un mantenedor del repositorio.
{% endhint %}

Ejemplo de **descarga de artefactos de un repositorio diferente**:

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Como se mencionó anteriormente, en un desencadenador de **`pull_request`**, la acción definida en la PR es la que se ejecuta. Por lo tanto, un **atacante** podría **definir** allí la **carga de artefactos** que le gustaría comprometer.

Por lo tanto, un atacante no necesita atacar un desencadenador de **`pull_request`** en la acción de carga de artefactos, sino simplemente cualquier desencadenador de **`pull_request`**.
{% endhint %}

Para obtener más información y opciones de defensa (como codificar en duro el artefacto a descargar), consulte [https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust](https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust)
### Secuestro de repositorio de espacio de nombres eliminado

Este es un buen artículo para leer sobre vulnerabilidades corregidas que permitirían a un atacante robar un espacio de nombres eliminado para robar un repositorio famoso (potencialmente debido a un cambio de nombre del espacio de nombres): [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

### Registro de imágenes Docker de Github

Es posible hacer acciones de Github que **compilen y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Acción de Github para compilar y subir una imagen Docker</summary>

```yaml
[...]

- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
  uses: docker/login-action@v1
  with:
    registry: ghcr.io
    username: ${{ github.repository_owner }}
    password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
  run: |
    sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
  uses: docker/build-push-action@v2
    with:
      context: .
      push: true
      tags: |
        ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
        ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```

</details>

Como se puede ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podrá descargar la imagen Docker usando un token de acceso personal:

```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```

Luego, el usuario podría buscar **secretos filtrados en las capas de la imagen Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

## Bypass de protección de rama

* **Requerir un número de aprobaciones**: Si compromete varias cuentas, puede aceptar sus PR desde otras cuentas. Si solo tiene la cuenta desde la que creó el PR, no puede aceptar su propio PR. Sin embargo, si tiene acceso a un entorno de **Github Action** dentro del repositorio, usando el **GITHUB\_TOKEN** podría **aprobar su PR** y obtener 1 aprobación de esta manera.
  * _Nota para esto y para la restricción de propietarios de código que generalmente un usuario no podrá aprobar sus propios PR, pero si lo hace, puede abusar de él para aceptar sus PR._
* **Descartar aprobaciones cuando se empujan nuevos commits**: Si esto no está configurado, puede enviar código legítimo, esperar a que alguien lo apruebe y poner código malicioso y fusionarlo en la rama protegida.
* **Requerir revisiones de los propietarios de código**: Si está activado y es un propietario de código, podría hacer que una **Github Action cree su PR y luego lo apruebe usted mismo**.
  * Cuando un archivo **CODEOWNER está mal configurado**, Github no se queja pero no lo usa. Por lo tanto, si está mal configurado, **no se aplica la protección de propietarios de código**.
* **Permitir que actores específicos eviten los requisitos de solicitud de extracción**: Si es uno de estos actores, puede evitar las protecciones de solicitud de extracción.
* **Incluir administradores**: Si esto no está configurado y es administrador del repositorio, puede evitar estas protecciones de rama.
* **Secuestro de PR**: Podría ser capaz de **modificar el PR de otra persona** agregando código malicioso, aprobando el PR resultante usted mismo y fusionando todo.
* **Eliminación de protecciones de rama**: Si es un **administrador del repositorio, puede desactivar las protecciones**, fusionar su PR y volver a establecer las protecciones.
* **Bypass de protecciones de empuje**: Si un repositorio **solo permite que ciertos usuarios** envíen empujes (fusionar código) en ramas (la protección de rama podría estar protegiendo todas las ramas especificando el comodín `*`).
  * Si tiene **permisos de escritura sobre el repositorio pero no se le permite enviar código** debido a la protección de la rama, aún puede **crear una nueva rama** y dentro de ella crear una **Github Action que se activa cuando se empuja código**. Como la **protección de rama no protegerá la rama hasta que se cree**, este primer empuje de código a la rama **ejecutará la acción de Github**.

## Bypass de protecciones de entornos

Para una introducción sobre [**Github Environment, consulte la información básica**](basic-github-information.md#git-environments).

En caso de que se pueda **acceder a un entorno desde todas las ramas**, no está **protegido** y puede acceder fácilmente a los secretos dentro del entorno. Tenga en cuenta que puede encontrar repositorios donde **todas las ramas están protegidas** (especificando sus nombres o usando `*`) en ese escenario, **encuentre una rama donde pueda enviar código** y puede **filtrar** los secretos creando una nueva acción de Github (o modificando una).

Tenga en cuenta que puede encontrar el caso extremo donde **todas las ramas están protegidas** (a través del comodín `*`) se especifica **quién puede enviar código a las ramas** (_puede especificarlo en la protección de la rama_) y **su usuario no está permitido**. Todavía puede ejecutar una acción personalizada de Github porque puede crear una rama y usar el disparador de empuje sobre sí misma. La **protección de la rama permite el empuje a una nueva rama, por lo que se activará la acción de Github**.

```yaml
  push: # Ejecútelo cuando se realiza un empuje a una rama
    branches:
      - current_branch_name #Use '**' para ejecutar cuando se realiza un empuje a cualquier rama
```

Tenga en cuenta que **después de la creación** de la rama, la **protección de la rama se aplicará a la nueva rama** y no podrá modificarla, pero para ese momento ya habrá filtrado los secretos.

## Persistencia

* Generar un **token de usuario**
* Robar **tokens de Github** de **secretos**
  * **Eliminación** de **resultados** de flujo de trabajo y **ramas**
* Dar **más permisos a toda la organización**
* Crear **webhooks** para filtrar información
* Invitar a **colaboradores externos**
* **Eliminar** **webhooks** utilizados por el **SIEM**
* Crear/modificar **Github Action con una puerta trasera**
* Encontrar una **Github Action vulnerable a la inyección de comandos** a través de la modificación del valor **secreto**

### Commits de impostores - Puerta trasera a través de los commits del repositorio

En Github es posible **crear un PR a un repositorio desde un fork**. Incluso si el PR **no es aceptado**, se creará un id de **commit** dentro del repositorio original para la versión de fork del código. Por lo tanto, un atacante **podría fijarse en usar un commit específico de un repositorio aparentemente legítimo que no fue creado por el propietario del repositorio**.

Como [**este**](https://github.com/actions/checkout/commit/c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e):

```yaml
name: example
on: [push]
jobs:
 commit:
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e
     - shell: bash
       run: |
         echo 'hello world!'
```

Para obtener más información, consulte [https://www.chainguard.dev/unchained/what-the-fork-imposter-comm