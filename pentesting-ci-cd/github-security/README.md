# Seguridad de Github

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).

* **Comparte tus trucos de hacking enviando PRs a los repositorios de Github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## ¿Qué es Github?

(De [aquí](https://kinsta.com/knowledgebase/what-is-github/)) A alto nivel, **Github es un sitio web y un servicio basado en la nube que ayuda a los desarrolladores a almacenar y administrar su código, así como a rastrear y controlar los cambios en su código**.

### Información básica

{% content-ref url="basic-github-information.md" %}
[basic-github-information.md](basic-github-information.md)
{% endcontent-ref %}

## Reconocimiento externo

Los repositorios de Github se pueden configurar como públicos, privados e internos.

* **Privado** significa que **solo** las personas de la **organización** podrán acceder a ellos.
* **Interno** significa que **solo** las personas de la **empresa** (una empresa puede tener varias organizaciones) podrán acceder a él.
* **Público** significa que **todo internet** podrá acceder a él.

En caso de que conozcas el **usuario, repositorio u organización que deseas atacar**, puedes usar **dorks de Github** para encontrar información confidencial o buscar **filtraciones de información confidencial en cada repositorio**.

### Dorks de Github

Github permite **buscar algo especificando como alcance un usuario, un repositorio o una organización**. Por lo tanto, con una lista de cadenas que van a aparecer cerca de información confidencial, puedes **buscar fácilmente información confidencial potencial en tu objetivo**.

Herramientas (cada herramienta contiene su lista de dorks):

* [https://github.com/obheda12/GitDorker](https://github.com/obheda12/GitDorker) ([Lista de dorks](https://github.com/obheda12/GitDorker/tree/master/Dorks))
* [https://github.com/techgaun/github-dorks](https://github.com/techgaun/github-dorks) ([Lista de dorks](https://github.com/techgaun/github-dorks/blob/master/github-dorks.txt))
* [https://github.com/hisxo/gitGraber](https://github.com/hisxo/gitGraber) ([Lista de dorks](https://github.com/hisxo/gitGraber/tree/master/wordlists))

### Filtraciones de Github

Ten en cuenta que los dorks de Github también están destinados a buscar filtraciones utilizando opciones de búsqueda de Github. Esta sección está dedicada a aquellas herramientas que **descargarán cada repositorio y buscarán información confidencial en ellos** (incluso verificando cierta profundidad de confirmaciones).

Herramientas (cada herramienta contiene su lista de expresiones regulares):

* [https://github.com/zricethezav/gitleaks](https://github.com/zricethezav/gitleaks)
* [https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)
* [https://github.com/eth0izzle/shhgit](https://github.com/eth0izzle/shhgit)
* [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob)
* [https://github.com/anshumanbh/git-all-secrets](https://github.com/anshumanbh/git-all-secrets)
* [https://github.com/kootenpv/gittyleaks](https://github.com/kootenpv/gittyleaks)
* [https://github.com/awslabs/git-secrets](https://github.com/awslabs/git-secrets)

{% hint style="warning" %}
Cuando busques filtraciones en un repositorio y ejecutes algo como `git log -p`, ¡no olvides que puede haber **otras ramas con otras confirmaciones** que contengan secretos!
{% endhint %}

### Forks externos

Es posible **comprometer repositorios abusando de las solicitudes de extracción**. Para saber si un repositorio es vulnerable, principalmente necesitas leer las configuraciones yaml de Github Actions. [**Más información sobre esto a continuación**](./#execution-from-a-external-fork).

## Fortalecimiento de la organización

### Privilegios de miembros

Hay algunos **privilegios predeterminados** que se pueden asignar a los **miembros** de la organización. Estos se pueden controlar desde la página `https://github.com/organizations/<org_name>/settings/member_privileges` o desde la [**API de Organizaciones**](https://docs.github.com/en/rest/orgs/orgs).

* **Permisos base**: Los miembros tendrán el permiso Ninguno/Lectura/escritura/Administrador sobre los repositorios de la organización. Se recomienda **Ninguno** o **Lectura**.
* **Creación de repositorios bifurcados**: Si no es necesario, es mejor **no permitir** a los miembros bifurcar los repositorios de la organización.
* **Creación de páginas**: Si no es necesario, es mejor **no permitir** a los miembros publicar páginas desde los repositorios de la organización. Si es necesario, puedes permitir crear páginas públicas o privadas.
* **Solicitudes de acceso a integraciones**: Con esto habilitado, los colaboradores externos podrán solicitar acceso para que las aplicaciones de GitHub o OAuth accedan a esta organización y sus recursos. Por lo general, se necesita, pero si no, es mejor deshabilitarlo.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Cambio de visibilidad del repositorio**: Si está habilitado, los **miembros** con permisos de **administrador** para el **repositorio** podrán **cambiar su visibilidad**. Si está deshabilitado, solo los propietarios de la organización pueden cambiar las visibilidades del repositorio. Si **no** quieres que las personas hagan cosas **públicas**, asegúrate de que esto esté **deshabilitado**.
  * _No pude encontrar esta información en la respuesta de las APIs, comparte si lo haces_
* **Eliminación y transferencia de repositorios**: Si está habilitado, los miembros con permisos de **administrador** para el repositorio podrán **eliminar** o **transferir** repositorios **públicos y privados**.
  * _No pude encontrar esta información en la respuesta de
### Con la clave SSH del usuario

Github permite a los **usuarios** establecer **claves SSH** que se utilizarán como **método de autenticación para implementar código** en su nombre (no se aplica la autenticación de dos factores).

Con esta clave, puede realizar **cambios en los repositorios donde el usuario tiene algunos privilegios**, sin embargo, no puede usarla para acceder a la API de Github para enumerar el entorno. Sin embargo, puede obtener **enumerar la configuración local** para obtener información sobre los repositorios y el usuario al que tiene acceso:

```bash
# Ir a la carpeta del repositorio
# Obtener la configuración del repositorio y el nombre de usuario y correo electrónico actuales
git config --list
```

Si el usuario ha configurado su nombre de usuario como su nombre de usuario de Github, puede acceder a las **claves públicas que ha establecido** en su cuenta en _https://github.com/\<github\_username>.keys_, puede verificar esto para confirmar que la clave privada que encontró se puede usar.

Las **claves SSH** también se pueden establecer en los repositorios como **claves de implementación**. Cualquier persona con acceso a esta clave podrá **lanzar proyectos desde un repositorio**. Por lo general, en un servidor con diferentes claves de implementación, el archivo local **`~/.ssh/config`** le dará información sobre la clave relacionada.

#### Claves GPG

Como se explica [**aquí**](broken-reference/) a veces es necesario firmar los commits o podrían descubrirte.

Verifique localmente si el usuario actual tiene alguna clave con:

```shell
gpg --list-secret-keys --keyid-format=long
```

### Con el token de usuario

Para obtener una introducción sobre [**los tokens de usuario, consulte la información básica**](basic-github-information.md#personal-access-tokens).

Se puede utilizar un token de usuario **en lugar de una contraseña** para Git a través de HTTPS, o se puede utilizar para [**autenticarse en la API mediante autenticación básica**](https://docs.github.com/v3/auth/#basic-authentication). Dependiendo de los privilegios que se le asignen, es posible que pueda realizar diferentes acciones.

Un token de usuario se ve así: `ghp_EfHnQFcFHX6fGIu5mpduvRiYR584kK0dX123`

### Con la aplicación Oauth

Para obtener una introducción sobre [**las aplicaciones Oauth de Github, consulte la información básica**](basic-github-information.md#oauth-applications).

Un atacante podría crear una **aplicación Oauth maliciosa** para acceder a datos / acciones privilegiados de los usuarios que los aceptan probablemente como parte de una campaña de phishing.

Estos son los [alcances que una aplicación Oauth puede solicitar](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps). Siempre debe verificar los alcances solicitados antes de aceptarlos.

Además, como se explica en la información básica, **las organizaciones pueden otorgar / denegar acceso a aplicaciones de terceros** a información / repos / acciones relacionadas con la organización.

### Con la aplicación Github

Para obtener una introducción sobre [**las aplicaciones de Github, consulte la información básica**](basic-github-information.md#github-applications).

Un atacante podría crear una **aplicación de Github maliciosa** para acceder a datos / acciones privilegiados de los usuarios que los aceptan probablemente como parte de una campaña de phishing.

Además, como se explica en la información básica, **las organizaciones pueden otorgar / denegar acceso a aplicaciones de terceros** a información / repos / acciones relacionadas con la organización.

## Abuso de la acción Github

Para obtener una introducción sobre [**las acciones de Github, consulte la información básica**](basic-github-information.md#github-actions).

En caso de que pueda **ejecutar acciones de Github arbitrarias** en un **repositorio**, puede **robar los secretos de ese repositorio**.

### Ejecución desde la creación del repositorio

En caso de que los miembros de una organización puedan **crear nuevos repositorios** y pueda ejecutar acciones de Github, puede **crear un nuevo repositorio y robar los secretos establecidos a nivel de organización**.

### Ejecución desde una nueva rama

Si puede **crear una nueva rama en un repositorio que ya contiene una acción de Github** configurada, puede **modificarla**, **cargar** el contenido y luego **ejecutar esa acción desde la nueva rama**. De esta manera, puede **filtrar secretos de nivel de repositorio y organización** (pero debe saber cómo se llaman).

Puede hacer que la acción modificada sea ejecutable **manualmente**, cuando se **crea una solicitud de extracción** o cuando se **envía algún código** (dependiendo de cuán ruidoso quiera ser):

```yaml
on:
  workflow_dispatch: # Ejecutar manualmente
  pull_request: # Ejecutar cuando se crea una solicitud de extracción a una rama
    branches:
      - master
  push: # Ejecutar cuando se realiza un push a una rama
    branches:
      - current_branch_name

# Use '**' en lugar de un nombre de rama para activar la acción en todas las ramas
```

### Ejecución desde un fork externo

Si un repositorio está utilizando acciones de Github, un atacante podría ser capaz de **crear una solicitud de extracción desde un repositorio bifurcado** inyectando **código malicioso** en el **flujo de trabajo** de Github, y podría ser capaz de **comprometer el repositorio de Github** de esa manera.

#### `pull_request`

El desencadenador de flujo de trabajo **`pull_request`** por defecto **impide los permisos de escritura** y el **acceso a secretos** al repositorio de destino. Además, por defecto, si es la **primera vez** que está **colaborando**, algún **mantenedor** deberá **aprobar** la **ejecución** del flujo de trabajo:

<figure><img src="../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la **limitación predeterminada** es para los colaboradores de **primera vez**, podría contribuir **solucionando un error válido** y luego enviar **otras solicitudes de extracción para abusar de sus nuevos privilegios de `pull_request`**.

**Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminó su cuenta.~~
{% endhint %}

Sin embargo, para **evitar** la **compromiso** del **repositorio** a través de **`pull_request`**, esto se menciona en la [**documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepción de `GITHUB_TOKEN`, **no se pasan secretos al runner** cuando se activa un flujo de trabajo desde un repositorio bifurcado. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en las solicitudes de extracción **de los repositorios bifurcados**.

Un atacante podría modificar la definición de la Acción de Github para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podrá robar secretos o sobrescribir el repositorio debido a las limitaciones mencionadas.

Sin embargo, incluso si la acción no menciona Artefactos, podría modificar un Artefacto del repositorio cambiando la acción?? (TODO).

{% hint style="danger" %}
**Sí, si el atacante cambia en la PR la acción de Github que se activará, su Acción de Github será la que se usará y no la del repositorio de origen.**
{% endhint %}

_Sin embargo, enviar una nueva acción que se activa en pull\_request no se activará._

#### **`pull_request_target`**

Sin embargo, el desencadenador de flujo de trabajo **`pull_request_target`** tiene **permiso de escritura** en el repositorio de destino y **acceso a secretos** (y no solicita permiso).

Tenga en cuenta que el desencadenador de flujo de trabajo **`pull_request_target`** **se ejecuta en el contexto base** y no en el proporcionado por la PR (para no ejecutar código no confiable). Para obtener más información sobre `pull_request_target` [**consulte la documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows
# INSEGURO. Proporcionado solo como ejemplo.
en:
  pull_request_target

trabajos:
  build:
    name: Construir y probar
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        ref: ${{ github.event.pull_request.head.sha }}

    - uses: actions/setup-node@v1
    - run: |
        npm install
        npm build

    - uses: completely/fakeaction@v2
      with:
        arg1: ${{ secrets.supersecret }}

    - uses: fakerepo/comment-on-pr@v1
      with:
        message: |
          ¡Gracias!
```

El código potencialmente **no confiable se está ejecutando durante `npm install` o `npm build`** ya que los scripts de construcción y los paquetes de referencia están controlados por el autor de la PR.

{% hint style="danger" %}
Si la acción se ejecuta en un runner autohospedado, el atacante podría ser capaz de comprometerlo aún más.
{% endhint %}

Un dork de Github para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml` sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acción está configurada de manera insegura (como usar condicionales sobre quién es el actor que genera la PR).

### Inyección / puerta trasera de Github Action

En caso de que de alguna manera haya logrado **infiltrarse dentro de una Github Action**, si puede escalar privilegios, puede **robar secretos de los procesos donde se han establecido los secretos**. En algunos casos, ni siquiera es necesario escalar privilegios.

```bash
cat /proc/<proc_number>/environ
cat /proc/*/environ | grep -i secret # Suponiendo que el nombre de la variable de entorno contiene "secret"
```

### Acceso de Github Action a AWS y GCP a través de OIDC

Consulte las siguientes páginas:

{% content-ref url="../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Información confidencial en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de acciones y **evitar mostrarlos**, **otros datos confidenciales** que podrían haberse generado en la ejecución de la acción no se ocultarán. Por ejemplo, un JWT firmado con un valor secreto no se ocultará a menos que se [configure específicamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

### GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se otorga cuando el administrador habilita esta opción:

<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que usará una **aplicación de Github**, por lo que puede acceder a los mismos puntos finales: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github debería lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que permita el acceso **entre repositorios** dentro de GitHub, para que un repositorio pueda acceder a otros repositorios internos usando el `GITHUB_TOKEN`.
{% endhint %}

Puede ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Tenga en cuenta que el token **caduca después de que se completa el trabajo**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puede hacer con este token:

```bash
# Fusionar PR
curl -X PUT \
    https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
    -H "Accept: application/vnd.github.v3+json" \
    --header "authorization: Bearer $GITHUB_TOKEN" \
    --header 'content-type: application/json' \
    -d '{"commit_title":"commit_title"}'

# Aprobar una PR
curl -X POST \
    https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
    -H "Accept: application/vnd.github.v3+json" \
    --header "authorization: Bearer $GITHUB_TOKEN" \
    --header 'content-type: application/json' \
    -d '{"event":"APPROVE"}'

# Crear una PR
curl -X POST \
  -H "Accept: application/vnd.github.v3+json" \
  --header "authorization: Bearer $GITHUB_TOKEN" \
    --header 'content-type: application/json' \
  https://api.github.com/repos/<org_name>/<repo_name>/pulls \
  -d '{"head":"<branch_name>","base":"master", "title":"title"}'
```

{% hint style="danger" %}
Tenga en cuenta que en varias ocasiones podrá encontrar **tokens de usuario de Github dentro de los entornos de Github Actions o en los secretos**. Estos tokens pueden darle más privilegios sobre el repositorio y la organización.
{% endhint %}

#### Listar secretos en la salida de Github Action

```yaml
name: list_env
on:
  workflow_dispatch: # Launch manually
  pull_request: #Run it when a PR is created to a branch
    branches:
      - '**'
  push: # Run it when a push is made to a branch
    branches:
      - '**'
jobs:     
  List_env:
    runs-on: ubuntu-latest
    steps:
      - name: List Env
        # Need to base64 encode or github will change the secret value for "***"
        run: sh -c 'env | grep "secret_" | base64 -w0'
        env:
          secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
          secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORD
### Envenenamiento de caché

El uso de la acción Git [**action/cache**](https://github.com/actions/cache) en cualquier lugar de CI ejecutará dos pasos: un paso tendrá lugar durante el proceso de **run** cuando se llama y el otro tendrá lugar después del **workflow** (si la acción de ejecución devolvió un cache-miss).

* **Acción de ejecución** - se utiliza para buscar y recuperar la caché. La búsqueda se realiza utilizando la clave de caché, siendo el resultado un cache-hit (éxito, datos encontrados en caché) o un cache-miss. Si se encuentra, los archivos y directorios se recuperan de la caché para su uso activo. Si el resultado es un cache-miss, los archivos y directorios deseados se descargan como si fuera la primera vez que se llaman.
* **Acción posterior al flujo de trabajo** - utilizada para guardar la caché. Si el resultado de la llamada de caché en la acción de ejecución devuelve un cache-miss, esta acción guardará el estado actual de los directorios que queremos cachear con la clave proporcionada. Esta acción ocurre automáticamente y no necesita ser llamada explícitamente.

Las **restricciones de acceso** proporcionan **aislamiento de caché** y seguridad al crear un **límite lógico entre diferentes ramas** _(por ejemplo: una caché creada para la rama **Feature-A** \[con la base principal] no sería accesible para una solicitud de extracción para la rama **Feature-B** \[con la base principal])_.

La acción de caché primero busca hits de caché para una clave y restaura las claves en la rama que contiene la **ejecución del flujo de trabajo**. Si no hay hits en la rama actual, la acción de caché busca la clave y restaura las claves en la rama principal y las ramas ascendentes.

El acceso a una caché está limitado por rama (actual y principal), lo que significa que se proporciona acceso a todos los **flujos de trabajo** en todas las **ejecuciones** de dicha rama.

Otra nota importante es que GitHub no permite modificaciones una vez que se han enviado las entradas: las entradas de caché son registros de solo lectura.

Utilizamos un ejemplo de CI que incluía dos flujos de trabajo. Este ejemplo muestra cómo un ataque puede pivotar desde un flujo de trabajo de baja permisión a uno de alta permisión.

* **Flujo de trabajo de prueba unitaria** que ejecuta herramientas de prueba unitaria y cobertura de código. Suponemos que una de las herramientas es maliciosa o vulnerable a la ejecución remota de código. El flujo de trabajo no necesita usar la acción Git **action/cache**. Cualquier flujo de trabajo puede acceder a la caché.
* **Flujo de trabajo de lanzamiento** que construye y lanza el artefacto de la aplicación. Este flujo de trabajo utiliza una caché para optimizar el uso de las dependencias de Golang.

El flujo de trabajo de **prueba unitaria** utiliza una acción maliciosa que agrega una entrada de caché con contenido malicioso cambiando una biblioteca de registro de Golang (**go.uber.org/zap@v1**) para agregar la cadena 'BAD library' a la descripción del artefacto de la aplicación.

A continuación, el flujo de trabajo de **lanzamiento** utiliza esta entrada de caché envenenada. Como resultado, el código malicioso se inyecta en el binario y la imagen de Golang construida. La caché permanece envenenada hasta que se descarta la clave de entrada (generalmente desencadenada por actualizaciones de dependencias). La misma caché envenenada afectará a cualquier otro **flujo de trabajo**, **ejecución** y **rama secundaria** que utilice la misma clave de caché.

En la prueba que realizamos, logramos inyectar la cadena 'BAD library' en la descripción de la imagen:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

Esto fue en la versión 0.4.1. A continuación, actualizamos la etiqueta y reconstruimos la imagen varias veces y observamos que 'Bad library' permaneció en la descripción.

Esta técnica fue tomada de [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

### Envenenamiento de artefactos

Hay varias acciones de Github que permiten **descargar artefactos de otros repositorios**. Estos otros repositorios suelen tener una acción de Github para **subir el artefacto** que luego se descargará.\
Si la **acción de Github** del repositorio que carga el artefacto permite el **`pull_request`** o **`pull_request_target`** (usando el código del atacante), un atacante podrá activar la acción que cargará un artefacto creado a partir de su código, por lo que cualquier otro repositorio que descargue y ejecute el último artefacto se verá comprometido.

{% hint style="info" %}
Como se mencionó en una sección de esta publicación, **`pull_requests`** suele **requerir una aprobación manual** de un mantenedor del repositorio.
{% endhint %}

Ejemplo de **descarga de artefactos de un repositorio diferente**:

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Como se mencionó anteriormente, en un desencadenador de **`pull_request`** la acción definida en el PR es la que se ejecuta. Por lo tanto, un **atacante** podría **definir** allí la **carga de artefactos** que le gustaría comprometer.

Por lo tanto, un atacante no necesita atacar un desencadenador de **`pull_request`** en la acción de carga de artefactos, sino simplemente cualquier desencadenador de **`pull_request`**.
{% endhint %}

Para obtener más información y opciones de defensa (como codificar en duro el artefacto a descargar), consulte [https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust](https://www.legitsecurity.com/blog/artifact-poisoning-vulnerability-discovered-in-rust)

### Secuestro de repositorio de espacio de nombres eliminado

Este es un buen artículo de blog para leer sobre vulnerabilidades corregidas que permitirían a un atacante robar un espacio de nombres eliminado para robar un repositorio famoso (potencialmente debido a un cambio de nombre del espacio de nombres): [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

### Registro de imágenes Docker de Github

Es posible hacer acciones de Github que **compilen y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Acción de Github Build &#x26; Push Docker Image</summary>

```yaml
[...]

- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
  uses: docker/login-action@v1
  with:
    registry: ghcr.io
    username: ${{ github.repository_owner }}
    password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
  run: |
    sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
  uses: docker/build-push-action@v2
    with:
      context: .
      push: true
      tags: |
        ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
        ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB
## Bypass de Protecciones de Entornos

Para una introducción sobre [**Github Environment, revisa la información básica**](basic-github-information.md#git-environments).

En caso de que un entorno pueda ser **accedido desde todas las ramas**, no está **protegido** y puedes acceder fácilmente a los secretos dentro del entorno. Ten en cuenta que puedes encontrar repositorios donde **todas las ramas están protegidas** (especificando sus nombres o usando `*`), en ese escenario, **encuentra una rama donde puedas enviar código** y puedes **filtrar** los secretos creando una nueva acción de Github (o modificando una existente).

Ten en cuenta que puedes encontrar el caso extremo donde **todas las ramas están protegidas** (a través del comodín `*`) y se especifica **quién puede enviar código a las ramas** (_puedes especificarlo en la protección de la rama_) y **tu usuario no está permitido**. Aún puedes ejecutar una acción personalizada de Github porque puedes crear una rama y usar el disparador de envío sobre sí misma. La **protección de la rama permite el envío a una nueva rama, por lo que se activará la acción de Github**.

```yaml
  push: # Ejecútalo cuando se realiza un envío a una rama
    branches:
      - current_branch_name #Usa '**' para ejecutar cuando se realiza un envío a cualquier rama
```

Ten en cuenta que **después de la creación** de la rama, la **protección de la rama se aplicará a la nueva rama** y no podrás modificarla, pero para ese momento ya habrás filtrado los secretos.

## Persistencia

* Generar **token de usuario**
* Robar **tokens de Github** de **secretos**
  * **Eliminación** de los **resultados** y **ramas** del flujo de trabajo
* Dar **más permisos a toda la organización**
* Crear **webhooks** para filtrar información
* Invitar a **colaboradores externos**
* **Eliminar** los **webhooks** utilizados por el **SIEM**
* Crear/modificar **Acción de Github** con una **puerta trasera**
* Encontrar una **Acción de Github vulnerable a la inyección de comandos** a través de la modificación del valor **secreto**

### Commits de Impostores - Puerta trasera a través de los commits del repositorio

En Github es posible **crear una solicitud de extracción (PR) a un repositorio desde un fork**. Incluso si la PR no es aceptada, se va a crear un id de **commit** dentro del repositorio original para la versión del código del fork. Por lo tanto, un atacante **podría fijarse en usar un commit específico de un repositorio aparentemente legítimo que no fue creado por el propietario del repositorio**.

Como [**este**](https://github.com/actions/checkout/commit/c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e):

```yaml
name: example
on: [push]
jobs:
 commit:
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e
     - shell: bash
       run: |
         echo 'hello world!'
```

Para obtener más información, consulta [https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd](https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd)

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>