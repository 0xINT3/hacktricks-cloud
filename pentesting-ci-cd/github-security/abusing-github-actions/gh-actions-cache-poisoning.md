# GH Actions - Cache Poisoning

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Cache Poisoning

Using the [**action/cache**](https://github.com/actions/cache) Git action anywhere in the CI will run two steps: one step will take place during the **run** process when it‚Äôs called and the other will take place post **workflow** (if the run action returned a cache-miss).

* **Run action** ‚Äì is used to search and retrieve the cache. The search is done using the cache key, with the result being either a cache-hit (success, data found in cache) or cache-miss. If found, the files and directories are retrieved from the cache for active use. If the result is cache-miss, the desired files and directories are downloaded as if it was the first time they are called.
* **Post workflow action** ‚Äì used for saving the cache. If the result of the cache call in the run action returns a cache-miss, this action will save the current state of the directories we want to cache with the provided key. This action happens automatically and doesn‚Äôt need to be explicitly called.

**Access restrictions** provide **cache isolation** and security by creating a logical **boundary between different branches** _(for example: a cache created for the branch **Feature-A** \[with the base main] would not be accessible to a pull request for the branch **Feature-B** \[with the base main])_.

The cache action first searches cache hits for a key and restores keys in the branch containing the **workflow run**. If there are no hits in the current branch, the cache action searches for the key and restores keys in the parent branch and upstream branches.

Access to a cache is scoped by branch (current and parent), meaning access is provided to all **workflows** across **runs** of said branch.

Another important note is that GitHub does not allow modifications once entries are pushed ‚Äì cache entries are read-only records.

We used an example CI that included two workflows. This example shows how an attack can pivot from a low permission workflow to a high permission one.

* **Unit-test** workflow running unit-test and code coverage tools. We assume that one of the tools is malicious or vulnerable to remote code execution. The workflow does need to use the **action/cache** Git action. Any workflow can access the cache.
* **Release** workflow builds and releases the application artifact. This workflow uses a cache to optimize using the Golang dependencies.

The **unit-test** workflow uses a malicious action that adds a cache entry with malicious content by changing a Golang logging library (**go.uber.org/zap@v1**) to add the string, ‚ÄòBAD library‚Äô to the application artifact description.

Next, the **release** workflow uses this poisoned cache entry. As a result, the malicious code is injected into the built Golang binary and image. The cache remains poisoned until the entry key is discarded (usually triggered by dependency updates). The same poisoned cache will affect any other **workflow**, **run**, and **child branch** using the same cache key.

In the test we performed, we managed to inject the string ‚ÄòBAD library‚Äô into the image description:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

This was in version 0.4.1. Next, we updated the tag and rebuilt the image several times, and observed that ‚ÄòBad library‚Äô remained in the description.

This techniques was taken from [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
