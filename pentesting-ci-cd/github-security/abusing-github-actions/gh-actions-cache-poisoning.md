# GH Actions - Zatrucie pamięci podręcznej

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów GitHub.

</details>


Aby uzyskać dalsze szczegóły, sprawdź oryginalny post [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)


## Zatrucie pamięci podręcznej

Akcja Git [**action/cache**](https://github.com/actions/cache) wprowadza mechanizm pamięci podręcznej w procesie Continuous Integration (CI), obejmujący dwie kluczowe fazy:

1. **Uruchomienie akcji**: Ta faza polega na wyszukiwaniu i pobieraniu danych z pamięci podręcznej podczas uruchamiania CI. Wyszukiwanie wykorzystuje unikalny klucz pamięci podręcznej, dając dwa wyniki:
- **Trafienie w pamięć podręczną**: Żądane dane są znalezione w pamięci podręcznej i są natychmiast pobierane do użycia.
- **Brak trafienia w pamięć podręczną**: Nie znaleziono pasujących danych w pamięci podręcznej, co powoduje pobranie wymaganych plików i katalogów, podobnie jak w przypadku pierwszego żądania.

2. **Akcja po zakończeniu przepływu pracy**: Ta faza jest poświęcona pamięci podręcznej danych po zakończeniu przepływu pracy CI. Konkretnie, jeśli wystąpi brak trafienia w pamięć podręczną podczas akcji uruchamiania, bieżący stan określonych katalogów jest przechowywany w pamięci podręcznej za pomocą podanego klucza. Ten proces jest zautomatyzowany i nie wymaga wywołania explicite.

#### Środki bezpieczeństwa: Izolacja pamięci podręcznej i ograniczenia dostępu

Aby utrzymać bezpieczeństwo i zapewnić izolację pamięci podręcznej, wprowadza się ograniczenia dostępu, tworząc logiczne rozdzielenie między różnymi gałęziami. Na przykład, pamięć podręczna utworzona dla gałęzi **Feature-A** (z bazą w głównej gałęzi) będzie niedostępna dla żądania pull request dla gałęzi **Feature-B** (również z bazą w głównej gałęzi).

Akcja pamięci podręcznej przestrzega określonej kolejności wyszukiwania:
- Najpierw szuka trafień w pamięci podręcznej w tej samej gałęzi, w której uruchamiany jest przepływ pracy.
- Jeśli nie powiedzie się, rozszerza wyszukiwanie do gałęzi nadrzędnej i innych gałęzi nadrzędnych.

Ważne jest, że dostęp do pamięci podręcznej jest ograniczony do gałęzi, obejmując wszystkie przepływy pracy i uruchomienia konkretnej gałęzi. Dodatkowo, GitHub narzuca politykę tylko do odczytu dla wpisów pamięci podręcznej po ich utworzeniu, zabraniając jakichkolwiek modyfikacji.

#### Implikacja w świecie rzeczywistym: Atak na przepływ pracy o niskich uprawnieniach, prowadzący do przepływu pracy o wysokich uprawnieniach

Ilustracyjny scenariusz CI pokazuje, jak atakujący może wykorzystać zatrucie pamięci podręcznej do eskalacji uprawnień z przepływu pracy o niskich uprawnieniach do przepływu pracy o wysokich uprawnieniach:

- Przepływ pracy **Unit-test**, odpowiedzialny za uruchamianie testów jednostkowych i narzędzi do pokrycia kodu, zakłada użycie narzędzia skompromitowanego lub podatnego. Ten przepływ pracy wykorzystuje akcję Git **action/cache**, dzięki czemu pamięć podręczna jest dostępna dla dowolnego przepływu pracy.
- Przepływ pracy **Release**, odpowiedzialny za budowanie i wydawanie artefaktu aplikacji, optymalizuje swoje operacje poprzez pamięci podręczne zależności Golang.

W tym scenariuszu przepływ pracy jednostkowego testu wprowadza złośliwy wpis do pamięci podręcznej, podmieniając prawidłową bibliotekę logowania Golang (`go
