# GH Actions - Cache Poisoning

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>


F√ºr weitere Details lesen Sie den Originalbeitrag [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)


## Cache-Vergiftung

Die Git-Aktion [**action/cache**](https://github.com/actions/cache) f√ºhrt einen Caching-Mechanismus im Continuous Integration (CI)-Prozess ein, der zwei wichtige Phasen umfasst:

1. **Ausf√ºhrungsaktion**: In dieser Phase wird nach und das zwischengespeicherte Daten w√§hrend des CI-Laufs abgerufen. Die Suche verwendet einen eindeutigen Cache-Schl√ºssel und f√ºhrt zu zwei Ergebnissen:
- **Cache-Treffer**: Die angeforderten Daten werden im Cache gefunden und daher sofort abgerufen.
- **Cache-Miss**: Es werden keine √ºbereinstimmenden Daten im Cache gefunden, was einen frischen Download der erforderlichen Dateien und Verzeichnisse zur Folge hat, √§hnlich wie bei einer Erstanforderung.

2. **Nach Workflow-Aktion**: Diese Phase ist der Zwischenspeicherung von Daten nach dem CI-Workflow gewidmet. Speziell, wenn ein Cache-Miss w√§hrend der Ausf√ºhrungsaktion auftritt, wird der aktuelle Zustand der angegebenen Verzeichnisse unter Verwendung des bereitgestellten Schl√ºssels zwischengespeichert. Dieser Prozess erfolgt automatisch und erfordert keine explizite Aufforderung.

#### Sicherheitsma√ünahmen: Cache-Isolierung und Zugriffsbeschr√§nkungen

Um die Sicherheit zu gew√§hrleisten und die Cache-Isolierung sicherzustellen, werden Zugriffsbeschr√§nkungen durchgesetzt, die eine logische Trennung zwischen verschiedenen Branches schaffen. Beispielsweise ist ein f√ºr den Branch **Feature-A** erstellter Cache (mit seinem Ursprung im Hauptbranch) f√ºr ein Pull-Request f√ºr den Branch **Feature-B** (ebenfalls basierend auf dem Hauptbranch) nicht zug√§nglich.

Die Cache-Aktion folgt einer spezifischen Suchreihenfolge:
- Zuerst werden Cache-Treffer im selben Branch wie der Workflow-Lauf gesucht.
- Bei Misserfolg wird die Suche auf den √ºbergeordneten Branch und andere √ºbergeordnete Branches ausgeweitet.

Wichtig ist, dass der Cache-Zugriff branchenbezogen ist und sich auf alle Workflows und L√§ufe eines bestimmten Branches erstreckt. Dar√ºber hinaus erzwingt GitHub eine Richtlinie nur f√ºr den Lesezugriff auf Cache-Eintr√§ge, sobald sie erstellt wurden, was √Ñnderungen verbietet.

#### Realweltliche Auswirkung: Von einem Workflow mit niedrigen Berechtigungen zu einem Angriff auf einen Workflow mit hohen Berechtigungen

Ein veranschaulichendes CI-Szenario zeigt, wie ein Angreifer Cache-Vergiftung nutzen k√∂nnte, um Berechtigungen von einem Workflow mit niedrigen Berechtigungen auf einen mit hohen Berechtigungen zu eskalieren:

- Der **Unit-Test**-Workflow, der f√ºr das Ausf√ºhren von Unittests und Codeabdeckungstools verantwortlich ist, verwendet ein kompromittiertes oder verwundbares Tool. Dieser Workflow verwendet die Git-Aktion **action/cache**, wodurch der Cache f√ºr jeden Workflow zug√§nglich wird.
- Der **Release**-Workflow, der mit dem Erstellen und Ver√∂ffentlichen des Anwendungsartefakts beauftragt ist, optimiert seine Operationen durch Zwischenspeichern von Golang-Abh√§ngigkeiten.

In diesem Szenario f√ºhrt der Unit-Test-Workflow einen b√∂sartigen Cache-Eintrag ein, indem er eine legitime Golang-Logging-Bibliothek (`go
