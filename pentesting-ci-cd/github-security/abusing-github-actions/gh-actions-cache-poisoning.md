# GH Actions - Cache Poisoning

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** repository di [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>


Per ulteriori dettagli consulta il post originale [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)


## Cache Poisoning

L'azione Git [**action/cache**](https://github.com/actions/cache) introduce un meccanismo di caching nel processo di Continuous Integration (CI), che comprende due fasi critiche:

1. **Esecuzione dell'azione**: Questa fase prevede la ricerca e il recupero dei dati memorizzati nella cache durante l'esecuzione della CI. La ricerca utilizza una chiave di cache univoca, che produce due risultati:
- **Cache-hit**: I dati richiesti vengono trovati nella cache e vengono quindi recuperati per un utilizzo immediato.
- **Cache-miss**: Non vengono trovati dati corrispondenti nella cache, il che comporta un nuovo download dei file e delle directory necessari, simile a una richiesta di primo accesso.

2. **Azione post workflow**: Questa fase √® dedicata alla memorizzazione nella cache dei dati dopo il workflow della CI. In particolare, se si verifica un cache-miss durante l'azione di esecuzione, lo stato corrente delle directory specificate viene memorizzato nella cache utilizzando la chiave fornita. Questo processo √® automatizzato e non richiede una chiamata esplicita.

#### Misure di sicurezza: Isolamento della cache e restrizioni di accesso

Per mantenere la sicurezza e garantire l'isolamento della cache, vengono applicate restrizioni di accesso che creano una separazione logica tra i diversi branch. Ad esempio, una cache creata per il branch **Feature-A** (con base nel branch principale) non sar√† accessibile a una pull request per il branch **Feature-B** (anch'essa basata nel branch principale).

L'azione di cache segue un ordine di ricerca specifico:
- Prima cerca cache hits nello stesso branch dell'esecuzione del workflow.
- Se non riesce, estende la ricerca al branch padre e agli altri branch upstream.

√à importante sottolineare che l'accesso alla cache √® limitato al branch, estendendosi a tutti i workflow ed esecuzioni di un determinato branch. Inoltre, GitHub impone una politica di sola lettura per le voci di cache una volta create, vietando eventuali modifiche.

#### Implicazioni reali: Da un attacco di workflow a bassi permessi a uno di workflow ad alto permesso

Uno scenario illustrativo di CI mostra come un attaccante potrebbe sfruttare il cache poisoning per elevare i privilegi da un workflow a bassi permessi a uno ad alto permesso:

- Si assume che il workflow **Unit-test**, responsabile dell'esecuzione dei test unitari e degli strumenti di copertura del codice, utilizzi uno strumento compromesso o vulnerabile. Questo workflow utilizza l'azione Git **action/cache**, rendendo la cache accessibile a qualsiasi workflow.
- Il workflow **Release**, incaricato di compilare e rilasciare l'artefatto dell'applicazione, ottimizza le sue operazioni memorizzando nella cache le dipendenze di Golang.

In questo scenario, il workflow dei test unitari introduce una voce di cache malevola sostituendo una libreria di logging Golang legittima (`go
