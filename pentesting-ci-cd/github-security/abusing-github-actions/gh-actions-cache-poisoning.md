# GH Actions - Envenenamiento de Caché

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

## Envenenamiento de Caché

El uso de la acción de Git [**action/cache**](https://github.com/actions/cache) en cualquier parte de CI ejecutará dos pasos: uno durante el proceso de **run** cuando se llama y otro después del **workflow** (si la acción de ejecución devuelve un cache-miss).

* **Acción de ejecución** - se utiliza para buscar y recuperar la caché. La búsqueda se realiza utilizando la clave de caché, y el resultado puede ser un cache-hit (éxito, datos encontrados en la caché) o un cache-miss. Si se encuentra, los archivos y directorios se recuperan de la caché para su uso activo. Si el resultado es un cache-miss, los archivos y directorios deseados se descargan como si fuera la primera vez que se llaman.
* **Acción posterior al workflow** - se utiliza para guardar la caché. Si el resultado de la llamada a la caché en la acción de ejecución devuelve un cache-miss, esta acción guardará el estado actual de los directorios que queremos cachear con la clave proporcionada. Esta acción se realiza automáticamente y no necesita ser llamada explícitamente.

Las **restricciones de acceso** proporcionan **aislamiento de caché** y seguridad al crear un **límite lógico entre diferentes ramas** _(por ejemplo: una caché creada para la rama **Feature-A** \[con la base main] no sería accesible para una solicitud de extracción de la rama **Feature-B** \[con la base main])_.

La acción de caché primero busca aciertos de caché para una clave y restaura las claves en la rama que contiene la **ejecución del workflow**. Si no hay aciertos en la rama actual, la acción de caché busca la clave y restaura las claves en la rama principal y las ramas ascendentes.

El acceso a una caché está limitado por rama (actual y principal), lo que significa que se proporciona acceso a todos los **workflows** en todas las **ejecuciones** de dicha rama.

Otra nota importante es que GitHub no permite modificaciones una vez que se han enviado las entradas: las entradas de caché son registros de solo lectura.

Utilizamos un ejemplo de CI que incluía dos workflows. Este ejemplo muestra cómo un ataque puede pasar de un workflow de baja permisos a uno de alta permisos.

* Workflow **Unit-test** que ejecuta pruebas unitarias y herramientas de cobertura de código. Suponemos que una de las herramientas es maliciosa o vulnerable a la ejecución remota de código. El workflow no necesita utilizar la acción de Git **action/cache**. Cualquier workflow puede acceder a la caché.
* Workflow **Release** que construye y lanza el artefacto de la aplicación. Este workflow utiliza una caché para optimizar el uso de las dependencias de Golang.

El workflow **unit-test** utiliza una acción maliciosa que agrega una entrada de caché con contenido malicioso al cambiar una biblioteca de registro de Golang (**go.uber.org/zap@v1**) para agregar la cadena 'BAD library' a la descripción del artefacto de la aplicación.

A continuación, el workflow **release** utiliza esta entrada de caché envenenada. Como resultado, el código malicioso se inyecta en el binario y la imagen de Golang construidos. La caché permanece envenenada hasta que se descarta la clave de entrada (generalmente desencadenada por actualizaciones de dependencias). La misma caché envenenada afectará a cualquier otro **workflow**, **ejecución** y **rama secundaria** que utilice la misma clave de caché.

En la prueba que realizamos, logramos inyectar la cadena 'BAD library' en la descripción de la imagen:

![BAD library](https://scribesecurity.com/wp-content/uploads/2022/02/BAD-library-2-300x79.jpg)

Esto fue en la versión 0.4.1. A continuación, actualizamos la etiqueta y reconstruimos la imagen varias veces, y observamos que 'Bad library' seguía apareciendo en la descripción.

Esta técnica fue tomada de [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>
