# Bypassando a Lista Branca de IP do SCM

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou se quiser acessar a **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

Esta p√°gina foi copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introdu√ß√£o

Muitas organiza√ß√µes combinam **sistemas de gerenciamento de controle de origem baseados em SaaS** (como GitHub ou GitLab) com uma solu√ß√£o de **CI** interna e auto-hospedada (por exemplo, Jenkins, TeamCity), permitindo que esses sistemas de CI **recebam eventos de webhook** dos fornecedores de controle de origem SaaS, com o simples prop√≥sito de acionar jobs de pipeline.

Portanto, as organiza√ß√µes **inserem na lista branca** os **intervalos de IP** do **SCM** permitindo que eles alcancem o sistema de CI **interno** com **webhooks**. No entanto, observe como **qualquer pessoa** pode criar uma **conta** no Github ou Gitlab e fazer com que ela **acione um webhook** que poderia enviar uma solicita√ß√£o para esse **sistema de CI interno**.

Al√©m disso, observe que, embora o intervalo de IP do servi√ßo de webhook do fornecedor SCM tenha sido aberto no firewall da organiza√ß√£o para **permitir que as solicita√ß√µes de webhook acionem pipelines**, isso **n√£o significa** que as solicita√ß√µes de webhook n√£o possam ser **direcionadas para outros endpoints de CI**, al√©m dos que normalmente ouvem eventos de webhook. Podemos tentar acessar esses endpoints para **visualizar dados valiosos como usu√°rios**, **pipelines**, **sa√≠da do console** de jobs de pipeline ou, se tivermos sorte o suficiente para cair em uma inst√¢ncia que concede privil√©gios de administrador a usu√°rios n√£o autenticados (sim, isso acontece), podemos acessar as **configura√ß√µes e se√ß√µes de credenciais**.

### Cen√°rio

Imagine um servi√ßo **Jenkins** que s√≥ **permite** que os IPs do **GitHub** e **GitLab** o alcancem **externamente**.

Nesse cen√°rio, um atacante acionar√° webhooks arbitr√°rios no GitHub e GitLab para fazer login no Jenkins e extrair informa√ß√µes.

### Limita√ß√µes Comuns de Webhooks

* **Apenas solicita√ß√µes POST**: Webhooks geralmente s√≥ permitem o envio de solicita√ß√µes POST, no entanto, alguns **endpoints** com informa√ß√µes **interessantes** precisam ser acessados por meio de solicita√ß√µes GET.
* Se o POST for **respondido com um redirecionamento**, ele pode ser seguido.
* Alguns CIs (Jenkins) permitem ter um **par√¢metro GET indicando para onde redirecionar o cliente** assim que ele conseguir fazer login, voc√™ pode usar isso para redirecion√°-lo para uma p√°gina espec√≠fica com um GET.
* **N√£o √© poss√≠vel controlar o corpo da solicita√ß√£o POST**: Se voc√™ precisar enviar dados espec√≠ficos no corpo do POST, n√£o poder√°.
* **Tokens CSRF**: Se o endpoint interessante estiver esperando tokens CSRF, voc√™ n√£o poder√° extra√≠-los e fornec√™-los.

## Webhooks do GitHub

### Abusando do login do Jenkins

O login requer o envio de uma **solicita√ß√£o POST**. Escolher direcionar o endpoint de login resolve o desafio de ter tokens CSRF, pois essa solicita√ß√£o espec√≠fica n√£o requer isso. Mas ainda enfrentamos o outro desafio, pois nossas habilidades de **modificar o corpo da solicita√ß√£o permanecem limitadas**.

Uma solicita√ß√£o de login do Jenkins √© assim:
```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```
Precisamos **enviar as credenciais que for√ßamos de alguma forma**.\
Felizmente, o endpoint de login do Jenkins **aceita** uma solicita√ß√£o POST com os **campos enviados como par√¢metros de consulta**:
```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json in body of request]
```
Ent√£o, como podemos fazer isso funcionar? Podemos **criar um novo webhook no GitHub**, definindo a **URL de solicita√ß√£o de login do Jenkins como a URL do payload**. Em seguida, podemos criar uma automa√ß√£o usando a API do GitHub para **for√ßar a senha da conta do usu√°rio**, modificando o campo de senha, acionando o webhook e inspecionando a resposta no log de eventos do webhook do reposit√≥rio.
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```
<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos o webhook e vemos os resultados. Todos os fornecedores de SCM exibem a solicita√ß√£o HTTP e a resposta enviada pelo webhook em sua interface do usu√°rio.\
Se a tentativa de login falhar, somos redirecionados para a p√°gina de erro de login.

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Mas se o **login for bem-sucedido**, somos redirecionados para a p√°gina principal do Jenkins e um **cookie de sess√£o √© definido**.

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

Portanto, podemos **for√ßar os credenciais do Jenkins e obter um cookie de sess√£o!**\
No entanto, estamos um pouco limitados - s√≥ podemos **enviar uma solicita√ß√£o sem estado de cada vez** e o **cookie n√£o pode ser anexado** √† nossa solicita√ß√£o, pois n√£o podemos controlar os cabe√ßalhos.

Outra op√ß√£o seria tentar obter um **token de acesso do Jenkins**, que pode ser anexado √† URL e usado para enviar solicita√ß√µes POST para o Jenkins sem a necessidade de adicionar um token CSRF. Essa op√ß√£o √© um pouco mais complexa, pois requer que um invasor encontre de alguma forma um CI auto-hospedado que s√≥ seja acess√≠vel a partir de intervalos de IP SCM e tamb√©m obtenha um token de acesso v√°lido para esse CI. Portanto, por enquanto, vamos nos concentrar em cen√°rios mais pr√°ticos.

## Webhooks do GitLab

### Abusando do Login do Jenkins

Vamos tentar enviar a mesma solicita√ß√£o, mas desta vez atrav√©s do GitLab. Devido √†s mesmas limita√ß√µes, enviamos a **mesma solicita√ß√£o POST, adicionando as credenciais como par√¢metros de consulta**.

<figure><img src="../../.gitbook/assets/image (2) (2) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos a solicita√ß√£o, mas ao contr√°rio do GitHub, a resposta √© 200. Como no √∫ltimo exemplo, usamos o **servi√ßo de webhook do GitLab para for√ßar um usu√°rio e obter um cookie de sess√£o**, mas desta vez, o conte√∫do da resposta do Jenkins foi transmitido de volta para a interface do GitLab, fornecendo-nos essencialmente o **conte√∫do completo da p√°gina principal do Jenkins**.\
Isso ocorre porque o **GitLab seguiu o redirecionamento** adicionando o **Cookie** √† solicita√ß√£o:

<figure><img src="../../.gitbook/assets/image (4) (1) (2).png" alt=""><figcaption></figcaption></figure>

Isso significa que podemos:

1. for√ßar usu√°rios e descobrir credenciais v√°lidas,
2. usar as credenciais v√°lidas na p√°gina de login para fazer login com sucesso,
3. obter o conte√∫do da p√°gina principal interna do Jenkins.

### Obtendo Dados Internos do Jenkins

O login do Jenkins aceita um par√¢metro de redirecionamento - "_from_". Originalmente usado para **redirecionar os usu√°rios para a p√°gina que eles pretendiam acessar ap√≥s o login**, mas no nosso caso - um recurso que podemos abusar para enviar uma solicita√ß√£o GET anexada com um cookie de sess√£o para uma p√°gina interna do Jenkins de nossa escolha. Vamos ver como:

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

1. Defina um webhook com a seguinte URL:
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=secretpass123&from=/job/prod_pipeline/1/consoleText&Submit=Sign+in
```
Um pedido POST √© enviado para o Jenkins e a autentica√ß√£o √© bem-sucedida.

* Recebemos uma resposta de redirecionamento 302, com um cookie de sess√£o e um redirecionamento para a p√°gina de sa√≠da do console do trabalho.
* O servi√ßo de webhook do GitLab segue automaticamente o redirecionamento com um pedido GET enviado para a p√°gina de sa√≠da do console do trabalho, juntamente com o cookie de sess√£o que √© adicionado √† solicita√ß√£o:
```
http://jenkins.example-domain.com/job/prod_pipeline/1/consoleText
```
* A sa√≠da do console do trabalho √© enviada de volta e apresentada no registro de eventos do webhook do GitLab do atacante.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

√â importante mencionar aqui que o Jenkins pode ser **configurado para permitir acesso a componentes internos sem autentica√ß√£o**, ou de uma maneira que exija que apenas usu√°rios autenticados possam acessar os componentes internos. Como isso nos afeta?

* Se **nenhuma autentica√ß√£o** estiver configurada, podemos fazer com que o servi√ßo de webhook do GitLab acesse qualquer p√°gina interna no CI, capturar a resposta e apresent√°-la para n√≥s.
* Se a autentica√ß√£o estiver configurada, podemos tentar for√ßar a entrada de um usu√°rio e, em seguida, usar as credenciais para acessar qualquer p√°gina interna (como na bala acima).

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no GitHub.

</details>
