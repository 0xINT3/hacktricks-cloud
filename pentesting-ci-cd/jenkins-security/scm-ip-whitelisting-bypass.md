# Bypass de lista blanca de IP de SCM

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si deseas ver a tu **empresa anunciada en HackTricks** o si deseas acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PR a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Esta página fue copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introducción

Muchas organizaciones combinan sistemas de gestión de control de origen (SCM) basados en SaaS (como GitHub o GitLab) con una solución de CI interna autohospedada (por ejemplo, Jenkins, TeamCity) que permite a estos sistemas de CI recibir eventos de webhook de los proveedores de control de origen de SaaS, con el simple propósito de activar trabajos de canalización.

Por lo tanto, las organizaciones incluyen en la lista blanca los rangos de IP de SCM que les permiten llegar al sistema de CI interno con webhooks. Sin embargo, tenga en cuenta cómo **cualquiera** puede crear una cuenta en GitHub o Gitlab y hacer que **active un webhook** que podría enviar una solicitud a ese sistema de CI **interno**.

Además, tenga en cuenta que aunque se abrió el rango de IP del servicio de webhook del proveedor de SCM en el firewall de la organización para **permitir que las solicitudes de webhook activen las canalizaciones**, esto **no significa** que las solicitudes de webhook no puedan ser **dirigidas hacia otros puntos finales de CI**, además de los que escuchan regularmente los eventos de webhook. Podemos intentar acceder a estos puntos finales para **ver datos valiosos como usuarios**, **canalizaciones**, **salida de consola** de trabajos de canalización, o si tenemos la suerte de caer en una instancia que otorga privilegios de administrador a usuarios no autenticados (sí, sucede), podemos acceder a las secciones de **configuraciones y credenciales**.

### Escenario

Imagina un servicio **Jenkins** que solo **permite que las IPs de GitHub y GitLab** lo alcancen **externamente**.

En este escenario, un atacante activará webhooks arbitrarios en GitHub y GitLab para iniciar sesión dentro de Jenkins y extraer información.

### Limitaciones comunes de los webhooks

* **Solo solicitudes POST**: los webhooks generalmente solo le permiten enviar solicitudes POST, sin embargo, algunos **puntos finales** con información **interesante** deben ser accedidos a través de solicitudes **GET**.
  * Si la publicación es **respondida con una redirección**, puede seguirla.
  * Algunos CIs (Jenkins) permiten tener un **parámetro GET que indica dónde redirigir al cliente** una vez que logró iniciar sesión, puede usar esto para redirigirlo a una página específica con un GET.
* **No se puede controlar el cuerpo de la solicitud POST**: si desea enviar datos específicos en el cuerpo POST, no puede hacerlo.
* **Tokens CSRF**: si el punto final interesante espera tokens CSRF, no podrá extraerlos y proporcionarlos.

## Webhooks de GitHub

### Abuso de inicio de sesión de Jenkins

El inicio de sesión requiere el envío de una **solicitud POST**. Elegir el punto final de inicio de sesión resuelve el desafío de mantener los tokens CSRF, ya que esta solicitud específica no lo requiere. Pero todavía enfrentamos el otro desafío, ya que nuestras habilidades para **modificar el cuerpo de la solicitud siguen siendo limitadas**.

Una solicitud de inicio de sesión de Jenkins se ve así:

```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```

Necesitamos **enviar las credenciales que fuerza bruta de alguna manera**.\
Afortunadamente, el punto final de inicio de sesión de Jenkins **acepta una solicitud POST con los campos enviados como parámetros de consulta**:

```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json en el cuerpo de la solicitud]
```

Entonces, ¿cómo podemos hacer que funcione? Podemos **crear un nuevo webhook en GitHub**, estableciendo la **URL de solicitud de inicio de sesión de Jenkins como la URL de carga útil**. Luego podemos crear una automatización usando la API de GitHub para **fuerza bruta de la contraseña de la cuenta de usuario**, modificando el campo de contraseña, activando el webhook e inspeccionando la respuesta en el registro de eventos de webhook del repositorio.

```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos el webhook y vemos los resultados. Todos los proveedores de