# Bypass de la Lista Blanca de IP de SCM

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

Esta página fue copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introducción

Muchas organizaciones combinan sistemas de gestión de control de origen (SCM) basados en SaaS (como GitHub o GitLab) con una solución de CI interna y autohospedada (por ejemplo, Jenkins, TeamCity), lo que permite que estos sistemas de CI reciban eventos de webhook de los proveedores de control de origen de SaaS, con el simple propósito de activar trabajos de canalización.

Por lo tanto, las organizaciones incluyen en la lista blanca los rangos de IP del SCM que les permiten llegar al sistema de CI interno con webhooks. Sin embargo, hay que tener en cuenta que **cualquiera** puede crear una cuenta en GitHub o GitLab y hacer que **active un webhook** que podría enviar una solicitud a ese sistema de CI interno.

Además, hay que tener en cuenta que si bien se abrió el rango de IP del servicio de webhook del proveedor de SCM en el firewall de la organización para **permitir que las solicitudes de webhook activen las canalizaciones**, esto no significa que las solicitudes de webhook no puedan dirigirse a otros puntos finales de CI, además de los que escuchan regularmente los eventos de webhook. Podemos intentar acceder a estos puntos finales para **ver datos valiosos como usuarios**, **canalizaciones**, **salida de consola** de los trabajos de canalización, o si tenemos la suerte de encontrar una instancia que otorgue privilegios de administrador a usuarios no autenticados (sí, sucede), podemos acceder a las **secciones de configuraciones y credenciales**.

### Escenario

Imagina un servicio de Jenkins que solo **permite** que las IP de **GitHub** y **GitLab** lo alcancen **externamente**.

En este escenario, un atacante activará webhooks arbitrarios en GitHub y GitLab para iniciar sesión dentro de Jenkins y extraer información.

### Limitaciones comunes de los webhooks

* **Solo solicitudes POST**: Los webhooks generalmente solo te permiten enviar solicitudes POST, sin embargo, algunos **puntos finales** con información **interesante** deben ser accedidos mediante solicitudes GET.
* Si la respuesta del POST es **redirigida**, puede seguirla.
* Algunos CI (Jenkins) permiten tener un **parámetro GET que indica dónde redirigir al cliente** una vez que haya logrado iniciar sesión, puedes usar esto para redirigirlo a una página específica con un GET.
* **No se puede controlar el cuerpo de la solicitud POST**: Si necesitas enviar datos específicos en el cuerpo del POST, no podrás hacerlo.
* **Tokens CSRF**: Si el punto final interesante espera tokens CSRF, no podrás extraerlos ni proporcionarlos.

## Webhooks de GitHub

### Abuso del inicio de sesión de Jenkins

El inicio de sesión requiere enviar una **solicitud POST**. Elegir el punto final de inicio de sesión resuelve el desafío de tener tokens CSRF, ya que esta solicitud específica no lo requiere. Pero aún enfrentamos el otro desafío, ya que nuestras habilidades para **modificar el cuerpo de la solicitud siguen siendo limitadas**.

Una solicitud de inicio de sesión de Jenkins se ve de la siguiente manera:
```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```
Necesitamos **enviar las credenciales que desciframos de alguna manera**.\
Afortunadamente, el punto de acceso de inicio de sesión de Jenkins **acepta** una solicitud POST con los **campos enviados como parámetros de consulta**:
```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json in body of request]
```
Entonces, ¿cómo podemos hacer que funcione? Podemos **crear un nuevo webhook en GitHub**, estableciendo la **URL de solicitud de inicio de sesión de Jenkins como la URL del payload**. Luego, podemos crear una automatización utilizando la API de GitHub para **forzar la contraseña de la cuenta de usuario**, modificando el campo de contraseña, activando el webhook e inspeccionando la respuesta en el registro de eventos del webhook del repositorio.
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```
<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos el webhook y vemos los resultados. Todos los proveedores de SCM muestran la solicitud HTTP y la respuesta enviada a través del webhook en su interfaz de usuario.\
Si el intento de inicio de sesión falla, somos redirigidos a la página de error de inicio de sesión.

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Pero si el **inicio de sesión es exitoso**, somos redirigidos a la página principal de Jenkins y se establece una **cookie de sesión**.

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

Por lo tanto, podemos **forzar las credenciales de Jenkins y obtener una cookie de sesión**.\
Sin embargo, estamos un poco limitados: solo podemos **enviar una solicitud sin estado cada vez** y la **cookie no se puede adjuntar** a nuestra solicitud, ya que no podemos controlar las cabeceras.

Otra opción sería intentar obtener un **token de acceso de Jenkins**, que se puede adjuntar en la URL y utilizar para enviar solicitudes POST a Jenkins sin necesidad de agregar un token CSRF. Esta opción es un poco más compleja, ya que requiere que un atacante encuentre de alguna manera un CI autohospedado que solo sea accesible desde los rangos de IP de SCM y también obtenga un token de acceso válido para ese CI. Por el momento, nos centraremos en escenarios más prácticos.

## Webhooks de GitLab

### Abuso del inicio de sesión de Jenkins

Intentemos enviar la misma solicitud, pero esta vez a través de GitLab. Debido a las mismas limitaciones, enviamos la **misma solicitud POST, agregando las credenciales como parámetros de consulta**.

<figure><img src="../../.gitbook/assets/image (2) (2).png" alt=""><figcaption></figcaption></figure>

Disparamos la solicitud, pero a diferencia de GitHub, la respuesta es 200. Como en el último ejemplo, utilizamos el servicio de webhook de **GitLab para forzar las credenciales de un usuario y obtener una cookie de sesión**, pero esta vez, el contenido de la respuesta de Jenkins se transmitió de vuelta a la interfaz de usuario de GitLab, proporcionándonos esencialmente el **contenido completo de la página principal de Jenkins**.\
Esto se debe a que **GitLab siguió la redirección** agregando la **Cookie** a la solicitud:

<figure><img src="../../.gitbook/assets/image (4) (1) (2).png" alt=""><figcaption></figcaption></figure>

Esto significa que podemos:

1. forzar usuarios y descubrir credenciales válidas,
2. utilizar las credenciales válidas en la página de inicio de sesión para iniciar sesión correctamente,
3. obtener el contenido de la página principal interna de Jenkins.

### Obtención de datos internos de Jenkins

El inicio de sesión de Jenkins acepta un parámetro de redirección: "_from_". Originalmente utilizado para **redirigir a los usuarios a la página a la que pretendían acceder después de iniciar sesión**, pero en nuestro caso, es una característica que podemos abusar para enviar una solicitud GET adjunta con una cookie de sesión a una página interna de Jenkins de nuestra elección. Veamos cómo:

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

1. Establezca un webhook con la siguiente URL:
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=secretpass123&from=/job/prod_pipeline/1/consoleText&Submit=Sign+in
```
Se envía una solicitud POST a Jenkins y la autenticación tiene éxito.

* Obtenemos una respuesta de redirección 302, con una cookie de sesión y una redirección a la página de salida de la consola del trabajo.
* El servicio de webhook de GitLab sigue automáticamente la redirección con una solicitud GET enviada a la página de salida de la consola del trabajo, junto con la cookie de sesión que se agrega a la solicitud:
```
http://jenkins.example-domain.com/job/prod_pipeline/1/consoleText
```
* La salida de la consola del trabajo se envía y se presenta en el registro de eventos del webhook de GitLab del atacante.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

Es importante mencionar aquí que Jenkins se puede **configurar para permitir el acceso a componentes internos sin autenticación**, o de una manera que exija que solo los usuarios autenticados puedan acceder a los componentes internos. ¿Cómo nos afecta esto?

* Si no hay autenticación configurada, podemos hacer que el servicio de webhook de **GitLab acceda a cualquier página interna en CI**, capturar la respuesta y presentarla ante nosotros.
* Si se configura la autenticación, podemos intentar forzar el acceso de un usuario y luego usar las credenciales para acceder a cualquier página interna (como en el punto anterior).

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, ¡consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
