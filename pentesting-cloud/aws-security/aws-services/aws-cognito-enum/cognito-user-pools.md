# Pools d'utilisateurs Cognito

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informations de base

Un pool d'utilisateurs est un r√©pertoire d'utilisateurs dans Amazon Cognito. Avec un pool d'utilisateurs, vos utilisateurs peuvent **se connecter √† votre application web ou mobile** via Amazon Cognito, **ou se f√©d√©rer** via un fournisseur d'identit√© **tiers** (IdP). Que vos utilisateurs se connectent directement ou via un tiers, tous les membres du pool d'utilisateurs ont un profil dans l'annuaire que vous pouvez acc√©der via un SDK.

Les pools d'utilisateurs fournissent :

* Des services d'inscription et de connexion.
* Une interface web int√©gr√©e et personnalisable pour connecter les utilisateurs.
* Connexion sociale avec Facebook, Google, Login with Amazon et Sign in with Apple, et via des fournisseurs d'identit√© SAML et OIDC de votre pool d'utilisateurs.
* Gestion des r√©pertoires d'utilisateurs et profils d'utilisateurs.
* Des fonctionnalit√©s de s√©curit√© telles que l'authentification multi-facteurs (MFA), la v√©rification des identifiants compromis, la protection contre la prise de contr√¥le de compte, et la v√©rification par t√©l√©phone et email.
* Des flux de travail personnalis√©s et la migration des utilisateurs via les d√©clencheurs AWS Lambda.

Le **code source** des applications contiendra g√©n√©ralement √©galement l'**ID du pool d'utilisateurs** et l'**ID de l'application cliente**, (et parfois le **secret de l'application** ?) qui sont n√©cessaires pour qu'un **utilisateur se connecte** √† un pool d'utilisateurs Cognito.

### Attaques potentielles

* **Inscription** : Par d√©faut, un utilisateur peut s'inscrire lui-m√™me, il pourrait donc cr√©er un utilisateur pour lui-m√™me.
* **√ânum√©ration des utilisateurs** : La fonctionnalit√© d'inscription peut √™tre utilis√©e pour trouver des noms d'utilisateur qui existent d√©j√†. Cette information peut √™tre utile pour l'attaque par force brute.
* **Force brute de connexion** : Dans la section [**Authentification**](cognito-user-pools.md#authentication), vous avez toutes les **m√©thodes** qu'un utilisateur doit utiliser pour **se connecter**, vous pourriez essayer de les forcer pour **trouver des identifiants valides**.

### Outils pour le pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), le framework d'exploitation AWS, inclut d√©sormais les modules "cognito\_\_enum" et "cognito\_\_attack" qui automatisent l'√©num√©ration de tous les actifs Cognito dans un compte et signalent les configurations faibles, les attributs d'utilisateur utilis√©s pour le contr√¥le d'acc√®s, etc., et automatisent √©galement la cr√©ation d'utilisateur (y compris le support MFA) et l'escalade de privil√®ges bas√©e sur des attributs personnalis√©s modifiables, des identifiants de pool d'identit√© utilisables, des r√¥les assumables dans les jetons d'identit√©, etc.

Pour une description des fonctions des modules, voir la partie 2 du [billet de blog](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Pour les instructions d'installation, consultez la page principale de [Pacu](https://github.com/RhinoSecurityLabs/pacu).

#### Utilisation

Exemple d'utilisation de cognito\_\_attack pour tenter la cr√©ation d'utilisateur et tous les vecteurs d'escalade de privil√®ges contre un pool d'identit√© et un client de pool d'utilisateurs donn√©s :
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
```markdown
Exemple d'utilisation de cognito\_\_enum pour rassembler tous les user pools, user pool clients, identity pools, utilisateurs, etc. visibles dans le compte AWS actuel :
```
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) est un outil CLI en python qui impl√©mente diff√©rentes attaques sur Cognito, y compris la cr√©ation de compte non d√©sir√©e et l'oracle de compte.

#### Installation
```bash
$ pip install cognito-scanner
```
#### Utilisation
```bash
$ cognito-scanner --help
```
Pour plus d'informations, consultez https://github.com/padok-team/cognito-scanner

## Inscription

User Pools permet par **d√©faut** de **cr√©er de nouveaux utilisateurs**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Si tout le monde peut s'inscrire

Vous pourriez trouver une erreur vous indiquant que vous devez **fournir plus de d√©tails** sur l'utilisateur :
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Vous pouvez fournir les d√©tails n√©cessaires avec un JSON tel que :
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Vous pourriez √©galement utiliser cette fonctionnalit√© pour **√©num√©rer les utilisateurs existants.** Voici le message d'erreur lorsqu'un utilisateur existe d√©j√† avec ce nom :
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Notez dans la commande pr√©c√©dente comment les **attributs personnalis√©s commencent par "custom:"**.\
Sachez √©galement que lors de l'enregistrement, vous **ne pouvez pas cr√©er de nouveaux attributs personnalis√©s pour l'utilisateur**. Vous pouvez uniquement donner une valeur aux **attributs par d√©faut** (m√™me s'ils ne sont pas requis) et aux **attributs personnalis√©s sp√©cifi√©s**.
{% endhint %}

Ou simplement pour tester si un identifiant client existe. Voici l'erreur si l'identifiant client n'existe pas :
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Si seuls les administrateurs peuvent enregistrer des utilisateurs

Vous rencontrerez cette erreur et vous ne pourrez pas enregistrer ou √©num√©rer les utilisateurs :
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### V√©rification de l'inscription

Cognito permet de **v√©rifier un nouvel utilisateur en v√©rifiant son e-mail ou son num√©ro de t√©l√©phone**. Ainsi, lors de la cr√©ation d'un utilisateur, il vous sera g√©n√©ralement demand√© au moins le nom d'utilisateur et le mot de passe ainsi que **l'e-mail et/ou le num√©ro de t√©l√©phone**. Il suffit d'en d√©finir un **que vous contr√¥lez** afin de recevoir le code pour **v√©rifier votre** nouveau compte utilisateur cr√©√© comme ceci :
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
M√™me si **il semble que vous pouvez utiliser le m√™me e-mail** et num√©ro de t√©l√©phone, lorsque vous devez v√©rifier l'utilisateur cr√©√©, Cognito se plaindra de l'utilisation des m√™mes informations et **ne vous permettra pas de v√©rifier le compte**.
{% endhint %}

### √âl√©vation de privil√®ges / Mise √† jour des attributs

Par d√©faut, un utilisateur peut **modifier la valeur de ses attributs** avec quelque chose comme :
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### √âl√©vation de privil√®ges via attribut personnalis√©

{% hint style="danger" %}
Vous pourriez trouver des **attributs personnalis√©s** utilis√©s (comme `isAdmin`), car par d√©faut vous pouvez **changer les valeurs de vos propres attributs**, vous pourriez √™tre capable d'**√©lever vos privil√®ges** en modifiant la valeur vous-m√™me !
{% endhint %}

#### √âl√©vation de privil√®ges via modification de l'email/nom d'utilisateur

Vous pouvez utiliser ceci pour **modifier l'email et le num√©ro de t√©l√©phone** d'un utilisateur, mais ensuite, m√™me si le compte reste v√©rifi√©, ces attributs sont **mis en statut non v√©rifi√©** (vous devez les v√©rifier √† nouveau).

{% hint style="warning" %}
Vous **ne pourrez pas vous connecter avec l'email ou le num√©ro de t√©l√©phone** jusqu'√† ce que vous les v√©rifiiez, mais vous serez **capable de vous connecter avec le nom d'utilisateur**.\
Notez que m√™me si l'email a √©t√© modifi√© et non v√©rifi√©, il appara√Ætra dans le Token ID dans le **champ `email`** et le champ **`email_verified`** sera **faux**, mais si l'application **ne v√©rifie pas cela, vous pourriez vous faire passer pour d'autres utilisateurs**.

De plus, notez que vous pouvez mettre n'importe quoi dans le champ **`name`** juste en modifiant l'**attribut name**. Si une application **v√©rifie** ce **champ** pour une raison quelconque **au lieu de l'`email`** (ou tout autre attribut), vous pourriez √™tre capable de **vous faire passer pour d'autres utilisateurs**.
{% endhint %}

Quoi qu'il en soit, si pour une raison quelconque vous avez chang√© votre email pour un nouveau auquel vous pouvez acc√©der, vous pouvez **confirmer l'email avec le code que vous avez re√ßu √† cette adresse email** :
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Utilisez **`phone_number`** au lieu de **`email`** pour changer/v√©rifier un **nouveau num√©ro de t√©l√©phone**.

{% hint style="info" %}
L'administrateur peut √©galement activer l'option de **connexion avec un nom d'utilisateur pr√©f√©r√©**. Notez que vous ne pourrez pas changer cette valeur pour **n'importe quel nom d'utilisateur ou preferred_username d√©j√† utilis√©** pour usurper l'identit√© d'un autre utilisateur.
{% endhint %}

### R√©cup√©rer/Changer de mot de passe

Il est possible de r√©cup√©rer un mot de passe en **connaissant uniquement le nom d'utilisateur** (ou l'email ou le t√©l√©phone sont accept√©s) et en ayant acc√®s √† celui-ci car un code y sera envoy√© :
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La r√©ponse du serveur sera toujours positive, comme si le nom d'utilisateur existait. Vous ne pouvez pas utiliser cette m√©thode pour √©num√©rer les utilisateurs.
{% endhint %}

Avec le code, vous pouvez changer le mot de passe avec :
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Pour changer le mot de passe, vous devez **conna√Ætre le mot de passe pr√©c√©dent** :
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentification

Un pool d'utilisateurs prend en charge **diff√©rentes mani√®res de s'authentifier**. Si vous avez un **nom d'utilisateur et un mot de passe**, il existe √©galement **diff√©rentes m√©thodes** prises en charge pour se connecter.\
De plus, lorsqu'un utilisateur est authentifi√© dans le Pool, **3 types de jetons sont donn√©s** : Le **jeton ID**, le **jeton d'acc√®s** et le **jeton d'actualisation**.

* [**Jeton ID**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) : Il contient des revendications sur **l'identit√© de l'utilisateur authentifi√©,** telles que `name`, `email`, et `phone_number`. Le jeton ID peut √©galement √™tre utilis√© pour **authentifier les utilisateurs aupr√®s de vos serveurs de ressources ou applications serveur**. Vous devez **v√©rifier** la **signature** du jeton ID avant de pouvoir faire confiance √† toute revendication √† l'int√©rieur du jeton ID si vous l'utilisez dans des applications externes.
* Le jeton ID est le jeton qui **contient les valeurs des attributs de l'utilisateur**, y compris les personnalis√©s.
* [**Jeton d'acc√®s**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) : Il contient des revendications sur l'utilisateur authentifi√©, une liste des **groupes de l'utilisateur, et une liste de port√©es**. Le but du jeton d'acc√®s est d'**autoriser les op√©rations API** dans le contexte de l'utilisateur dans le pool d'utilisateurs. Par exemple, vous pouvez utiliser le jeton d'acc√®s pour **accorder √† votre utilisateur l'acc√®s** pour ajouter, modifier ou supprimer des attributs d'utilisateur.
* [**Jeton d'actualisation**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html) : Avec les jetons d'actualisation, vous pouvez **obtenir de nouveaux jetons ID et jetons d'acc√®s** pour l'utilisateur jusqu'√† ce que le **jeton d'actualisation soit invalide**. Par **d√©faut**, le jeton d'actualisation **expire 30 jours apr√®s** que votre utilisateur d'application se connecte √† votre pool d'utilisateurs. Lorsque vous cr√©ez une application pour votre pool d'utilisateurs, vous pouvez d√©finir l'expiration du jeton d'actualisation de l'application √† **toute valeur entre 60 minutes et 10 ans**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Voici le flux d'authentification c√¥t√© serveur :

* L'application c√¥t√© serveur appelle l'op√©ration API **`AdminInitiateAuth`** (au lieu de `InitiateAuth`). Cette op√©ration n√©cessite des identifiants AWS avec des permissions qui incluent **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**. L'op√©ration renvoie les param√®tres d'authentification requis.
* Apr√®s que l'application c√¥t√© serveur ait les **param√®tres d'authentification**, elle appelle l'op√©ration API **`AdminRespondToAuthChallenge`**. L'op√©ration API `AdminRespondToAuthChallenge` ne r√©ussit que lorsque vous fournissez des identifiants AWS.

Cette **m√©thode n'est PAS activ√©e** par d√©faut.

Pour **se connecter**, vous **devez conna√Ætre** :

* l'identifiant du pool d'utilisateurs
* l'identifiant du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (seulement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour √™tre **capable de se connecter avec cette m√©thode**, l'application doit autoriser la connexion avec `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
De plus, pour effectuer cette action, vous avez besoin d'identifiants avec les permissions **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Cette m√©thode est un autre flux d'authentification **traditionnel utilisateur & mot de passe** simple. Il est recommand√© de **migrer une m√©thode d'authentification traditionnelle vers Cognito** et de la **d√©sactiver** ensuite pour **utiliser** la m√©thode **ALLOW\_USER\_SRP\_AUTH** √† la place (car celle-ci ne transmet jamais le mot de passe sur le r√©seau).\
Cette **m√©thode n'est PAS activ√©e** par d√©faut.

La principale **diff√©rence** avec la **m√©thode d'authentification pr√©c√©dente** dans le code est que vous **n'avez pas besoin de conna√Ætre l'ID du pool d'utilisateurs** et que vous **n'avez pas besoin de permissions suppl√©mentaires** dans le pool d'utilisateurs Cognito.

Pour **se connecter**, vous devez conna√Ætre :

* l'ID client
* le nom d'utilisateur
* le mot de passe
* le secret client (seulement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour √™tre **capable de se connecter avec cette m√©thode**, l'application doit permettre de se connecter avec ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Code Python pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### AUTHENTIFICATION\_USER\_SRP

Ce sc√©nario est similaire au pr√©c√©dent mais **au lieu d'envoyer le mot de passe** √† travers le r√©seau pour se connecter, une **authentification par d√©fi est effectu√©e** (donc pas de mot de passe circulant, m√™me crypt√©, sur le net).\
Cette **m√©thode est activ√©e** par d√©faut.

Pour **se connecter**, vous devez conna√Ætre :

* l'identifiant du pool d'utilisateurs
* l'identifiant du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

<details>

<summary>Code pour se connecter</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Cette **m√©thode sera toujours valide** (elle ne peut pas √™tre d√©sactiv√©e) mais vous devez avoir un jeton d'actualisation valide.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
D√©tails non fournis pour la traduction. Veuillez fournir le contenu sp√©cifique √† traduire.
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

Dans ce cas, l'**authentification** sera effectu√©e par l'**ex√©cution d'une fonction lambda**.

## S√©curit√© suppl√©mentaire

### S√©curit√© avanc√©e

Par d√©faut, elle est d√©sactiv√©e, mais si activ√©e, Cognito pourrait √™tre capable de **d√©tecter des prises de contr√¥le de compte**. Pour minimiser la probabilit√©, vous devriez vous connecter depuis un **r√©seau √† l'int√©rieur de la m√™me ville, en utilisant le m√™me agent utilisateur** (et l'IP si c'est possible)**.**

### **MFA Se souvenir de l'appareil**

Si l'utilisateur se connecte depuis le m√™me appareil, le MFA pourrait √™tre contourn√©, donc essayez de vous connecter depuis le m√™me navigateur avec les m√™mes m√©tadonn√©es (IP ?) pour essayer de contourner la protection MFA.

## Groupes de User Pool et r√¥les IAM

Il est possible d'ajouter des **utilisateurs aux groupes de User Pool** qui sont li√©s √† un **r√¥le IAM**.\
De plus, les **utilisateurs** peuvent √™tre assign√©s √† **plus d'un groupe avec diff√©rents r√¥les IAM** attach√©s.

Notez que m√™me si un groupe est dans un groupe avec un r√¥le IAM attach√©, pour pouvoir acc√©der aux identifiants IAM de ce groupe, il est n√©cessaire que le **User Pool soit approuv√© par un Identity Pool** (et conna√Ætre les d√©tails de cet Identity Pool).

Une autre condition pour obtenir le **r√¥le IAM indiqu√© dans l'IdToken** lorsqu'un utilisateur est authentifi√© dans le User Pool (`aws cognito-idp initiate-auth...`) est que le **fournisseur d'authentification Identity Provider** doit indiquer que le **r√¥le doit √™tre s√©lectionn√© √† partir du token.**

<figure><img src="../../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

Les **r√¥les** auxquels un utilisateur a acc√®s sont **√† l'int√©rieur du `IdToken`**, et un utilisateur peut **s√©lectionner quel r√¥le il souhaite des identifiants pour** avec le **`--custom-role-arn`** de `aws cognito-identity get-credentials-for-identity`.\
Cependant, si l'**option par d√©faut** est celle **configur√©e** (`use default role`), et que vous essayez d'acc√©der √† un r√¥le √† partir de l'IdToken, vous obtiendrez une **erreur** (c'est pourquoi la configuration pr√©c√©dente est n√©cessaire) :

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Notez que le r√¥le attribu√© √† un **User Pool Group** doit √™tre **accessible par le fournisseur d'identit√©** qui **fait confiance au User Pool** (car les **informations d'identification de session du r√¥le IAM** seront obtenues √† partir de celui-ci).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
