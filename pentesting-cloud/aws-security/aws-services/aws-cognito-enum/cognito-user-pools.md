# Piscinas de usuarios de Cognito

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén [**productos oficiales de PEASS y HackTricks**](https://peass.creator-spring.com).
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family).
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).

</details>

## Información básica

Un grupo de usuarios es un directorio de usuarios en Amazon Cognito. Con un grupo de usuarios, tus usuarios pueden **iniciar sesión en tu aplicación web o móvil** a través de Amazon Cognito, **o federarse** a través de un proveedor de identidad (IdP) **tercero**. Ya sea que tus usuarios inicien sesión directamente o a través de un tercero, todos los miembros del grupo de usuarios tienen un perfil de directorio al que puedes acceder a través de un SDK.

Los grupos de usuarios proporcionan:

* Servicios de registro e inicio de sesión.
* Una interfaz de usuario web integrada y personalizable para que los usuarios inicien sesión.
* Inicio de sesión social con Facebook, Google, Inicio de sesión con Amazon y Inicio de sesión con Apple, y a través de proveedores de identidad SAML y OIDC de tu grupo de usuarios.
* Gestión de directorios de usuarios y perfiles de usuario.
* Funciones de seguridad como autenticación multifactor (MFA), verificación de credenciales comprometidas, protección contra toma de cuentas y verificación de teléfono y correo electrónico.
* Flujos de trabajo personalizados y migración de usuarios a través de desencadenadores de AWS Lambda.

El **código fuente** de las aplicaciones generalmente también contiene el **ID del grupo de usuarios** y el **ID de la aplicación cliente** (¿y a veces el **secreto de la aplicación**?), que se necesitan para que un **usuario inicie sesión** en un grupo de usuarios de Cognito.

### Posibles ataques

* **Registro**: Por defecto, un usuario puede registrarse por sí mismo, por lo que podría crear un usuario para sí mismo.
* **Enumeración de usuarios**: La funcionalidad de registro se puede utilizar para encontrar nombres de usuario que ya existen. Esta información puede ser útil para el ataque de fuerza bruta.
* **Ataque de fuerza bruta en el inicio de sesión**: En la sección [**Autenticación**](cognito-user-pools.md#authentication) tienes todos los **métodos** que un usuario tiene que **usar para iniciar sesión**, podrías intentar realizar un ataque de fuerza bruta para **encontrar credenciales válidas**.

### Módulos de Pacu para pentesting y enumeración

[Pacu](https://github.com/RhinoSecurityLabs/pacu), el marco de explotación de AWS, ahora incluye los módulos "cognito__enum" y "cognito__attack" que automatizan la enumeración de todos los activos de Cognito en una cuenta y detectan configuraciones débiles, atributos de usuario utilizados para el control de acceso, etc., y también automatizan la creación de usuarios (incluido el soporte de MFA) y la escalada de privilegios basada en atributos personalizables modificables, credenciales de la piscina de identidades utilizables, roles asumibles en tokens de identidad, etc.

Para obtener una descripción de las funciones de los módulos, consulta la parte 2 de la [publicación del blog](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Para obtener instrucciones de instalación, consulta la página principal de [Pacu](https://github.com/RhinoSecurityLabs/pacu).

### Uso

Uso de muestra de cognito__attack para intentar la creación de usuarios y todos los vectores de escalada de privilegios contra una piscina de identidades y un cliente de grupo de usuarios específicos:
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Uso de ejemplo de cognito__enum para recopilar todos los grupos de usuarios, clientes de grupos de usuarios, grupos de identidad, usuarios, etc. visibles en la cuenta actual de AWS:

```bash
cognito__enum --all
```

Este comando ejecutará una enumeración exhaustiva de todos los servicios de Cognito en la cuenta de AWS actual. Recopilará información sobre los grupos de usuarios, los clientes de grupos de usuarios, los grupos de identidad y los usuarios asociados a cada grupo de usuarios. Esta información puede ser útil para evaluar la seguridad de los servicios de Cognito y detectar posibles vulnerabilidades.
```bash
Pacu (new:test) > run cognito__enum
```
### Herramienta para pentesting

[Cognito Scanner](https://github.com/padok-team/cognito-scanner) es una herramienta de línea de comandos en Python que implementa diferentes ataques en Cognito, incluyendo la creación no deseada de cuentas y el oráculo de cuentas.

#### Instalación
```bash
$ pip install cognito-scanner
```
#### Uso

```plaintext
cognito-user-pools.py [-h] [--region REGION] [--userpool USERPOOL]
                      [--username USERNAME] [--email EMAIL]
                      [--phone PHONE] [--output OUTPUT] [--verbose]
                      [--no-color]

optional arguments:
  -h, --help           show this help message and exit
  --region REGION      AWS region where the user pool is located
  --userpool USERPOOL  User pool ID
  --username USERNAME  Username to search for
  --email EMAIL        Email to search for
  --phone PHONE        Phone number to search for
  --output OUTPUT      Output file to save the results
  --verbose            Enable verbose output
  --no-color           Disable colored output
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --email admin@example.com
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --phone +1234567890
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --output results.txt
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --verbose
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --no-color
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --output results.txt --verbose
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --email admin@example.com --no-color
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --phone +1234567890 --output results.txt --verbose --no-color
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color > results.html
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee results.html
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq .
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin"
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}'
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users"
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u | wc -l
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u | wc -l | awk '{print $1}'
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u | wc -l | awk '{print $1}' | xargs -I {} echo "Total {} unique users found"
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u | wc -l | awk '{print $1}' | xargs -I {} echo "Total {} unique users found" | tee -a results.txt
```

```plaintext
python3 cognito-user-pools.py --region us-west-2 --userpool us-west-2_abcd1234 --username admin --email admin@example.com --phone +1234567890 --output results.txt --verbose --no-color | tee -a results.html | jq . > results.json | cat results.json | grep "admin" | wc -l | awk '{print $1}' | xargs -I {} echo "Found {} users" | tee -a results.txt | cat results.txt | sort -u | wc -l | awk '{print $1}' | xargs -I {} echo "Total {} unique users found" | tee -a results.txt | cat results.txt
```

```plaintext
cat results.txt
```

```plaintext
cat results.html
```

```plaintext
cat results.json
```

```plaintext
rm results.txt
```

```plaintext
rm results.html
```

```plaintext
rm results.json
```

```plaintext
rm -rf __pycache__
```

```plaintext
rm -rf .mypy_cache
```

```plaintext
rm -rf .pytest_cache
```

```plaintext
rm -rf .coverage
```

```plaintext
rm -rf htmlcov
```

```plaintext
rm -rf dist
```

```plaintext
rm -rf build
```

```plaintext
rm -rf *.egg-info
```

```plaintext
rm -rf .eggs
```

```plaintext
rm -rf .tox
```

```plaintext
rm -rf .venv
```

```plaintext
rm -rf venv
```

```plaintext
rm -rf .vscode
```

```plaintext
rm -rf .idea
```

```plaintext
rm -rf .git
```

```plaintext
rm -rf .github
```

```plaintext
rm -rf .gitignore
```

```plaintext
rm -rf .gitattributes
```

```plaintext
rm -rf .travis.yml
```

```plaintext
rm -rf .dockerignore
```

```plaintext
rm -rf Dockerfile
```

```plaintext
rm -rf docker-compose.yml
```

```plaintext
rm -rf Jenkinsfile
```

```plaintext
rm -rf Pipfile
```

```plaintext
rm -rf Pipfile.lock
```

```plaintext
rm -rf requirements.txt
```

```plaintext
rm -rf setup.py
```

```plaintext
rm -rf MANIFEST.in
```

```plaintext
rm -rf LICENSE
```

```plaintext
rm -rf README.md
```

```plaintext
rm -rf CHANGELOG.md
```

```plaintext
rm -rf CONTRIBUTING.md
```

```plaintext
rm -rf CODE_OF_CONDUCT.md
```

```plaintext
rm -rf SECURITY.md
```

```plaintext
rm -rf .pre-commit-config.yaml
```

```plaintext
rm -rf .pylintrc
```

```plaintext
rm -rf .flake8
```

```plaintext
rm -rf .editorconfig
```

```plaintext
rm -rf .gitlab-ci.yml
```

```plaintext
rm -rf .azure-pipelines.yml
```

```plaintext
rm -rf .circleci
```

```plaintext
rm -rf .appveyor.yml
```

```plaintext
rm -rf .bumpversion.cfg
```

```plaintext
rm -rf .coveragerc
```

```plaintext
rm -rf .readthedocs.yml
```

```plaintext
rm -rf .gitkeep
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```

```plaintext
rm -rf .gitpod.yml
```

```plaintext
rm -rf .gitpod.Dockerfile
```

```plaintext
rm -rf .gitpod.docker-compose.yml
```bash
$ cognito-scanner --help
```
Para más información, visita https://github.com/padok-team/cognito-scanner

## Registro

Los User Pools permiten, por **defecto**, **registrar nuevos usuarios**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Si cualquiera puede registrarse

Es posible que encuentres un error que te indique que necesitas **proporcionar más detalles** sobre el usuario:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Puedes proporcionar los detalles necesarios con un JSON como:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
También puedes utilizar esta funcionalidad para **enumerar usuarios existentes**. Este es el mensaje de error cuando ya existe un usuario con ese nombre:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Ten en cuenta que en el comando anterior, los **atributos personalizados comienzan con "custom:"**.\
También debes saber que al registrarte **no puedes crear nuevos atributos personalizados para el usuario**. Solo puedes asignar valores a los **atributos predeterminados** (incluso si no son obligatorios) y a los **atributos personalizados especificados**.
{% endhint %}

O simplemente para probar si existe un ID de cliente. Este es el error si el ID de cliente no existe:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Si solo el administrador puede registrar usuarios

Encontrarás este error y no podrás registrar o enumerar usuarios:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verificación de Registro

Cognito permite **verificar a un nuevo usuario verificando su correo electrónico o número de teléfono**. Por lo tanto, al crear un usuario, generalmente se requerirá al menos el nombre de usuario y la contraseña, y el **correo electrónico y/o número de teléfono**. Simplemente establezca uno **que controle** para recibir el código y **verificar su** cuenta de usuario recién creada de la siguiente manera:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
Incluso si parece que puedes usar el mismo correo electrónico y número de teléfono, cuando necesites verificar el usuario creado, Cognito se quejará de usar la misma información y no te permitirá verificar la cuenta.
{% endhint %}

### Escalada de privilegios / Actualización de atributos

Por defecto, un usuario puede modificar el valor de sus atributos con algo como:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Privilegio de escalada de atributos personalizados

{% hint style="danger" %}
Es posible que encuentres el uso de **atributos personalizados** (como `isAdmin`), ya que de forma predeterminada puedes **cambiar los valores de tus propios atributos**, lo que te permitiría **escalar privilegios** cambiando el valor tú mismo.
{% endhint %}

#### Privilegio de modificación de correo electrónico/nombre de usuario

Puedes utilizar esto para **modificar el correo electrónico y el número de teléfono** de un usuario, pero luego, aunque la cuenta siga verificada, esos atributos se **establecerán en estado no verificado** (deberás verificarlos nuevamente).

{% hint style="warning" %}
No podrás iniciar sesión con el correo electrónico o el número de teléfono hasta que los verifiques, pero podrás iniciar sesión con el nombre de usuario.\
Ten en cuenta que incluso si el correo electrónico se modificó y no se verificó, aparecerá en el Token de ID dentro del campo **`email`** y el campo **`email_verified`** será **falso**, pero si la aplicación **no verifica eso**, podrías suplantar a otros usuarios.

Además, ten en cuenta que puedes poner cualquier cosa dentro del campo **`name`** simplemente modificando el **atributo de nombre**. Si una aplicación está **verificando** ese campo por alguna razón **en lugar del `email`** (u otro atributo), podrías suplantar a otros usuarios.
{% endhint %}

De todos modos, si por alguna razón cambiaste tu correo electrónico, por ejemplo, a uno nuevo al que puedes acceder, puedes **confirmar el correo electrónico con el código que recibiste en esa dirección de correo**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Utilice **`phone_number`** en lugar de **`email`** para cambiar/verificar un **nuevo número de teléfono**.

{% hint style="info" %}
El administrador también puede habilitar la opción de **iniciar sesión con un nombre de usuario preferido por el usuario**. Tenga en cuenta que no podrá cambiar este valor a **cualquier nombre de usuario o preferred\_username que ya esté siendo utilizado** para suplantar a otro usuario.
{% endhint %}

### Recuperar/Cambiar contraseña

Es posible recuperar una contraseña solo **conociendo el nombre de usuario** (o el correo electrónico o el teléfono también son aceptados) y teniendo acceso a él, ya que se enviará un código allí:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La respuesta del servidor siempre será positiva, como si el nombre de usuario existiera. No se puede utilizar este método para enumerar usuarios.
{% endhint %}

Con el código puedes cambiar la contraseña con:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Para cambiar la contraseña, necesitas **conocer la contraseña anterior**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Autenticación

Un grupo de usuarios admite **diferentes formas de autenticación**. Si tienes un **nombre de usuario y contraseña**, también hay **diferentes métodos** compatibles para iniciar sesión. Además, cuando un usuario se autentica en el grupo, se le otorgan **3 tipos de tokens**: el **Token de ID**, el **Token de acceso** y el **Token de actualización**.

* [**Token de ID**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Contiene reclamaciones sobre la **identidad del usuario autenticado**, como `nombre`, `correo electrónico` y `número de teléfono`. El token de ID también se puede utilizar para **autenticar usuarios en tus servidores de recursos o aplicaciones de servidor**. Debes **verificar** la **firma** del token de ID antes de confiar en cualquier reclamación dentro del token de ID si lo usas en aplicaciones externas.
* El Token de ID es el token que **contiene los valores de los atributos del usuario**, incluso los personalizados.
* [**Token de acceso**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Contiene reclamaciones sobre el usuario autenticado, una lista de los **grupos del usuario y una lista de alcances**. El propósito del token de acceso es **autorizar operaciones de API** en el contexto del usuario en el grupo de usuarios. Por ejemplo, puedes usar el token de acceso para **conceder acceso a tu usuario** para agregar, cambiar o eliminar atributos de usuario.
* [**Token de actualización**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Con los tokens de actualización, puedes **obtener nuevos Tokens de ID y Tokens de acceso** para el usuario hasta que el **token de actualización sea inválido**. De forma **predeterminada**, el token de actualización **caduca 30 días después** de que el usuario de tu aplicación inicie sesión en el grupo de usuarios. Cuando creas una aplicación para tu grupo de usuarios, puedes establecer la expiración del token de actualización de la aplicación a **cualquier valor entre 60 minutos y 10 años**.

### ADMIN\_NO\_SRP\_AUTH y ADMIN\_USER\_PASSWORD\_AUTH

Este es el flujo de autenticación del lado del servidor:

* La aplicación del lado del servidor llama a la operación de API **`AdminInitiateAuth`** (en lugar de `InitiateAuth`). Esta operación requiere credenciales de AWS con permisos que incluyan **`cognito-idp:AdminInitiateAuth`** y **`cognito-idp:AdminRespondToAuthChallenge`**. La operación devuelve los parámetros de autenticación requeridos.
* Después de que la aplicación del lado del servidor tenga los **parámetros de autenticación**, llama a la operación de API **`AdminRespondToAuthChallenge`**. La operación de API `AdminRespondToAuthChallenge` solo tiene éxito cuando proporcionas credenciales de AWS.

Este **método NO está habilitado** de forma predeterminada.

Para **iniciar sesión**, necesitas saber:

* ID del grupo de usuarios
* ID del cliente
* Nombre de usuario
* Contraseña
* Secreto del cliente (solo si la aplicación está configurada para usar un secreto)

{% hint style="info" %}
Para poder **iniciar sesión con este método**, la aplicación debe permitir iniciar sesión con `ALLOW_ADMIN_USER_PASSWORD_AUTH`. Además, para realizar esta acción, necesitas credenciales con los permisos **`cognito-idp:AdminInitiateAuth`** y **`cognito-idp:AdminRespondToAuthChallenge`**.
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Código para iniciar sesión</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Este método es otro flujo de autenticación de usuario y contraseña simple y tradicional. Se recomienda migrar un método de autenticación tradicional a Cognito y luego deshabilitarlo y utilizar el método ALLOW\_USER\_SRP\_AUTH en su lugar (ya que este nunca envía la contraseña a través de la red). Este método NO está habilitado de forma predeterminada.

La principal diferencia con el método de autenticación anterior en el código es que no necesitas conocer el ID del grupo de usuarios y no necesitas permisos adicionales en el grupo de usuarios de Cognito.

Para iniciar sesión, necesitas conocer:

* ID del cliente
* nombre de usuario
* contraseña
* secreto del cliente (solo si la aplicación está configurada para usar un secreto)

{% hint style="info" %}
Para poder iniciar sesión con este método, la aplicación debe permitir iniciar sesión con ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Código Python para iniciar sesión</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Este escenario es similar al anterior pero en lugar de enviar la contraseña a través de la red para iniciar sesión, se realiza una autenticación de desafío (por lo que la contraseña no navega ni siquiera encriptada a través de la red).\
Este método está habilitado de forma predeterminada.

Para iniciar sesión, necesitas saber:

* ID del grupo de usuarios
* ID del cliente
* nombre de usuario
* contraseña
* secreto del cliente (solo si la aplicación está configurada para usar un secreto)

<details>

<summary>Código para iniciar sesión</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Este **método siempre será válido** (no se puede desactivar), pero necesitas tener un token de actualización válido.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Código para refrescar</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

En este caso, la **autenticación** se realizará a través de la **ejecución de una función lambda**.

## Seguridad adicional

### Seguridad avanzada

De forma predeterminada, está desactivada, pero si está habilitada, Cognito podría ser capaz de **detectar tomas de control de cuentas**. Para minimizar la probabilidad, debes iniciar sesión desde una **red dentro de la misma ciudad, utilizando el mismo agente de usuario** (y la misma IP si es posible).

### **Recordar dispositivo MFA**

Si el usuario inicia sesión desde el mismo dispositivo, es posible que se omita el MFA, por lo tanto, intenta iniciar sesión desde el mismo navegador con los mismos metadatos (¿IP?) para intentar omitir la protección MFA.

## Roles IAM de grupos de User Pool

Es posible agregar **usuarios a grupos de User Pool** que están relacionados con **roles IAM**. Además, los **usuarios** pueden ser asignados a **más de 1 grupo con diferentes roles IAM** adjuntos.

Ten en cuenta que incluso si un grupo está dentro de un grupo con un rol IAM adjunto, para poder acceder a las credenciales IAM de ese grupo, es necesario que el **User Pool sea confiable por un Identity Pool** (y conocer los detalles de ese Identity Pool).

Otro requisito para obtener el **rol IAM indicado en el IdToken** cuando un usuario se autentica en el User Pool (`aws cognito-idp initiate-auth...`) es que el **proveedor de autenticación del proveedor de identidad** debe indicar que el **rol debe ser seleccionado del token**.

<figure><img src="../../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

Los **roles** a los que un usuario tiene acceso están **dentro del `IdToken`**, y un usuario puede **seleccionar qué rol desea obtener credenciales** con el **`--custom-role-arn`** de `aws cognito-identity get-credentials-for-identity`. Sin embargo, si la opción **predeterminada** es la que está **configurada** (`use default role`), y tratas de acceder a un rol desde el IdToken, obtendrás un **error** (por eso se necesita la configuración anterior):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Ten en cuenta que el rol asignado a un **Grupo de User Pool** debe ser **accesible por el Proveedor de Identidad** que **confía en la User Pool** (ya que las credenciales de sesión del rol IAM **se obtendrán de él**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop).
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com).
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family).
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>
