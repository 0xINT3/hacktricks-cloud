# Cognito User Pools

<details>

<summary><strong>从零开始学习AWS黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

用户池是Amazon Cognito中的用户目录。使用用户池，您的用户可以通过Amazon Cognito**登录到您的Web或移动应用程序**，或通过**第三方**身份提供商（IdP）**联合登录**。无论用户是直接登录还是通过第三方登录，用户池的所有成员都有一个目录配置文件，您可以通过SDK访问。

用户池提供：

* 注册和登录服务。
* 一个内置的、可自定义的Web UI用于用户登录。
* 与Facebook、Google、使用Amazon登录和使用Apple登录以及通过SAML和OIDC身份提供商从您的用户池登录的社交登录。
* 用户目录管理和用户配置文件。
* 安全功能，如多因素身份验证（MFA）、检查受损凭据、防止账户被接管以及电话和电子邮件验证。
* 通过AWS Lambda触发器进行自定义工作流和用户迁移。

应用程序的**源代码**通常还会包含**用户池ID**和**客户端应用程序ID**（有时还包括**应用程序密钥**？），这些信息对于**用户登录到Cognito用户池**是必需的。

### 潜在攻击

* **注册**：默认情况下，用户可以自行注册，因此他可以为自己创建用户。
* **用户枚举**：注册功能可用于查找已存在的用户名。这些信息对于暴力破解攻击可能很有用。
* **登录暴力破解**：在[**身份验证**](cognito-user-pools.md#authentication)部分，您可以找到用户登录所需的所有**方法**，您可以尝试对它们进行暴力破解以**找到有效凭据**。

### 渗透测试工具

* [Pacu](https://github.com/RhinoSecurityLabs/pacu)，AWS利用框架，现在包括“cognito\_\_enum”和“cognito\_\_attack”模块，自动枚举账户中所有Cognito资产，并标记弱配置、用于访问控制的用户属性等，并自动创建用户（包括MFA支持）和基于可修改的自定义属性、可用的身份池凭据、id令牌中可假定的角色等进行特权升级。

有关模块功能的描述，请参阅[博客文章](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)的第2部分。有关安装说明，请参阅主要[Pacu](https://github.com/RhinoSecurityLabs/pacu)页面。

#### 用法

示例cognito\_\_attack用法，尝试对给定的身份池和用户池客户端进行用户创建和所有特权升级向量的攻击：

```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```

以下是使用cognito\_\_enum的示例，用于收集当前AWS账户中可见的所有用户池、用户池客户端、身份池、用户等信息：

```bash
Pacu (new:test) > run cognito__enum
```

* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) 是一个用 Python 编写的 CLI 工具，实现对 Cognito 的不同攻击，包括未经授权的账户创建和账户预测。

#### 安装

```bash
$ pip install cognito-scanner
```

#### 用法

```bash
$ cognito-scanner --help
```

更多信息请查看 https://github.com/padok-team/cognito-scanner

## 注册

用户池默认允许注册新用户。

```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```

#### 如果任何人都可以注册

您可能会遇到一个错误，指示您需要提供有关用户的更多详细信息：

```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```

您可以使用以下 JSON 提供所需的详细信息：

```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```

你也可以使用这个功能来**枚举现有用户**。当使用已存在的用户名时，会显示以下错误消息：

```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```

{% hint style="info" %}
请注意前一个命令中**自定义属性以"custom:"开头**。\
还要知道，在注册时**无法为用户创建新的自定义属性**。您只能为**默认属性**（即使它们不是必需的）和**指定的自定义属性**赋值。
{% endhint %}

或者只是测试客户端ID是否存在。如果客户端ID不存在，则会出现以下错误：

```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```

#### 如果只有管理员可以注册用户

您将会遇到此错误，无法注册或枚举用户：

```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```

### 验证注册

Cognito允许通过验证电子邮件或电话号码来验证新用户。因此，当创建用户时，通常至少需要用户名和密码以及电子邮件和/或电话号码。只需设置一个您控制的电子邮件或电话号码，这样您将收到用于验证新创建的用户帐户的代码，如下所示：

```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```

{% hint style="warning" %}
即使**看起来你可以使用相同的电子邮件**和电话号码，但当您需要验证创建的用户时，Cognito会抱怨使用相同的信息，并且**不会让您验证该帐户**。
{% endhint %}

### 提权 / 更新属性

默认情况下，用户可以使用以下方式**修改其属性的值**：

```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```

#### 自定义属性权限提升

{% hint style="danger" %}
您可能会发现正在使用**自定义属性**（例如`isAdmin`），默认情况下，您可以**更改自己属性的值**，因此您可能能够通过更改值来**提升权限**！
{% endhint %}

#### 电子邮件/用户名修改权限提升

您可以使用此功能来**修改用户的电子邮件和电话号码**，但即使帐户保持为已验证状态，这些属性也会**设置为未验证状态**（您需要重新验证它们）。

{% hint style="warning" %}
您**将无法使用电子邮件或电话号码登录**，直到您验证它们，但您将**能够使用用户名登录**。\
请注意，即使电子邮件已被修改但未经验证，它也将出现在ID令牌中的\*\*`email`\*\* **字段**中，字段\*\*`email_verified`**将为**false\*\*，但如果应用程序**未检查**，您可能会冒充其他用户。

此外，请注意，您可以通过修改**名称属性**在\*\*`name`**字段中放入任何内容。如果应用程序出于某种原因**检查**该字段而不是`email`（或任何其他属性），您可能能够**冒充其他用户\*\*。
{% endhint %}

无论如何，如果由于某种原因您将您的电子邮件更改为新的电子邮件地址，您可以使用您在该电子邮件地址中收到的代码**确认电子邮件**：

```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```

使用\*\*`phone_number`**而不是**`email`**来更改/验证**新的电话号码\*\*。

{% hint style="info" %}
管理员还可以启用选项，使用用户首选的用户名进行登录。请注意，您无法将此值更改为已被使用的**任何用户名或preferred\_username**以冒充不同的用户。
{% endhint %}

### 恢复/更改密码

只需**知道用户名**（或接受电子邮件或电话）并访问该用户名，即可恢复密码，代码将发送到该位置：

```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```

{% hint style="info" %}
服务器的响应始终是积极的，就像用户名存在一样。您无法使用此方法枚举用户。
{% endhint %}

使用以下代码可以更改密码：

```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```

要更改密码，您需要**知道先前的密码**：

```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```

## 认证

用户池支持**不同的身份验证方式**。如果您有**用户名和密码**，还支持**不同的登录方法**。此外，当用户在池中进行身份验证时，会提供**3种类型的令牌**：**ID 令牌**、**访问令牌**和**刷新令牌**。

* [**ID 令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html)：它包含有关**经过身份验证的用户的身份**的声明，如`name`、`email`和`phone_number`。ID 令牌还可用于**将用户身份验证到您的资源服务器或服务器应用程序**。在您将其用于外部应用程序之前，必须**验证**ID 令牌的**签名**，以便信任ID 令牌中的任何声明。
* ID 令牌是**包含用户属性值的令牌**，甚至包括自定义属性。
* [**访问令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html)：它包含有关经过身份验证的用户、用户组列表和作用域列表的声明。访问令牌的目的是**授权用户池中用户的 API 操作**。例如，您可以使用访问令牌**授予用户访问权限**以添加、更改或删除用户属性。
* [**刷新令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html)：使用刷新令牌，您可以为用户获取新的 ID 令牌和访问令牌，直到**刷新令牌失效**。**默认情况下**，刷新令牌**在用户登录到用户池后的 30 天后过期**。创建用户池的应用程序时，可以将应用程序的刷新令牌过期时间设置为**60分钟至10年之间的任何值**。

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

这是服务器端的身份验证流程：

* 服务器端应用程序调用\*\*`AdminInitiateAuth` API 操作\*\*（而不是`InitiateAuth`）。此操作需要具有包括\*\*`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`\*\*权限的 AWS 凭据。该操作返回所需的身份验证参数。
* 在服务器端应用程序获得**身份验证参数**后，调用\*\*`AdminRespondToAuthChallenge` API 操作\*\*。只有在提供 AWS 凭据时，`AdminRespondToAuthChallenge` API 操作才会成功。

此方法**默认情况下未启用**。

要**登录**，您需要知道：

* 用户池 ID
* 客户端 ID
* 用户名
* 密码
* 客户端密钥（仅当应用程序配置为使用密钥时）

{% hint style="info" %}
为了**能够使用此方法登录**，该应用程序必须允许使用`ALLOW_ADMIN_USER_PASSWORD_AUTH`登录。\
此外，要执行此操作，您需要具有\*\*`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`\*\*权限的凭据。
{% endhint %}

```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```

<details>

<summary>登录代码</summary>

\`\`\`python import boto3 import botocore import hmac import hashlib import base64

client\_id = "" user\_pool\_id = "" client\_secret = "" username = "" password = ""

boto\_client = boto3.client('cognito-idp', region\_name='us-east-1')

def get\_secret\_hash(username, client\_id, client\_secret): key = bytes(client\_secret, 'utf-8') message = bytes(f'{username}{client\_id}', 'utf-8') return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

## If the Client App isn't configured to use a secret

### just delete the line setting the SECRET\_HASH

def login\_user(username\_or\_alias, password, client\_id, client\_secret, user\_pool\_id): try: return boto\_client.admin\_initiate\_auth( UserPoolId=user\_pool\_id, ClientId=client\_id, AuthFlow='ADMIN\_USER\_PASSWORD\_AUTH', AuthParameters={ 'USERNAME': username\_or\_alias, 'PASSWORD': password, 'SECRET\_HASH': get\_secret\_hash(username\_or\_alias, client\_id, client\_secret) } ) except botocore.exceptions.ClientError as e: return e.response

print(login\_user(username, password, client\_id, client\_secret, user\_pool\_id))

````
</details>

### USER\_PASSWORD\_AUTH

这种方法是另一种简单且传统的用户和密码认证流程。建议将传统的认证方法迁移到 Cognito，并建议随后禁用它，然后改用 ALLOW\_USER\_SRP\_AUTH 方法（因为该方法永远不会通过网络发送密码）。\
此方法默认**未启用**。

与代码中的先前认证方法的主要**区别**在于，您**无需知道用户池 ID**，也**无需在 Cognito 用户池中获得额外权限**。

要**登录**，您需要知道：

- 客户端 ID
- 用户名
- 密码
- 客户端密钥（仅当应用程序配置为使用密钥时）

<div data-gb-custom-block data-tag="hint" data-style='info'>

为了**能够使用此方法登录**，应用程序必须允许使用 ALLOW\_USER\_PASSWORD\_AUTH 进行登录。

</div>

```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
````

#### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

此方法**始终有效**（无法禁用），但您需要拥有有效的刷新令牌。

```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```

</details>
