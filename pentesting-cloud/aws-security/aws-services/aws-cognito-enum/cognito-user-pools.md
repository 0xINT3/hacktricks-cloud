# Cognito User Pools

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

사용자 풀은 Amazon Cognito의 사용자 디렉터리입니다. 사용자 풀을 사용하면 사용자는 Amazon Cognito를 통해 **웹 또는 모바일 앱에 로그인**하거나 **제3자** 신원 제공자(IdP)를 통해 **페더레이션**할 수 있습니다. 사용자가 직접 로그인하든 제3자를 통해 로그인하든, 사용자 풀의 모든 구성원은 SDK를 통해 액세스할 수 있는 디렉터리 프로필을 가지고 있습니다.

사용자 풀은 다음을 제공합니다:

* 가입 및 로그인 서비스.
* 사용자가 로그인하기 위한 내장형, 사용자 지정 가능한 웹 UI.
* Facebook, Google, Amazon 로그인 및 Apple 로그인과 SAML 및 OIDC 신원 제공자를 통한 소셜 로그인, 사용자 풀에서 사용자 디렉터리 관리 및 사용자 프로필.
* 다중 요소 인증(MFA), 유출된 자격 증명 확인, 계정 탈취 방지, 전화 및 이메일 확인과 같은 보안 기능.
* AWS Lambda 트리거를 통한 사용자 정의 워크플로 및 사용자 마이그레이션.

일반적으로 애플리케이션의 **소스 코드**에는 사용자가 Cognito 사용자 풀에 로그인하기 위해 필요한 **사용자 풀 ID**와 **클라이언트 애플리케이션 ID** (그리고 때로는 **애플리케이션 비밀**?)도 포함되어 있습니다.

### 가능한 공격

* **등록**: 기본적으로 사용자는 자체적으로 등록할 수 있으므로 자신을 위해 사용자를 생성할 수 있습니다.
* **사용자 열거**: 등록 기능을 사용하여 이미 존재하는 사용자 이름을 찾을 수 있습니다. 이 정보는 브루트 포스 공격에 유용할 수 있습니다.
* **로그인 브루트 포스**: [**인증**](cognito-user-pools.md#authentication) 섹션에는 사용자가 **로그인**하기 위해 사용해야 하는 **메서드**가 모두 나와 있으므로 이를 브루트 포스하여 **유효한 자격 증명**을 찾을 수 있습니다.

### 펜테스팅 도구

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), AWS 공격 프레임워크에는 이제 계정의 모든 Cognito 자산을 열거하고 약한 구성, 액세스 제어에 사용되는 사용자 속성 등을 자동으로 확인하는 "cognito\_\_enum" 및 "cognito\_\_attack" 모듈이 포함되어 있으며, 수정 가능한 사용자 정의 속성, 사용 가능한 신원 풀 자격 증명, id 토큰의 가정 가능한 역할 등을 기반으로 사용자 생성(다중 요소 인증 지원 포함) 및 권한 상승도 자동화합니다.

모듈 기능에 대한 설명은 [블로그 게시물](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)의 2부를 참조하세요. 설치 지침은 주요 [Pacu](https://github.com/RhinoSecurityLabs/pacu) 페이지를 참조하세요.

#### 사용법

주어진 신원 풀과 사용자 풀 클라이언트에 대해 사용자 생성 및 모든 권한 상승 벡터를 시도하는 샘플 cognito\_\_attack 사용법:

```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```

현재 AWS 계정에서 볼 수 있는 모든 사용자 풀, 사용자 풀 클라이언트, 신원 풀, 사용자 등을 수집하기 위한 cognito\_\_enum 사용 예시입니다.

```bash
Pacu (new:test) > run cognito__enum
```

* [Cognito Scanner](https://github.com/padok-team/cognito-scanner)은 Cognito에 대한 다양한 공격을 구현하는 파이썬 CLI 도구입니다. 이 도구는 원치 않는 계정 생성 및 계정 오라클과 같은 공격을 수행합니다.

#### 설치

```bash
$ pip install cognito-scanner
```

#### 사용법

```plaintext
cognito-user-pools.py [-h] [--region REGION] [--userpool USERPOOL]
                      [--username USERNAME] [--email EMAIL]
                      [--phone PHONE] [--output OUTPUT]

optional arguments:
  -h, --help           show this help message and exit
  --region REGION      AWS region where the user pool is located
  --userpool USERPOOL  User pool ID
  --username USERNAME  Username to search for
  --email EMAIL        Email to search for
  --phone PHONE        Phone number to search for
  --output OUTPUT      Output file to save the results
```

#### 사용법

```plaintext
cognito-user-pools.py [-h] [--region REGION] [--userpool USERPOOL]
                      [--username USERNAME] [--email EMAIL]
                      [--phone PHONE] [--output OUTPUT]

선택적 인수:
  -h, --help           도움말 메시지를 표시하고 종료합니다.
  --region REGION      사용자 풀이 위치한 AWS 지역
  --userpool USERPOOL  사용자 풀 ID
  --username USERNAME  검색할 사용자 이름
  --email EMAIL        검색할 이메일
  --phone PHONE        검색할 전화번호
  --output OUTPUT      결과를 저장할 출력 파일
```

```bash
$ cognito-scanner --help
```

자세한 정보는 https://github.com/padok-team/cognito-scanner를 확인하세요.

## 등록

사용자 풀은 **기본적으로** **새로운 사용자를 등록**할 수 있습니다.

```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```

#### 누구나 등록할 수 있는 경우

사용자에 대한 **추가 세부 정보**를 제공해야 한다는 오류가 발생할 수 있습니다.

```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```

다음과 같이 JSON을 사용하여 필요한 세부 정보를 제공할 수 있습니다:

```json
{
  "username": "사용자 이름",
  "password": "비밀번호",
  "email": "이메일 주소",
  "phone_number": "전화번호",
  "attributes": {
    "custom:attribute1": "속성 1 값",
    "custom:attribute2": "속성 2 값"
  }
}
```

위의 예시에서 "username"은 사용자 이름, "password"는 비밀번호, "email"은 이메일 주소, "phone\_number"는 전화번호를 나타냅니다. "attributes"는 사용자 지정 속성을 포함하며, "custom:attribute1"과 "custom:attribute2"는 각각 속성 1 값과 속성 2 값을 나타냅니다.

```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```

다음 기능을 사용하여 기존 사용자를 **열거할 수도 있습니다.** 해당 이름으로 이미 사용자가 존재할 경우에는 다음과 같은 오류 메시지가 표시됩니다:

```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```

{% hint style="info" %}
이전 명령에서 **사용자 정의 속성은 "custom:"으로 시작**함을 주목하세요.\
또한, 등록할 때 **사용자에게 새로운 사용자 정의 속성을 생성할 수 없습니다**. 기본 속성에만 값을 지정할 수 있으며 (필수가 아니더라도) **지정된 사용자 정의 속성**에만 값을 지정할 수 있습니다.
{% endhint %}

또는 클라이언트 ID가 존재하는지 테스트하기 위해 사용할 수도 있습니다. 클라이언트 ID가 존재하지 않을 경우 발생하는 오류는 다음과 같습니다:

```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```

#### 관리자만 사용자를 등록할 수 있는 경우

이 오류를 발견하면 사용자를 등록하거나 열람할 수 없습니다:

```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```

### 등록 확인

Cognito는 새로운 사용자를 등록할 때 **이메일 또는 전화번호를 확인하여 사용자를 인증**할 수 있습니다. 따라서 사용자를 생성할 때 일반적으로 **사용자 이름과 비밀번호**와 함께 **이메일과/또는 전화번호**를 요구합니다. **제어할 수 있는** 하나를 설정하여 새로 생성된 사용자 **계정**의 확인 코드를 받을 수 있습니다. 예를 들면 다음과 같습니다:

```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```

{% hint style="warning" %}
비록 **같은 이메일**과 전화번호를 사용할 수 있는 것처럼 보이지만, 생성된 사용자를 확인해야 할 때 Cognito는 동일한 정보를 사용하는 것에 대해 불평하고 **계정을 확인할 수 없게** 합니다.
{% endhint %}

### 권한 상승 / 속성 업데이트

기본적으로 사용자는 다음과 같이 자신의 속성 값을 **수정할 수 있습니다**:

```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```

#### 사용자 정의 속성 권한 상승

{% hint style="danger" %}
기본적으로 `isAdmin`과 같은 **사용자 정의 속성**을 찾을 수 있습니다. 자신의 속성 값을 변경할 수 있으므로, 값을 변경하여 권한 상승을 할 수 있을 수도 있습니다!
{% endhint %}

#### 이메일/사용자 이름 수정 권한 상승

이를 사용하여 사용자의 **이메일과 전화번호를 수정**할 수 있지만, 계정이 확인된 상태로 유지되더라도 해당 속성은 **확인되지 않은 상태로 설정**됩니다 (다시 확인해야 함).

{% hint style="warning" %}
이메일이나 전화번호로 로그인할 수 없지만, **사용자 이름으로 로그인할 수 있습니다**.\
이메일이 수정되었고 확인되지 않았더라도 ID 토큰 내의 **`email`** **필드**에 표시되며, **`email_verified`** 필드는 **false**가 됩니다. 그러나 앱이 이를 확인하지 않는다면 다른 사용자를 가장할 수 있습니다.

또한, **`name`** 필드에는 **이름 속성**을 수정하여 아무 내용이나 넣을 수 있습니다. 앱이 **`email`** (또는 다른 속성) 대신에 **해당** 필드를 확인하는 경우 다른 사용자를 가장할 수 있을 수 있습니다.
{% endhint %}

어쨌든, 이메일을 새로운 이메일로 변경한 경우, 해당 이메일 주소로 받은 코드로 이메일을 **확인**할 수 있습니다.

```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```

**`이메일`** 대신 \*\*`전화번호`\*\*를 사용하여 **새 전화번호**를 변경/확인할 수 있습니다.

{% hint style="info" %}
관리자는 **사용자가 선호하는 사용자 이름으로 로그인**할 수 있는 옵션을 활성화할 수도 있습니다. 다른 사용자를 표현하기 위해 이미 사용 중인 **아무 사용자 이름이나 선호\_사용자\_이름**으로 이 값을 변경할 수 없습니다.
{% endhint %}

### 비밀번호 복구/변경

비밀번호를 복구하는 것은 **사용자 이름** (또는 이메일 또는 전화번호)을 알고 있고 해당 사용자에게 코드가 전송될 수 있는 액세스 권한이 있는 경우에만 가능합니다.

```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```

{% hint style="info" %}
서버의 응답은 항상 긍정적일 것이며, 마치 사용자 이름이 존재하는 것처럼 보일 것입니다. 이 방법을 사용하여 사용자를 열거할 수는 없습니다.
{% endhint %}

다음 코드를 사용하여 비밀번호를 변경할 수 있습니다:

```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```

비밀번호를 변경하려면 **이전 비밀번호를 알아야 합니다**:

```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```

## 인증

사용자 풀은 **다양한 방법으로 인증**을 지원합니다. 사용자 이름과 비밀번호가 있는 경우 로그인하기 위해도 **다양한 방법**이 지원됩니다. 또한, 사용자 풀에서 사용자가 인증되면 **3 종류의 토큰**이 제공됩니다: **ID 토큰**, **액세스 토큰** 및 **리프레시 토큰**.

* [**ID 토큰**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): 인증된 사용자의 **식별 정보**에 대한 클레임을 포함합니다. 예를 들어 `name`, `email`, `phone_number`와 같은 정보가 있습니다. ID 토큰은 또한 **리소스 서버 또는 서버 애플리케이션에 사용자를 인증하는 데 사용**될 수 있습니다. 외부 애플리케이션에서 사용할 경우 ID 토큰 내의 어떤 클레임도 신뢰하기 전에 ID 토큰의 **서명을 검증**해야 합니다.
* ID 토큰은 사용자의 속성 값, 심지어 사용자 정의 속성까지 포함하는 토큰입니다.
* [**액세스 토큰**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): 인증된 사용자에 대한 클레임, 사용자의 그룹 목록 및 스코프 목록을 포함합니다. 액세스 토큰의 목적은 사용자 풀의 사용자 컨텍스트에서 API 작업을 **인가**하는 것입니다. 예를 들어, 액세스 토큰을 사용하여 사용자에게 사용자 속성을 추가, 변경 또는 삭제할 수 있는 권한을 부여할 수 있습니다.
* [**리프레시 토큰**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): 리프레시 토큰을 사용하면 **리프레시 토큰이 만료될 때까지** 사용자를 위해 새로운 ID 토큰 및 액세스 토큰을 얻을 수 있습니다. 기본적으로, 리프레시 토큰은 사용자 풀에 로그인한 후 30일 후에 만료됩니다. 사용자 풀에 대한 애플리케이션을 생성할 때 리프레시 토큰 만료 시간을 **60분에서 10년 사이의 값으로 설정**할 수 있습니다.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

이것은 서버 측 인증 플로우입니다:

* 서버 측 앱은 **`AdminInitiateAuth` API 작업**을 호출합니다(`InitiateAuth` 대신). 이 작업은 **`cognito-idp:AdminInitiateAuth`** 및 **`cognito-idp:AdminRespondToAuthChallenge`** 권한을 포함한 AWS 자격 증명이 필요합니다. 이 작업은 필요한 인증 매개변수를 반환합니다.
* 서버 측 앱이 **인증 매개변수**를 가지고 있는 후, **`AdminRespondToAuthChallenge` API 작업**을 호출합니다. `AdminRespondToAuthChallenge` API 작업은 AWS 자격 증명을 제공할 때만 성공합니다.

이 **메소드는 기본적으로 활성화되어 있지 않습니다**.

로그인하기 위해 다음을 알아야 합니다:

* 사용자 풀 ID
* 클라이언트 ID
* 사용자 이름
* 비밀번호
* 클라이언트 시크릿 (앱이 시크릿을 사용하도록 구성된 경우에만 필요)

{% hint style="info" %}
이 방법으로 **로그인할 수 있도록** 애플리케이션은 `ALLOW_ADMIN_USER_PASSWORD_AUTH`로 로그인을 허용해야 합니다. 또한, 이 작업을 수행하려면 **`cognito-idp:AdminInitiateAuth`** 및 **`cognito-idp:AdminRespondToAuthChallenge`** 권한이 있는 자격 증명이 필요합니다.
{% endhint %}

```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```

<details>

<summary>로그인을 위한 코드</summary>

\`\`\`python import boto3 import botocore import hmac import hashlib import base64

client\_id = "" user\_pool\_id = "" client\_secret = "" username = "" password = ""

boto\_client = boto3.client('cognito-idp', region\_name='us-east-1')

def get\_secret\_hash(username, client\_id, client\_secret): key = bytes(client\_secret, 'utf-8') message = bytes(f'{username}{client\_id}', 'utf-8') return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

## If the Client App isn't configured to use a secret

### just delete the line setting the SECRET\_HASH

def login\_user(username\_or\_alias, password, client\_id, client\_secret, user\_pool\_id): try: return boto\_client.admin\_initiate\_auth( UserPoolId=user\_pool\_id, ClientId=client\_id, AuthFlow='ADMIN\_USER\_PASSWORD\_AUTH', AuthParameters={ 'USERNAME': username\_or\_alias, 'PASSWORD': password, 'SECRET\_HASH': get\_secret\_hash(username\_or\_alias, client\_id, client\_secret) } ) except botocore.exceptions.ClientError as e: return e.response

print(login\_user(username, password, client\_id, client\_secret, user\_pool\_id))

````
</details>

### USER\_PASSWORD\_AUTH

이 방법은 또 다른 간단하고 전통적인 사용자 및 비밀번호 인증 흐름입니다. 전통적인 인증 방법을 Cognito로 이전하고, 그런 다음 ALLOW\_USER\_SRP\_AUTH 방법을 사용하여 비활성화하고 대신 사용하는 것이 권장됩니다(이 방법은 비밀번호를 네트워크를 통해 전송하지 않기 때문입니다).\
이 방법은 기본적으로 **활성화되어 있지 않습니다**.

코드 내에서 이전 인증 방법과의 주요 차이점은 사용자 풀 ID를 알 필요가 없으며, Cognito 사용자 풀에 추가 권한이 필요하지 않다는 것입니다.

로그인하려면 다음을 알아야 합니다:

* 클라이언트 ID
* 사용자 이름
* 비밀번호
* 클라이언트 시크릿 (앱이 시크릿을 사용하도록 구성된 경우에만 필요)

<div data-gb-custom-block data-tag="hint" data-style='info'>

이 방법으로 로그인할 수 있도록 하려면 해당 애플리케이션이 ALLOW\_USER\_PASSWORD\_AUTH로 로그인을 허용해야 합니다.

</div>

```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
````

#### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

이 **메소드는 항상 유효**합니다(비활성화할 수 없음) 그러나 유효한 리프레시 토큰이 필요합니다.

```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```

</details>
