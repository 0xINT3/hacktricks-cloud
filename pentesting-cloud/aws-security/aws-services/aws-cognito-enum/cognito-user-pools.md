# Cognito korisnički bazeni

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Korisnički bazen je direktorijum korisnika u Amazon Cognitu. Sa korisničkim bazenom, vaši korisnici mogu **da se prijave na vašu veb ili mobilnu aplikaciju** putem Amazon Cognita, **ili da se federišu** putem **trećeg lica** koje pruža identitet (IdP). Bez obzira da li se vaši korisnici prijavljuju direktno ili putem trećeg lica, svi članovi korisničkog bazena imaju profil direktorijuma koji možete pristupiti putem SDK-a.

Korisnički bazeni pružaju:

* Usluge registracije i prijave.
* Ugrađeni, prilagodljivi veb korisnički interfejs za prijavu korisnika.
* Socijalnu prijavu putem Facebook-a, Google-a, Prijave putem Amazon-a i Prijave putem Apple-a, kao i putem SAML i OIDC provajdera identiteta iz vašeg korisničkog bazena.
* Upravljanje korisničkim direktorijumom i korisničkim profilima.
* Bezbednosne funkcije kao što su višefaktorska autentifikacija (MFA), provera kompromitovanih akreditiva, zaštita od preuzimanja naloga, provera telefonom i e-poštom.
* Prilagođene radne tokove i migraciju korisnika putem AWS Lambda okidača.

**Izvorni kod** aplikacija obično takođe sadrži **ID korisničkog bazena** i **ID klijentske aplikacije**, (a ponekad i **tajnu aplikacije**?) koje su potrebne za **prijavu korisnika** na Cognito korisnički bazen.

### Potencijalni napadi

* **Registracija**: Podrazumevano, korisnik može sam sebe registrovati, tako da može kreirati korisnika za sebe.
* **Enumeracija korisnika**: Funkcionalnost registracije može se koristiti za pronalaženje korisničkih imena koja već postoje. Ove informacije mogu biti korisne za napad metodom iscrpljivanja resursa.
* **Brute-force prijava**: U odeljku [**Autentifikacija**](cognito-user-pools.md#authentication) imate sve **metode** koje korisnik mora da koristi za **prijavu**, možete pokušati da ih iscrpljujete kako biste **pronašli validne akreditive**.

### Alati za pentestiranje

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), okvir za iskorišćavanje AWS-a, sada uključuje module "cognito\_\_enum" i "cognito\_\_attack" koji automatizuju enumeraciju svih Cognito resursa u nalogu i označavaju slabe konfiguracije, korisničke atribute koji se koriste za kontrolu pristupa, itd., a takođe automatizuju kreiranje korisnika (uključujući podršku za MFA) i eskalaciju privilegija na osnovu promenljivih prilagodljivih atributa, korisnih akreditiva za identifikacioni bazen, uloga koje se mogu pretpostaviti u ID tokenima, itd.

Za opis funkcija modula pogledajte deo 2 [blog posta](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Za uputstva za instalaciju pogledajte glavnu [Pacu](https://github.com/RhinoSecurityLabs/pacu) stranicu.

#### Upotreba

Primer upotrebe cognito\_\_attack za pokušaj kreiranja korisnika i svih vektora eskalacije privilegija protiv datog identifikacionog bazena i klijentske aplikacije korisničkog bazena:
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Primer upotrebe cognito\_\_enum alata za prikupljanje svih bazena korisnika, klijenata bazena korisnika, bazena identiteta, korisnika, itd. vidljivih u trenutnom AWS nalogu:

```plaintext
cognito__enum --all
```
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) je CLI alatka napisana u Pythonu koja implementira različite napade na Cognito, uključujući neželjeno kreiranje naloga i napad na orakl računa.

#### Instalacija
```bash
$ pip install cognito-scanner
```
#### Upotreba
```bash
$ cognito-scanner --help
```
Za više informacija posetite https://github.com/padok-team/cognito-scanner

## Registracija

User Pools podrazumevano omogućava **registraciju novih korisnika**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Ako se svako može registrovati

Možda ćete naići na grešku koja ukazuje da trebate **pružiti više detalja** o korisniku:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Možete pružiti potrebne detalje putem JSON-a, kao što je:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Možete koristiti ovu funkcionalnost i za **nabrojavanje postojećih korisnika**. Ovo je poruka o grešci kada korisnik već postoji sa tim imenom:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Primetite u prethodnoj komandi kako **prilagođeni atributi počinju sa "custom:"**.\
Takođe, znajte da prilikom registracije **ne možete kreirati nove prilagođene atribute** za korisnika. Možete samo dati vrednost **podrazumevanim atributima** (čak i ako nisu obavezni) i **navedenim prilagođenim atributima**.
{% endhint %}

Ili samo testirajte da li postoji klijentski ID. Ovo je greška ako klijentski ID ne postoji:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Ako samo admin može registrovati korisnike

Naići ćete na ovu grešku i nećete moći registrovati ili nabrojati korisnike:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifikacija registracije

Cognito omogućava **verifikaciju novog korisnika putem verifikacije njegove e-pošte ili telefonskog broja**. Stoga, prilikom kreiranja korisnika obično će vam biti potrebno barem korisničko ime i lozinka, kao i **e-pošta i/ili telefonski broj**. Samo postavite jedan **kojim upravljate**, tako da ćete primiti kod za **verifikaciju vašeg** novo kreiranog korisničkog **računa** na ovaj način:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
Čak i ako **izgleda da možete koristiti isti email** i broj telefona, kada trebate verifikovati kreiranog korisnika, Cognito će se žaliti na korišćenje istih informacija i **neće vam dozvoliti verifikaciju naloga**.
{% endhint %}

### Eskalacija privilegija / Ažuriranje atributa

Podrazumevano, korisnik može **izmeniti vrednost svojih atributa** koristeći nešto poput:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Privesc putem prilagođenih atributa

{% hint style="danger" %}
Možete pronaći **prilagođene atribute** koji se koriste (kao što je `isAdmin`), jer prema zadanim postavkama možete **promeniti vrednosti sopstvenih atributa** i možda ćete moći **povećati privilegije** promenom vrednosti sami!
{% endhint %}

#### Privesc putem izmena e-pošte/korisničkog imena

Možete koristiti ovo da **izmenite e-poštu i broj telefona** korisnika, ali čak i ako nalog ostane verifikovan, ti atributi su **postavljeni u neproverenom statusu** (moraju se ponovo verifikovati).

{% hint style="warning" %}
Nećete moći da se prijavite putem e-pošte ili broja telefona dok ih ne verifikujete, ali ćete moći da se prijavite sa korisničkim imenom.\
Imajte na umu da će čak i ako je e-pošta izmenjena i nije verifikovana, ona će se pojaviti u ID token-u unutar polja **`email`**, a polje **`email_verified`** će biti **false**, ali ako aplikacija **ne proverava to**, možete se predstavljati kao drugi korisnici.

Takođe, imajte na umu da možete staviti bilo šta unutar polja **`name`** jednostavnom izmenom atributa **name**. Ako aplikacija **proverava** to polje iz nekog razloga **umesto `email`** (ili bilo koji drugi atribut), možete se predstavljati kao drugi korisnici.
{% endhint %}

U svakom slučaju, ako iz nekog razloga promenite svoju e-poštu na primer na novu, možete **potvrditi e-poštu sa kodom koji ste dobili na toj adresi e-pošte**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Koristite **`phone_number`** umesto **`email`** da biste promenili/verifikovali **novi broj telefona**.

{% hint style="info" %}
Administrator takođe može omogućiti opciju **prijave sa korisničkim imenom koje korisnik preferira**. Imajte na umu da nećete moći promeniti ovu vrednost u **bilo koje korisničko ime ili preferirano_korisničko_ime koje već koristi** kako biste se predstavili kao drugi korisnik.
{% endhint %}

### Vraćanje/Promena lozinke

Moguće je vratiti lozinku samo **znajući korisničko ime** (ili email ili broj telefona) i imajući pristup tome jer će tamo biti poslat kod:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
Odgovor servera će uvek biti pozitivan, kao da korisničko ime postoji. Ne možete koristiti ovu metodu za enumeraciju korisnika.
{% endhint %}

Sa kodom možete promeniti lozinku korisnika:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Da biste promenili lozinku, potrebno je **znati prethodnu lozinku**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Autentifikacija

Korisnički bazen podržava **različite načine autentifikacije**. Ako imate **korisničko ime i lozinku**, takođe postoje **različite metode** podržane za prijavljivanje.\
Osim toga, kada je korisnik autentifikovan u bazenu, dodeljuju se **3 vrste tokena**: **ID token**, **Pristupni token** i **Token za osvežavanje**.

* [**ID token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Sadrži tvrdnje o **identitetu autentifikovanog korisnika**, kao što su `ime`, `email` i `broj telefona`. ID token se takođe može koristiti za **autentifikaciju korisnika na vašim serverskim aplikacijama**. Morate **proveriti** **potpis** ID tokena pre nego što možete verovati bilo kojim tvrdnjama unutar ID tokena ako ga koristite u eksternim aplikacijama.
* ID token je token koji **sadrži vrednosti atributa korisnika**, čak i prilagođene.
* [**Pristupni token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Sadrži tvrdnje o autentifikovanom korisniku, listu **grupa korisnika i listu opsega**. Svrha pristupnog tokena je **autorizacija API operacija** u kontekstu korisnika u korisničkom bazenu. Na primer, možete koristiti pristupni token da **omogućite korisniku pristup** za dodavanje, promenu ili brisanje atributa korisnika.
* [**Token za osvežavanje**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Pomoću tokena za osvežavanje možete **dobiti nove ID tokene i pristupne tokene** za korisnika sve dok je **token za osvežavanje važeći**. Podrazumevano, token za osvežavanje **ističe 30 dana nakon** što se korisnik vaše aplikacije prijavi u korisnički bazen. Prilikom kreiranja aplikacije za korisnički bazen, možete postaviti istek tokena za osvežavanje aplikacije na **bilo koju vrednost između 60 minuta i 10 godina**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Ovo je autentifikacija na serverskoj strani:

* Aplikacija na serverskoj strani poziva operaciju **`AdminInitiateAuth`** API-ja (umesto `InitiateAuth`). Ova operacija zahteva AWS akreditive sa dozvolama koje uključuju **`cognito-idp:AdminInitiateAuth`** i **`cognito-idp:AdminRespondToAuthChallenge`**. Operacija vraća potrebne parametre za autentifikaciju.
* Nakon što aplikacija na serverskoj strani dobije **parametre za autentifikaciju**, poziva operaciju **`AdminRespondToAuthChallenge`** API-ja. Operacija `AdminRespondToAuthChallenge` API-ja uspeva samo kada pružite AWS akreditive.

Ova **metoda NIJE omogućena** podrazumevano.

Da biste se **prijavili**, morate znati:

* ID korisničkog bazena
* ID klijenta
* Korisničko ime
* Lozinku
* Klijentsku tajnu (samo ako je aplikacija konfigurisana da koristi tajnu)

{% hint style="info" %}
Da biste mogli **da se prijavite ovom metodom**, aplikacija mora dozvoliti prijavljivanje sa `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
Osim toga, da biste izvršili ovu radnju, potrebne su vam akreditacije sa dozvolama **`cognito-idp:AdminInitiateAuth`** i **`cognito-idp:AdminRespondToAuthChallenge`**.
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Kod za prijavu</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Ova metoda je još jednostavnija i **tradicionalna metoda autentifikacije korisnika i lozinke**. Preporučuje se **migracija tradicionalne** metode autentifikacije **na Cognito** i zatim **onemogućavanje** te metode i umesto nje korišćenje metode **ALLOW\_USER\_SRP\_AUTH** (jer ova metoda nikada ne šalje lozinku preko mreže).\
Ova metoda **nije omogućena** podrazumevano.

Glavna **razlika** u odnosu na **prethodnu metodu autentifikacije** u kodu je da ne morate znati ID bazena korisnika i da ne trebate dodatne dozvole u Cognito bazenu korisnika.

Da biste se **prijavili**, morate znati:

* ID klijenta
* korisničko ime
* lozinku
* tajnu klijenta (samo ako je aplikacija konfigurisana da koristi tajnu)

{% hint style="info" %}
Da biste mogli **da se prijavite ovom metodom**, aplikacija mora dozvoliti prijavu sa ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<detalji>

<summary>Python kod za prijavu</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Ovaj scenario je sličan prethodnom, ali umesto slanja lozinke preko mreže za prijavu se vrši izazovna autentifikacija (tako da lozinka ne prolazi čak ni enkriptovana kroz mrežu).\
Ova metoda je podrazumevano omogućena.

Da biste se prijavili, potrebno je znati:

* ID bazena korisnika
* ID klijenta
* korisničko ime
* lozinku
* tajni klijent (samo ako je aplikacija konfigurisana da koristi tajnu)

<details>

<summary>Kod za prijavu</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Ova **metoda će uvek biti validna** (ne može biti onemogućena), ali morate imati validan refresh token.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Kod za osvežavanje</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

U ovom slučaju će se **autentifikacija** izvršiti putem **izvršavanja lambda funkcije**.

## Dodatna sigurnost

### Napredna sigurnost

Po defaultu je onemogućena, ali ako je omogućena, Cognito bi mogao **pronaći preuzimanje naloga**. Da biste smanjili verovatnoću, trebali biste se prijaviti sa **mreže unutar istog grada, koristeći isti korisnički agent** (i IP adresu ako je moguće).

### **MFA Zapamti uređaj**

Ako se korisnik prijavi sa istog uređaja, MFA može biti zaobiđen, stoga pokušajte se prijaviti sa istim pregledačem i istim metapodacima (IP?) kako biste pokušali zaobići MFA zaštitu.

## IAM uloge grupa korisničkih bazena

Moguće je dodati **korisnike u grupe korisničkih bazena** koje su povezane sa jednom **IAM ulogom**.\
Osim toga, **korisnici** mogu biti dodijeljeni **više od 1 grupe sa različitim IAM ulogama**.

Imajte na umu da čak i ako je grupa unutar grupe sa pridruženom IAM ulogom, da biste mogli pristupiti IAM akreditivima te grupe, potrebno je da je **korisnički bazen pouzdan od strane bazena identiteta** (i da zna detalje tog bazena identiteta).

Još jedan uslov da se dobije **IAM uloga navedena u IdToken-u** kada se korisnik autentifikuje u korisničkom bazenu (`aws cognito-idp initiate-auth...`) je da **provajder za autentifikaciju identiteta** treba da naznači da **uloga mora biti izabrana iz tokena**.

<figure><img src="../../../../.gitbook/assets/image (7) (1) (2).png" alt=""><figcaption></figcaption></figure>

**Uloge** kojima korisnik ima pristup su **unutar `IdToken`-a**, i korisnik može **izabrati za koju ulogu želi akreditive** koristeći **`--custom-role-arn`** iz `aws cognito-identity get-credentials-for-identity`.\
Međutim, ako je **podrazumevana opcija** ona koja je **konfigurisana** (`use default role`), i pokušate pristupiti ulozi iz IdToken-a, dobićete **grešku** (zato je potrebna prethodna konfiguracija):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Napomena da uloga dodeljena **User Pool Group**-u mora biti **pristupačna od strane Identity Provider-a** koji **veruje User Pool-u** (jer će se **sesijski akreditivi IAM uloge dobiti od njega**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
