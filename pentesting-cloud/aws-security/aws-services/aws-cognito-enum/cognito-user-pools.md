# Cognitoユーザープール

<details>

<summary><strong>ハックトリックをサポートして特典を得る！</strong></summary>

* **HackTricksで会社を宣伝**したい場合や、**PEASSの最新バージョンを見たい**場合、または**HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## 基本情報

ユーザープールはAmazon Cognitoのユーザーディレクトリです。ユーザープールを使用すると、ユーザーはAmazon Cognitoを介してWebアプリやモバイルアプリに**サインイン**したり、**サードパーティ**のIDプロバイダ（IdP）を介して**フェデレーション**したりできます。ユーザーが直接サインインするか、サードパーティを介してサインインする場合でも、ユーザープールのすべてのメンバーには、SDKを介してアクセスできるディレクトリプロファイルがあります。

ユーザープールは以下の機能を提供します：

* サインアップおよびサインインサービス。
* ユーザーのサインインに使用する組み込みのカスタマイズ可能なWeb UI。
* Facebook、Google、Login with Amazon、Sign in with Apple、およびSAMLおよびOIDC IDプロバイダを介したソーシャルサインイン、およびユーザープールからのユーザーディレクトリ管理とユーザープロファイル。
* マルチファクタ認証（MFA）、侵害された資格情報のチェック、アカウント乗っ取り保護、電話およびメールの確認などのセキュリティ機能。
* AWS Lambdaトリガを介したカスタマイズされたワークフローとユーザーマイグレーション。

アプリケーションの**ソースコード**には通常、Cognitoユーザープールに**ログイン**するために必要な**ユーザープールID**と**クライアントアプリケーションID**（および場合によっては**アプリケーションシークレット**？）も含まれています。

### 潜在的な攻撃

* **登録**: ユーザーはデフォルトで自分自身を登録できるため、自分自身のユーザーを作成することができます。
* **ユーザー列挙**: 登録機能を使用して既に存在するユーザー名を見つけることができます。この情報はブルートフォース攻撃に役立つ可能性があります。
* **ログインのブルートフォース**: [**認証**](cognito-user-pools.md#authentication)セクションには、ユーザーが**ログイン**するために必要な**方法**がすべて記載されています。有効な資格情報を見つけるためにブルートフォース攻撃を試みることができます。

### ペネトレーションテストと列挙のためのPacuモジュール

AWSの脆弱性フレームワークである[Pacu](https://github.com/RhinoSecurityLabs/pacu)には、アカウント内のすべてのCognitoアセットの列挙と弱い設定のフラグ付け、アクセス制御に使用されるユーザー属性などを自動化する「cognito__enum」と「cognito__attack」モジュールが含まれています。また、変更可能なカスタム属性、使用可能なアイデンティティプールの資格情報、IDトークンのアサーティブルロールなどに基づいたユーザー作成（MFAサポートを含む）および特権エスカレーションも自動化します。

モジュールの機能の詳細については、[ブログ記事](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)のパート2を参照してください。インストール手順については、メインの[Pacu](https://github.com/RhinoSecurityLabs/pacu)ページを参照してください。

### 使用方法

指定されたアイデンティティプールとユーザープールクライアントに対してユーザー作成とすべての特権エスカレーションベクトルを試すためのcognito__attackの使用例：
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
現在のAWSアカウントで表示されるすべてのユーザープール、ユーザープールクライアント、アイデンティティプール、ユーザーなどを収集するためのcognito__enumの使用例:
```bash
Pacu (new:test) > run cognito__enum
```
### ペンテストツール

[Cognito Scanner](https://github.com/padok-team/cognito-scanner)は、Cognitoに対して不要なアカウント作成やアカウントオラクルを含むさまざまな攻撃を実装したPythonのCLIツールです。

#### インストール
```bash
$ pip install cognito-scanner
```
#### 使用法

```plaintext
cognito-user-pools.py [-h] [--region REGION] [--userpool USERPOOL]
                      [--username USERNAME] [--email EMAIL] [--phone PHONE]
                      [--output OUTPUT] [--verbose]

optional arguments:
  -h, --help           show this help message and exit
  --region REGION      AWS region where the user pool is located
  --userpool USERPOOL  User pool ID
  --username USERNAME  Username to check
  --email EMAIL        Email to check
  --phone PHONE        Phone number to check
  --output OUTPUT      Output file to save the results
  --verbose            Enable verbose output
```

```plaintext
cognito-user-pools.py [-h] [--region REGION] [--userpool USERPOOL]
                      [--username USERNAME] [--email EMAIL] [--phone PHONE]
                      [--output OUTPUT] [--verbose]

オプション引数:
  -h, --help           ヘルプメッセージを表示して終了します
  --region REGION      ユーザープールが存在するAWSリージョン
  --userpool USERPOOL  ユーザープールのID
  --username USERNAME  確認するユーザー名
  --email EMAIL        確認するメールアドレス
  --phone PHONE        確認する電話番号
  --output OUTPUT      結果を保存する出力ファイル
  --verbose            詳細な出力を有効にする
```
```bash
$ cognito-scanner --help
```
詳細については、https://github.com/padok-team/cognito-scanner を参照してください。

## 登録

ユーザープールは、**デフォルトで新しいユーザーを登録**することができます。
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 誰でも登録できる場合

ユーザーの**詳細情報を提供する必要がある**というエラーが表示されることがあります。
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
必要な詳細は、次のようなJSONで提供できます。

```json
{
  "username": "ユーザー名",
  "password": "パスワード",
  "email": "メールアドレス",
  "phone_number": "電話番号",
  "attributes": {
    "custom:attribute1": "属性1",
    "custom:attribute2": "属性2"
  }
}
```

このJSONには、ユーザー名、パスワード、メールアドレス、電話番号、およびカスタム属性が含まれています。
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
この機能を使用して、既存のユーザーを列挙することもできます。その名前のユーザーが既に存在する場合、次のエラーメッセージが表示されます：
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
前のコマンドで、**カスタム属性は "custom:" で始まる**ことに注意してください。\
また、登録時には、ユーザーの新しいカスタム属性を作成することはできません。**デフォルト属性**（必須でなくても）と**指定されたカスタム属性**にのみ値を設定できます。
{% endhint %}

または、クライアントIDが存在するかどうかをテストするだけでも構いません。クライアントIDが存在しない場合のエラーは次のとおりです：
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### 管理者のみがユーザーを登録できる場合

このエラーが表示され、ユーザーの登録や列挙ができなくなります。
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### 登録の検証

Cognitoでは、新しいユーザーのメールアドレスまたは電話番号を検証することで、ユーザーを検証することができます。したがって、通常、ユーザーを作成する際には、少なくともユーザー名とパスワード、そしてメールアドレスと/または電話番号が必要です。自分が制御しているものを設定してください。これにより、新しく作成したユーザーアカウントの検証コードを受け取ることができます。以下のようになります：
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
同じメールアドレスや電話番号を使用できるように見えるかもしれませんが、作成したユーザーを検証する必要がある場合、Cognitoは同じ情報の使用について警告し、アカウントの検証を許可しません。
{% endhint %}

### 特権エスカレーション / 属性の更新

デフォルトでは、ユーザーは次のような方法で属性の値を変更できます：
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### カスタム属性の特権昇格

{% hint style="danger" %}
デフォルトでは、`isAdmin`のような**カスタム属性**が使用されている場合、自分自身の属性の値を変更できるため、値を変更することで特権を昇格させることができるかもしれません！
{% endhint %}

#### メール/ユーザー名の変更による特権昇格

これを使用して、ユーザーの**メールアドレスと電話番号を変更**することができますが、アカウントが確認済みのままでも、これらの属性は**未確認の状態に設定**されます（再度確認する必要があります）。

{% hint style="warning" %}
メールアドレスまたは電話番号でのログインは**確認するまでできません**が、ユーザー名でのログインは**可能です**。\
メールが変更されて確認されていない場合でも、IDトークンの**`email`**フィールドには表示され、**`email_verified`**フィールドは**false**になりますが、アプリがそれを**チェックしていない場合、他のユーザーになりすます**ことができます。

さらに、**`name`**フィールドには、**名前属性**を変更するだけで任意の値を入力することができます。アプリが**`email`**（または他の属性）の代わりに**そのフィールドをチェックしている場合**、他のユーザーになりすますことができるかもしれません。
{% endhint %}

とにかく、何らかの理由でメールアドレスを新しいものに変更した場合、そのメールアドレスで受け取ったコードでメールを**確認することができます**：
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
**`email`**ではなく、**`phone_number`**を使用して、**新しい電話番号**を変更/確認します。

{% hint style="info" %}
管理者は、**ユーザーが好むユーザー名でログイン**するオプションも有効にすることができます。ただし、**既に使用されているユーザー名やpreferred\_username**を使用して別のユーザーをなりすますことはできません。
{% endhint %}

### パスワードの回復/変更

パスワードを回復するには、単に**ユーザー名**（またはメールアドレスまたは電話番号）を知っていれば、コードがそこに送信されます：
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
サーバーの応答は常に肯定的であり、ユーザー名が存在するかのようになっています。この方法ではユーザーを列挙することはできません。
{% endhint %}

コードを使用すると、パスワードを変更できます。
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
パスワードを変更するには、**以前のパスワードを知っている必要があります**：
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## 認証

ユーザープールは、**さまざまな認証方法**をサポートしています。ユーザー名とパスワードを持っている場合、ログインするための**さまざまな方法**もサポートされています。\
さらに、ユーザーがプールで認証されると、**3種類のトークン**が与えられます。**IDトークン**、**アクセストークン**、**リフレッシュトークン**です。

* [**IDトークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): 認証されたユーザーの**身元に関するクレーム**（`name`、`email`、`phone_number`など）が含まれています。IDトークンは、ユーザーを**リソースサーバーやサーバーアプリケーションに認証するためにも使用**できます。外部アプリケーションで使用する場合、IDトークン内のクレームを信頼する前に、IDトークンの**署名を検証する必要があります**。
* IDトークンは、ユーザーの属性値を**含むトークン**です。カスタム属性も含まれます。
* [**アクセストークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): 認証されたユーザーに関するクレーム、ユーザーのグループのリスト、およびスコープのリストが含まれています。アクセストークンの目的は、ユーザープールのユーザーのコンテキストで**API操作を承認する**ことです。たとえば、アクセストークンを使用して、ユーザーにユーザー属性の追加、変更、削除のアクセス権を**付与**することができます。
* [**リフレッシュトークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): リフレッシュトークンを使用すると、**リフレッシュトークンが無効になるまで**ユーザーの新しいIDトークンとアクセストークンを取得できます。デフォルトでは、リフレッシュトークンは、アプリケーションのユーザープールにサインインした後**30日後に期限切れになります**。ユーザープールのアプリケーションを作成する際に、リフレッシュトークンの有効期限を**60分から10年までの任意の値**に設定できます。

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

これはサーバーサイドの認証フローです：

* サーバーサイドアプリは、**`AdminInitiateAuth` API操作**（`InitiateAuth`ではなく）を呼び出します。この操作には、**`cognito-idp:AdminInitiateAuth`**と**`cognito-idp:AdminRespondToAuthChallenge`**を含む権限を持つAWS認証情報が必要です。この操作は、必要な認証パラメータを返します。
* サーバーサイドアプリが**認証パラメータを取得**した後、**`AdminRespondToAuthChallenge` API操作**を呼び出します。`AdminRespondToAuthChallenge` API操作は、AWS認証情報を提供する場合にのみ成功します。

この方法は、デフォルトでは**有効になっていません**。

ログインするには、次の情報が必要です：

* ユーザープールID
* クライアントID
* ユーザー名
* パスワード
* クライアントシークレット（アプリがシークレットを使用するように構成されている場合のみ）

{% hint style="info" %}
この方法で**ログインできるようにするには**、アプリケーションは`ALLOW_ADMIN_USER_PASSWORD_AUTH`でログインを許可する必要があります。\
また、この操作を実行するには、**`cognito-idp:AdminInitiateAuth`**と**`cognito-idp:AdminRespondToAuthChallenge`**の権限を持つ認証情報が必要です。
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>ログインするためのコード</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

この方法は、別のシンプルで伝統的なユーザーとパスワードによる認証フローです。伝統的な認証方法をCognitoに移行し、その後はそれを無効にして、代わりにALLOW\_USER\_SRP\_AUTHメソッドを使用することが推奨されています（このメソッドはパスワードをネットワーク上で送信しないため）。\
このメソッドはデフォルトでは有効になっていません。

コード内の前の認証方法との主な違いは、ユーザープールIDを知る必要がないことと、Cognitoユーザープールで追加の権限が必要ないことです。

ログインするためには、以下の情報が必要です：

- クライアントID
- ユーザー名
- パスワード
- クライアントシークレット（アプリがシークレットを使用するように設定されている場合のみ）

{% hint style="info" %}
このメソッドを使用してログインするためには、アプリケーションがALLOW\_USER\_PASSWORD\_AUTHでログインを許可する必要があります。
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>ログインするためのPythonコード</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

このシナリオは前のものと似ていますが、パスワードをネットワーク経由で送信する代わりに、チャレンジ認証が行われます（つまり、パスワードはネットワークを介して暗号化されていない状態で送信されません）。\
この方法はデフォルトで有効になっています。

ログインするためには、以下の情報が必要です：

* ユーザープールID
* クライアントID
* ユーザー名
* パスワード
* クライアントシークレット（アプリがシークレットを使用するように構成されている場合のみ）

<details>

<summary>ログインするためのコード</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

この**メソッドは常に有効**です（無効にすることはできません）が、有効なリフレッシュトークンが必要です。
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>リフレッシュするためのコード</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

この場合、**認証**は**Lambda関数の実行**によって行われます。

## 追加のセキュリティ

### 高度なセキュリティ

デフォルトでは無効ですが、有効にするとCognitoは**アカウント乗っ取りを検出**することができます。確率を最小限にするためには、**同じ都市内のネットワークから、同じユーザーエージェントを使用してログイン**する必要があります（可能であればIPも）。

### MFAデバイスの記憶

ユーザーが同じデバイスからログインする場合、MFAはバイパスされる可能性があります。したがって、MFA保護をバイパスするために、同じブラウザで同じメタデータ（IP？）からログインしようとしてください。

## ユーザープールグループのIAMロール

**ユーザーをユーザープールのグループに追加**することができます。これらのグループは**IAMロール**に関連付けられています。さらに、**ユーザー**は**異なるIAMロールが割り当てられた複数のグループに所属**することができます。

グループがIAMロールが割り当てられたグループ内にある場合でも、そのグループのIAM資格情報にアクセスするためには、**ユーザープールがアイデンティティプールによって信頼されている**必要があります（およびそのアイデンティティプールの詳細を知っている必要があります）。

ユーザープールでユーザーが認証されたとき（`aws cognito-idp initiate-auth...`）、**IdTokenに示されたIAMロール**を取得するための要件は、**Identity Provider認証プロバイダ**が**トークンからロールを選択する必要がある**ということです。

<figure><img src="../../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

ユーザーがアクセスできる**ロールは`IdToken`内にあり**、ユーザーは**`aws cognito-identity get-credentials-for-identity`**の**`--custom-role-arn`**を使用して、どのロールの資格情報を取得するかを選択することができます。ただし、**デフォルトオプション**が**構成されている場合**（`デフォルトロールを使用`）、IdTokenからロールにアクセスしようとすると**エラーが発生**します（そのため、前述の構成が必要です）：

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
ユーザープールグループに割り当てられた役割は、ユーザープールを信頼する**Identity Provider**から**アクセス可能である必要があります**（IAMロールの**セッション資格情報はそれから取得されるため**）。
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>Support HackTricksと特典を受け取る！</strong></summary>

* **HackTricksで会社を宣伝したい**場合や、**最新バージョンのPEASSにアクセスしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見しましょう
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローしましょう 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **ハッキングのトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>
