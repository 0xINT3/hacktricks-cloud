# Cognito User Pools

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informations de base

Un pool d'utilisateurs est un r√©pertoire d'utilisateurs dans Amazon Cognito. Avec un pool d'utilisateurs, vos utilisateurs peuvent **se connecter √† votre application web ou mobile** via Amazon Cognito, **ou se f√©d√©rer** via un fournisseur d'identit√© **tierce** (IdP). Que vos utilisateurs se connectent directement ou via un tiers, tous les membres du pool d'utilisateurs ont un profil de r√©pertoire auquel vous pouvez acc√©der via un SDK.

Les pools d'utilisateurs offrent :

* Des services d'inscription et de connexion.
* Une interface utilisateur web int√©gr√©e et personnalisable pour la connexion des utilisateurs.
* Une connexion sociale avec Facebook, Google, Login with Amazon et Sign in with Apple, ainsi qu'avec des fournisseurs d'identit√© SAML et OIDC de votre pool d'utilisateurs.
* La gestion du r√©pertoire des utilisateurs et des profils d'utilisateurs.
* Des fonctionnalit√©s de s√©curit√© telles que l'authentification multi-facteurs (MFA), la v√©rification des informations d'identification compromises, la protection contre la prise de contr√¥le de compte, et la v√©rification par t√©l√©phone et par e-mail.
* Des flux de travail personnalis√©s et la migration des utilisateurs via des d√©clencheurs AWS Lambda.

Le **code source** des applications contient g√©n√©ralement √©galement l'**ID du pool d'utilisateurs** et l'**ID de l'application cliente**, (et parfois le **secret de l'application** ?), qui sont n√©cessaires pour qu'un **utilisateur se connecte** √† un pool d'utilisateurs Cognito.

### Attaques potentielles

* **Inscription** : Par d√©faut, un utilisateur peut s'inscrire lui-m√™me, il peut donc cr√©er un utilisateur pour lui-m√™me.
* **√ânum√©ration des utilisateurs** : La fonctionnalit√© d'inscription peut √™tre utilis√©e pour trouver des noms d'utilisateur qui existent d√©j√†. Ces informations peuvent √™tre utiles pour l'attaque par force brute.
* **Attaque par force brute de la connexion** : Dans la section [**Authentification**](cognito-user-pools.md#authentication), vous avez toutes les **m√©thodes** qu'un utilisateur doit utiliser pour **se connecter**, vous pouvez essayer de les attaquer par force brute pour **trouver des identifiants valides**.

### Modules Pacu pour les tests de p√©n√©tration et l'√©num√©ration

[Pacu](https://github.com/RhinoSecurityLabs/pacu), le framework d'exploitation AWS, inclut d√©sormais les modules "cognito__enum" et "cognito__attack" qui automatisent l'√©num√©ration de tous les actifs Cognito dans un compte et signalent les configurations faibles, les attributs d'utilisateur utilis√©s pour le contr√¥le d'acc√®s, etc., et automatisent √©galement la cr√©ation d'utilisateurs (y compris la prise en charge de MFA) et l'√©l√©vation de privil√®ges bas√©e sur des attributs personnalisables modifiables, des informations d'identification de pool d'identit√©s utilisables, des r√¥les assumables dans les jetons d'identit√©, etc.

Pour une description des fonctions des modules, consultez la partie 2 de l'article de blog [ici](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Pour les instructions d'installation, consultez la page principale de [Pacu](https://github.com/RhinoSecurityLabs/pacu).

### Utilisation

Exemple d'utilisation de cognito__attack pour tenter la cr√©ation d'utilisateurs et tous les vecteurs de privil√®ge contre un pool d'identit√©s donn√© et un client de pool d'utilisateurs :
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Voici un exemple d'utilisation de cognito__enum pour collecter tous les pools d'utilisateurs, les clients de pool d'utilisateurs, les pools d'identit√©s, les utilisateurs, etc. visibles dans le compte AWS actuel :

```bash
cognito__enum --all
```

Cet outil permet de r√©cup√©rer des informations sur les services Cognito d'AWS, tels que les pools d'utilisateurs, les clients de pool d'utilisateurs, les pools d'identit√©s et les utilisateurs associ√©s. L'option `--all` est utilis√©e pour r√©cup√©rer toutes les informations disponibles.

Notez que cet outil est destin√© √† des fins de test de p√©n√©tration et doit √™tre utilis√© avec l'autorisation appropri√©e.
```bash
Pacu (new:test) > run cognito__enum
```
### Outil pour le pentest

[Cognito Scanner](https://github.com/padok-team/cognito-scanner) est un outil en ligne de commande (CLI) en python qui met en ≈ìuvre diff√©rentes attaques sur Cognito, y compris la cr√©ation de comptes ind√©sirables et l'oracle de compte.

#### Installation
```bash
$ pip install cognito-scanner
```
#### Utilisation

The `cognito-user-pools` module is used to enumerate user pools in AWS Cognito. It can be used to gather information about the user pools, such as the pool name, ID, and the number of users in each pool.

To use this module, you need to provide the AWS access key and secret key using the `--access-key` and `--secret-key` options. Additionally, you can specify the AWS region using the `--region` option.

```
$ pentest-toolkit aws-security aws-cognito-enum cognito-user-pools --access-key <AWS_ACCESS_KEY> --secret-key <AWS_SECRET_KEY> --region <AWS_REGION>
```

#### Example

```
$ pentest-toolkit aws-security aws-cognito-enum cognito-user-pools --access-key ABCDEFGHIJKLMNOPQRST --secret-key 1234567890 --region us-west-2
```

This command will enumerate the user pools in the specified AWS region using the provided access key and secret key.
```bash
$ cognito-scanner --help
```
Pour plus d'informations, consultez https://github.com/padok-team/cognito-scanner

## Inscription

Les User Pools permettent par **d√©faut** de **s'inscrire en tant que nouveaux utilisateurs**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Si n'importe qui peut s'inscrire

Vous pourriez rencontrer une erreur vous indiquant que vous devez **fournir plus de d√©tails** sur l'utilisateur :
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Vous pouvez fournir les d√©tails n√©cessaires avec un JSON tel que :
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Vous pouvez √©galement utiliser cette fonctionnalit√© pour **√©num√©rer les utilisateurs existants**. Voici le message d'erreur lorsqu'un utilisateur existe d√©j√† avec ce nom :
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Notez dans la commande pr√©c√©dente comment les **attributs personnalis√©s commencent par "custom:"**.\
Sachez √©galement que lors de l'inscription, vous **ne pouvez pas cr√©er de nouveaux attributs personnalis√©s pour l'utilisateur**. Vous pouvez seulement donner une valeur aux **attributs par d√©faut** (m√™me s'ils ne sont pas obligatoires) et aux **attributs personnalis√©s sp√©cifi√©s**.
{% endhint %}

Ou simplement pour tester si un ID client existe. Voici l'erreur si l'ID client n'existe pas :
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Si seul l'administrateur peut enregistrer des utilisateurs

Vous rencontrerez cette erreur et vous ne pourrez pas vous inscrire ou √©num√©rer les utilisateurs :
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### V√©rification de l'inscription

Cognito permet de **v√©rifier un nouvel utilisateur en v√©rifiant son adresse e-mail ou son num√©ro de t√©l√©phone**. Par cons√©quent, lors de la cr√©ation d'un utilisateur, vous devrez g√©n√©ralement fournir au moins le nom d'utilisateur et le mot de passe, ainsi que l'adresse e-mail et/ou le num√©ro de t√©l√©phone. Il suffit de d√©finir un **que vous contr√¥lez** afin de recevoir le code pour **v√©rifier votre** compte utilisateur nouvellement cr√©√©, comme ceci :
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
M√™me si **il semble que vous pouvez utiliser la m√™me adresse e-mail** et le m√™me num√©ro de t√©l√©phone, lorsque vous devez v√©rifier l'utilisateur cr√©√©, Cognito se plaindra de l'utilisation des m√™mes informations et **ne vous permettra pas de v√©rifier le compte**.
{% endhint %}

### √âl√©vation de privil√®ges / Mise √† jour des attributs

Par d√©faut, un utilisateur peut **modifier la valeur de ses attributs** avec quelque chose comme :
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Privil√®ge d'√©l√©vation d'attribut personnalis√©

{% hint style="danger" %}
Vous pourriez trouver l'utilisation d'**attributs personnalis√©s** (comme `isAdmin`). Par d√©faut, vous pouvez **modifier les valeurs de vos propres attributs**, ce qui pourrait vous permettre d'**√©lever vos privil√®ges** en modifiant vous-m√™me la valeur !
{% endhint %}

#### Privil√®ge d'√©l√©vation de modification d'email/nom d'utilisateur

Vous pouvez utiliser ceci pour **modifier l'email et le num√©ro de t√©l√©phone** d'un utilisateur, mais ensuite, m√™me si le compte reste v√©rifi√©, ces attributs sont **d√©finis comme non v√©rifi√©s** (vous devez les v√©rifier √† nouveau).

{% hint style="warning" %}
Vous **ne pourrez pas vous connecter avec l'email ou le num√©ro de t√©l√©phone** tant que vous ne les aurez pas v√©rifi√©s, mais vous pourrez vous connecter avec le nom d'utilisateur.\
Notez que m√™me si l'email a √©t√© modifi√© et n'est pas v√©rifi√©, il appara√Ætra dans le jeton d'identification dans le champ **`email`** et le champ **`email_verified`** sera **faux**, mais si l'application **ne v√©rifie pas cela, vous pourriez vous faire passer pour d'autres utilisateurs**.

De plus, notez que vous pouvez mettre n'importe quoi dans le champ **`name`** en modifiant simplement l'attribut **name**. Si une application **v√©rifie** ce champ pour une raison quelconque **au lieu de l'email** (ou tout autre attribut), vous pourriez vous faire passer pour d'autres utilisateurs.
{% endhint %}

Quoi qu'il en soit, si pour une raison quelconque vous avez modifi√© votre email par exemple pour un nouvel email auquel vous pouvez acc√©der, vous pouvez **confirmer l'email avec le code que vous avez re√ßu √† cette adresse email** :
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Utilisez **`phone_number`** √† la place de **`email`** pour changer/v√©rifier un **nouveau num√©ro de t√©l√©phone**.

{% hint style="info" %}
L'administrateur peut √©galement activer l'option de **connexion avec un nom d'utilisateur pr√©f√©r√© par l'utilisateur**. Notez que vous ne pourrez pas modifier cette valeur en **utilisant un nom d'utilisateur ou un preferred\_username d√©j√† utilis√©** pour se faire passer pour un autre utilisateur.
{% endhint %}

### R√©cup√©rer/Changer le mot de passe

Il est possible de r√©cup√©rer un mot de passe en connaissant simplement le nom d'utilisateur (ou l'email ou le t√©l√©phone sont accept√©s) et en y ayant acc√®s, un code y sera envoy√© :
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La r√©ponse du serveur sera toujours positive, comme si le nom d'utilisateur existait. Vous ne pouvez pas utiliser cette m√©thode pour √©num√©rer les utilisateurs.
{% endhint %}

Avec le code, vous pouvez changer le mot de passe avec :
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Pour changer le mot de passe, vous devez **conna√Ætre le mot de passe pr√©c√©dent** :
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentification

Un pool d'utilisateurs prend en charge **diff√©rentes m√©thodes d'authentification**. Si vous avez un **nom d'utilisateur et un mot de passe**, il existe √©galement **diff√©rentes m√©thodes** prises en charge pour la connexion.\
De plus, lorsqu'un utilisateur est authentifi√© dans le pool, **3 types de jetons sont fournis** : le **jeton ID**, le **jeton d'acc√®s** et le **jeton de rafra√Æchissement**.

* [**Jeton ID**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) : Il contient des informations sur l'**identit√© de l'utilisateur authentifi√©**, telles que le `nom`, l'`adresse e-mail` et le `num√©ro de t√©l√©phone`. Le jeton ID peut √©galement √™tre utilis√© pour **authentifier les utilisateurs aupr√®s de vos serveurs de ressources ou de vos applications serveur**. Vous devez **v√©rifier** la **signature** du jeton ID avant de pouvoir faire confiance √† toutes les informations qu'il contient si vous l'utilisez dans des applications externes.
* Le jeton ID est le jeton qui **contient les valeurs des attributs de l'utilisateur**, y compris les attributs personnalis√©s.
* [**Jeton d'acc√®s**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) : Il contient des informations sur l'utilisateur authentifi√©, une liste des **groupes de l'utilisateur et une liste des √©tendues**. Le but du jeton d'acc√®s est d'**autoriser les op√©rations API** dans le contexte de l'utilisateur dans le pool d'utilisateurs. Par exemple, vous pouvez utiliser le jeton d'acc√®s pour **accorder √† votre utilisateur l'acc√®s** pour ajouter, modifier ou supprimer des attributs utilisateur.
* [**Jeton de rafra√Æchissement**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html) : Avec les jetons de rafra√Æchissement, vous pouvez **obtenir de nouveaux jetons ID et jetons d'acc√®s** pour l'utilisateur jusqu'√† ce que le **jeton de rafra√Æchissement soit invalide**. Par **d√©faut**, le jeton de rafra√Æchissement **expire 30 jours apr√®s** que l'utilisateur de votre application se soit connect√© √† votre pool d'utilisateurs. Lorsque vous cr√©ez une application pour votre pool d'utilisateurs, vous pouvez d√©finir l'expiration du jeton de rafra√Æchissement de l'application sur **n'importe quelle valeur entre 60 minutes et 10 ans**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Il s'agit du flux d'authentification c√¥t√© serveur :

* L'application c√¥t√© serveur appelle l'op√©ration API **`AdminInitiateAuth`** (au lieu de `InitiateAuth`). Cette op√©ration n√©cessite des informations d'identification AWS avec des autorisations qui incluent **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**. L'op√©ration renvoie les param√®tres d'authentification requis.
* Une fois que l'application c√¥t√© serveur dispose des **param√®tres d'authentification**, elle appelle l'op√©ration API **`AdminRespondToAuthChallenge`**. L'op√©ration API `AdminRespondToAuthChallenge` r√©ussit uniquement lorsque vous fournissez des informations d'identification AWS.

Cette **m√©thode n'est PAS activ√©e** par d√©faut.

Pour **vous connecter**, vous devez conna√Ætre :

* l'ID du pool d'utilisateurs
* l'ID du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Afin de pouvoir **vous connecter avec cette m√©thode**, l'application doit autoriser la connexion avec `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
De plus, pour effectuer cette action, vous avez besoin d'informations d'identification avec les autorisations **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**.
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Cette m√©thode est un autre flux d'authentification simple et **traditionnel avec nom d'utilisateur et mot de passe**. Il est recommand√© de **migrer une m√©thode d'authentification traditionnelle** vers Cognito, puis de **la d√©sactiver** et d'utiliser la m√©thode **ALLOW\_USER\_SRP\_AUTH** √† la place (car celle-ci n'envoie jamais le mot de passe sur le r√©seau).\
Cette m√©thode n'est **pas activ√©e par d√©faut**.

La principale **diff√©rence** avec la **m√©thode d'authentification pr√©c√©dente** dans le code est que vous **n'avez pas besoin de conna√Ætre l'ID du pool d'utilisateurs** et que vous **n'avez pas besoin de permissions suppl√©mentaires** dans le pool d'utilisateurs Cognito.

Pour **vous connecter**, vous devez conna√Ætre :

* l'ID du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour pouvoir **vous connecter avec cette m√©thode**, l'application doit autoriser la connexion avec ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Code Python pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Ce sc√©nario est similaire au pr√©c√©dent, mais au lieu d'envoyer le mot de passe √† travers le r√©seau pour se connecter, une authentification de d√©fi est effectu√©e (donc aucun mot de passe ne navigue m√™me chiffr√© √† travers le r√©seau).\
Cette m√©thode est activ√©e par d√©faut.

Pour vous connecter, vous devez conna√Ætre :

* l'ID du pool d'utilisateurs
* l'ID du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

<details>

<summary>Code pour se connecter</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Cette **m√©thode sera toujours valide** (elle ne peut pas √™tre d√©sactiv√©e), mais vous devez avoir un jeton de rafra√Æchissement valide.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Code √† rafra√Æchir</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

Dans ce cas, l'**authentification** sera effectu√©e par l'**ex√©cution d'une fonction lambda**.

## S√©curit√© suppl√©mentaire

### S√©curit√© avanc√©e

Par d√©faut, elle est d√©sactiv√©e, mais si elle est activ√©e, Cognito pourrait √™tre en mesure de **d√©tecter les prises de contr√¥le de compte**. Pour minimiser la probabilit√©, vous devriez vous connecter √† partir d'un **r√©seau situ√© dans la m√™me ville, en utilisant le m√™me agent utilisateur** (et la m√™me adresse IP si possible).

### **MFA Se souvenir de l'appareil**

Si l'utilisateur se connecte √† partir du m√™me appareil, le MFA pourrait √™tre contourn√©, donc essayez de vous connecter √† partir du m√™me navigateur avec les m√™mes m√©tadonn√©es (adresse IP ?) pour contourner la protection MFA.

## R√¥les IAM des groupes de pools d'utilisateurs

Il est possible d'ajouter des **utilisateurs √† des groupes de pools d'utilisateurs** qui sont li√©s √† des **r√¥les IAM**.\
De plus, les **utilisateurs** peuvent √™tre assign√©s √† **plus d'un groupe avec des r√¥les IAM diff√©rents** attach√©s.

Notez que m√™me si un groupe est √† l'int√©rieur d'un groupe avec un r√¥le IAM attach√©, afin de pouvoir acc√©der aux informations d'identification IAM de ce groupe, il est n√©cessaire que le **pool d'utilisateurs soit approuv√© par un pool d'identit√©s** (et conna√Ætre les d√©tails de ce pool d'identit√©s).

Une autre condition requise pour obtenir le **r√¥le IAM indiqu√© dans le jeton d'identification** lorsqu'un utilisateur est authentifi√© dans le pool d'utilisateurs (`aws cognito-idp initiate-auth...`) est que le **fournisseur d'authentification du fournisseur d'identit√©** doit indiquer que le **r√¥le doit √™tre s√©lectionn√© √† partir du jeton**.

<figure><img src="../../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

Les **r√¥les** auxquels un utilisateur a acc√®s sont **contenus dans le `IdToken`**, et un utilisateur peut **s√©lectionner le r√¥le pour lequel il souhaite obtenir des informations d'identification** avec l'option **`--custom-role-arn`** de `aws cognito-identity get-credentials-for-identity`.\
Cependant, si l'option **par d√©faut** est celle **configur√©e** (`utiliser le r√¥le par d√©faut`), et que vous essayez d'acc√©der √† un r√¥le √† partir du jeton d'identification, vous obtiendrez une **erreur** (c'est pourquoi la configuration pr√©c√©dente est n√©cessaire) :

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Notez que le r√¥le attribu√© √† un **groupe de pools d'utilisateurs** doit √™tre **accessible par le fournisseur d'identit√©** qui **fait confiance au pool d'utilisateurs** (car les **informations d'identification de session du r√¥le IAM seront obtenues √† partir de celui-ci**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
