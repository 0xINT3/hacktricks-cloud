# Cognito 用户池

<details>

<summary><strong>从零开始学习AWS黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您希望在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter**上**关注**我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

## 基本信息

用户池是Amazon Cognito中的用户目录。通过用户池，您的用户可以通过Amazon Cognito**登录到您的网页或移动应用**，或者通过**第三方**身份提供商(IdP)进行**联合身份验证**。无论用户是直接登录还是通过第三方，用户池中的所有成员都有一个您可以通过SDK访问的目录配置文件。

用户池提供：

* 注册和登录服务。
* 内置的、可定制的用于用户登录的网页UI。
* 通过Facebook、Google、Login with Amazon和Sign in with Apple进行社交登录，以及通过您用户池中的SAML和OIDC身份提供商进行社交登录。
* 用户目录管理和用户配置文件。
* 安全功能，如多因素认证(MFA)、检查受损凭证、账户接管保护以及电话和电子邮件验证。
* 通过AWS Lambda触发器定制工作流程和用户迁移。

**源代码**通常也会包含**用户池ID**和**客户端应用程序ID**（有时还有**应用程序密钥**？），这些是用户登录Cognito用户池所需的。

### 潜在攻击

* **注册**：默认情况下，用户可以自行注册，因此他可以为自己创建一个用户。
* **用户枚举**：注册功能可用于查找已经存在的用户名。这些信息对于暴力破解攻击很有用。
* **登录暴力破解**：在[**认证**](cognito-user-pools.md#authentication)部分，您有所有用户**登录**的**方法**，您可以尝试暴力破解它们**找到有效凭证**。

### 用于渗透测试的工具

* [Pacu](https://github.com/RhinoSecurityLabs/pacu)，AWS利用框架，现在包括"cognito\_\_enum"和"cognito\_\_attack"模块，这些模块自动枚举账户中的所有Cognito资产并标记弱配置、用于访问控制的用户属性等，并自动化用户创建（包括MFA支持）和基于可修改的自定义属性、可用的身份池凭证、id令牌中的可假设角色等进行权限提升。

有关模块功能的描述，请参阅[博客文章](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)的第2部分。有关安装说明，请参阅主要的[Pacu](https://github.com/RhinoSecurityLabs/pacu)页面。

#### 使用方法

尝试针对给定身份池和用户池客户端创建用户和所有权限提升向量的示例cognito\_\_attack使用方法：
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
```markdown
示例 cognito__enum 的用法，用于收集当前 AWS 账户中可见的所有用户池、用户池客户端、身份池、用户等：
```
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) 是一个用Python编写的CLI工具，实现了对Cognito的不同攻击，包括不必要的账户创建和账户预言机。

#### 安装
```bash
$ pip install cognito-scanner
```
#### 使用方法
```bash
$ cognito-scanner --help
```
有关更多信息，请查看 https://github.com/padok-team/cognito-scanner

## 注册

User Pools **默认**允许**注册新用户**。
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 如果任何人都可以注册

你可能会发现一个错误，提示你需要**提供更多关于用户的详细信息**：
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
您可以使用如下的JSON来提供所需的详细信息：
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
你也可以使用这个功能来**枚举现有用户。**当用户名已存在时，会出现以下错误信息：
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
请注意，在上一个命令中，**自定义属性以“custom:”开头**。\
还要知道，在注册时，您**不能为用户创建新的自定义属性**。您只能为**默认属性**（即使它们不是必需的）和**指定的自定义属性**赋值。
{% endhint %}

或者只是为了测试客户端 ID 是否存在。如果客户端 ID 不存在，会出现以下错误：
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### 如果只有管理员可以注册用户

您会发现此错误，并且无法注册或枚举用户：
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### 验证注册

Cognito 允许通过**验证其电子邮件或电话号码**来**验证新用户**。因此，在创建用户时，通常至少需要用户名和密码以及**电子邮件和/或电话号码**。只需设置一个**你控制的**，这样你就会收到代码来**验证你的**新创建的用户**账户**，如下所示：
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
即使**看起来你可以使用相同的电子邮件**和电话号码，当你需要验证创建的用户时，Cognito会因为使用相同的信息而抱怨，并且**不会允许你验证账户**。
{% endhint %}

### 权限提升 / 更新属性

默认情况下，用户可以**修改他的属性值**，类似于：
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### 自定义属性权限提升

{% hint style="danger" %}
你可能会发现使用了**自定义属性**（例如`isAdmin`），因为默认情况下你可以**更改自己属性的值**，你可能能够通过自行更改值来**提升权限**！
{% endhint %}

#### 电子邮件/用户名修改权限提升

你可以使用这个方法来**修改用户的电子邮件和电话号码**，但即使账户保持验证状态，这些属性都会被**设置为未验证状态**（你需要再次验证它们）。

{% hint style="warning" %}
在你验证它们之前，你**无法使用电子邮件或电话号码登录**，但你将能够**使用用户名登录**。\
注意，即使电子邮件被修改且未经验证，它也会出现在 ID 令牌的**`email`** **字段**中，字段**`email_verified`**将是**false**，但如果应用程序**没有检查这一点，你可能会冒充其他用户**。

此外，请注意，你可以通过修改**name属性**在**`name`**字段中放入任何内容。如果应用程序出于某种原因**检查**该字段**而不是`email`**（或任何其他属性），你可能能够**冒充其他用户**。
{% endhint %}

无论如何，如果由于某种原因你例如将你的电子邮件更改为一个新的你可以访问的电子邮件，你可以**使用你在该电子邮件地址收到的代码来确认电子邮件**：
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
使用 **`phone_number`** 替代 **`email`** 来更改/验证**新的电话号码**。

{% hint style="info" %}
管理员还可以启用**使用用户首选用户名登录**的选项。请注意，您将无法将此值更改为**任何已被使用的用户名或 preferred_username**，以免冒充其他用户。
{% endhint %}

### 恢复/更改密码

只需**知道用户名**（或接受电子邮件或电话），并且能够访问它，因为会有一个代码发送到那里，就可以恢复密码：
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
服务器的响应总是会是积极的，就好像用户名存在一样。您不能使用此方法来枚举用户
{% endhint %}

使用以下代码可以更改密码：
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
要更改密码，您需要**知道之前的密码**：
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## 认证

用户池支持**不同的认证方式**。如果您有**用户名和密码**，也支持**不同的方法**进行登录。\
此外，当用户在池中认证后，会给出**3种类型的令牌**：**ID 令牌**、**访问令牌**和**刷新令牌**。

* [**ID 令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html)：它包含关于**已认证用户身份的声明**，如 `name`、`email` 和 `phone_number`。ID 令牌还可以用来**向您的资源服务器或服务器应用程序认证用户**。如果您在外部应用程序中使用它，必须**验证**ID 令牌的**签名**，才能信任其中的任何声明。
* ID 令牌是包含用户**属性值的令牌**，甚至包括自定义属性。
* [**访问令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html)：它包含关于已认证用户的声明、**用户组列表和作用域列表**。访问令牌的目的是在用户池中的用户上下文中**授权 API 操作**。例如，您可以使用访问令牌**授权用户访问**以添加、更改或删除用户属性。
* [**刷新令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html)：使用刷新令牌，您可以为用户**获取新的 ID 令牌和访问令牌**，直到**刷新令牌失效**。**默认情况下**，刷新令牌在您的应用程序用户登录到用户池后**30天后过期**。当您为用户池创建应用程序时，可以将应用程序的刷新令牌过期时间设置为**60分钟至10年之间的任何值**。

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

这是服务器端认证流程：

* 服务器端应用调用 **`AdminInitiateAuth` API 操作**（而不是 `InitiateAuth`）。此操作需要具有包括**`cognito-idp:AdminInitiateAuth`** 和 **`cognito-idp:AdminRespondToAuthChallenge`** 权限的 AWS 凭证。操作返回所需的认证参数。
* 在服务器端应用获取了**认证参数**后，它调用 **`AdminRespondToAuthChallenge` API 操作**。`AdminRespondToAuthChallenge` API 操作只有在您提供 AWS 凭证时才会成功。

此**方法默认不启用**。

要**登录**您**需要知道**：

* 用户池 id
* 客户端 id
* 用户名
* 密码
* 客户端密钥（仅当应用配置为使用密钥时）

{% hint style="info" %}
为了能够使用此方法**登录**，应用程序必须允许通过 `ALLOW_ADMIN_USER_PASSWORD_AUTH` 登录。\
此外，要执行此操作，您需要具有权限**`cognito-idp:AdminInitiateAuth`** 和 **`cognito-idp:AdminRespondToAuthChallenge`** 的凭证。
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>登录代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

此方法是另一种简单且**传统的用户与密码认证**流程。建议将传统认证方法**迁移到 Cognito**，然后建议**禁用**它，并改用**ALLOW\_USER\_SRP\_AUTH**方法（因为该方法从不通过网络发送密码）。\
此**方法默认不启用**。

与**先前认证方法**的主要**区别**在于代码中**不需要知道用户池 ID**，且在 Cognito 用户池中**不需要额外权限**。

要**登录**，你需要知道：

* 客户端 id
* 用户名
* 密码
* 客户端密钥（仅当应用配置为使用密钥时）

{% hint style="info" %}
为了能够使用此方法**登录**，应用必须允许通过 ALLOW\_USER\_PASSWORD\_AUTH 登录。
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python代码登录</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

这种情况与前一种类似，但**不是通过网络发送密码**来登录，而是执行**挑战认证**（因此没有密码，即使是加密的，也不会通过网络传输）。\
这种**方法默认启用**。

要**登录**，你**需要**知道：

* 用户池 ID
* 客户端 ID
* 用户名
* 密码
* 客户端密钥（仅当应用配置为使用密钥时）

<details>

<summary>登录代码</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

此**方法始终有效**（无法禁用），但您需要有一个有效的刷新令牌。
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>刷新代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

在这种情况下，**认证**将通过**执行一个lambda函数**来进行。

## 额外安全性

### 高级安全

默认情况下是禁用的，但如果启用，Cognito可能能够**发现账户接管**。为了最小化可能性，您应该从**同一城市内的网络登录，使用相同的用户代理**（如果可能的话，还有IP）。

### **MFA 记住设备**

如果用户从同一设备登录，MFA可能会被绕过，因此尝试从带有相同元数据（IP？）的同一浏览器登录，以尝试绕过MFA保护。

## 用户池组 IAM 角色

可以将**用户添加到与某个**IAM角色**相关联的用户池**组中。
此外，**用户**可以被分配到**多个不同IAM角色**的组中。

请注意，即使一个组在一个附有IAM角色的组内，为了能够访问该组的IAM凭证，需要**用户池被一个身份池信任**（并且知道该身份池的详细信息）。

当用户在用户池中认证时（`aws cognito-idp initiate-auth...`），获取**IdToken中指示的IAM角色**的另一个要求是**身份提供商认证提供商**需要指出**角色必须从令牌中选择**。

<figure><img src="../../../../.gitbook/assets/image (7) (1) (2).png" alt=""><figcaption></figcaption></figure>

用户可以访问的**角色**在`IdToken`**内**，用户可以使用`aws cognito-identity get-credentials-for-identity`的**`--custom-role-arn`**选择他希望获取凭证的角色。
然而，如果**默认选项**是配置的（`use default role`），并且你尝试从IdToken访问一个角色，你将得到**错误**（这就是为什么需要前面的配置）：

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
请注意，分配给**用户池组**的角色需要能够被**信任用户池的身份提供者**访问（因为 IAM 角色**会话凭证将从中获取**）。
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>从零到英雄学习AWS黑客技术，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
