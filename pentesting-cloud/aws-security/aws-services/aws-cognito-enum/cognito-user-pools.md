# Cognito用户池

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF格式的HackTricks，请查看[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks衣物**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来**分享您的黑客技巧**。

</details>

## 基本信息

用户池是Amazon Cognito中的用户目录。通过用户池，您的用户可以通过Amazon Cognito直接登录到您的Web或移动应用程序，或通过第三方身份提供商（IdP）进行联合登录。无论用户是直接登录还是通过第三方登录，用户池的所有成员都有一个目录配置文件，您可以通过SDK访问该配置文件。

用户池提供以下功能：

* 注册和登录服务。
* 内置的可自定义的Web用户界面，用于用户登录。
* 通过Facebook、Google、Login with Amazon和Sign in with Apple以及通过SAML和OIDC身份提供商从用户池中进行社交登录。
* 用户目录管理和用户配置文件。
* 安全功能，如多因素身份验证（MFA）、检查受损凭据、防止账户劫持以及电话和电子邮件验证。
* 通过AWS Lambda触发器进行自定义工作流和用户迁移。

应用程序的**源代码**通常还包含用户池ID和客户端应用程序ID（以及有时的应用程序密钥？），这些信息对于用户登录到Cognito用户池是必需的。

### 潜在攻击

* **注册**：默认情况下，用户可以自行注册，因此他可以为自己创建一个用户。
* **用户枚举**：注册功能可用于查找已存在的用户名。这些信息对于暴力破解攻击可能很有用。
* **登录暴力破解**：在[**身份验证**](cognito-user-pools.md#authentication)部分，您可以找到用户登录所需的所有**方法**，您可以尝试对它们进行暴力破解以找到有效的凭据。

## 注册

用户池默认允许**注册新用户**。
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 如果任何人都可以注册

你可能会遇到一个错误，提示你需要提供有关用户的更多详细信息：
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
您可以使用JSON提供所需的详细信息，例如：
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
您还可以使用此功能来**枚举现有用户**。当使用该名称的用户已存在时，将显示以下错误消息：
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
请注意前面的命令中，**自定义属性以"custom:"开头**。\
还要知道，在注册时，**不能为用户创建新的自定义属性**。您只能为**默认属性（即使它们不是必需的）**和**指定的自定义属性**赋值。
{% endhint %}

或者只是测试客户端ID是否存在。如果客户端ID不存在，则会出现以下错误：
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### 如果只有管理员可以注册用户

你会遇到这个错误，无法注册或枚举用户：
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### 验证注册

Cognito允许通过验证电子邮件或电话号码来验证新用户。因此，当创建用户时，通常需要提供至少用户名和密码以及电子邮件和/或电话号码。只需设置一个您控制的电子邮件或电话号码，这样您就可以收到用于验证新创建的用户帐户的代码，如下所示：
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
即使**看起来你可以使用相同的电子邮件**和电话号码，但当你需要验证创建的用户时，Cognito会抱怨使用相同的信息，并且**不会让你验证该帐户**。
{% endhint %}

### 特权升级/更新属性

默认情况下，用户可以使用以下方式**修改其属性的值**：
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### 自定义属性权限提升

{% hint style="danger" %}
你可能会发现使用了**自定义属性**（例如`isAdmin`），默认情况下你可以**更改自己属性的值**，因此你可能能够通过更改值来**提升权限**！
{% endhint %}

#### 电子邮件/用户名修改权限提升

你可以使用此方法来**修改用户的电子邮件和电话号码**，但即使帐户保持为已验证状态，这些属性也会**设置为未验证状态**（你需要重新验证它们）。

{% hint style="warning" %}
在你验证这些属性之前，你**无法使用电子邮件或电话号码登录**，但你将**能够使用用户名登录**。\
请注意，即使电子邮件被修改但未验证，它将出现在ID令牌的**`email`字段**中，而字段**`email_verified`**将为**false**，但如果应用程序**没有检查**这一点，你可能会冒充其他用户。

此外，请注意你可以通过修改**名称属性**在**`name`字段**中放入任何内容。如果应用程序出于某种原因**检查**该字段而不是**`email`**（或任何其他属性），你可能能够**冒充其他用户**。
{% endhint %}

无论如何，如果由于某种原因你将你的电子邮件更改为新的电子邮件，你可以使用你在该电子邮件地址中收到的代码**确认电子邮件**：
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
使用**`phone_number`**而不是**`email`**来更改/验证**新的电话号码**。

{% hint style="info" %}
管理员还可以启用使用用户首选用户名登录的选项。请注意，您将无法将此值更改为已经被使用的**任何用户名或preferred\_username**，以冒充不同的用户。
{% endhint %}

### 恢复/更改密码

只需知道用户名（或接受电子邮件或电话）并且能够访问它，就可以恢复密码，因为代码将发送到该位置：
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
服务器的响应总是积极的，就像用户名存在一样。您不能使用此方法枚举用户。
{% endhint %}

使用以下代码可以更改密码：
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
要更改密码，您需要**知道先前的密码**：
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## 认证

用户池支持**不同的身份验证方式**。如果您有**用户名和密码**，还有**不同的登录方法**可供选择。此外，当用户在池中进行身份验证时，会提供**3种类型的令牌**：**ID 令牌**、**访问令牌**和**刷新令牌**。

* [**ID 令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html)：它包含有关**已验证用户的身份**的声明，例如`name`、`email`和`phone_number`。ID 令牌还可用于**将用户身份验证到资源服务器或服务器应用程序**。如果您在外部应用程序中使用 ID 令牌，您必须**验证**ID 令牌的**签名**，然后才能信任 ID 令牌中的任何声明。
* ID 令牌是**包含用户属性值的令牌**，甚至包括自定义属性。
* [**访问令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html)：它包含有关已验证用户、用户组列表和作用域列表的声明。访问令牌的目的是**在用户池的用户上下文中授权 API 操作**。例如，您可以使用访问令牌**授予用户访问权限**以添加、更改或删除用户属性。
* [**刷新令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html)：使用刷新令牌，您可以为用户获取新的 ID 令牌和访问令牌，直到**刷新令牌失效**。默认情况下，刷新令牌在应用程序用户登录到用户池后**30天后过期**。当您为用户池创建应用程序时，可以将应用程序的刷新令牌过期时间设置为**60分钟至10年之间的任何值**。

### ADMIN\_NO\_SRP\_AUTH 和 ADMIN\_USER\_PASSWORD\_AUTH

这是服务器端的身份验证流程：

* 服务器端应用调用**`AdminInitiateAuth` API 操作**（而不是 `InitiateAuth`）。此操作需要具有包括**`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`**权限的 AWS 凭证。该操作返回所需的身份验证参数。
* 在服务器端应用获取到**身份验证参数**后，调用**`AdminRespondToAuthChallenge` API 操作**。只有在提供 AWS 凭证时，`AdminRespondToAuthChallenge` API 操作才会成功。

此方法**默认情况下未启用**。

要进行**登录**，您需要知道：

* 用户池 ID
* 客户端 ID
* 用户名
* 密码
* 客户端密钥（仅在应用程序配置为使用密钥时需要）

{% hint style="info" %}
为了能够使用此方法进行**登录**，应用程序必须允许使用`ALLOW_ADMIN_USER_PASSWORD_AUTH`进行登录。此外，执行此操作需要具有**`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`**权限的凭证。
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>登录代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

这种方法是另一种简单且传统的用户和密码认证流程。建议将传统的身份验证方法迁移到Cognito，并建议禁用它，然后改用ALLOW\_USER\_SRP\_AUTH方法（因为该方法永远不会将密码发送到网络上）。\
默认情况下，**此方法未启用**。

与代码中的先前身份验证方法相比，主要的**区别**是您**不需要知道用户池ID**，也**不需要额外的权限**在Cognito用户池中。

要进行**登录**，您需要知道：

* 客户端ID
* 用户名
* 密码
* 客户端密钥（仅当应用程序配置为使用密钥时）

{% hint style="info" %}
为了能够使用此方法登录，该应用程序必须允许使用ALLOW\_USER\_PASSWORD\_AUTH登录。
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python代码登录</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

这种情况与之前的情况类似，但是**不会通过网络发送密码**来登录，而是执行**挑战认证**（因此密码甚至不会通过网络加密传输）。\
此**方法默认启用**。

要进行**登录**，您需要知道：

* 用户池ID
* 客户端ID
* 用户名
* 密码
* 客户端密钥（仅当应用程序配置为使用密钥时）

<details>

<summary>登录代码</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

这个方法**始终有效**（无法禁用），但您需要拥有有效的刷新令牌。
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>刷新代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

在这种情况下，**身份验证**将通过**执行一个lambda函数**来完成。

## 额外的安全性

### 高级安全性

默认情况下是禁用的，但如果启用，Cognito可以**发现账户劫持**。为了最小化概率，您应该从**同一城市内的网络**使用**相同的用户代理**（如果可能的话使用相同的IP）进行登录。

### MFA记住设备

如果用户从同一设备登录，MFA可能会被绕过，因此尝试使用相同的浏览器和相同的元数据（IP？）进行登录，以尝试绕过MFA保护。

## 用户池组IAM角色

可以将**用户添加到用户池**组，这些组与一个**IAM角色**相关联。此外，**用户**可以被分配到**多个具有不同IAM角色的组**中。

请注意，即使一个组位于具有IAM角色的组中，为了能够访问该组的IAM凭证，需要**用户池受到身份池的信任**（并了解该身份池的详细信息）。

当用户在用户池中进行身份验证（`aws cognito-idp initiate-auth...`）时，要获得**IdToken中指定的IAM角色**，还需要**身份提供者身份验证提供者**指示**必须从令牌中选择角色**。

<figure><img src="../../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

用户可以访问的**角色**位于**`IdToken`**中，并且用户可以使用**`--custom-role-arn`**从`aws cognito-identity get-credentials-for-identity`选择他想要凭证的角色。\
然而，如果**默认选项**是**已配置的选项**（使用默认角色），并且您尝试从IdToken访问角色，您将收到**错误**（这就是为什么需要先前的配置）：

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
请注意，分配给**用户池组**的角色需要被**信任用户池的身份提供者**所**访问**（因为IAM角色的**会话凭证将从其中获取**）。
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
<details>

<summary><strong>支持HackTricks并获得好处！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版本的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或者 [**Telegram群组**](https://t.me/peass) 或者 **关注**我在**Twitter**上的账号 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
