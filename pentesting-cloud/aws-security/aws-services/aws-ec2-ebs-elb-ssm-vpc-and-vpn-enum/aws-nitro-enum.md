# AWS - Enumerazione Nitro

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team di HackTricks AWS)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**Gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di Base

AWS Nitro √® una suite di **tecnologie innovative** che costituiscono la piattaforma sottostante per le istanze AWS EC2. Introdotto da Amazon per **migliorare la sicurezza, le prestazioni e l'affidabilit√†**, Nitro sfrutta componenti hardware personalizzati e un ipervisore leggero. Astrae gran parte della funzionalit√† di virtualizzazione tradizionale verso hardware e software dedicati, **minimizzando la superficie di attacco** e migliorando l'efficienza delle risorse. Scaricando le funzioni di virtualizzazione, Nitro consente alle istanze EC2 di offrire **prestazioni quasi bare-metal**, rendendolo particolarmente vantaggioso per le applicazioni ad alta intensit√† di risorse. Inoltre, il Chip di Sicurezza Nitro garantisce specificamente la **sicurezza dell'hardware e del firmware**, consolidando ulteriormente la sua architettura robusta.

### Nitro Enclavi

**AWS Nitro Enclavi** fornisce un ambiente di calcolo sicuro e **isolato all'interno delle istanze Amazon EC2**, progettato specificamente per elaborare dati altamente sensibili. Sfruttando il Sistema AWS Nitro, queste enclavi garantiscono un'**isolamento e una sicurezza robusti**, ideali per **gestire informazioni confidenziali** come PII o registri finanziari. Presentano un ambiente minimalista, riducendo significativamente il rischio di esposizione dei dati. Inoltre, le Nitro Enclavi supportano l'attestazione crittografica, consentendo agli utenti di verificare che sia in esecuzione solo codice autorizzato, fondamentale per mantenere rigorosi standard di conformit√† e protezione dei dati.

{% hint style="danger" %}
Le immagini delle Nitro Enclavi vengono **eseguite da dentro le istanze EC2** e non √® possibile vedere dalla console web AWS se un'istanza EC2 sta eseguendo immagini in Nitro Enclave o meno.
{% endhint %}

## Installazione della CLI delle Nitro Enclavi

Segui tutte le istruzioni [**dalla documentazione**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave). Tuttavia, queste sono le pi√π importanti:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Immagini di Nitro Enclave

Le immagini che puoi eseguire in Nitro Enclave sono basate su immagini docker, quindi puoi creare le tue immagini di Nitro Enclave da immagini docker come:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Come puoi vedere, le immagini Nitro Enclave utilizzano l'estensione **`eif`** (Enclave Image File).

L'output sar√† simile a:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Esegui un'Immagine

Secondo [**la documentazione**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave), per eseguire un'immagine di enclave √® necessario assegnare ad essa una memoria di **almeno 4 volte la dimensione del file `eif`**. √à possibile configurare le risorse predefinite da assegnare ad essa nel file&#x20;
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
Ricorda sempre che √® necessario **riservare alcune risorse anche per l'istanza EC2 genitore**!
{% endhint %}

Dopo aver individuato le risorse da assegnare a un'immagine e aver modificato il file di configurazione, √® possibile eseguire un'immagine enclave con:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enumerare Enclavi

Se comprometti un host EC2, √® possibile ottenere un elenco delle immagini di enclave in esecuzione con:
```bash
nitro-cli describe-enclaves
```
Non √® possibile ottenere una shell all'interno di un'immagine enclave in esecuzione perch√© questo √® lo scopo principale dell'enclave, tuttavia, se si utilizza il parametro `--debug-mode`, √® possibile ottenere il **stdout** di essa con:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminare Enclavi

Se un attaccante compromette un'istanza EC2, di default non sar√† in grado di ottenere una shell all'interno di essa, ma sar√† in grado di **terminarla** con:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsock

L'unico modo per comunicare con un'**enclave** in esecuzione √® utilizzare **vsocks**.

**Virtual Socket (vsock)** √® una famiglia di socket in Linux progettata specificamente per facilitare la **comunicazione** tra macchine virtuali (**VM**) e i loro **hypervisor**, o tra le VM **stesse**. Vsock consente una **comunicazione bidirezionale** efficiente senza dover fare affidamento sullo stack di rete dell'host. Ci√≤ consente alle VM di comunicare anche senza configurazioni di rete, **utilizzando un ID di contesto a 32 bit (CID) e numeri di porta** per identificare e gestire le connessioni. L'API vsock supporta sia tipi di socket di flusso che di datagrammi, simili a TCP e UDP, fornendo uno strumento versatile per le applicazioni a livello utente in ambienti virtuali.

{% hint style="success" %}
Pertanto, un indirizzo vsock appare cos√¨: `<CID>:<Port>`
{% endhint %}

Per trovare i **CID** delle immagini in esecuzione nell'enclave √® sufficiente eseguire il seguente comando e ottenere il **`EnclaveCID`**:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
Si noti che dall'host non c'√® modo di sapere se un CID sta esponendo una porta! A meno che non si utilizzi uno **scanner di porte vsock come** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner).
{% endhint %}

### Server/Listener Vsock

Qui trovi un paio di esempi:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Listener Python Semplice</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Cliente Vsock

Esempi:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>Cliente Python Semplice</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</dettagli>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Proxy Vsock

Lo strumento vsock-proxy consente di fare il proxy di un vsock con un altro indirizzo, ad esempio:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
Questo inoltrer√† la **porta locale 8001 in vsock** a `ip-ranges.amazonaws.com:443` e il file **`your-vsock-proxy.yaml`** potrebbe contenere questo contenuto che consente di accedere a `ip-ranges.amazonaws.com:443`:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
√à possibile visualizzare gli indirizzi vsock (**`<CID>:<Port>`**) utilizzati dall'host EC2 con (nota il `3:8001`, 3 √® il CID e 8001 √® la porta):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Attestazione e KMS di Nitro Enclave

Il SDK di Nitro Enclaves consente a un enclave di richiedere un **documento di attestazione firmato crittograficamente** dall'**Hypervisor** Nitro, che include **misure uniche** specifiche per quell'enclave. Queste misure, che includono **hash e registri di configurazione della piattaforma (PCRs)**, vengono utilizzate durante il processo di attestazione per **dimostrare l'identit√† dell'enclave** e **creare fiducia con servizi esterni**. Il documento di attestazione contiene tipicamente valori come PCR0, PCR1 e PCR2, con cui ti sei gi√† imbattuto quando hai costruito e salvato un EIF dell'enclave.

Dai [**documenti**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves), questi sono i valori PCR:

<table><thead><tr><th width="97">PCR</th><th width="221">Hash di ...</th><th>Descrizione</th></tr></thead><tbody><tr><td>PCR0</td><td>File immagine dell'enclave</td><td>Una misura contigua dei contenuti del file immagine, senza i dati della sezione.</td></tr><tr><td>PCR1</td><td>Kernel Linux e bootstrap</td><td>Una misurazione contigua del kernel e dei dati di boot ramfs.</td></tr><tr><td>PCR2</td><td>Applicazione</td><td>Una misurazione contigua e in ordine delle applicazioni utente, senza il boot ramfs.</td></tr><tr><td>PCR3</td><td>Ruolo IAM assegnato all'istanza genitore</td><td>Una misurazione contigua del ruolo IAM assegnato all'istanza genitore. Garantisce che il processo di attestazione riesca solo quando l'istanza genitore ha il ruolo IAM corretto.</td></tr><tr><td>PCR4</td><td>ID dell'istanza genitore</td><td>Una misurazione contigua dell'ID dell'istanza genitore. Garantisce che il processo di attestazione riesca solo quando l'istanza genitore ha un ID di istanza specifico.</td></tr><tr><td>PCR8</td><td>Certificato di firma del file immagine dell'enclave</td><td>Una misura del certificato di firma specificato per il file immagine dell'enclave. Garantisce che il processo di attestazione riesca solo quando l'enclave √® stata avviata da un file immagine dell'enclave firmato da un certificato specifico.</td></tr></tbody></table>

Puoi integrare **l'attestazione crittografica** nelle tue applicazioni e sfruttare integrazioni predefinite con servizi come **AWS KMS**. AWS KMS pu√≤ **convalidare le attestazioni dell'enclave** e offre chiavi di condizione basate sull'attestazione (`kms:RecipientAttestation:ImageSha384` e `kms:RecipientAttestation:PCR`) nelle sue policy delle chiavi. Queste policy garantiscono che AWS KMS permetta operazioni utilizzando la chiave KMS **solo se il documento di attestazione dell'enclave √® valido** e soddisfa le **condizioni specificate**.

{% hint style="success" %}
Nota che gli Enclavi in modalit√† debug (--debug) generano documenti di attestazione con PCRs composti da zeri (`000000000000000000000000000000000000000000000000`). Pertanto, le policy di KMS che controllano questi valori falliranno.
{% endhint %}

### Bypass PCR

Dal punto di vista di un attaccante, si noti che alcuni PCRs potrebbero consentire di modificare alcune parti o l'intera immagine dell'enclave e sarebbero comunque validi (ad esempio PCR4 controlla solo l'ID dell'istanza genitore, quindi eseguire qualsiasi immagine dell'enclave in quella EC2 consentir√† di soddisfare questo potenziale requisito di PCR).

Pertanto, un attaccante che compromette l'istanza EC2 potrebbe essere in grado di eseguire altre immagini dell'enclave per eludere tali protezioni.

La ricerca su come modificare/creare nuove immagini per eludere ciascuna protezione (soprattutto quelle non cos√¨ ovvie) √® ancora da fare.

## Riferimenti

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* Tutte le parti del tutorial Nitro da AWS: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
