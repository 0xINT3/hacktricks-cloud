# AWS - Nitro Enum

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

AWS Nitro to zestaw **innowacyjnych technologii**, które stanowią podstawową platformę dla instancji AWS EC2. Wprowadzony przez Amazon w celu **poprawy bezpieczeństwa, wydajności i niezawodności**, Nitro wykorzystuje dedykowane **komponenty sprzętowe i lekki hipernadzorca**. Abstrahuje wiele tradycyjnych funkcji wirtualizacji do dedykowanego sprzętu i oprogramowania, **minimalizując powierzchnię ataku** i poprawiając efektywność zasobów. Poprzez przeniesienie funkcji wirtualizacji, Nitro pozwala instancjom EC2 osiągać **wydajność zbliżoną do metalu**, co jest szczególnie korzystne dla aplikacji wymagających dużych zasobów. Dodatkowo, specjalny układ zabezpieczeń Nitro zapewnia **bezpieczeństwo sprzętu i oprogramowania**, dodatkowo umacniając jego solidną architekturę.

### Komory Nitro

**AWS Nitro Enclaves** zapewniają bezpieczne, **izolowane środowisko obliczeniowe w instancjach Amazon EC2**, specjalnie zaprojektowane do przetwarzania bardzo wrażliwych danych. Wykorzystując System AWS Nitro, te komory zapewniają solidną **izolację i bezpieczeństwo**, idealne do **obsługi poufnych informacji** takich jak PII czy dane finansowe. Charakteryzują się minimalistycznym środowiskiem, znacząco zmniejszając ryzyko ujawnienia danych. Dodatkowo, komory Nitro obsługują atestację kryptograficzną, pozwalając użytkownikom zweryfikować, że uruchamiany jest tylko autoryzowany kod, co jest kluczowe dla zachowania surowych standardów zgodności i ochrony danych.

{% hint style="danger" %}
Obrazy komór Nitro są **uruchamiane wewnątrz instancji EC2** i nie można ich zobaczyć w konsoli internetowej AWS, czy instancja EC2 uruchamia obrazy w komorze Nitro, czy nie.
{% endhint %}

## Instalacja interfejsu wiersza poleceń komory Nitro

Postępuj zgodnie ze wszystkimi instrukcjami [**z dokumentacji**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave). Jednakże, oto najważniejsze:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Obrazy Enklawy Nitro

Obrazy, które można uruchamiać w Enklawie Nitro, są oparte na obrazach dockerowych, więc możesz tworzyć swoje obrazy Enklawy Nitro z obrazów dockerowych, takich jak:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Jak widać obrazy Nitro Enclave używają rozszerzenia **`eif`** (Enclave Image File).

Wyjście będzie wyglądać podobnie jak:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Uruchom obraz

Zgodnie z [**dokumentacją**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave), aby uruchomić obraz enklawy, musisz przypisać mu pamięć **co najmniej 4 razy większą niż rozmiar pliku `eif`**. Możliwe jest skonfigurowanie domyślnych zasobów do przypisania w pliku.
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
Zawsze pamiętaj, że musisz **zarezerwować pewne zasoby dla nadrzędnego EC2** instancji!
{% endhint %}

Po poznaniu zasobów do przypisania obrazowi i nawet po zmodyfikowaniu pliku konfiguracyjnego można uruchomić obraz enklawy za pomocą:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Wyliczanie Enklaw

Jeśli przejmiesz hosta EC2, możesz uzyskać listę uruchomionych obrazów enklaw za pomocą:
```bash
nitro-cli describe-enclaves
```
Nie jest możliwe uzyskanie powłoki wewnątrz działającego obrazu enklawy, ponieważ to główne przeznaczenie enklawy, jednakże, jeśli użyto parametru `--debug-mode`, możliwe jest uzyskanie jego **stdout** za pomocą:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Zakończ enklawy

Jeśli atakujący przejmie instancję EC2, domyślnie nie będzie mógł uzyskać do nich dostępu za pomocą powłoki, ale będzie mógł je **zakończyć** przy użyciu:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsock

Jedynym sposobem komunikacji z uruchomionym obrazem **enklawy** jest użycie **vsocks**.

**Wirtualny gniazdek (vsock)** to rodzina gniazdek w systemie Linux, specjalnie zaprojektowana do ułatwiania **komunikacji** między maszynami wirtualnymi (**VM**) a ich **hipernadzorcami**, lub między samymi VM **sobą**. Vsock umożliwia efektywną, **dwukierunkową komunikację** bez polegania na stosie sieciowym hosta. Dzięki temu maszyny wirtualne mogą komunikować się nawet bez konfiguracji sieciowej, **korzystając z 32-bitowego identyfikatora kontekstu (CID) i numerów portów** do identyfikacji i zarządzania połączeniami. Interfejs API vsock obsługuje zarówno gniazdka strumieniowe, jak i datagramowe, podobnie jak TCP i UDP, zapewniając wszechstronne narzędzie dla aplikacji na poziomie użytkownika w środowiskach wirtualnych.

{% hint style="success" %}
Dlatego adres vsock wygląda tak: `<CID>:<Port>`
{% endhint %}

Aby znaleźć **CIDs** uruchomionych obrazów enklawy, wystarczy wykonać następujące polecenie i uzyskać **`EnclaveCID`**:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
Zauważ, że z hosta nie ma sposobu, aby dowiedzieć się, czy CID ujawnia jakikolwiek port! Chyba że użyjesz jakiegoś **skanera portów vsock, takiego jak** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner).
{% endhint %}

### Serwer/odbiornik Vsock

Oto kilka przykładów:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Prosty Słuchacz w Pythonie</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</szczegóły>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Klient Vsock

Przykłady:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>Prosty klient w języku Python</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</szczegóły>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

Narzędzie vsock-proxy pozwala na proxy vsock z innym adresem, na przykład:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
To przekieruje **lokalny port 8001 w vsock** do `ip-ranges.amazonaws.com:443`, a plik **`your-vsock-proxy.yaml`** może zawierać ten kod umożliwiający dostęp do `ip-ranges.amazonaws.com:443`:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
Możliwe jest zobaczenie adresów vsock (**`<CID>:<Port>`**) używanych przez hosta EC2 za pomocą (zauważ `3:8001`, gdzie 3 to CID, a 8001 to port):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Atestacja Nitro Enclave i KMS

SDK Nitro Enclaves umożliwia enklawie żądanie **kryptograficznie podpisanego dokumentu atestacji** od **Hypervisora** Nitro, który zawiera **unikalne pomiaru** specyficzne dla tej enklawy. Te pomiary, które obejmują **skróty i rejestry konfiguracji platformy (PCRs)**, są wykorzystywane podczas procesu atestacji do **udowodnienia tożsamości enklawy** i **budowania zaufania z zewnętrznymi usługami**. Dokument atestacji zazwyczaj zawiera wartości takie jak PCR0, PCR1 i PCR2, z którymi już się spotkałeś tworząc i zapisując plik EIF enklawy.

Z [**dokumentacji**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves), oto wartości PCR:

<table><thead><tr><th width="97">PCR</th><th width="221">Skrót z ...</th><th>Opis</th></tr></thead><tbody><tr><td>PCR0</td><td>Plik obrazu enklawy</td><td>Ciągły pomiar zawartości pliku obrazu, bez danych sekcji.</td></tr><tr><td>PCR1</td><td>Jądro Linuxa i bootstrap</td><td>Ciągły pomiar jądra i danych boot ramfs.</td></tr><tr><td>PCR2</td><td>Aplikacja</td><td>Ciągły, uporządkowany pomiar aplikacji użytkownika, bez boot ramfs.</td></tr><tr><td>PCR3</td><td>Rola IAM przypisana do instancji nadrzędnej</td><td>Ciągły pomiar roli IAM przypisanej do instancji nadrzędnej. Zapewnia, że proces atestacji powiedzie się tylko wtedy, gdy instancja nadrzędna ma właściwą rolę IAM.</td></tr><tr><td>PCR4</td><td>ID instancji instancji nadrzędnej</td><td>Ciągły pomiar ID instancji nadrzędnej. Zapewnia, że proces atestacji powiedzie się tylko wtedy, gdy instancja nadrzędna ma określone ID instancji.</td></tr><tr><td>PCR8</td><td>Certyfikat podpisujący plik obrazu enklawy</td><td>Pomiar certyfikatu podpisującego określony dla pliku obrazu enklawy. Zapewnia, że proces atestacji powiedzie się tylko wtedy, gdy enklawa została uruchomiona z pliku obrazu enklawy podpisanego określonym certyfikatem.</td></tr></tbody></table>

Możesz zintegrować **kryptograficzną atestację** do swoich aplikacji i wykorzystać gotowe integracje z usługami takimi jak **AWS KMS**. AWS KMS może **zweryfikować atestacje enklawy** i oferuje klucze warunkowe oparte na atestacji (`kms:RecipientAttestation:ImageSha384` i `kms:RecipientAttestation:PCR`) w swoich politykach klucza. Te polityki zapewniają, że AWS KMS zezwala na operacje przy użyciu klucza KMS **tylko jeśli dokument atestacji enklawy jest ważny** i spełnia **określone warunki**.

{% hint style="success" %}
Zauważ, że Enklawy w trybie debugowania (--debug) generują dokumenty atestacji z PCRs, które składają się z zer (`000000000000000000000000000000000000000000000000`). Dlatego polityki KMS sprawdzające te wartości zawiodą.
{% endhint %}

### Ominięcie PCR

Z perspektywy atakującego, zauważ, że niektóre PCRs pozwoliłyby na modyfikację niektórych części lub całego obrazu enklawy i wciąż byłyby ważne (na przykład PCR4 sprawdza tylko ID instancji nadrzędnej, więc uruchomienie dowolnego obrazu enklawy w tej EC2 pozwoliłoby spełnić to potencjalne wymaganie PCR).

Dlatego atakujący, który skompromituje instancję EC2, może być w stanie uruchomić inne obrazy enklaw w celu ominięcia tych zabezpieczeń.

Badania nad tym, jak modyfikować/tworzyć nowe obrazy w celu ominięcia każdego zabezpieczenia (szczególnie tych mniej oczywistych) są wciąż do zrobienia.

## Odnośniki

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* Wszystkie części samouczka Nitro od AWS: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
