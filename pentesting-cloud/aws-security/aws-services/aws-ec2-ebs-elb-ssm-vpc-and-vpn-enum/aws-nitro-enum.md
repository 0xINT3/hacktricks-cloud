# AWS - Nitro Enum

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 제로부터 전문가까지 배우세요!</strong></summary>

다른 HackTricks 지원 방법:

- **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

AWS Nitro는 AWS EC2 인스턴스의 기본 플랫폼을 형성하는 **혁신적인 기술 모음**입니다. Amazon에 의해 소개된 Nitro는 **보안, 성능 및 신뢰성을 향상**시키기 위해 사용자 정의 **하드웨어 구성 요소 및 가벼운 하이퍼바이저**를 활용합니다. Nitro는 전통적인 가상화 기능의 많은 부분을 전용 하드웨어 및 소프트웨어로 추상화하여 **공격 표면을 최소화**하고 리소스 효율성을 향상시킵니다. 가상화 기능을 오프로드함으로써 Nitro는 EC2 인스턴스가 **거의 베어 메탈 성능**을 제공할 수 있게 하여 리소스 집약적인 응용 프로그램에 특히 유용합니다. 또한 Nitro 보안 칩은 특히 **하드웨어 및 펌웨어의 보안**을 보장하여 견고한 아키텍처를 더욱 확고히 합니다.

### Nitro Enclaves

**AWS Nitro Enclaves**는 Amazon EC2 인스턴스 내에서 **안전한 격리된 컴퓨팅 환경**을 제공하며, 고도로 민감한 데이터를 처리하기 위해 특별히 설계되었습니다. AWS Nitro 시스템을 활용하여 이러한 Enclaves는 견고한 **격리 및 보안**을 보장하여 PII 또는 금융 기록과 같은 **기밀 정보를 처리**하는 데 이상적입니다. 이들은 데이터 노출 위험을 크게 줄이는 최소한의 환경을 제공합니다. 또한 Nitro Enclaves는 암호화 인증을 지원하여 사용자가 실행 중인 코드가 인증된 코드인지 확인할 수 있도록 하여 엄격한 규정 준수 및 데이터 보호 표준을 유지하는 데 중요합니다.

{% hint style="danger" %}
Nitro Enclave 이미지는 **EC2 인스턴스 내부에서 실행**되며 AWS 웹 콘솔에서 EC2 인스턴스가 Nitro Enclave 이미지를 실행 중인지 확인할 수 없습니다.
{% endhint %}

## Nitro Enclave CLI 설치

모든 지침을 [**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)에서 따르세요. 그러나 이것이 가장 중요한 부분입니다:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave 이미지

Nitro Enclave에서 실행할 수 있는 이미지들은 도커 이미지를 기반으로 하며, 따라서 다음과 같이 도커 이미지로부터 Nitro Enclave 이미지를 생성할 수 있습니다:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Nitro Enclave 이미지는 **`eif`** (Enclave Image File) 확장자를 사용합니다.

출력은 다음과 유사할 것입니다:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### 이미지 실행

[**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)에 따르면, 엔클레이브 이미지를 실행하려면 해당 이미지에 **`eif` 파일 크기의 최소 4배 이상의 메모리를 할당**해야 합니다. 파일 내에서 할당할 기본 리소스를 구성하는 것이 가능합니다.
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
언제나 부모 EC2 인스턴스에 일부 **리소스를 예약해야** 한다는 것을 기억하세요!
{% endhint %}

이미지에 할당할 리소스를 알고 구성 파일을 수정한 후에도 다음과 같이 엔클레이브 이미지를 실행할 수 있습니다:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enclaves 열거

EC2 호스트를 침입하면 다음과 같이 실행 중인 엔클레이브 이미지 목록을 얻을 수 있습니다:
```bash
nitro-cli describe-enclaves
```
그 실행 중인 엔클레이브 이미지 내부에 쉘을 얻는 것은 불가능합니다. 왜냐하면 그것이 엔클레이브의 주요 목적이기 때문입니다. 그러나 **`--debug-mode`** 매개변수를 사용하면 해당 이미지의 **stdout**을 얻을 수 있습니다.
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Enclaves 종료

공격자가 EC2 인스턴스를 침투하더라도 기본적으로 그들 안에 쉘을 얻을 수는 없지만, 다음을 사용하여 **종료**할 수 있습니다:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsock

**안클레이브** 실행 이미지와 통신하는 유일한 방법은 **vsocks**를 사용하는 것입니다.

**가상 소켓 (vsock)**은 리눅스의 소켓 패밀리로, 가상 머신(**VMs**)과 그들의 **하이퍼바이저** 또는 VMs **간**의 **통신**을 용이하게 하는 것을 목적으로 특별히 설계되었습니다. Vsock은 호스트의 네트워킹 스택에 의존하지 않고 효율적인 **양방향 통신**을 가능하게 합니다. 이를 통해 VMs는 네트워크 구성 없이도 통신할 수 있으며, **32비트 Context ID (CID)와 포트 번호**를 사용하여 연결을 식별하고 관리합니다. vsock API는 TCP와 UDP와 유사한 스트림 및 데이터그램 소켓 유형을 지원하며, 가상 환경에서 사용자 수준 응용 프로그램에 대한 다재다능한 도구를 제공합니다.

{% hint style="success" %}
따라서, vsock 주소는 다음과 같이 보입니다: `<CID>:<Port>`
{% endhint %}

**안클레이브** 실행 이미지의 **CIDs**를 찾으려면 다음 명령을 실행하고 **`EnclaveCID`**를 확인할 수 있습니다:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
호스트에서 CID가 포트를 노출하고 있는지 알 수 있는 방법은 없습니다! **[https://github.com/carlospolop/Vsock-scanner](https://github.com/carlospolop/Vsock-scanner)**와 같은 **vsock 포트 스캐너**를 사용하지 않는 한.
{% endhint %}

### Vsock 서버/리스너

여기에 몇 가지 예제가 있습니다:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>간단한 Python 리스너</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock 클라이언트

예시:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>간단한 Python 클라이언트</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>  

<details>  
<summary>번역</summary>  

다음은 AWS Nitro 인스턴스에서 발견할 수 있는 몇 가지 유용한 정보입니다.  

- Nitro 인스턴스 유형  
- Nitro 인스턴스의 상태  
- Nitro 인스턴스의 네트워크 인터페이스  
- Nitro 인스턴스의 블록 장치  
- Nitro 인스턴스의 SR-IOV 지원 여부  

이러한 정보는 AWS 환경에서 펜테스팅을 수행할 때 유용할 수 있습니다.  
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock 프록시

도구 vsock-proxy를 사용하면 다른 주소로 vsock 프록시를 프록시할 수 있습니다. 예시:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
이것은 **vsock**의 **로컬 포트 8001**을 `ip-ranges.amazonaws.com:443`로 전달하며 파일 **`your-vsock-proxy.yaml`**에는 `ip-ranges.amazonaws.com:443`에 액세스할 수 있도록 하는 내용이 포함될 수 있습니다:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
다음은 EC2 호스트에서 사용되는 vsock 주소(**`<CID>:<Port>`**)를 볼 수 있습니다 (`3:8001`, 3은 CID이고 8001은 포트임을 참고하세요):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave Attestation & KMS

Nitro Enclaves SDK를 사용하면 enclave가 Nitro Hypervisor로부터 **암호화된 서명된 인증 문서**를 요청할 수 있습니다. 이 문서에는 해당 enclave에 특정한 **고유 측정값**이 포함됩니다. 이러한 측정값에는 **해시 및 플랫폼 구성 레지스터 (PCRs)**가 포함되며, 이러한 값들은 인증 프로세스 중에 사용되어 **enclave의 신원을 증명**하고 **외부 서비스와의 신뢰를 구축**하는 데 사용됩니다. 인증 문서에는 일반적으로 PCR0, PCR1 및 PCR2와 같은 값이 포함되어 있으며, 이 값들은 enclave EIF를 빌드하고 저장할 때 이전에 만난 값들입니다.

[**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves)에서 다음은 PCR 값들입니다:

<table><thead><tr><th width="97">PCR</th><th width="221">해시 값</th><th>설명</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave 이미지 파일</td><td>섹션 데이터 없이 이미지 파일의 내용의 연속된 측정값입니다.</td></tr><tr><td>PCR1</td><td>Linux 커널 및 부트스트랩</td><td>커널 및 부트 ramfs 데이터의 연속된 측정값입니다.</td></tr><tr><td>PCR2</td><td>애플리케이션</td><td>부트 ramfs 없이 사용자 애플리케이션의 연속된 순서대로 측정값입니다.</td></tr><tr><td>PCR3</td><td>부모 인스턴스에 할당된 IAM 역할</td><td>부모 인스턴스에 할당된 IAM 역할의 연속된 측정값입니다. 인증 프로세스가 올바른 IAM 역할을 가진 부모 인스턴스일 때에만 인증 프로세스가 성공하도록 보장합니다.</td></tr><tr><td>PCR4</td><td>부모 인스턴스의 인스턴스 ID</td><td>부모 인스턴스의 ID의 연속된 측정값입니다. 인증 프로세스가 특정 인스턴스 ID를 가진 부모 인스턴스일 때에만 인증 프로세스가 성공하도록 보장합니다.</td></tr><tr><td>PCR8</td><td>Enclave 이미지 파일 서명 인증서</td><td>enclave 이미지 파일에 지정된 서명 인증서의 측정값입니다. 특정 인증서로 서명된 enclave 이미지 파일에서만 인증 프로세스가 성공하도록 보장합니다.</td></tr></tbody></table>

**암호화된 인증**을 애플리케이션에 통합하고 **AWS KMS**와 같은 서비스와의 사전 구축된 통합을 활용할 수 있습니다. AWS KMS는 **enclave 인증을 확인**하고 키 정책에서 인증 기반 조건 키 (`kms:RecipientAttestation:ImageSha384` 및 `kms:RecipientAttestation:PCR`)를 제공합니다. 이러한 정책은 AWS KMS가 **enclave의 인증 문서가 유효하고 지정된 조건을 충족하는 경우에만** KMS 키를 사용하여 작업을 허용하도록 보장합니다.

{% hint style="success" %}
디버그 (--debug) 모드의 Enclaves는 PCR이 모두 0으로 이루어진 인증 문서를 생성합니다 (`000000000000000000000000000000000000000000000000`). 따라서, 이러한 값들을 확인하는 KMS 정책은 실패할 것입니다.
{% endhint %}

### PCR 우회

공격자의 관점에서, 일부 PCR은 enclave 이미지의 일부 또는 전체를 수정할 수 있도록 허용하며 여전히 유효할 수 있습니다 (예: PCR4는 부모 인스턴스의 ID만 확인하므로 해당 EC2에서 어떤 enclave 이미지를 실행하더라도 이 잠재적인 PCR 요구 사항을 충족할 수 있습니다).

따라서 EC2 인스턴스를 침해한 공격자는 이러한 보호 기능을 우회하기 위해 다른 enclave 이미지를 실행할 수 있을 수 있습니다.

각 보호 기능을 우회하도록 이미지를 수정/생성하는 방법에 대한 연구 (특히 명백하지 않은 것들)은 아직 TODO 상태입니다.

## 참고 자료

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* AWS의 Nitro 튜토리얼의 모든 부분: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹을 배우세요**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>
