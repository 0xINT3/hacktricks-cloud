# AWS - 람다 요청 도용

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 제로부터 전문가까지 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 요령을 공유하세요.

</details>

## 람다 플로우

<figure><img src="../../../../.gitbook/assets/image (152).png" alt=""><figcaption><p><a href="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png">https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/lambda_poc_2_arch.png</a></p></figcaption></figure>

1. **Slicer**는 컨테이너 외부의 프로세스로, **init** 프로세스에 **호출**을 보냅니다.
2. init 프로세스는 몇 가지 흥미로운 엔드포인트를 노출하는 포트 **9001**에서 수신 대기합니다:
* **`/2018-06-01/runtime/invocation/next`** – 다음 호출 이벤트를 가져옵니다.
* **`/2018-06-01/runtime/invocation/{invoke-id}/response`** – 호출에 대한 핸들러 응답 반환
* **`/2018-06-01/runtime/invocation/{invoke-id}/error`** – 실행 오류 반환
3. **bootstrap.py**는 init 프로세스에서 호출을 받아 사용자 코드를 처리하기 위해 루프를 실행합니다 (**`/next`**).
4. 마지막으로, **bootstrap.py**는 응답을 init에게 보냅니다.

bootstrap은 사용자 코드를 모듈로로드하므로 사용자 코드에 의해 수행된 모든 코드 실행은 실제로 이 프로세스에서 발생합니다.

## 람다 요청 도용

이 공격의 목표는 사용자 코드가 취약한 요청을 처리하는 **`bootstrap.py`** 프로세스 내에서 악성 **`bootstrap.py`** 프로세스를 실행하도록 만드는 것입니다. 이렇게 하면 **악성 bootstrap** 프로세스가 요청을 처리하기 위해 init 프로세스와 **통신**을 시작하면서 **합법적인** bootstrap이 악성 프로세스를 실행하는 동안 **갇히게**되어 init 프로세스에 대해 요청을 하지 않을 것입니다.

사용자 코드의 코드가 합법적인 **`bootstrap.py`** 프로세스에 의해 실행되고 있기 때문에 이 작업은 간단히 수행할 수 있습니다. 따라서 공격자는 다음을 수행할 수 있습니다:

* 현재 호출의 가짜 결과를 init 프로세스에 **보내어** init이 bootstrap 프로세스가 더 많은 호출을 기다리고 있다고 생각하게 합니다.
* 요청은 **`/${invoke-id}/response`**로 보내야 합니다.
* invoke-id는 합법적인 **`bootstrap.py`** 프로세스의 스택에서 [**inspect**](https://docs.python.org/3/library/inspect.html) 파이썬 모듈을 사용하여 얻을 수 있습니다 ([여기에서 제안된대로](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/switch\_runtime.py)) 또는 단순히 다시 **`/2018-06-01/runtime/invocation/next`**로 요청하여 얻을 수 있습니다 ([여기에서 제안된대로](https://github.com/Djkusik/serverless\_persistency\_poc/blob/master/gcp/exploit\_files/switcher.py)).
* 다음 호출을 처리할 악성 **`boostrap.py`**를 실행합니다.
* 은밀성을 위해 람다 호출 매개변수를 공격자가 제어하는 C2로 보내고 그런 다음 요청을 처리할 수 있습니다.
* 이 공격에는 시스템에서 **`bootstrap.py`**의 원본 코드를 가져와 악성 코드를 추가하고 현재 람다 호출에서 **`invoke-id`**를 매개변수로 지정하여 실행하는 것이 충분합니다.

### 공격 단계

## 참고 자료

* [https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/](https://unit42.paloaltonetworks.com/gaining-persistency-vulnerable-lambdas/)
