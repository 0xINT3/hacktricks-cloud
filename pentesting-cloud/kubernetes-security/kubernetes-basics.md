# Kubernetes基础知识

## Kubernetes基础知识

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向**[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

**本页面的原始作者是**[**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **（阅读他的原始帖子**[**这里**](https://sickrov.github.io)**）**

## 架构和基础知识

### Kubernetes是做什么的？

* 允许在容器引擎中运行容器。
* 调度允许容器高效地执行任务。
* 保持容器的运行。
* 允许容器之间的通信。
* 允许部署技术。
* 处理大量信息。

### 架构

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **节点**：具有Pod或多个Pod的操作系统。
* **Pod**：包装容器或多个容器的容器。一个Pod应该只包含一个应用程序（因此通常一个Pod只运行一个容器）。Pod是Kubernetes抽象容器技术运行的方式。
* **服务**：每个Pod都有一个来自节点内部范围的内部**IP地址**。但是，它也可以通过服务进行公开。**服务也有一个IP地址**，其目标是维护Pod之间的通信，因此如果一个Pod死亡，**新的替代品**（具有不同的内部IP）将在**服务的相同IP中可访问**。它可以配置为内部或外部。当两个Pod连接到同一个服务时，服务还充当**负载均衡器**。\
创建**服务**后，可以通过运行`kubectl get endpoints`来查找每个服务的端点。
* **Kubelet**：主要的节点代理。该组件在节点和kubectl之间建立通信，并且只能运行Pod（通过API服务器）。Kubelet不管理由Kubernetes创建的容器。
* **Kube-proxy**：负责与apiserver和节点之间的通信（服务）的服务。基础是节点的IPtables。有经验的用户可以安装其他供应商的kube-proxy。
* **Sidecar容器**：Sidecar容器是应与Pod中的主要容器一起运行的容器。这种Sidecar模式扩展和增强了当前容器的功能，而不改变它们。现在，我们知道我们使用容器技术来封装应用程序在任何地方运行的所有依赖项。容器只做一件事，并且做得非常好。
* **主进程**：
* **API服务器**：是用户和Pod与主进程通信的方式。只允许经过身份验证的请求。
* **调度器**：调度是指确保Pod与节点匹配，以便Kubelet可以运行它们。它具有足够的智能来决定哪个节点具有更多可用资源，并将新的Pod分配给该节点。请注意，调度器不会启动新的Pod，它只与节点内运行的Kubelet进程通信，后者将启动新的Pod。
* **Kube控制器管理器**：它检查资源（如副本集或部署）以检查是否运行了正确数量的Pod或节点。如果缺少一个Pod，它将与调度器通信以启动一个新的Pod。它控制复制、令牌和向API提供服务的帐户。
* **etcd**：数据存储，持久、一致和分布式。是Kubernetes的数据库和键值存储，它保持集群的完整状态（每个更改都在此处记录）。调度器或控制器管理器等组件依赖于此数据来了解发生了哪些更改（节点的可用资源、运行的Pod数量等）。
* **云控制器管理器**：是用于流量控制和应用程序的特定控制器，例如：如果您在AWS或OpenStack中有集群。

请注意，由于可能有多个节点（运行多个Pod），因此可能还有多个主进程，它们对Api服务器的访问是负载平衡的，并且它们的etcd是同步的。

**卷：**

当Pod创建的数据在Pod消失时不应丢失时，应将其存储在物理卷中。**Kubernetes允许将卷附加到Pod以持久化数据**。卷可以位于本地机器上或远程存储中。如果在不同的物理节点上运行Pod，应使用远程存储，以便所有Pod都可以访问它。

**其他配置：**

* **ConfigMap**：您可以配置**URL**以访问服务。Pod将从这里获取数据，以了解如何与其他服务（Pod）通信。请注意，这不是保存凭据的推荐位置！
* **Secret**：这是存储秘密数据（如密码、API密钥等）的位置，以B64编码。Pod将能够访问此数据以使用所需的凭据。
* **部署**：这是指示由Kubernetes运行的组件的位置。用户通常不会直接使用Pod，Pod被抽象为**ReplicaSets**（复制的相同Pod数量），通过部署运行。请注意，部署是用于**无状态**应用程序的。部署的最小配置是名称和要运行的镜像。
* **StatefulSet**：此组件专门用于像**数据库**这样需要**访问相同存储**的应用程序。
* **Ingress**：这是用于使用URL**公开应用程序**的配置。请注意，也可以使用外部服务来完成此操作，但这是公开应用程序的正确方式。
* 如果您实现了Ingress，则需要创建**Ingress Controllers**。Ingress Controller是一个将接收请求并检查并将其负载均衡到服务的**Pod**的终结点。Ingress Controller将根据配置的Ingress规则**发送请求**。请注意，Ingress规则可以指向不同的路径，甚至是不同的内部Kubernetes服务的子域。
* 更好的安全实践是使用云负载均衡器或代理服务器作为入口点，以避免将Kubernetes集群的任何部分暴露出去。
* 当接收到不匹配任何Ingress规则的请求时，Ingress Controller将将其定向到“**默认后端**”。您可以使用`describe`命令获取Ingress Controller的地址参数。

`minikube addons enable ingress`
### PKI基础设施 - 证书颁发机构CA：

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA是集群内所有证书的可信根。
* 允许组件相互验证。
* 所有集群证书都由CA签名。
* ETCd有自己的证书。
* 类型：
* apiserver证书。
* kubelet证书。
* scheduler证书。

## 基本操作

### Minikube

**Minikube**可用于在不需要部署整个Kubernetes环境的情况下对Kubernetes进行一些**快速测试**。它将在一台机器上运行**主节点和工作节点进程**。Minikube将使用virtualbox来运行节点。请参阅[**此处的安装方法**](https://minikube.sigs.k8s.io/docs/start/)。
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Kubectl 基础

**`Kubectl`** 是用于 Kubernetes 集群的命令行工具。它与主进程的 API 服务器通信，以执行 Kubernetes 中的操作或请求数据。
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube 仪表板

仪表板允许您更轻松地查看 minikube 正在运行的内容，您可以在以下位置找到访问它的 URL：
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML配置文件示例

每个配置文件包含3个部分：**元数据**，**规范**（需要启动的内容），**状态**（期望的状态）。\
在部署配置文件的规范中，您可以找到使用新的配置结构定义要运行的镜像的模板：

**在同一配置文件中声明部署和服务的示例（来自** [**这里**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**）**

由于服务通常与一个部署相关联，因此可以在同一配置文件中声明两者（此配置中声明的服务仅在内部可访问）：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**外部服务配置示例**

此服务将可以从外部访问（请检查`nodePort`和`type: LoadBalancer`属性）：
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
这对于测试很有用，但对于生产环境，您应该只有内部服务和一个Ingress来暴露应用程序。
{% endhint %}

**Ingress配置文件示例**

这将在`http://dashboard.com`中暴露应用程序。
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**秘密配置文件示例**

请注意密码是以B64编码的（这并不安全！）
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**ConfigMap示例**

一个**ConfigMap**是提供给Pod的配置，以便它们知道如何定位和访问其他服务。在这种情况下，每个Pod将知道`mongodb-service`是一个可以与之通信的Pod的地址（该Pod将执行一个mongodb）：
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
然后，在**部署配置**中，可以通过以下方式指定该地址，以便在Pod的环境中加载：
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**卷配置示例**

您可以在[https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes)中找到不同的存储配置yaml文件的示例。\
**请注意，卷不在命名空间内**

### 命名空间

Kubernetes支持由同一物理集群支持的**多个虚拟集群**。这些虚拟集群称为**命名空间**。这些命名空间适用于在多个团队或项目中分散的许多用户的环境中使用。对于具有几个到几十个用户的集群，您不需要创建或考虑命名空间。您只需要开始使用命名空间来更好地控制和组织在Kubernetes中部署的应用程序的每个部分。

命名空间为名称提供了范围。资源的名称在命名空间内需要是唯一的，但在命名空间之间不需要唯一。命名空间不能嵌套在彼此内部，**每个**Kubernetes**资源**只能**在一个**命名空间中。

如果您使用minikube，默认情况下有4个命名空间：
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: 这个命名空间不是为用户使用的，你不应该触碰它。它是用于主节点和kubectl进程的。
* **kube-public**: 公开可访问的数据。包含一个配置映射，其中包含集群信息。
* **kube-node-lease**: 确定节点的可用性。
* **default**: 用户将用来创建资源的命名空间。
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
请注意，大多数Kubernetes资源（例如pod、service、replication controller等）都属于某个命名空间。但是，其他资源，如命名空间资源和低级资源（例如节点和持久卷）不属于任何命名空间。要查看哪些Kubernetes资源属于命名空间，哪些不属于命名空间：
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

您可以在该上下文中为所有后续的kubectl命令保存命名空间。
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm是Kubernetes的**包管理器**。它允许将YAML文件打包并分发到公共和私有仓库中。这些包被称为**Helm Charts**。
```
helm search <keyword>
```
Helm也是一个模板引擎，允许使用变量生成配置文件：

## Kubernetes secrets

**Secret**是一个包含敏感数据（如密码、令牌或密钥）的对象。这些信息可能会放在Pod规范或镜像中。用户可以创建Secrets，系统也会创建Secrets。Secret对象的名称必须是一个有效的DNS子域名。在这里阅读[官方文档](https://kubernetes.io/docs/concepts/configuration/secret/)。

Secrets可以是以下内容：

* API、SSH密钥。
* OAuth令牌。
* 凭据、密码（明文或b64 +加密）。
* 信息或注释。
* 数据库连接代码、字符串...。

Kubernetes中有不同类型的secrets

| 内置类型                            | 用途                                       |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **任意用户定义的数据（默认）**             |
| kubernetes.io/service-account-token | 服务帐户令牌                               |
| kubernetes.io/dockercfg             | 序列化的\~/.dockercfg文件                  |
| kubernetes.io/dockerconfigjson      | 序列化的\~/.docker/config.json文件         |
| kubernetes.io/basic-auth            | 基本身份验证凭据                           |
| kubernetes.io/ssh-auth              | SSH身份验证凭据                            |
| kubernetes.io/tls                   | 用于TLS客户端或服务器的数据                |
| bootstrap.kubernetes.io/token       | 引导令牌数据                               |

{% hint style="info" %}
**Opaque类型是默认类型，由用户定义的典型键值对。**
{% endhint %}

**Secrets的工作原理：**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

以下配置文件定义了一个名为`mysecret`的**secret**，其中包含2个键值对`username: YWRtaW4=`和`password: MWYyZDFlMmU2N2Rm`。它还定义了一个名为`secretpod`的**pod**，该pod将在**环境变量**`SECRET_USERNAME`和`SECRET_PASSWORD`中公开`mysecret`中定义的`username`和`password`。它还将以`0640`权限将`username` secret挂载到路径`/etc/foo/my-group/my-username`中。

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### 在 etcd 中发现秘密 <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** 是一个一致且高可用的**键值存储**，用作 Kubernetes 的后备存储，用于存储集群数据。让我们访问存储在 etcd 中的秘密：
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
你会看到证书、密钥和URL的位置在文件系统中。一旦获取到它们，你就能够连接到etcd。
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
一旦建立通信，您将能够获取秘密：
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**为ETCD添加加密**

默认情况下，除非应用加密层，否则所有的密钥都以明文形式存储在etcd中。以下示例基于[https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

之后，您需要在 `kube-apiserver` 上设置 `--encryption-provider-config` 标志，指向创建的配置文件的位置。您可以修改 `/etc/kubernetes/manifest/kube-apiserver.yaml` 文件，并添加以下行：
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
向下滚动到volumeMounts部分：
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
在volumeMounts中向下滚动到hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**验证数据是否加密**

数据在写入etcd时会被加密。在重新启动`kube-apiserver`之后，任何新创建或更新的密钥都应该在存储时被加密。为了检查，您可以使用`etcdctl`命令行程序来检索密钥的内容。

1. 在`default`命名空间中创建一个名为`secret1`的新密钥：

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. 使用etcdctl命令行从etcd中读取该密钥：

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

其中`[...]`必须是连接到etcd服务器的附加参数。
3. 验证存储的密钥是否以`k8s:enc:aescbc:v1:`为前缀，这表示`aescbc`提供程序已加密生成的数据。
4. 通过API检索密钥时，验证密钥是否被正确解密：

```
kubectl describe secret secret1 -n default
```

应该与`mykey: bXlkYXRh`匹配，其中mydata是编码的，请参阅[解码密钥](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret)以完全解码密钥。

**由于密钥在写入时被加密，对密钥进行更新将加密该内容：**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**最后的提示：**

* 尽量不要将秘密保存在文件系统中，从其他地方获取它们。
* 查看 [https://www.vaultproject.io/](https://www.vaultproject.io) 以增加对您的秘密的保护。
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## 参考资料

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 HackTricks 的 PDF，请查看 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库提交 PR 来分享您的黑客技巧。**

</details>
