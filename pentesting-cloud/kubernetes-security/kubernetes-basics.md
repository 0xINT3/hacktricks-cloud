# Βασικά του Kubernetes

## Βασικά του Kubernetes

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

**Ο αρχικός συγγραφέας αυτής της σελίδας είναι** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(διαβάστε την αρχική του ανάρτηση** [**εδώ**](https://sickrov.github.io)**)**

## Αρχιτεκτονική & Βασικά

### Τι κάνει το Kubernetes;

* Επιτρέπει την εκτέλεση ενός ή περισσότερων containers σε έναν κινητήρα container.
* Ο προγραμματισμός επιτρέπει την αποστολή των containers με αποδοτικό τρόπο.
* Διατηρεί τα containers ενεργά.
* Επιτρέπει την επικοινωνία μεταξύ των containers.
* Επιτρέπει τεχνικές αναπτύξεων.
* Διαχειρίζεται όγκους πληροφοριών.

### Αρχιτεκτονική

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Κόμβος (Node)**: λειτουργικό σύστημα με pod ή pods.
* **Pod**: Περιτύλιγμα γύρω από ένα container ή πολλαπλά containers. Ένα pod θα πρέπει να περιέχει μόνο μία εφαρμογή (συνήθως, ένα pod εκτελεί μόνο 1 container). Το pod είναι ο τρόπος με τον οποίο το Kubernetes αφαιρεί την τεχνολογία container που εκτελείται.
* **Υπηρεσία (Service)**: Κάθε pod έχει 1 εσωτερική **διεύθυνση IP** από την εσωτερική περιοχή του κόμβου. Ωστόσο, μπορεί επίσης να εκτίθεται μέσω μιας υπηρεσίας. Η **υπηρεσία έχει επίσης μια διεύθυνση IP** και ο στόχος της είναι να διατηρεί την επικοινωνία μεταξύ των pods, έτσι ώστε εάν ένα πεθαίνει, το **νέο αντικατασταθέν** (με διαφορετική εσωτερική IP) **θα είναι προσβάσιμο** και θα εκτίθεται στην **ίδια IP της υπηρεσίας**. Μπορεί να ρυθμιστεί ως εσωτερική ή εξωτερική. Η υπηρεσία επίσης λειτουργεί ως **εξισορροπητής φορτίου όταν 2 pods είναι συνδεδεμένα** στην ίδια υπηρεσία.\
Όταν δημιουργείται μια **υπηρεσία** μπορείτε να βρείτε τα σημεία πρόσβασης κάθε υπηρεσίας εκτελώντας `kubectl get endpoints`
* **Kubelet**: Κύριος πράκτορας κόμβου. Ο συστατικός που επιτρέπει την επικοινωνία μεταξύ του κόμβου και του kubectl, και μπορεί να εκτελέσει μόνο pods (μέσω του API server). Το kubelet δεν διαχειρίζεται containers που δεν δημιουργήθηκαν από το Kubernetes.
* **Kube-proxy**: Είναι η υπηρεσία που αναλαμβάνει τις επικοινωνίες (υπηρεσίες) μεταξύ του apiserver και του κόμβου. Βασίζεται στο IPtables για τους κόμβους. Οι πιο έμπειροι χρήστες μπορούν να εγκαταστήσουν άλλους kube-proxy από άλλους προμηθευτές.
* **Sidecar container**: Τα sidecar containers είναι τα containers που πρέπει να εκτελούνται μαζί με το κύριο container στο pod. Αυτό το πρότυπο sidecar επεκτείνε
### Υποδομή PKI - Αρχή Πιστοποίησης Πιστοποιητικών CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* Η CA είναι η αξιόπιστη ρίζα για όλα τα πιστοποιητικά μέσα στο cluster.
* Επιτρέπει στα στοιχεία να επικυρώνονται μεταξύ τους.
* Όλα τα πιστοποιητικά του cluster υπογράφονται από την CA.
* Το ETCd έχει το δικό του πιστοποιητικό.
* Τύποι:
* πιστοποιητικό apiserver.
* πιστοποιητικό kubelet.
* πιστοποιητικό scheduler.

## Βασικές Ενέργειες

### Minikube

Το **Minikube** μπορεί να χρησιμοποιηθεί για να πραγματοποιήσει **γρήγορες δοκιμές** στο Kubernetes χωρίς να χρειάζεται να αναπτύξετε ολόκληρο περιβάλλον Kubernetes. Θα εκτελέσει τις διεργασίες master και node σε ένα μηχάνημα. Το Minikube θα χρησιμοποιήσει το virtualbox για να εκτελέσει τον κόμβο. Δείτε [**εδώ πώς να το εγκαταστήσετε**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Βασικά του Kubectl

Το **`Kubectl`** είναι το εργαλείο γραμμής εντολών για τα κατανεμημένα συστήματα Kubernetes. Επικοινωνεί με τον διακομιστή Api της κύριας διεργασίας για να εκτελέσει ενέργειες στο Kubernetes ή να ζητήσει δεδομένα.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Πίνακας ελέγχου Minikube

Ο πίνακας ελέγχου σας επιτρέπει να βλέπετε ευκολότερα τι εκτελείται στο Minikube, μπορείτε να βρείτε το URL για πρόσβαση σε αυτό στο:
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Παραδείγματα αρχείων ρυθμίσεων YAML

Κάθε αρχείο ρυθμίσεων έχει 3 μέρη: **metadata**, **specification** (τι πρέπει να εκκινηθεί), **status** (επιθυμητή κατάσταση).\
Μέσα στην προδιαγραφή του αρχείου ρυθμίσεων της αναπτυξιακής διαμόρφωσης μπορείτε να βρείτε το πρότυπο που έχει καθοριστεί με μια νέα δομή ρυθμίσεων που καθορίζει την εικόνα που θα εκτελεστεί:

**Παράδειγμα αναπτυξιακής διαμόρφωσης + Υπηρεσίας που δηλώνονται στο ίδιο αρχείο ρυθμίσεων (από** [**εδώ**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Καθώς μια υπηρεσία συνήθως σχετίζεται με μια ανάπτυξη, είναι δυνατόν να δηλωθούν και οι δύο στο ίδιο αρχείο ρυθμίσεων (η υπηρεσία που δηλώνεται σε αυτήν την ρύθμιση είναι προσβάσιμη μόνο εσωτερικά):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Παράδειγμα εξωτερικής διαμόρφωσης υπηρεσίας**

Αυτή η υπηρεσία θα είναι προσβάσιμη εξωτερικά (ελέγξτε τα χαρακτηριστικά `nodePort` και `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Αυτό είναι χρήσιμο για δοκιμές, αλλά για παραγωγή θα πρέπει να έχετε μόνο εσωτερικές υπηρεσίες και ένα Ingress για να εκθέσετε την εφαρμογή.
{% endhint %}

**Παράδειγμα αρχείου ρύθμισης Ingress**

Αυτό θα εκθέσει την εφαρμογή στο `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Παράδειγμα αρχείου ρύθμισης μυστικών**

Παρατηρήστε πώς οι κωδικοί πρόσβασης κωδικοποιούνται σε B64 (το οποίο δεν είναι ασφαλές!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Παράδειγμα του ConfigMap**

Ένα **ConfigMap** είναι η διαμόρφωση που δίνεται στα pods ώστε να γνωρίζουν πώς να εντοπίσουν και να έχουν πρόσβαση σε άλλες υπηρεσίες. Σε αυτήν την περίπτωση, κάθε pod θα γνωρίζει ότι το όνομα `mongodb-service` είναι η διεύθυνση ενός pod με το οποίο μπορεί να επικοινωνήσει (αυτό το pod θα εκτελεί ένα mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Στη συνέχεια, μέσα σε ένα **deployment config**, αυτή η διεύθυνση μπορεί να καθοριστεί με τον εξής τρόπο, ώστε να φορτώνεται μέσα στο περιβάλλον του pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Παράδειγμα ρύθμισης όγκου**

Μπορείτε να βρείτε διάφορα παραδείγματα αρχείων ρύθμισης αποθήκευσης σε μορφή yaml στο [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Σημειώστε ότι οι όγκοι δεν βρίσκονται μέσα στα namespaces**

### Namespaces

Το Kubernetes υποστηρίζει **πολλαπλά εικονικά clusters** που υποστηρίζονται από το ίδιο φυσικό cluster. Αυτά τα εικονικά clusters ονομάζονται **namespaces**. Αυτά προορίζονται για χρήση σε περιβάλλοντα με πολλούς χρήστες που είναι διασκορπισμένοι σε πολλές ομάδες ή έργα. Για clusters με λίγους έως δεκάδες χρήστες, δεν θα χρειαστεί να δημιουργήσετε ή να σκεφτείτε για τα namespaces καθόλου. Θα πρέπει μόνο να αρχίσετε να χρησιμοποιείτε τα namespaces για να έχετε καλύτερο έλεγχο και οργάνωση κάθε μέρους της εφαρμογής που έχει αναπτυχθεί στο Kubernetes.

Τα namespaces παρέχουν ένα πεδίο ορατότητας για τα ονόματα. Τα ονόματα των πόρων πρέπει να είναι μοναδικά εντός ενός namespace, αλλά όχι ανάμεσα σε διάφορα namespaces. Τα namespaces δεν μπορούν να είναι εμφωλευμένα μέσα σε άλλα και **κάθε** πόρος του Kubernetes μπορεί να βρίσκεται μόνο **σε ένα** **namespace**.

Υπάρχουν 4 namespaces από προεπιλογή αν χρησιμοποιείτε το minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Δεν προορίζεται για χρήση από τους χρήστες και δεν πρέπει να το αγγίξετε. Χρησιμοποιείται για τις διεργασίες του master και του kubectl.
* **kube-public**: Δημόσια προσβάσιμα δεδομένα. Περιέχει ένα configmap που περιέχει πληροφορίες για το cluster.
* **kube-node-lease**: Καθορίζει τη διαθεσιμότητα ενός κόμβου.
* **default**: Το namespace που ο χρήστης θα χρησιμοποιήσει για τη δημιουργία πόρων.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Σημειώστε ότι οι περισσότεροι πόροι του Kubernetes (π.χ. pods, services, replication controllers και άλλοι) βρίσκονται σε ορισμένα namespaces. Ωστόσο, άλλοι πόροι όπως οι πόροι των namespaces και οι χαμηλού επιπέδου πόροι, όπως οι κόμβοι και οι persistenVolumes, δεν βρίσκονται σε ένα namespace. Για να δείτε ποιοι πόροι του Kubernetes είναι και ποιοι δεν είναι σε ένα namespace:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Μπορείτε να αποθηκεύσετε το namespace για όλες τις επόμενες εντολές kubectl σε αυτό το πλαίσιο.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Το Helm είναι ο **διαχειριστής πακέτων** για το Kubernetes. Επιτρέπει την συσκευασία των αρχείων YAML και τη διανομή τους σε δημόσιους και ιδιωτικούς αποθετήριους. Αυτά τα πακέτα ονομάζονται **Helm Charts**.
```
helm search <keyword>
```
Το Helm είναι επίσης ένα εργαλείο προτύπων που επιτρέπει τη δημιουργία αρχείων ρυθμίσεων με μεταβλητές:

## Μυστικά του Kubernetes

Ένα **Μυστικό** είναι ένα αντικείμενο που **περιέχει ευαίσθητα δεδομένα** όπως ένας κωδικός πρόσβασης, ένα τοκέν ή ένα κλειδί. Τέτοιες πληροφορίες θα μπορούσαν αλλιώς να τοποθετηθούν σε μια προδιαγραφή Pod ή σε μια εικόνα. Οι χρήστες μπορούν να δημιουργήσουν Μυστικά και το σύστημα δημιουργεί επίσης Μυστικά. Το όνομα ενός αντικειμένου Μυστικού πρέπει να είναι ένα έγκυρο **DNS υποτομέας**. Διαβάστε εδώ [την επίσημη τεκμηρίωση](https://kubernetes.io/docs/concepts/configuration/secret/).

Τα Μυστικά μπορεί να είναι πράγματα όπως:

* Κλειδιά API, SSH.
* Τοκέν OAuth.
* Διαπιστευτήρια, Κωδικοί πρόσβασης (κανονικό κείμενο ή b64 + κρυπτογράφηση).
* Πληροφορίες ή σχόλια.
* Κώδικας σύνδεσης βάσης δεδομένων, συμβολοσειρές... .

Υπάρχουν διάφοροι τύποι μυστικών στο Kubernetes

| Ενσωματωμένος Τύπος                    | Χρήση                                      |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **αυθαίρετα ορισμένα δεδομένα από τον χρήστη (Προεπιλογή)** |
| kubernetes.io/service-account-token | διαπιστευτήριο λογαριασμού υπηρεσίας                     |
| kubernetes.io/dockercfg             | σειριοποιημένο αρχείο \~/.dockercfg             |
| kubernetes.io/dockerconfigjson      | σειριοποιημένο αρχείο \~/.docker/config.json    |
| kubernetes.io/basic-auth            | διαπιστευτήρια για βασική πιστοποίηση      |
| kubernetes.io/ssh-auth              | διαπιστευτήρια για πιστοποίηση SSH        |
| kubernetes.io/tls                   | δεδομένα για έναν πελάτη ή διακομιστή TLS           |
| bootstrap.kubernetes.io/token       | δεδομένα εκκίνησης του token                      |

{% hint style="info" %}
**Ο τύπος Opaque είναι ο προεπιλεγμένος, το κλασικό ζευγάρι κλειδιού-τιμής που καθορίζεται από τους χρήστες.**
{% endhint %}

**Πώς λειτουργούν τα μυστικά:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Το παρακάτω αρχείο ρυθμίσεων καθορίζει ένα **μυστικό** με το όνομα `mysecret` που περιέχει 2 ζευγάρια κλειδιού-τιμής `username: YWRtaW4=` και `password: MWYyZDFlMmU2N2Rm`. Ορίζει επίσης ένα **pod** με το όνομα `secretpod` που θα έχει το `username` και το `password` που καθορίζονται στο `mysecret` προσβάσιμα στις **μεταβλητές περιβάλλοντος** `SECRET_USERNAME` και `SECRET_PASSWOR`. Επίσης, θα **προσαρτήσει** το μυστικό `username` μέσα στο `mysecret` στη διαδρομή `/etc/foo/my-group/my-username` με δικαιώματα `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Μυστικά στο etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** είναι ένα συνεπές και υψηλής διαθεσιμότητας **key-value store** που χρησιμοποιείται ως αποθήκη υποστήριξης του Kubernetes για όλα τα δεδομένα του cluster. Ας αποκτήσουμε πρόσβαση στα μυστικά που αποθηκεύονται στο etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Θα δείτε ότι τα πιστοποιητικά, τα κλειδιά και οι διευθύνσεις URL βρίσκονται στο σύστημα αρχείων. Μόλις τα αποκτήσετε, θα μπορείτε να συνδεθείτε στο etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Μόλις επιτύχετε να εγκαθιδρύσετε επικοινωνία, θα μπορείτε να αποκτήσετε τα μυστικά:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Προσθήκη κρυπτογράφησης στο ETCD**

Από προεπιλογή, όλα τα μυστικά αποθηκεύονται σε απλό κείμενο μέσα στο etcd εκτός αν εφαρμόσετε ένα επίπεδο κρυπτογράφησης. Το παρακάτω παράδειγμα βασίζεται στο [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Μετά από αυτό, πρέπει να ορίσετε τη σημαία `--encryption-provider-config` στον `kube-apiserver` για να δείχνει στην τοποθεσία του δημιουργημένου αρχείου ρυθμίσεων. Μπορείτε να τροποποιήσετε το `/etc/kubernetes/manifest/kube-apiserver.yaml` και να προσθέσετε τις παρακάτω γραμμές:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Κατέβασε προς τα κάτω στο volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Κατέβετε στον κατάλογο volumeMounts και βρείτε το hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Επαλήθευση της κρυπτογράφησης των δεδομένων**

Τα δεδομένα κρυπτογραφούνται κατά την εγγραφή τους στο etcd. Μετά την επανεκκίνηση του `kube-apiserver`, οποιοδήποτε νέο ή ενημερωμένο μυστικό θα πρέπει να κρυπτογραφείται κατά την αποθήκευσή του. Για να ελέγξετε αυτό, μπορείτε να χρησιμοποιήσετε το πρόγραμμα γραμμής εντολών `etcdctl` για να ανακτήσετε το περιεχόμενο του μυστικού σας.

1. Δημιουργήστε ένα νέο μυστικό με το όνομα `secret1` στο namespace `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Χρησιμοποιώντας το etcdctl στη γραμμή εντολών, διαβάστε αυτό το μυστικό από το etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

όπου `[...]` πρέπει να είναι οι επιπλέον παράμετροι για τη σύνδεση με τον εξυπηρετητή etcd.
3. Επαληθεύστε ότι το αποθηκευμένο μυστικό έχει πρόθεμα `k8s:enc:aescbc:v1:`, το οποίο υποδηλώνει ότι ο πάροχος `aescbc` έχει κρυπτογραφήσει τα δεδομένα.
4. Επαληθεύστε ότι το μυστικό αποκρυπτογραφείται σωστά όταν ανακτάται μέσω του API:

```
kubectl describe secret secret1 -n default
```

πρέπει να ταιριάζει με `mykey: bXlkYXRh`, το mydata είναι κωδικοποιημένο, ελέγξτε το [αποκωδικοποίηση ενός μυστικού](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) για να αποκωδικοποιήσετε πλήρως το μυστικό.

**Καθώς τα μυστικά κρυπτογραφούνται κατά την εγγραφή, η ενημέρωση ενός μυστικού θα κρυπτογραφήσει το περιεχόμενο αυτό:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Τελικές συμβουλές:**

* Προσπαθήστε να μην κρατάτε μυστικά στο FS, αλλά να τα αντλείτε από άλλα μέρη.
* Ελέγξτε το [https://www.vaultproject.io/](https://www.vaultproject.io) για να προσθέσετε περισσότερη προστασία στα μυστικά σας.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Αναφορές

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
