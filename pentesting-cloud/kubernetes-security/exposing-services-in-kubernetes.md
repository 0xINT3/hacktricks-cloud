# Expondo Servi√ßos no Kubernetes

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no Github.

</details>

Existem **diferentes maneiras de expor servi√ßos** no Kubernetes para que tanto os endpoints **internos** quanto os endpoints **externos** possam acess√°-los. Essa configura√ß√£o do Kubernetes √© bastante cr√≠tica, pois o administrador pode dar acesso a **atacantes a servi√ßos aos quais eles n√£o deveriam ter acesso**.

### Enumera√ß√£o Autom√°tica

Antes de come√ßar a enumerar as maneiras que o K8s oferece para expor servi√ßos ao p√∫blico, saiba que se voc√™ puder listar namespaces, servi√ßos e ingressos, poder√° encontrar tudo exposto ao p√∫blico com:

```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
    echo "Namespace: $ns"
    kubectl get service -n "$ns"
    kubectl get ingress -n "$ns"
    echo "=============================================="
    echo ""
    echo ""
done | grep -v "ClusterIP"
# Remova o √∫ltimo '| grep -v "ClusterIP"' para ver tamb√©m o tipo ClusterIP
```

### ClusterIP

Um servi√ßo **ClusterIP** √© o **servi√ßo padr√£o** do Kubernetes. Ele fornece um **servi√ßo interno** em seu cluster que outros aplicativos dentro do seu cluster podem acessar. N√£o h√° **acesso externo**.

No entanto, isso pode ser acessado usando o Proxy do Kubernetes:

```
kubectl proxy --port=8080
```

Agora, voc√™ pode navegar pela API do Kubernetes para acessar servi√ßos usando este esquema:

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

Por exemplo, voc√™ pode usar a seguinte URL:

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

para acessar este servi√ßo:

```yaml
apiVersion: v1
kind: Service
metadata:  
  name: my-internal-service
spec:
  selector:    
    app: my-app
  type: ClusterIP
  ports:  
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
```

_Este m√©todo requer que voc√™ execute o `kubectl` como um usu√°rio **autenticado**._

### NodePort

**NodePort abre uma porta espec√≠fica em todos os Nodes** (as VMs), e qualquer **tr√°fego** que √© enviado para esta porta √© **encaminhado para o servi√ßo**. Esta √© uma op√ß√£o realmente ruim geralmente.

Um exemplo de especifica√ß√£o NodePort:

```yaml
apiVersion: v1
kind: Service
metadata:  
  name: my-nodeport-service
spec:
  selector:    
    app: my-app
  type: NodePort
  ports:  
  - name: http
    port: 80
    targetPort: 80
    nodePort: 30036
    protocol: TCP
```

Se voc√™ **n√£o especificar** o **nodePort** no yaml (√© a porta que ser√° aberta), uma porta na **faixa de 30000-32767 ser√° usada**.

### LoadBalancer <a href="#0d96" id="0d96"></a>

Exp√µe o servi√ßo externamente **usando o balanceador de carga do provedor de nuvem**. No GKE, isso iniciar√° um [Balanceador de Carga de Rede](https://cloud.google.com/compute/docs/load-balancing/network/) que lhe dar√° um √∫nico endere√ßo IP que encaminhar√° todo o tr√°fego para o seu servi√ßo.

Voc√™ tem que pagar por um LoadBalancer por servi√ßo exposto, o que pode ficar caro.

### ExternalName

Servi√ßos do tipo ExternalName **mapeiam um servi√ßo para um nome DNS**, n√£o para um seletor t√≠pico como `my-service` ou `cassandra`. Voc√™ especifica esses servi√ßos com o par√¢metro `spec.externalName`.

Esta defini√ß√£o de servi√ßo, por exemplo, mapeia o servi√ßo `my-service` no namespace `prod` para `my.database.example.com`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: prod
spec:
  type: ExternalName
  externalName: my.database.example.com
```

Ao procurar o host `my-service.prod.svc.cluster.local`, o servi√ßo DNS do cluster retorna um registro `CNAME` com o valor `my.database.example.com`. O acesso a `my-service` funciona da mesma forma que outros servi√ßos, mas com a diferen√ßa crucial de que o **redirecionamento acontece no n√≠vel DNS** em vez de por meio de proxy ou encaminhamento.

### IPs Externos <a href="#external-ips" id="external-ips"></a>

O tr√°fego que ingressa no cluster com o **IP externo** (como **IP de destino**), na porta do servi√ßo, ser√° **roteado para um dos endpoints do servi√ßo**. Os `externalIPs` n√£o s√£o gerenciados pelo Kubernetes e s√£o de responsabilidade do administrador do cluster.

Na especifica√ß√£o do servi√ßo, `externalIPs` podem ser especificados juntamente com qualquer um dos `ServiceTypes`. No exemplo abaixo, "`my-service`" pode ser acessado por clientes em "`80.11.12.10:80`" (`externalIP:port`)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
  externalIPs:
    - 80.11.12.10
```

### Ingress

Ao contr√°rio de todos os exemplos acima, **Ingress N√ÉO √© um tipo de servi√ßo**. Em vez disso, ele fica **na frente de v√°rios servi√ßos e atua como um "roteador inteligente"** ou ponto de entrada em seu cluster.

Voc√™ pode fazer muitas coisas diferentes com um Ingress, e existem **muitos tipos de controladores de Ingress que t√™m capacidades diferentes**.

O controlador de ingress padr√£o do GKE iniciar√° um [Balanceador de Carga HTTP(S)](https://cloud.google.com/compute/docs/load-balancing/http/) para voc√™. Isso permitir√° que voc√™ fa√ßa roteamento baseado em caminho e subdom√≠nio para servi√ßos de backend. Por exemplo, voc√™ pode enviar tudo em foo.yourdomain.com para o servi√ßo foo e tudo sob o caminho yourdomain.com/bar/ para o servi√ßo bar.

O YAML para um objeto Ingress no GKE com um [Balanceador de C