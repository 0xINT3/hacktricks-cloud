# Az - Roadtx - Authentication

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Post copied from** [**https://dirkjanm.io/introducing-roadtools-token-exchange-roadtx/**](https://dirkjanm.io/introducing-roadtools-token-exchange-roadtx/)

## Basic Information

ROADtools Token eXchange (roadtx) is a tool for **exchanging and using different types of Azure AD issued tokens**. It supports many different authentication flows, device registration and PRT related operations.

It can do the following:

* Register and join devices to Azure AD.
* Request Primary Refresh Tokens from user credentials or other valid tokens.
* Use Primary Refresh Tokens in a similar way as the Web Account Manager (WAM) in Windows does.
* Perform all kind of Oauth2 token redemption flows.
* Perform interactive logins based on Browser SSO by injecting the Primary Refresh Token into the authentication flow.
* Add SSO capabilities to Chrome via the Windows 10 accounts plugin and a custom browsercore implementation.
* Automate sign-ins, MFA and token requesting to various resources in Azure AD by using Selenium.
* Possibility to load credentials and MFA TOTP seeds from a KeePass database to use in automated flows.

## Registering a device

Most of the modules of roadtx are designed around Primary Refresh Tokens and device identities. **To obtain a PRT, we must first register a device in Azure AD**.\
Registering a device **requires** an **access token** to the device registration service resource. The access token must be a **token without a device claim**, so you cannot use single sign-on or an existing PRT to request one. There are a **few ways to obtain such a token with roadtx**, where some methods support MFA and others do not.\
**MFA could be required to register a device, depending on tenant settings**. If it is not, you can request a token for the device registration service (specified here through the _devicereg_ alias) with only a username and password:

```bash
roadtx gettokens -u myuser@mytenant.com -p password -r devicereg
```

If MFA is required, you can use the device authentication flow to request the tokens from a **browser window somewhere**:

```bash
roadtx gettokens --device-auth -r devicereg
```

Alternatively, we use a **Selenium based window for MFA**, while autofilling the username + password:

```bash
roadtx interactiveauth -u myuser@mytenant.com -p password -r devicereg
```

Any of the commands above with **save an access token to the `.roadtools_auth` file**. The device registration command will automatically load it from this file. You can customize what you want for device properties with various commandline parameters to the `roadtx device` module:

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We register an Azure AD joined device with the name ‚Äúblogdevice‚Äù:

```bash
roadtx device -n blogdevice
Saving private key to blogdevice.key
Registering device
Device ID: 5f138d8b-6416-448d-89ef-9b279c419943
Saved device certificate to blogdevice.pem
```

We get two pieces of data that identify our device: The first is the **device certificate** saved in `blogdevice.pem`, which is issued by Azure AD and **identifies our device**. The second part is the `blogdevice.key` file, which contains the **private key of the certificate** and is also used as transport key. Now that we have the device certificate, we can do **operations that require a device identity**. The most useful one is **requesting a Primary Refresh Token**, since that will enable us to add Single Sign On capabilities to our (interactive or automated) token requests.

## Requesting a Primary Refresh Token <a href="#requesting-a-primary-refresh-token" id="requesting-a-primary-refresh-token"></a>

A primary refresh token is most often requested with a username and password. When you log in to an Azure AD joined or hybrid joined workstation with your **username and password**, Windows immediately **requests a PRT** from Azure AD. I‚Äôve talked about the technicalities behind this flow at my Troopers and Romhack [talks](https://dirkjanm.io/talks/) in the past, so if you‚Äôre interested in the technicalities have a read through those slides. **To request a PRT with roadtx, run the `roadtx prt` command**, specify the device cert/key and the username + password to use, and you get a PRT:

{% code overflow="wrap" %}
```bash
roadtx prt -u myuser@mytenant.com -p password --key-pem blogdevice.key --cert-pem blogdevice.pem
```
{% endcode %}

The command will give us a **PRT** (in the form of an encrypted token), and a **session key** that we need to use the PRT. The PRT is by default saved to `roadtx.prt`, where it can be picked up by other roadtx modules.

A PRT is by default valid for 90 days, but we can **renew it at any time** to extend the validity for another 90 days with the `renew` action:

```bash
roadtx prt -a renew
Renewing PRT
Saved PRT to roadtx.prt
```

Note that the PRT we requested here is only based on a password, so **any authentication that requires MFA will fail even if we use the PRT**. We can also upgrade or ‚Äúenrich‚Äù the PRT with an MFA claim, this is shown in the next section on Selenium based authentication.

## Using Primary Refresh Tokens on the command line <a href="#using-primary-refresh-tokens-on-the-command-line" id="using-primary-refresh-tokens-on-the-command-line"></a>

Once we have a PRT, we can use it to **sign in to resources that accept Azure AD authentication**. You can do this either with the **`roadtx gettokens`** command, and **specify the PRT and session key** on the command line, or use the **`roadtx prtauth`** command. The difference between the two is that the **`gettokens`** command implements authentication that is **based on how Chrome does Single Sign On** in the browser. This method is slightly hacky and if it fails won‚Äôt give you any feedback.

The **`prtauth`** module instead emulates the **Web Account Manager (WAM) that Windows** uses if you request access tokens from an app or native process. The WAM acts like a token broker, and requests tokens on behalf of other clients. It uses a combination of signed requests and encrypted responses to prevent exposing the tokens in transit, all done using the PRT session key.

By default, the `roadtx prtauth` module with use the **Azure AD PowerShell Module client ID** and the Azure AD graph as resource, but you can specify any other client ID or resource URL either by its full part or as an alias (listable with `roadtx listaliases`):

```bash
roadtx prtauth
Tokens were written to .roadtools_auth
```

Example using the Azure CLI as client ID and requesting tokens for the Azure Resource Manager:

```bash
roadtx prtauth -c azcli -r azrm     
Tokens were written to .roadtools_auth
```

There‚Äôs also other options you can use to specify other resources or the correct redirect URL for the app you are using:

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Selenium based Azure AD authentication <a href="#selenium-based-azure-a-d-authentication" id="selenium-based-azure-a-d-authentication"></a>

Command line based token requests and usage are nice, but often you will encounter some flow that either requires a browser window to do Multi Factor Authentication, or you simply want to use your PRT in an interactive way to browse things like the Azure Portal or just read your mail using a stolen PRT.&#x20;

The principle of Selenium based operations in roadtx is simple: **it launches a browser window, tries to autofill any credentials that you supplied to the command, and let you fill in the rest by hand**. If you have your accounts set up correctly, it will do the authentication fully automatically.

### Interactive authentication <a href="#interactive-authentication" id="interactive-authentication"></a>

In the simplest form, roadtx will launch a browser for you, request a token for the indicated service, fill in any credentials you specified, and obtain tokens. Example:

```bash
roadtx interactiveauth -u myuser@mytenant.com -p password
```

If **MFA** is required, you can enter that and obtain a token with MFA claim. If not, it will capture the output and save the requested tokens. You can specify the **client ID** you want to use with `-c` and the resource to authenticate to with `-r`. Here‚Äôs a [**short video demo**](https://dirkjanm.io/assets/video/selenium\_autofill.mp4).

### Using KeePass to auth in different accounts <a href="#keepass-credentials-based-authentication" id="keepass-credentials-based-authentication"></a>

**`roadtx`** supports **sourcing credentials and TOTP based MFA information from a kdbx file** (KeePass file) or KeePass XML export. To use this, use the **`roadtx keepassauth`** command. It accepts a **KeePass** file with the **`-kp`** parameter or if you leave this parameter out it tries to load `roadtx.kdbx` from the current directory. The **password** of the KeePass file can be specified with **`-kpp`** or via the `KPPASS` environment variable. The only **required** parameter is the **username**, which it will look up in the KeePass file. It will autofill the password and also the OTP code if ‚ÄúMobile app OTP‚Äù is enabled as an MFA method on the account. This requires the TOTP seed to be stored in the `otp` additional parameter of the identity in the KeePass file. For instructions on how to set this up and some caveats of using KeePass files, see the [roadtx wiki](https://github.com/dirkjanm/ROADtools/wiki/ROADtools-Token-eXchange-\(roadtx\)).

Check the [**video demo**](https://dirkjanm.io/assets/video/selenium\_kpautofill.mp4).

Aside from requesting tokens directly, you can also use this as an interactive browser window with auto authentication. To do this, specify a URL manually that will redirect you to the Microsoft sign-in page. For example, using `-url https://myaccount.microsoft.com` will open a browser, authenticate you, and go to the ‚ÄúMy account‚Äù page. You can use `--keep-open` to keep the browser window open after authentication, which makes it possible to browse to other pages from an authenticated perspective. Example:

{% code overflow="wrap" %}
```bash
roadtx keepassauth -url https://myaccount.microsoft.com --keep-open -u myuser@mytenant.com -kp accounts.kdbx -kpp keepassfilepassword
```
{% endcode %}

### PRT auth in browser <a href="#primary-refresh-token-authentication-in-browser" id="primary-refresh-token-authentication-in-browser"></a>

A more interesting scenario is using a Primary Refresh Token that you either registered yourself or that you [stole from a legitimate endpoint](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) during a red team to create an interactive browser experience. Lets assume that we **dumped a PRT and session key using Mimikatz from an endpoint** (this is only possible if it doesn‚Äôt use a Trusted Platform Module). We can use this PRT on the command line, or we can automatically inject that into our Selenium browser session. roadtx does this by proxying the browser traffic through itself and injecting a PRT cookie at various points during authentication. On the victim endpoint, we can use Mimikatz to dump the PRT and session key.

You can **check the commands** to dump the PRT and session key and then use the values with **`roadtx`** in the [**Option 2 of the mimikatz method to Pass the PRT**](pass-the-prt.md#attack-mimikatz)**.**

### PRT usage with other accounts <a href="#primary-refresh-token-usage-with-other-accounts" id="primary-refresh-token-usage-with-other-accounts"></a>

An interesting use case for stolen Primary Refresh Tokens is that you can also **use them for other accounts to add device claims** to the authentication. For example, if there is a conditional access policy that requires a compliant or hybrid joined corporate device to access specific resources, the device claim originates from the primary refresh token used during authentication. This claim can also be used for other users. So if I have a **stolen PRT from a compliant device** for user `tpmtest@iminyour.cloud`, I can use this **PRT with the credentials of `newlowpriv@iminyour.cloud`** to sign in and pass the compliancy test.

In this example we still have the stolen PRT from `tpmtest@iminyour.cloud` used in the example above saved as `roadtx.prt`. I can use this **PRT together with the credentials of `newlowpriv`** that are stored in my KeePass file to sign in to Microsoft Teams and access data there with the `roadtx browserprtinject` command.

```bash
roadtx browserprtinject -u newlowpriv@iminyour.cloud -r msgraph -c msteams
```

The issued access token will contain the `deviceid` claim, which is the device from which we stole the PRT. Since this device is Intune managed and compliant, it passes the compliancy requirement:

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Adding MFA claims to an existing PRT <a href="#adding-mfa-claims-to-an-existing-prt" id="adding-mfa-claims-to-an-existing-prt"></a>

Moving back from the PRTs that we stole and back to the PRT we registered earlier using a username + password combination. If we want to have a **PRT with MFA claim, we have to use an interactive session** that will request a special refresh token from Azure AD for ‚Äúenriching‚Äù our PRT. The command for this is **`roadtx prtenrich`**, which like the previous commands accepts an identity in a KeePass file to autofill the MFA information, or you can do this by hand.

```bash
roadtx prtenrich -u newlowpriv@iminyour.cloud
Got refresh token. Can be used to request prt with roadtx prt -r <refreshtoken>
```

The result is a special refresh token that we can use to request a new PRT. For this we go back to the `roadtx prt` module:

```bash
roadtx prt -r <refreshtoken> -c blogdevice.pem -k blogdevice.key
```

The new PRT is written to disk and when we use it to request tokens we see the MFA claim:

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We can use this PRT to obtain tokens for resources that require MFA using any of the above methods.

### SSO using Chrome and a custom browsercore <a href="#single-sign-on-in-windows-using-chrome-and-a-custom-browsercore" id="single-sign-on-in-windows-using-chrome-and-a-custom-browsercore"></a>

In the following page you have info about how Google Chrome uses **`browsercore.exe`** to authenticate via SSO:

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

**`roadtx`** has `browsercore.py`, you can use a PTR from **`roadtx`** (or one that you stole elsewhere) to automatically authenticate in your Chrome browser on your attacker controlled host. You don‚Äôt need to have a Selenium window, but can use the PRT directly just as if you were on the victims machine in a legitimate browser.

The custom SSO requires a few steps to set up:

* You should put the `browsercore.py` and `manifest.json` [files](https://github.com/dirkjanm/ROADtools/tree/master/browsercore) in some location on disk, for example in `C:\browsercore\`.
* Install roadtx and place a `roadtx.prt` file in the same directory.
* Modify `HKEY_CURRENT_USER\Software\Google\Chrome\NativeMessagingHosts\com.microsoft.browsercore` to point to `C:\browsercore\manifest.json`.
* Test whether everything works using `bctest.py`
* Clear any existing cookies in Chrome for `login.microsoftonline.com`

Full install instructions are on the [ROADtools wiki](https://github.com/dirkjanm/ROADtools/wiki/Setting-up-BrowserCore.py). After setup, Chrome should use the PRT automatically during sign in. The first time it may need a hint for the username to work properly.

With this setup you can browse any Azure AD connected resource with SSO and the claims from the PRT, including device status and cached MFA information.

## Other utilities <a href="#other-utilities" id="other-utilities"></a>

There are a few other utilities in roadtx, mostly to make my own research easier:

* `roadtx decrypt` can decrypt encrypted responses given a PRT session key or a device transport key
* `roadtx getotp` can calculate an OTP code from a seed or from the otp property stored in a KeePass file (if you need to do MFA for that user)
* `roadtx codeauth` can perform the OAuth2 code redemption flow for public and confidential clients.
* `roadtx listaliases` lists all the aliases that are supported for resources and clients. If you need any other aliases that you use frequently feel free to open an issue or send me a message.

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
