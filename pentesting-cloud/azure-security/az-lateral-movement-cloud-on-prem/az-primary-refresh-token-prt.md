# Az - プライマリリフレッシュトークン (PRT)

<details>

<summary><strong>AWSのハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>

**この投稿は** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) からコピーされましたが、同じ内容を説明している別の投稿が [**https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30**](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30) で見つけることができます。

## 基本情報

**プライマリリフレッシュトークン**は、Active Directoryの長期的な**永続的なチケット付与チケット (TGT)** に例えることができます。これは、ユーザーがAzure ADに接続されたデバイスで**一度サインインすると**、その後**自動的にAzure ADに接続されたリソースにサインインする**ことを可能にするトークンです。

プライマリリフレッシュトークンは、**任意のアプリケーションに対して認証を行うために使用**できます。これが、Microsoftがこのトークンに追加の保護を適用している理由です。最も重要な保護は、**TPM**があるデバイスでは、暗号化キーがそのTPM内に格納されており、通常の状況では**OS自体から実際のキーを回復することができない**ということです。プライマリリフレッシュトークンについては、[こちら](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)でかなり詳細なドキュメントが利用可能です。技術的な詳細が多く含まれているため、全文を読むことをお勧めしますが、この投稿の目的のために、ここに最も重要なポイントを記載します：

* TPMが存在する場合、PRTを要求または使用するために必要なキーは**TPMによって保護され**、通常の状況では抽出できません。
* **デバイスでMFAが使用されると、PRTはMFAクレームで更新され**、その後MFAを要求するリソースへのSSOを可能にします。
* **PRTにはデバイスIDが含まれており**、Azure ADのデバイスオブジェクトに**紐付けられています**。これは、準拠したデバイスを要求する条件付きアクセスポリシーにトークンをマッチさせるために使用できます。
* デバイスがAzure ADで無効にされると、**PRTは無効になり**、その時点で新しいトークンを要求するためには使用できなくなります。
* SSO中に**PRTはリフレッシュトークンとアクセストークンを要求するために使用されます**。リフレッシュトークンは**CloudAPプラグインによって保持され、DPAPIで暗号化されます**。アクセストークンは要求したアプリケーションに渡されます。

これについて注目すべき点は、これらの保護の多くが**TPM**を使用しており、これはハイブリッドジョインでは**オプション**です。TPMがない場合、**キーはソフトウェア内に保存されます**。このシナリオでは、適切な権限を持つ場合、OSから**それらを回復することが可能です**。さらに研究が必要な注目すべきもう一つの点は、[PRTドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)全体で何度も言及されている**セッションキー**です。これは、トランスポートキーを使用して復号化され、その後TPMに格納されます。これがTPM内で完全に行われる単一のステップでない限り、セッションキーがメモリ内で暗号化されていない状態になる**短い時間窓が提供される可能性があります**。その時点で、すでにシステム上にいる攻撃者によって傍受される可能性があります。セッションキーが更新されたり、特定の時点で変更されたりすると、このキーを傍受する機会が増える可能性があります。

## シングルサインオン <a href="#single-sign-on" id="single-sign-on"></a>

PRTドキュメントに記載されているように、PRTは**Azure ADリソースへのシングルサインオンを可能にします**。Edgeではこれがネイティブに行われます（予想通りですが）、**Chromeはこれをネイティブには行いません**。これを可能にするために、MicrosoftからのChrome拡張機能を使用します。

### Chrome拡張機能によるPRT <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Windows 10でのSSOを提供するためにMicrosoftが提供する[Chrome拡張機能](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en)から始めましょう。拡張機能がインストールされ、office.comなどのAzure ADに接続されたアプリケーションにアクセスすると、サインインプロセスは何も求められずに直接アカウントに進みます。Chrome拡張機能はJavaScriptで書かれているため、お気に入りのエディタでコードを読み込むことができます。参考までに、拡張機能は`C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`に保存されています。そのマニフェストでは、`background.js`スクリプトが実際に`com.microsoft.browsercore`名前空間に対して`sendNativeMessage`関数を使用していることを宣言している`nativeMessaging`権限が宣言されています。

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

[ドキュメント](https://developer.chrome.com/extensions/nativeMessaging)によると、これには`HKCU\Software\Google\Chrome\NativeMessagingHosts`にレジストリキーが必要であり、実際に拡張機能で見た`com.microsoft.browsercore`名のために存在しています。これは私たちを`C:\Windows\BrowserCore\manifest.json`に案内し、どの拡張機能が`BrowserCore.exe`バイナリを呼び出すことが許可されているかについての参照が含まれています。注意すべき点は、`C:\Windows\BrowserCore`はWindows 10の最近のインサイダービルドの場所であり、古いバージョンでは`C:\Program Files\Windows Security\BrowserCore`に位置しています。

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

そして`manifest.json`：
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
このプロセスに何が送信されるかを確認するために、SysinternalsのProcess Monitorが実行されている間に数回サインインし、プロセスコマンドラインをキャプチャしました：

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Chromeは名前付きパイプを使用して`stdin`に情報を供給し、別のパイプを使用して`stdout`を読み取っていることがわかります。これらの名前付きパイプを介して送信される内容を確認する最良の方法は、トラフィックを傍受または監視することだと考えました。オープンソースのツールで名前付きパイプの監視を容易に行えるものが見つからなかったため、商用の[IO Ninja](https://ioninja.com/plugins/pipe-monitor.html)のPipe Monitorを使用することにしました（評価版を使用しました）。これはかなりうまく機能し、Office.comに再度サインインしてクッキーをクリアした後、名前付きパイプ通信が表示されました：

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

既に`nativeMessaging`のドキュメンテーションで述べたように、最初の数バイトはメッセージの全長であり、残りはネイティブコンポーネントに転送されるデータ（JSON形式）です。JSONは以下の通りです：
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
それから、リフレッシュトークンクッキーを含む類似のJSONレスポンスを受け取ります。これは（Azure ADの他のトークンと同様に）JSON Web Token（JWT）です：
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
JWTをデコードすると、PRT自体と、現在実行されているログインにクッキーを結びつけるnonceが含まれていることがわかります:
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
AzureのほとんどのJWTはAzure ADによって管理されるキーで署名されていますが、この場合に含まれる**PRTのJWTはデバイスのTPMにあるセッションキーで署名されています**。PRT自体は**暗号化されたblob**であり、デバイス上のどのキーでも復号化できません。なぜなら、これにはAzure ADによって管理されるアイデンティティクレームが含まれているからです。

### ログインプロセス

Azure ADで全ての重要な認証が行われるプライマリドメインは`login.microsoftonline.com`です。このドメインは、**資格情報が送信され、トークンが要求され、更新される場所**です。

このリクエストにはまだPRTクッキーが含まれていませんが、Chromeユーザーエージェントを使用しているため、「リダイレクト中」ページが表示され、Chrome拡張機能と対話するJavaScriptコードが含まれています。

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

拡張機能からネイティブコンポーネントに送信されるURLを見ると、このURLは訪問していたURLに**`sso_nonce`**パラメータ（ページ上のJavaScriptを介して拡張機能に渡される）が追加されています。このnonceは、**トークンに反映され**、この特定のログインにPRTを持つ署名されたJWTを結びつけます。ログインページがどのように状態を処理し、このnonceをどこに/どのように保存するかはわかりませんが、異なるnonceを持つJWTは受け入れられません。

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### nonceの取り除き方 <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

`BrowserCore.exe`とどのように対話できるかを理解したので、プロセスを起動し、JSONを直接その`stdin`と`stdout`に書き込む小さなPythonツールを書きました。それから応答を読み取り、解読し、任意のURLのPRTクッキーを要求することができます。
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
```markdown
このことを少し試してみたところ、有効なPRTクッキーを取得するためにはURLのほとんどのパラメータが必要ではないことに気づきました。例えば、`https://login.microsoftonline.com/?sso_nonce=aaaaa"` のURLだけで、nonce `aaaaa` が付いた有効な署名されたPRTクッキーを取得できます。

私のテストでは、**PRTクッキーは約35分後に期限切れ**になり、それ以降はサインインに使用できなくなりました。独自のセッション管理を行うほとんどのサイトでは、**リフレッシュトークン**を使用してアクセスを延長できるため、しばらくの間サインインしたままになりますが、暗黙的な**OAuth2**フローを使用するサイトはアクセストークンのみを発行します。このアクセス**トークンは1時間後に期限切れ**になるため、PRTクッキーを使用してそのようなサイトにサインインした場合、1時間後に再度ログアウトされます。これはまた、何らかの理由でデバイスへのアクセスを失った場合、Azure ADへのアクセスも失われることを意味します。

### パブリッククライアントでのPRTクッキーの使用 <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Azure ADアプリケーション、例えばAzure PowerShellモジュールなどでSSOを使用できるかどうか興味がありました。`Connect-AzureAD` コマンドレットを実行すると、ログインを促すポップアップボックスが開き、SSOは行われません。~~なぜこれが起こるのかは確信がありませんが、もしかするとまだサポートされていないのかもしれません~~ [cnotinさんが指摘してくれたように](https://twitter.com/cnotin/status/1285734903389265922?s=20) `-AccountId` パラメータを指定するとSSOが行われますが、それがなくても `x-ms-RefreshTokenCredential` HTTPヘッダーにはPRTクッキーが含まれています：

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

しかし、**PRTクッキーがあってもSSOは行われません**。これは `prompt=login` パラメータによって、ユーザーを直接サインインさせる代わりにログインプロンプトが強制的に表示されるためです。PowerShellモジュールが使用しているフレームワークはわかりませんが、ドキュメントに記載されているWAMフレームワーク（ユーザーエージェントはInternet Explorerを指している？）に関連していると思われます。HTTPリクエストで `prompt` パラメータを削除すると、認証コードが得られます：

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

このコードは[OAuth2認証コードフロー](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow)で使用され、**アクセストークンとリフレッシュトークンを取得**するために使用できます。Azure AD PowerShellモジュールは_パブリック_アプリケーションであるため、この認証コードを使用してアクセスとリフレッシュトークンを要求する際には秘密が関与しません。これは、バックエンドがなく、これらのクライアントが直接さまざまなAPIと通信するため、モバイルアプリやネイティブアプリにも当てはまります。これは同じページで[文書化](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token)されています。この例では、デフォルトでかなりの権限を持っているAzure PowerShellモジュールを使用していますが、他にもあります。これらのいくつかは、私の[BlueHatトーク](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf)のスライド24で説明しています。また、ROADreconを使用して**パブリッククライアントを見つける**こともできます。ファーストパーティアプリケーション（同じテナント内に存在するアプリケーション）の場合、これは概要の列として表示されます。テナント内にないが、サービスプリンシパルを持っているアプリケーション（Office 365アプリケーションのほとんど）の場合、ApplicationRefsテーブルのデータベースでパブリッククライアントを見つけることができます：

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

取得した認証コードを正しいエンドポイント（`https://login.microsoftonline.com/Common/oauth2/token`）に送信することで、アクセストークンとリフレッシュトークンの両方を取得できます。通常、リフレッシュトークンはアプリに送信されずにWAMによって保護されていますが、リクエストを自分で送信することで、問題なく両方のトークンを取得できます：

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

結果のJSONレスポンス：

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## トークンのクレームとその影響 <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

このプロセスによって発行されるアクセストークンとリフレッシュトークンは、PRTが持っていたのと同じクレームを持ちます。したがって、SSOを使用するアプリでMFA認証が行われた場合、**PRTにはMFAクレームが含まれます**[ドキュメントによると](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim)。これは、ほとんどの場合、この方法で取得した**リフレッシュトークン**にも**MFAクレームが含まれる**ことを意味し、MFAを要求するConditional Accessポリシーを満たします。さらに、PRTはAzure ADに参加しているデバイスに発行されるため、PRTクッキーを使用して取得したトークンにもデバイスIDが含まれ、準拠またはHybridデバイスを要求するポリシーを満たします：

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

要するに、ログイン保護がいかに強固であっても、攻撃者がSSO機能を持つマシンでコード実行を行うことができれば、そのSSOを利用して最も厳格なConditional Accessポリシーを満たすトークンを取得することができます。実際、私がこれまでテストしていたマシンは、認証にFIDO2を持つYubiKeyを使用しています。しかし、リフレッシュトークンが取得された後、攻撃者はハードウェアセキュリティトークンを所持していなくても、ユーザーのデータ（例えばメールやOneDriveファイル）にアクセスできます。これは、**リフレッシュトークンがデバイス上の暗号的なものにはもはや関連していない**ため、永続性の方法を提供します。適切なアプリケーションIDを持っていれば、Office 365のAPIにフルアクセス権を持ついくつかのデフォルトアプリケーションがあるため、ほとんどのOffice 365 APIにアクセスできます。リフレッシュトークンは**デフォルトで90日間有効**ですが、使用すると新しいリフレッシュトークンが発行され、有効期限が延長されます。したがって、このトークンを一度手に入れると、数週間ごとにトークンを更新する限り、アクセスを維持することができます。以前はパブリッククライアントに発行されるリフレッシュトークンの有効期限を制限するプレビュー機能の設定オプションが[ありました](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes)が、それはもうサポートされていません。[サインイン頻度](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime)の設定がこれとどのように関連しているかは確信がありませんが、そのようなポリシーを使用するとリフレッシュトークンの有効期限が制限されると思われます。さらにいくつかの興味深い観察点：

* **PRTは、それが属する**デバイスがAzure ADで**無効**になると**機能しなくなります**。
* PRTを使用して取得した**リフレッシュトークンは、デバイスが無効になっても有効**です。唯一の例外は、デバイスが無効になると、管理されているか準拠しているデバイスを要求するConditional Accessポリシーを**もはや通過しない**ことです。
* **リフレッシュトークンを取得する**ことはサインインと見なされ、Azure ADのサインインログに**記録されます**。しかし、**リフレッシュトークンを更新してアクセストークンを取得する**ことはサインインとは見なされず、サインインログには記録されません。
* 特定のIPを信頼された場所として関与させ、それ以外からのログインを拒否するポリシーがある場合、新しいアクセストークンを要求する際にリフレッシュトークンを使用すると、それでもトリガーされます。

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## 攻撃

侵害されたデバイスからPRTトークンを取得し、Azureにアクセスする方法については、このページを確認してください：

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

## [Roadtx](https://github.com/dirkjanm/ROADtools)

このツールは、Azure ADにマシンを登録してPRTを取得したり、PRT（合法的または盗まれたもの）を使用してさまざまな方法でリソースにアクセスするなど、いくつかのアクションを実行することができます。これらは直接的な攻撃ではありませんが、PRTを使用してさまざまな方法でリソースにアクセスすることを容易にします。詳細は以下を参照してください：

{% content-ref url="az-roadtx-authentication.md" %}
[az-roadtx-authentication.md](az-roadtx-authentication.md)
{% endcontent-ref %}

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには、</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* HackTricksに**広告を掲載したい**場合や**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションです。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、Twitter 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>
```
