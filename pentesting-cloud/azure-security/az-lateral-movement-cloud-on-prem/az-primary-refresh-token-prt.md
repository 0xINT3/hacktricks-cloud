# Az - Primary Refresh Token (PRT)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Post copiado de** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) embora outro post explicando o mesmo possa ser encontrado em [**https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30**](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)

## Informa√ß√µes B√°sicas

Um **Primary Refresh Token** pode ser comparado a um **Ticket Granting Ticket (TGT) persistente de longo prazo** no Active Directory. √â um token que permite aos usu√°rios **entrar uma vez** em seu dispositivo conectado ao Azure AD e, em seguida, **entrar automaticamente em recursos conectados ao Azure AD**.

Um Primary Refresh Token pode ser usado para **autenticar em qualquer aplica√ß√£o**. √â por isso que a Microsoft aplicou prote√ß√µes extras a esse token. A prote√ß√£o mais importante √© que em dispositivos com um **TPM**, as chaves criptogr√°ficas s√£o armazenadas dentro desse TPM, tornando, na maioria das circunst√¢ncias, **imposs√≠vel recuperar as chaves reais do pr√≥prio SO**. H√° uma documenta√ß√£o bastante extensa sobre o Primary Refresh Token [dispon√≠vel aqui](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token). Sugiro que leia o artigo inteiro, pois ele cont√©m muitos detalhes t√©cnicos, mas para o prop√≥sito deste post, aqui est√£o os pontos mais importantes:

* Se um TPM est√° presente, as chaves necess√°rias para solicitar ou usar o PRT s√£o **protegidas pelo TPM** e n√£o podem ser extra√≠das em circunst√¢ncias normais.
* **Um PRT pode ser atualizado com uma reivindica√ß√£o MFA quando MFA √© usado no dispositivo**, o que possibilita SSO para recursos que exigem MFA posteriormente.
* O **PRT cont√©m o ID do dispositivo** e, portanto, √© **vinculado ao objeto do dispositivo** no Azure AD, isso pode ser usado para combinar os tokens com pol√≠ticas de Acesso Condicional que exigem dispositivos compat√≠veis.
* O **PRT √© invalidado quando o dispositivo √© desativado** no Azure AD e n√£o pode mais ser usado para solicitar novos tokens a partir desse ponto.
* Durante o SSO, o **PRT √© usado para solicitar tokens de atualiza√ß√£o e acesso**. Os tokens de atualiza√ß√£o s√£o mantidos pelo **plug-in CloudAP e criptografados com DPAPI**, os tokens de acesso s√£o passados para a aplica√ß√£o solicitante.

Algo a se notar √© que v√°rias dessas prote√ß√µes usam o **TPM**, que √© **opcional** em uma jun√ß√£o h√≠brida. Se n√£o houver TPM, as **chaves s√£o armazenadas em software**. Nesse cen√°rio, √© poss√≠vel **recuper√°-las** do SO com os privil√©gios certos. Outro ponto que merece mais pesquisa √© a **Chave de Sess√£o** que √© mencionada v√°rias vezes ao longo da [documenta√ß√£o do PRT](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token), que √© descriptografada usando a chave de transporte e depois armazenada no TPM. A menos que isso seja um passo √∫nico ocorrendo inteiramente dentro do TPM, isso poderia fornecer uma **breve janela na qual a chave de sess√£o est√° descriptografada na mem√≥ria**, momento em que poderia ser interceptada por um atacante j√° no sistema. O n√∫mero de oportunidades para interceptar essa chave pode aumentar se a chave de sess√£o for renovada ou alterada em certos momentos.

## Single Sign On <a href="#single-sign-on" id="single-sign-on"></a>

Como descrito na documenta√ß√£o do PRT, o PRT possibilita **single sign-on para recursos do Azure AD**. No Edge isso √© feito nativamente (como esperado), mas o **Chrome n√£o faz isso nativamente**, ele usa uma extens√£o do Chrome da Microsoft para habilitar essa capacidade.

### PRT pela Extens√£o do Chrome <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Vamos come√ßar com a [extens√£o do Chrome](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en) que a Microsoft fornece para SSO no Windows 10. Uma vez que a extens√£o est√° instalada e voc√™ navega para uma aplica√ß√£o conectada ao Azure AD, como office.com, o processo de login n√£o pede nada e continua diretamente para sua conta. Como as extens√µes do Chrome s√£o escritas em JavaScript, voc√™ pode carregar o c√≥digo no seu editor favorito. Para refer√™ncia, as extens√µes s√£o salvas em `C:\Users\seuusuario\AppData\Local\Google\Chrome\User Data\Default\Extensions`. Em seu manifesto, a permiss√£o `nativeMessaging` √© declarada, com o script `background.js` de fato usando a fun√ß√£o `sendNativeMessage` para o namespace `com.microsoft.browsercore`.

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

De acordo com a [documenta√ß√£o](https://developer.chrome.com/extensions/nativeMessaging), isso requer uma chave de registro em `HKCU\Software\Google\Chrome\NativeMessagingHosts`, que de fato est√° presente para o nome `com.microsoft.browsercore` que vimos na extens√£o. Ela nos aponta para `C:\Windows\BrowserCore\manifest.json`, que cont√©m uma refer√™ncia a quais extens√µes est√£o autorizadas a chamar o bin√°rio `BrowserCore.exe`. Note que `C:\Windows\BrowserCore` √© a localiza√ß√£o em builds recentes insider do Windows 10, em vers√µes mais antigas est√° localizado em `C:\Program Files\Windows Security\BrowserCore`.

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

E o `manifest.json`:
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
Para ver o que √© enviado para este processo, fiz login algumas vezes enquanto o Process Monitor da Sysinternals estava em execu√ß√£o, o que capturou a linha de comando do processo:

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Como vemos, o Chrome est√° usando pipes nomeados para fornecer informa√ß√µes ao `stdin` e outro pipe para ler `stdout`. Conclu√≠ que a melhor maneira de ver o que √© enviado por esses pipes nomeados era tentar interceptar ou monitorar o tr√°fego. N√£o consegui encontrar uma ferramenta de c√≥digo aberto que permitisse facilmente o monitoramento de pipes nomeados, ent√£o tive que optar pelo Pipe Monitor comercial da [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html) (eles oferecem uma vers√£o de avalia√ß√£o que eu usei para isso). Isso funcionou muito bem e, ap√≥s limpar os cookies e fazer login novamente no Office.com, vi a comunica√ß√£o do pipe nomeado aparecer:

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

Como j√° mencionado na documenta√ß√£o `nativeMessaging`, os primeiros bytes s√£o o comprimento total da mensagem e o resto s√£o os dados (em JSON) transferidos para o componente nativo. O JSON √© o seguinte:
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
Em seguida, ele recebe uma resposta JSON semelhante contendo o cookie do token de atualiza√ß√£o, que √© (como outros tokens no Azure AD) um JSON Web Token (JWT):
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
Ao decodificarmos este JWT, vemos que ele cont√©m o pr√≥prio PRT e um nonce, que vincula o cookie ao login atual que est√° sendo realizado:
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Enquanto a maioria dos JWTs no Azure √© assinada com uma chave gerenciada pelo Azure AD, neste caso o JWT contendo o **PRT √© assinado pela chave de sess√£o que est√° no TPM do dispositivo**. O pr√≥prio PRT √© um **blob criptografado** e n√£o pode ser descriptografado por nenhuma chave no dispositivo, porque isso cont√©m as reivindica√ß√µes de identidade que s√£o gerenciadas pelo Azure AD.

### O processo de login

O dom√≠nio principal onde toda autentica√ß√£o importante acontece no Azure AD √© `login.microsoftonline.com`. Este √© o dom√≠nio onde **credenciais s√£o enviadas e tokens s√£o solicitados e renovados**.

Esta solicita√ß√£o ainda n√£o cont√©m o cookie PRT, mas como usa o agente do usu√°rio Chrome, somos recebidos por uma p√°gina "Redirecionando" que cont√©m c√≥digo JavaScript para interagir com a extens√£o do Chrome.

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

Quando olhamos para a URL que √© enviada da extens√£o para o componente nativo, esta URL consiste na URL que est√°vamos visitando, mais o par√¢metro **`sso_nonce`** (que √© passado para a extens√£o via JavaScript na p√°gina). Este nonce √© ent√£o **refletido de volta no token**, essencialmente vinculando o JWT assinado com PRT a este login espec√≠fico. N√£o tenho certeza de como a p√°gina de login lida com o estado e onde/se armazena este nonce, mas ela n√£o aceitar√° um JWT com um nonce diferente.

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### Livrando-se do nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

Agora que descobrimos como podemos interagir com `BrowserCore.exe`, escrevi uma pequena ferramenta em Python que inicia o processo e escreve o JSON diretamente no seu `stdin` e `stdout`. Em seguida, l√™ a resposta e a decodifica, permitindo-nos solicitar cookies PRT para uma URL arbitr√°ria.
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
Brincando um pouco com isso, notei que a maioria dos par√¢metros na URL n√£o s√£o necess√°rios para obter um cookie PRT v√°lido. Por exemplo, uma URL com `https://login.microsoftonline.com/?sso_nonce=aaaaa"` √© suficiente para obter um cookie PRT assinado v√°lido com o nonce `aaaaa`.

Nos meus testes, o **cookie PRT expirou ap√≥s cerca de 35 minutos**, ap√≥s o qual n√£o p√¥de mais ser usado para fazer login. A maioria dos sites que fazem sua pr√≥pria gest√£o de sess√£o vai mant√™-lo conectado por um tempo, pois pode usar o **refresh token** para estender o acesso, mas sites que usam o fluxo **OAuth2** impl√≠cito s√≥ fornecem um token de acesso. Este token de acesso **expira ap√≥s uma hora**, o que significa que se voc√™ usar o cookie PRT para fazer login em um site desses, ser√° desconectado novamente ap√≥s uma hora. Isso tamb√©m significa que se voc√™ perder o acesso ao dispositivo por qualquer motivo, o acesso ao Azure AD tamb√©m ser√° perdido.

### Usando o cookie PRT com clientes p√∫blicos <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Fiquei curioso se poder√≠amos usar SSO com outras aplica√ß√µes do Azure AD, como o m√≥dulo Azure PowerShell. Quando executamos o cmdlet `Connect-AzureAD`, uma caixa de pop-up se abre solicitando que fa√ßamos login, e nenhum SSO ocorre. ~~N√£o tenho certeza do motivo, talvez ainda n√£o seja suportado~~ Como [apontado por @cnotin](https://twitter.com/cnotin/status/1285734903389265922?s=20) o SSO ocorre se o par√¢metro `-AccountId` for especificado, mas mesmo sem ele h√° um cookie PRT inclu√≠do no cabe√ßalho HTTP `x-ms-RefreshTokenCredential`:

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

No entanto **n√£o h√° SSO ocorrendo, apesar de haver um cookie PRT**. Isso √© causado pelo par√¢metro `prompt=login`, que for√ßa explicitamente a apari√ß√£o do prompt de login em vez de fazer login direto do usu√°rio. N√£o tenho certeza de qual framework os m√≥dulos PowerShell usam, mas suponho que esteja relacionado ao framework WAM mencionado na documenta√ß√£o (o agente do usu√°rio aponta para o Internet Explorer?). Quando removemos o par√¢metro `prompt` na solicita√ß√£o HTTP, obtemos um c√≥digo de autoriza√ß√£o:

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

Este c√≥digo √© usado no [fluxo de c√≥digo de autoriza√ß√£o OAuth2](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), e podemos us√°-lo para **obter um token de acesso e refresh token**. Como o m√≥dulo Azure AD PowerShell √© uma aplica√ß√£o _p√∫blica_, n√£o h√° segredo envolvido na solicita√ß√£o do token de acesso e refresh token usando este c√≥digo de autoriza√ß√£o. Isso vale para todos os aplicativos m√≥veis e nativos, j√° que n√£o h√° como armazenar tal segredo de forma segura, pois n√£o h√° backend em vigor e esses clientes se comunicam diretamente com as v√°rias APIs. Isso tamb√©m est√° [documentado](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token) na mesma p√°gina. Neste exemplo, estou usando o m√≥dulo Azure PowerShell porque ele tem bastante permiss√µes por padr√£o, mas existem outros. Descrevi alguns desses no meu [palestra BlueHat](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf) no slide 24. Voc√™ tamb√©m pode **encontrar clientes p√∫blicos usando ROADrecon**. Para aplica√ß√µes de primeira parte (aplica√ß√µes que existem no mesmo tenant), isso √© mostrado como uma coluna na vis√£o geral. Para aplica√ß√µes que n√£o est√£o no seu tenant, mas que t√™m um principal de servi√ßo (como a maioria das aplica√ß√µes do Office 365), voc√™ pode encontrar clientes p√∫blicos no banco de dados na tabela ApplicationRefs:

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

Ao enviar o c√≥digo de autoriza√ß√£o obtido para o endpoint correto (`https://login.microsoftonline.com/Common/oauth2/token`), obtemos tanto um token de acesso quanto um refresh token. Embora o refresh token normalmente n√£o seja enviado para o aplicativo, mas protegido pelo WAM, ao enviar a solicita√ß√£o n√≥s mesmos, podemos obter ambos os tokens sem problemas:

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

Resposta JSON resultante:

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## Reivindica√ß√µes de token e implica√ß√µes <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

Os tokens de acesso e refresh tokens emitidos por esse processo ter√£o as mesmas reivindica√ß√µes que o PRT tinha. Ent√£o, se a autentica√ß√£o MFA foi realizada em um aplicativo que usa SSO, o **PRT conter√° a reivindica√ß√£o MFA** [conforme a documenta√ß√£o](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim). Isso significa que, na maioria dos casos, o **refresh token** obtido por esse meio vai **incluir a reivindica√ß√£o MFA** e, portanto, vai satisfazer as pol√≠ticas de Acesso Condicional que exigem MFA. Al√©m disso, como o PRT √© emitido para um dispositivo unido ao Azure AD, os tokens que obtemos usando o cookie PRT tamb√©m cont√™m o ID do dispositivo, fazendo com que satisfa√ßa pol√≠ticas que exigem um dispositivo compat√≠vel ou H√≠brido:

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

Ent√£o, em resumo, n√£o importa qu√£o forte seja a prote√ß√£o de login, uma vez que um atacante ganha execu√ß√£o de c√≥digo em uma m√°quina com capacidades de SSO, eles podem **se beneficiar desse SSO para adquirir um token que satisfaz at√© as pol√≠ticas de Acesso Condicional mais rigorosas**. Na verdade, a m√°quina na qual estive testando isso at√© agora est√° usando um YubiKey com FIDO2 para autenticar. No entanto, ap√≥s a obten√ß√£o do refresh token, um atacante pode acessar os dados do usu√°rio, como e-mail ou arquivos do OneDrive, sem estar na posse do token de seguran√ßa de hardware. Isso oferece uma maneira de persist√™ncia, j√° que o **refresh token n√£o est√° mais vinculado a nada criptograficamente no dispositivo**, e com o ID de aplicativo correto, a maioria das APIs do Office 365 pode ser acessada, pois existem v√°rias aplica√ß√µes padr√£o que t√™m permiss√µes completas nessas APIs. O refresh token √© **v√°lido por 90 dias por padr√£o**, mas se voc√™ us√°-lo, um novo refresh token √© emitido com validade estendida. Ent√£o, uma vez que voc√™ tenha esse token, o acesso pode ser mantido enquanto voc√™ atualizar o token a cada poucas semanas. [Costumava haver](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes) uma op√ß√£o de configura√ß√£o em pr√©-visualiza√ß√£o que poderia limitar a vida √∫til de um refresh token emitido para clientes p√∫blicos, mas isso n√£o √© mais suportado. N√£o tenho certeza de como a configura√ß√£o da [frequ√™ncia de login](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime) se relaciona com tudo isso, mas minha suposi√ß√£o √© que usar tal pol√≠tica limitaria a validade dos refresh tokens. Mais algumas observa√ß√µes interessantes:

* O **PRT vai parar de funcionar** quando o **dispositivo** ao qual pertence for **desativado** no Azure AD.
* O **refresh token obtido usando o PRT permanece v√°lido mesmo se o dispositivo for desativado**. A √∫nica exce√ß√£o √© que quando o dispositivo √© desativado, ele **n√£o passar√° mais pelas pol√≠ticas de Acesso Condicional** que exigem um dispositivo gerenciado ou compat√≠vel.
* **Obter um refresh token** conta como um login e √© **registrado** no log de login do Azure AD. **Atualizar** o **refresh token e obter um token de acesso** com ele, no entanto, **n√£o conta como um login** e n√£o √© registrado no log de login.
* Se houver pol√≠ticas que envolvam um IP espec√≠fico como localiza√ß√£o confi√°vel e neguem logins de fora desses, isso ainda ser√° acionado quando o refresh token for usado para solicitar um novo token de acesso.

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## Ataque

Verifique como obter um token PRT de um dispositivo comprometido e us√°-lo para acessar o Azure nesta p√°gina:

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

## [Roadtx](https://github.com/dirkjanm/ROADtools)

Esta ferramenta permite realizar v√°rias a√ß√µes, como registrar uma m√°quina no Azure AD para obter um PRT, e usar PRTs (leg√≠timos ou roubados) para acessar recursos de v√°rias maneiras diferentes. Estes n√£o s√£o ataques diretos, mas facilita o uso de PRTs para acessar recursos de diferentes maneiras. Encontre mais informa√ß√µes em:

{% content-ref url="az-roadtx-authentication.md" %}
[az-roadtx-authentication.md](az-roadtx-authentication.md)
{% endcontent-ref %}

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
