# Az - Jeton d'actualisation principal (PRT)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Article copi√© de** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)

## Informations de base

Un **Jeton d'actualisation principal** peut √™tre compar√© √† un **Ticket Granting Ticket (TGT) persistant √† long terme** dans Active Directory. C'est un jeton qui permet aux utilisateurs de **se connecter une fois** sur leur appareil connect√© √† Azure AD, puis de **se connecter automatiquement aux ressources connect√©es √† Azure AD**.&#x20;

Un Jeton d'actualisation principal peut √™tre utilis√© pour **s'authentifier √† n'importe quelle application**. C'est pourquoi Microsoft a appliqu√© une protection suppl√©mentaire √† ce jeton. La protection la plus importante est que sur les appareils avec un **TPM**, les cl√©s cryptographiques sont stock√©es dans ce TPM, rendant dans la plupart des cas **impossible de r√©cup√©rer les cl√©s r√©elles √† partir du syst√®me d'exploitation lui-m√™me**. Il existe une documentation assez compl√®te sur le Jeton d'actualisation principal [disponible ici](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token). Je vous sugg√®re de lire l'article en entier car il contient pas mal de d√©tails techniques, mais pour les besoins de cet article, voici les points les plus importants :

* Si un TPM est pr√©sent, les cl√©s requises pour demander ou utiliser le PRT sont **prot√©g√©es par le TPM** et ne peuvent pas √™tre extraites dans des circonstances normales.
* **Un PRT peut √™tre mis √† jour avec une revendication MFA lorsque MFA est utilis√© sur l'appareil**, ce qui permet le SSO vers des ressources n√©cessitant MFA par la suite.
* Le **PRT contient l'ID de l'appareil** et est donc **li√© √† l'objet appareil** dans Azure AD, cela peut √™tre utilis√© pour faire correspondre les jetons aux politiques d'Acc√®s Conditionnel exigeant des appareils conformes.
* Le **PRT est invalid√© lorsque l'appareil est d√©sactiv√©** dans Azure AD et ne peut plus √™tre utilis√© pour demander de nouveaux jetons √† ce moment-l√†.
* Pendant le SSO, le **PRT est utilis√© pour demander des jetons d'actualisation et d'acc√®s**. Les jetons d'actualisation sont conserv√©s par le **plug-in CloudAP et chiffr√©s avec DPAPI**, les jetons d'acc√®s sont transmis √† l'application demandeuse.

Il est √† noter que bon nombre de ces protections utilisent le **TPM**, qui est **optionnel** dans une jonction hybride. S'il n'y a pas de TPM, les **cl√©s sont stock√©es dans le logiciel**. Dans ce sc√©nario, il est possible de **les r√©cup√©rer** √† partir du syst√®me d'exploitation avec les bons privil√®ges. Un autre point √† noter qui m√©rite des recherches suppl√©mentaires est la **cl√© de session** qui est mentionn√©e √† plusieurs reprises tout au long de la [documentation PRT](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token), qui est d√©chiffr√©e en utilisant la cl√© de transport puis stock√©e dans le TPM. √Ä moins que ce ne soit une √©tape unique se d√©roulant enti√®rement dans le TPM, cela pourrait fournir une **br√®ve fen√™tre pendant laquelle la cl√© de session est non chiffr√©e en m√©moire**, √† ce moment-l√†, elle pourrait √™tre intercept√©e par un attaquant d√©j√† sur le syst√®me. Le nombre d'opportunit√©s d'intercepter cette cl√© pourrait augmenter si la cl√© de session est renouvel√©e ou modifi√©e √† certains moments.

## Connexion unique <a href="#single-sign-on" id="single-sign-on"></a>

Comme d√©crit dans la documentation PRT, le PRT permet la **connexion unique aux ressources Azure AD**. Dans Edge, cela se fait de mani√®re native (comme pr√©vu), mais **Chrome ne le fait pas nativement**, il utilise une extension Chrome de Microsoft pour activer cette capacit√©.

### PRT par l'extension Chrome <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Commen√ßons par l'[extension Chrome](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en) que Microsoft fournit pour le SSO sur Windows 10. Une fois l'extension install√©e et lorsque vous naviguez vers une application connect√©e √† Azure AD telle que office.com, le processus de connexion ne demande rien mais continue directement vers votre compte. Comme les extensions Chrome sont √©crites en JavaScript, vous pouvez simplement charger le code dans votre √©diteur pr√©f√©r√©. Pour r√©f√©rence, les extensions sont enregistr√©es dans `C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`. Dans son manifeste, la permission `nativeMessaging` est d√©clar√©e, avec le script `background.js` utilisant effectivement la fonction `sendNativeMessage` √† l'espace de noms `com.microsoft.browsercore`.

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

Selon la [documentation](https://developer.chrome.com/extensions/nativeMessaging), cela n√©cessite une cl√© de registre dans `HKCU\Software\Google\Chrome\NativeMessagingHosts`, qui est effectivement pr√©sente pour le nom `com.microsoft.browsercore` que nous avons vu dans l'extension. Elle nous dirige vers `C:\Windows\BrowserCore\manifest.json`, qui contient une r√©f√©rence aux extensions autoris√©es √† appeler le binaire `BrowserCore.exe`. Notez que `C:\Windows\BrowserCore` est l'emplacement dans les versions r√©centes d'aper√ßu de Windows 10, dans les versions plus anciennes, il est situ√© dans `C:\Program Files\Windows Security\BrowserCore`.

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

Et le `manifest.json` :
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
Pour voir ce qui est envoy√© √† ce processus, je me suis connect√© plusieurs fois pendant que Process Monitor de Sysinternals √©tait en cours d'ex√©cution, ce qui a captur√© la ligne de commande du processus :

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Comme nous le voyons, Chrome utilise des tubes nomm√©s pour alimenter des informations dans `stdin` et un autre tube pour lire `stdout`. J'ai pens√© que la meilleure fa√ßon de voir ce qui est envoy√© sur ces tubes nomm√©s √©tait d'essayer d'intercepter ou de surveiller le trafic. Je n'ai pas trouv√© d'outil open source qui permettait facilement de surveiller les tubes nomm√©s, donc j'ai d√ª opter pour le Pipe Monitor commercial de [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html) (ils offrent une version d'√©valuation que j'ai utilis√©e pour cela). Cela a tr√®s bien fonctionn√© et apr√®s avoir effac√© les cookies et s'√™tre reconnect√© √† Office.com, j'ai vu la communication du tube nomm√© appara√Ætre :

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

Comme d√©j√† mentionn√© dans la documentation `nativeMessaging`, les premiers octets sont la longueur totale du message et le reste est les donn√©es (en JSON) transf√©r√©es au composant natif. Le JSON est comme suit :
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
Il re√ßoit alors une r√©ponse JSON similaire contenant le cookie de jeton d'actualisation, qui est (comme les autres jetons dans Azure AD) un JSON Web Token (JWT) :
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
Lorsque nous d√©codons ce JWT, nous constatons qu'il contient le PRT lui-m√™me et un nonce, qui lie le cookie √† la connexion actuelle qui est en cours :
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Alors que la plupart des JWT dans Azure sont sign√©s avec une cl√© g√©r√©e par Azure AD, dans ce cas, le JWT contenant le **PRT est sign√© par la cl√© de session qui se trouve dans le TPM de l'appareil**. Le PRT lui-m√™me est un **blob chiffr√©** et ne peut pas √™tre d√©chiffr√© par aucune cl√© sur l'appareil, car il contient les revendications d'identit√© g√©r√©es par Azure AD.

### Le processus de connexion

Le domaine principal o√π toute authentification importante a lieu dans Azure AD est `login.microsoftonline.com`. C'est le domaine o√π **les identifiants sont envoy√©s et les jetons sont demand√©s et renouvel√©s**.

Cette requ√™te ne contient pas encore le cookie PRT, mais comme elle utilise l'agent utilisateur Chrome, nous sommes accueillis par une page "Redirection" qui contient du code JavaScript pour interagir avec l'extension Chrome.

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

Lorsque nous examinons l'URL qui est envoy√©e de l'extension au composant natif, cette URL se compose de l'URL que nous visitions, plus le param√®tre **`sso_nonce`** (qui est transmis √† l'extension via JavaScript sur la page). Ce nonce est ensuite **r√©fl√©chi dans le jeton**, liant essentiellement le JWT sign√© avec le PRT √† cette connexion sp√©cifique. Je ne suis pas s√ªr de la mani√®re dont la page de connexion g√®re l'√©tat et o√π/si elle stocke ce nonce, mais elle n'acceptera pas un JWT avec un nonce diff√©rent.

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### Se d√©barrasser du nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

Maintenant que nous avons compris comment nous pouvons interagir avec `BrowserCore.exe`, j'ai √©crit un petit outil en Python qui lance le processus et √©crit le JSON directement dans son `stdin` et `stdout`. Il lit ensuite la r√©ponse et la d√©code, ce qui nous permet de demander des cookies PRT pour une URL arbitraire.
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
En jouant un peu avec cela, j'ai remarqu√© que la plupart des param√®tres dans l'URL ne sont pas n√©cessaires pour obtenir un cookie PRT valide. Par exemple, une URL avec `https://login.microsoftonline.com/?sso_nonce=aaaaa"` suffit pour obtenir un cookie PRT sign√© valide avec le nonce `aaaaa`.

Dans mes tests, le **cookie PRT a expir√© apr√®s environ 35 minutes**, apr√®s quoi il ne pouvait plus √™tre utilis√© pour se connecter. La plupart des sites qui g√®rent leur propre session vous laisseront connect√© pendant un moment car ils peuvent utiliser le **token de rafra√Æchissement** pour prolonger l'acc√®s, mais les sites qui utilisent le flux **OAuth2** implicite ne donnent qu'un token d'acc√®s. Ce token d'acc√®s **expire apr√®s une heure**, ce qui signifie que si vous utilisez le cookie PRT pour vous connecter sur un tel site, vous serez d√©connect√© apr√®s une heure. Cela signifie √©galement que si vous perdez l'acc√®s √† l'appareil pour une raison quelconque, l'acc√®s √† Azure AD sera √©galement perdu.

### Utilisation du cookie PRT avec des clients publics <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Je me demandais si nous pouvions utiliser SSO avec d'autres applications Azure AD, telles que le module PowerShell Azure. Lorsque nous ex√©cutons la cmdlet `Connect-AzureAD`, une bo√Æte de dialogue s'ouvre nous invitant √† nous connecter, et aucun SSO ne se produit. ~~Je ne suis pas s√ªr de la raison, peut-√™tre que ce n'est pas encore pris en charge~~ Comme [l'a soulign√© @cnotin](https://twitter.com/cnotin/status/1285734903389265922?s=20) SSO se produit si le param√®tre `-AccountId` est sp√©cifi√©, mais m√™me sans cela, il y a un cookie PRT inclus dans l'en-t√™te HTTP `x-ms-RefreshTokenCredential` :

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

Pourtant **il n'y a pas de SSO qui se produit, malgr√© la pr√©sence d'un cookie PRT**. Cela est caus√© par le param√®tre `prompt=login`, qui force explicitement l'apparition de l'invite de connexion au lieu de connecter directement l'utilisateur. Je ne suis pas s√ªr du framework utilis√© par les modules PowerShell, mais je suppose qu'il est li√© au framework WAM mentionn√© dans la documentation (l'agent utilisateur pointe vers Internet Explorer ?). Lorsque nous supprimons le param√®tre `prompt` dans la requ√™te HTTP, nous obtenons un code d'autorisation :

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

Ce code est utilis√© dans le [flux de code d'autorisation OAuth2](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), et nous pouvons l'utiliser pour **obtenir un token d'acc√®s et un token de rafra√Æchissement**. Comme le module PowerShell Azure AD est une application _publique_, il n'y a pas de secret impliqu√© dans la demande du token d'acc√®s et du token de rafra√Æchissement en utilisant ce code d'autorisation. C'est le cas pour toutes les applications mobiles et natives, car il n'y a aucun moyen de stocker de mani√®re s√©curis√©e un tel secret puisqu'il n'y a pas de backend en place et que ces clients communiquent directement avec les diff√©rentes API. Cela est √©galement [document√©](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token) sur la m√™me page. Dans cet exemple, j'utilise le module PowerShell Azure car il a pas mal de permissions par d√©faut, mais il y en a d'autres. J'ai d√©crit certains d'entre eux dans ma [pr√©sentation BlueHat](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf) √† la diapositive 24. Vous pouvez √©galement **trouver des clients publics en utilisant ROADrecon**. Pour les applications de premi√®re partie (applications qui existent dans le m√™me locataire), cela est affich√© comme une colonne dans l'aper√ßu. Pour les applications qui ne sont pas dans votre locataire, mais qui ont un principal de service (comme la plupart des applications Office 365), vous pouvez trouver des clients publics dans la base de donn√©es dans la table ApplicationRefs :

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

En envoyant le code d'autorisation obtenu au point de terminaison correct (`https://login.microsoftonline.com/Common/oauth2/token`), nous obtenons √† la fois un token d'acc√®s et un token de rafra√Æchissement. Bien que le token de rafra√Æchissement ne soit normalement pas envoy√© √† l'application mais prot√©g√© par le WAM, en envoyant la requ√™te nous-m√™mes, nous pouvons obtenir les deux tokens sans probl√®me :

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

R√©ponse JSON r√©sultante :

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## Revendications des tokens et implications <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

Les tokens d'acc√®s et les tokens de rafra√Æchissement √©mis par ce processus auront les m√™mes revendications que le PRT avait. Donc, si une authentification MFA a √©t√© effectu√©e dans une application qui utilise SSO, le **PRT contiendra la revendication MFA** [selon la documentation](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim). Cela signifie que dans la plupart des cas, le **token de rafra√Æchissement** obtenu de cette mani√®re inclura **la revendication MFA** et satisfera donc les politiques d'Acc√®s Conditionnel qui exigent MFA. De plus, puisque le PRT est √©mis √† un appareil joint √† Azure AD, les tokens que nous obtenons en utilisant le cookie PRT contiennent √©galement l'ID de l'appareil, ce qui le rend conforme aux politiques qui exigent un appareil conforme ou hybride :

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

En r√©sum√©, peu importe la force de la protection de connexion, une fois qu'un attaquant obtient l'ex√©cution de code sur une machine avec des capacit√©s SSO, il peut **profiter de ce SSO pour acqu√©rir un token qui satisfait m√™me les politiques d'Acc√®s Conditionnel les plus strictes**. En fait, la machine sur laquelle j'ai test√© cela jusqu'√† pr√©sent utilise un YubiKey avec FIDO2 pour s'authentifier. Pourtant, apr√®s l'obtention du token de rafra√Æchissement, un attaquant peut acc√©der aux donn√©es de l'utilisateur telles que les emails ou les fichiers OneDrive sans √™tre en possession du jeton de s√©curit√© mat√©riel. Cela offre un moyen de persistance puisque le **token de rafra√Æchissement n'est plus li√© cryptographiquement √† l'appareil**, et avec le bon ID d'application, la plupart des API Office 365 peuvent √™tre accessibles car il existe plusieurs applications par d√©faut qui ont des permissions compl√®tes sur ces API. Le token de rafra√Æchissement est valide pendant 90 jours par d√©faut, mais si vous l'utilisez, un nouveau token de rafra√Æchissement vous est d√©livr√© avec une validit√© prolong√©e. Donc, une fois que vous avez ce token, l'acc√®s peut √™tre maintenu aussi longtemps que vous rafra√Æchissez le token toutes les quelques semaines. Il [existait](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes) une option de configuration en pr√©visualisation qui pouvait limiter la dur√©e de vie d'un token de rafra√Æchissement √©mis aux clients publics mais cela n'est plus pris en charge. Je ne suis pas s√ªr de la mani√®re dont le r√©glage de la [fr√©quence de connexion](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime) s'int√®gre √† tout cela, mais je suppose qu'une telle politique limiterait la validit√© des tokens de rafra√Æchissement. Quelques observations int√©ressantes suppl√©mentaires :

* Le **PRT cessera de fonctionner** lorsque l'**appareil** auquel il appartient est **d√©sactiv√©** dans Azure AD.
* Le **token de rafra√Æchissement obtenu en utilisant le PRT reste valide m√™me si l'appareil est d√©sactiv√©**. La seule exception est que lorsque l'appareil est d√©sactiv√©, il ne **passera plus les politiques d'Acc√®s Conditionnel** qui exigent un appareil g√©r√© ou conforme.
* **Obtenir un token de rafra√Æchissement** compte comme une connexion et est **enregistr√© dans** le journal de connexion d'Azure AD. **Rafra√Æchir** le **token de rafra√Æchissement et obtenir un token d'acc√®s** avec cependant ne **compte pas comme une connexion** et n'est pas enregistr√© dans le journal de connexion.
* Si des politiques impliquent une IP sp√©cifique comme emplacement de confiance et refusent les connexions de l'ext√©rieur de celles-ci, cela d√©clenchera toujours lorsque le token de rafra√Æchissement est utilis√© pour demander un nouveau token d'acc√®s.

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## Attaque

V√©rifiez comment obtenir un token PRT √† partir d'un appareil compromis et l'utiliser pour acc√©der √† Azure sur cette page :

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
