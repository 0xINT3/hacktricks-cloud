# Az - 主要刷新令牌（PRT）

<details>

<summary><strong>从零开始学习AWS黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

**文章复制自** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)

## 基本信息

**主要刷新令牌**可以比作Active Directory中的长期**持久票据授予票证（TGT）**。它是一个令牌，使用户能够在其Azure AD连接的设备上**一次性登录**，然后**自动登录到Azure AD连接的资源**。

主要刷新令牌可以用来**认证任何应用程序**。这就是为什么微软对这个令牌施加了额外的保护。最重要的保护是，在带有**TPM**的设备上，加密密钥存储在TPM内，这在大多数情况下**无法从操作系统本身恢复实际密钥**。关于主要刷新令牌有一些相当详尽的文档[在这里可以找到](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)。我建议你阅读整篇文章，因为它包含了相当多的技术细节，但为了本文的目的，这里是最重要的几点：

* 如果存在TPM，请求或使用PRT所需的密钥**受TPM保护**，在正常情况下无法提取。
* **当设备上使用MFA时，PRT可以更新MFA声明**，之后可以启用对需要MFA的资源的SSO。
* **PRT包含设备ID**，因此**与设备对象在Azure AD中绑定**，这可以用来匹配对需要合规设备的条件访问策略的令牌。
* 当设备在Azure AD中被禁用时，**PRT会失效**，此时无法再用来请求新的令牌。
* 在SSO期间，**PRT用于请求刷新和访问令牌**。刷新令牌由**CloudAP插件保管并用DPAPI加密**，访问令牌传递给请求应用程序。

值得注意的是，这些保护措施中有相当多是使用**TPM**的，这在混合加入中是**可选的**。如果没有TPM，**密钥存储在软件中**。在这种情况下，如果拥有正确的权限，就有可能从操作系统中**恢复它们**。另一个值得进一步研究的注意事项是**会话密钥**，它在[PRT文档](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)中多次提到，它使用传输密钥解密，然后存储到TPM中。除非这是一个完全在TPM内部进行的单一步骤，否则这可能提供了一个**会话密钥在内存中未加密的短暂窗口**，此时攻击者如果已经在系统上，就可能截获它。如果会话密钥在某些时间点更新或更改，截获这个密钥的机会可能会增加。

## 单点登录 <a href="#single-sign-on" id="single-sign-on"></a>

如PRT文档所述，PRT启用了**对Azure AD资源的单点登录**。在Edge中这是原生完成的（如预期），但**Chrome并不是原生完成的**，它使用来自微软的Chrome扩展程序来启用这个功能。

### Chrome扩展程序的PRT <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

让我们从微软为Windows 10上的SSO提供的[Chrome扩展程序](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en)开始。一旦安装了扩展程序，当你浏览到Azure AD连接的应用程序，如office.com时，登录过程不会提示任何内容，而是直接继续进入你的账户。由于Chrome扩展程序是用JavaScript编写的，你可以在你最喜欢的编辑器中加载代码。作为参考，扩展程序保存在`C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`。在其清单中，声明了权限`nativeMessaging`，`background.js`脚本确实使用了`sendNativeMessage`函数到`com.microsoft.browsercore`命名空间。

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

根据[文档](https://developer.chrome.com/extensions/nativeMessaging)，这需要在`HKCU\Software\Google\Chrome\NativeMessagingHosts`中的注册表键，确实存在于我们在扩展程序中看到的`com.microsoft.browsercore`名称。它指向了`C:\Windows\BrowserCore\manifest.json`，其中包含了哪些扩展程序被允许调用`BrowserCore.exe`二进制文件的引用。注意`C:\Windows\BrowserCore`是Windows 10最近内部版本中的位置，在旧版本中位于`C:\Program Files\Windows Security\BrowserCore`。

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

以及`manifest.json`：
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
要查看发送到此进程的内容，我在运行Sysinternals的Process Monitor时登录了几次，它捕获了进程命令行：

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
正如我们所见，Chrome 正在使用命名管道（named pipes）向 `stdin` 提供信息，并使用另一个管道来读取 `stdout`。我认为查看通过这些命名管道发送的内容的最佳方式是尝试拦截或监控流量。我找不到一个开源工具可以轻松地监控命名管道，所以我不得不选择使用商业软件 Pipe Monitor 来自 [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html)（他们确实提供了我使用的评估版本）。这个方法效果很好，在清除了 cookies 并重新登录 Office.com 后，我看到了命名管道通信出现：

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

如 `nativeMessaging` 文档中已经提到的，前几个字节是消息的总长度，其余的是传输给本地组件的数据（以 JSON 格式）。JSON 的内容如下：
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
它随后会收到一个包含刷新令牌cookie的类似JSON响应，该令牌（像Azure AD中的其他令牌一样）是一个JSON Web Token（JWT）：
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
当我们解码这个JWT时，我们可以看到它包含了PRT本身和一个nonce，这个nonce将cookie与当前正在进行的登录操作绑定在一起：
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Azure中的大多数JWT都是由Azure AD管理的密钥签名的，但在这种情况下，包含**PRT的JWT是由设备TPM中的会话密钥签名的**。PRT本身是一个**加密的数据块**，设备上的任何密钥都无法解密，因为这包含了由Azure AD管理的身份声明。

### 登录过程

Azure AD中所有重要认证发生的主域是`login.microsoftonline.com`。这是一个**发送凭证和请求及更新令牌**的域。

这个请求尚未包含PRT cookie，但由于它使用了Chrome用户代理，我们会看到一个包含JavaScript代码与Chrome扩展交互的“正在重定向”页面。

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

当我们查看从扩展发送到本地组件的URL时，这个URL由我们正在访问的URL加上**`sso_nonce`**参数组成（该参数通过页面上的JavaScript传递给扩展）。然后，这个nonce被**反射回令牌中**，实质上将带有PRT的签名JWT绑定到这次特定的登录。我不确定登录页面如何处理状态以及它是否/在哪里存储这个nonce，但它不会接受一个带有不同nonce的JWT。

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### 摆脱nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

现在我们已经弄清楚了如何与`BrowserCore.exe`交互，我用Python编写了一个小工具，它可以启动进程并直接向它的`stdin`和`stdout`写入JSON。然后它读取回复并解码，允许我们为任意URL请求PRT cookies。
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
在我玩弄这个的时候，我注意到大多数URL中的参数并不是获取有效PRT cookie所必需的。例如，一个带有`https://login.microsoftonline.com/?sso_nonce=aaaaa"`的URL就足以用nonce `aaaaa`获取一个有效的签名PRT cookie。

在我的测试中，**PRT cookie大约在35分钟后过期**，之后就不能再用来登录了。大多数进行自己会话管理的网站会让你保持登录状态一段时间，因为它可以使用**刷新令牌**来延长访问权限，但是只使用隐式**OAuth2**流程的网站只会发放一个访问令牌。这个访问**令牌在一个小时后过期**，这意味着如果你使用PRT cookie在这样的网站上登录，你将在一个小时后再次被登出。这也意味着如果你因为某种原因失去了对设备的访问权限，对Azure AD的访问权限也会丢失。

### 使用PRT cookie与公共客户端 <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

我很好奇我们是否可以使用SSO与其他Azure AD应用程序，例如Azure PowerShell模块。当我们运行`Connect-AzureAD` cmdlet时，会弹出一个提示我们登录的窗口，并且没有发生SSO。~~我不确定为什么会这样，也许它还不支持~~正如[cnotin指出的](https://twitter.com/cnotin/status/1285734903389265922?s=20)，如果指定了`-AccountId`参数，SSO确实会发生，但即使没有指定，HTTP头中也包含了PRT cookie在`x-ms-RefreshTokenCredential`中：

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

尽管存在PRT cookie，**但没有发生SSO**。这是由于`prompt=login`参数导致的，它明确强制出现登录提示，而不是直接登录用户。我不确定PowerShell模块使用的是什么框架，但我假设它与文档中提到的WAM框架有关（用户代理指向Internet Explorer？）。当我们在HTTP请求中移除`prompt`参数时，我们确实得到了一个授权码：

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

这个代码用于[OAuth2授权码流程](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow)，我们可以使用它来**获取访问令牌和刷新令牌**。因为Azure AD PowerShell模块是一个_公共_应用程序，在使用这个授权码请求访问和刷新令牌时不涉及任何秘密。对于所有移动和本地应用程序都是如此，因为没有后端，没有办法安全地存储这样的秘密，这些客户端直接与各种API通信。这也在同一页面上[有文档说明](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token)。在这个例子中，我使用的是Azure PowerShell模块，因为它默认有相当多的权限，但还有其他的。我在我的[BlueHat演讲](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf)的第24页描述了一些这样的应用程序。你也可以使用ROADrecon**找到公共客户端**。对于同一租户中存在的第一方应用程序（应用程序），这会在概览中显示为一列。对于不在你的租户中，但确实有服务主体的应用程序（如大多数Office 365应用程序），你可以在ApplicationRefs表中的数据库中找到公共客户端：

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

通过将获得的授权码发送到正确的端点（`https://login.microsoftonline.com/Common/oauth2/token`），我们获得了访问令牌和刷新令牌。尽管刷新令牌通常不会发送给应用程序，而是由WAM保护，但通过我们自己发送请求，我们可以毫无问题地获得这两个令牌：

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

结果JSON响应：

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## 令牌声明和影响 <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

通过这个过程发放的访问令牌和刷新令牌将具有与PRT相同的声明。因此，如果在使用SSO的应用程序中进行了MFA认证，**PRT将包含MFA声明**[根据文档](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim)。这意味着在大多数情况下，以这种方式获得的**刷新令牌**将**包含MFA声明**，因此将满足需要MFA的Conditional Access策略。此外，由于PRT是发给Azure AD加入的设备，我们使用PRT cookie获得的令牌也包含设备ID，使其满足需要合规或混合设备的策略：

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

所以简而言之，无论登录保护有多强，一旦攻击者在具有SSO能力的机器上获得代码执行权限，他们就可以**利用SSO获取满足最严格Conditional Access策略的令牌**。实际上，我迄今为止测试的机器使用YubiKey和FIDO2进行认证。然而，在获得刷新令牌后，攻击者可以访问用户的数据，如电子邮件或OneDrive文件，而不需要拥有硬件安全令牌。这提供了一种持久性方式，因为**刷新令牌不再与设备上的任何加密内容绑定**，并且使用正确的应用程序ID，大多数Office 365 API都可以被访问，因为有几个默认应用程序对这些API有完全的权限。刷新令牌默认有效期为90天，但如果你使用它，你会被发放一个新的刷新令牌，其有效期被延长。所以一旦你拥有这个令牌，只要你每隔几周刷新一次令牌，就可以保持访问权限。[曾经有](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes)一个预览版的配置选项，可以限制发放给公共客户端的刷新令牌的生命周期，但这不再被支持。我不确定设置[登录频率](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime)如何与所有这些联系起来，但我的假设是，使用这样的策略会限制刷新令牌的有效性。还有一些更有趣的观察：

* 当**设备**在Azure AD中被**禁用**时，**PRT将停止工作**。
* 使用PRT获得的**刷新令牌即使设备被禁用也仍然有效**。唯一的例外是，当设备被禁用时，它将**不再通过需要管理或合规设备的Conditional Access策略**。
* **获取刷新令牌**算作一次登录，并且会在Azure AD的登录日志中**记录**。然而，**刷新**刷新令牌并用它获取访问令牌**不算作登录**，并且不会在登录日志中记录。
* 如果有涉及特定IP作为受信任位置的策略，并且拒绝来自这些位置之外的登录，这将在使用刷新令牌请求新的访问令牌时仍然触发。

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## 攻击

查看如何从受损设备获取PRT令牌并使用它访问Azure的页面：

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。

</details>
