# Az - プライマリリフレッシュトークン (PRT)

<details>

<summary><strong>AWSのハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>

**以下の投稿は** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) **からコピーされました**

## 基本情報

**プライマリリフレッシュトークン**は、Active Directoryの長期的な**永続的なチケット付与チケット (TGT)** に例えることができます。これは、ユーザーがAzure ADに接続されたデバイスで**一度サインインすると**、その後**自動的にAzure ADに接続されたリソースにサインインする**ことを可能にするトークンです。

プライマリリフレッシュトークンは、**任意のアプリケーションに対して認証を行うために使用**できます。これが、Microsoftがこのトークンに追加の保護を適用している理由です。最も重要な保護は、**TPM**があるデバイスでは、暗号化キーがそのTPM内に格納され、ほとんどの状況下で**OS自体から実際のキーを回復することができない**ということです。プライマリリフレッシュトークンに関するかなり詳細なドキュメントが[こちらにあります](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)。技術的な詳細が多く含まれているため、全文を読むことをお勧めしますが、この投稿の目的のために、ここでは最も重要なポイントをいくつか挙げます：

* TPMが存在する場合、PRTを要求または使用するために必要なキーは**TPMによって保護され**、通常の状況下では抽出できません。
* **デバイスでMFAが使用されると、PRTはMFAクレームで更新され**、その後MFAを要求するリソースへのSSOを可能にします。
* **PRTにはデバイスIDが含まれており**、Azure AD内のデバイスオブジェクトに**紐付けられています**。これは、準拠したデバイスを要求する条件付きアクセスポリシーにトークンをマッチさせるために使用できます。
* デバイスがAzure ADで無効にされると、**PRTは無効になり**、その時点で新しいトークンを要求するためには使用できなくなります。
* SSO中に**PRTはリフレッシュトークンとアクセストークンを要求するために使用されます**。リフレッシュトークンは**CloudAPプラグインによって保持され、DPAPIで暗号化されます**。アクセストークンは要求したアプリケーションに渡されます。

これに関して注目すべき点は、これらの保護の多くが**TPM**を使用しており、ハイブリッドジョインでは**オプション**であるということです。TPMがない場合、**キーはソフトウェア内に保存されます**。このシナリオでは、適切な権限を持つ場合、OSから**それらを回復することが可能です**。さらに研究が必要な注目すべき点は、[PRTドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token)全体で何度も言及されている**セッションキー**です。これは、トランスポートキーを使用して復号され、その後TPMに格納されます。これがTPM内で完全に行われる単一のステップでない限り、**セッションキーがメモリ内で暗号化されていない状態になる短いウィンドウが提供される可能性があり**、その時点でシステム上に既にいる攻撃者によって傍受される可能性があります。セッションキーが特定の時点で更新または変更される場合、このキーを傍受する機会が増える可能性があります。

## シングルサインオン <a href="#single-sign-on" id="single-sign-on"></a>

PRTドキュメントに記載されているように、PRTは**Azure ADリソースへのシングルサインオンを可能にします**。Edgeではこれがネイティブに行われますが、**Chromeではネイティブには行われません**。Chromeでは、この機能を有効にするためにMicrosoftから提供されているChrome拡張機能を使用します。

### Chrome拡張機能によるPRT <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Windows 10でSSOを提供するためにMicrosoftが提供している[Chrome拡張機能](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en)から始めましょう。拡張機能がインストールされ、office.comなどのAzure ADに接続されたアプリケーションにアクセスすると、サインインプロセスは何も求められることなく、ただちにアカウントに直行します。Chrome拡張機能はJavaScriptで書かれているため、お気に入りのエディタでコードを読み込むことができます。参考までに、拡張機能は`C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`に保存されています。そのマニフェストでは、`nativeMessaging`の権限が宣言されており、`background.js`スクリプトは実際に`com.microsoft.browsercore`名前空間に対して`sendNativeMessage`関数を使用しています。

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

[ドキュメント](https://developer.chrome.com/extensions/nativeMessaging)によると、これには`HKCU\Software\Google\Chrome\NativeMessagingHosts`にレジストリキーが必要であり、実際に拡張機能で見た`com.microsoft.browsercore`名のために存在しています。これは、`C:\Windows\BrowserCore\manifest.json`を指しており、どの拡張機能が`BrowserCore.exe`バイナリを呼び出すことが許可されているかを参照しています。注意すべきは、`C:\Windows\BrowserCore`はWindows 10の最近のインサイダービルドの場所であり、古いバージョンでは`C:\Program Files\Windows Security\BrowserCore`に位置しています。

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

そして`manifest.json`：
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
プロセスに何が送信されるかを確認するために、SysinternalsのProcess Monitorが実行中の間に数回サインインし、プロセスコマンドラインをキャプチャしました：

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Chromeは名前付きパイプを使用して`stdin`に情報を供給し、別のパイプを使用して`stdout`を読み取っていることがわかります。これらの名前付きパイプを介して送信される内容を確認する最良の方法は、トラフィックを傍受または監視することだと考えました。オープンソースのツールで名前付きパイプの監視を容易に行えるものは見つけられなかったため、商用の[IO Ninja](https://ioninja.com/plugins/pipe-monitor.html)のPipe Monitorを使用することにしました（評価版を使用しました）。これはかなりうまく機能し、Office.comに再度サインインしてクッキーをクリアした後、名前付きパイプ通信が表示されました：

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

すでに`nativeMessaging`のドキュメンテーションで述べたように、最初の数バイトはメッセージの全長であり、残りはネイティブコンポーネントに転送されるデータ（JSON形式）です。JSONは以下の通りです：
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
それから、リフレッシュトークンクッキーを含む類似のJSONレスポンスを受け取ります。これは（Azure ADの他のトークンと同様に）JSON Web Token（JWT）です：
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
JWTをデコードすると、PRT自体と、現在実行されているログインにクッキーを結びつけるnonceが含まれていることがわかります：
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
AzureのほとんどのJWTはAzure ADによって管理されるキーで署名されていますが、この場合に含まれる**PRTのJWTはデバイスのTPMにあるセッションキーで署名されています**。PRT自体は**暗号化されたblob**であり、デバイス上のどのキーでも復号化できません。なぜなら、これにはAzure ADによって管理されるアイデンティティクレームが含まれているからです。

### ログインプロセス

Azure ADで全ての重要な認証が行われるプライマリドメインは`login.microsoftonline.com`です。このドメインは、**資格情報が送信され、トークンが要求され、更新される場所**です。

このリクエストにはまだPRTクッキーが含まれていませんが、Chromeユーザーエージェントを使用しているため、「リダイレクト中」ページが表示され、Chrome拡張機能と対話するJavaScriptコードが含まれています。

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

拡張機能からネイティブコンポーネントに送信されるURLを見ると、このURLは私たちが訪れていたURLに**`sso_nonce`**パラメーター（ページ上のJavaScriptを介して拡張機能に渡される）が追加されています。このnonceは、**トークンに反映され**、この特定のログインにPRTを持つ署名されたJWTを結びつけます。ログインページがどのように状態を処理し、このnonceをどこに/どのように保存するかはわかりませんが、異なるnonceを持つJWTは受け入れられません。

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### nonceの取り除き方 <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

`BrowserCore.exe`とどのように対話できるかを理解したので、プロセスを起動し、JSONを直接その`stdin`と`stdout`に書き込む小さなPythonツールを書きました。それから応答を読み取り、解読し、任意のURLのPRTクッキーを要求することができます。
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
以下は、有効なPRTクッキーを取得するために必要なURLのパラメータのほとんどが不要であることに気づきました。例えば、`https://login.microsoftonline.com/?sso_nonce=aaaaa"`のURLだけで、nonce `aaaaa`を持つ有効な署名されたPRTクッキーを取得できます。

私のテストでは、**PRTクッキーは約35分後に期限切れ**になり、それ以降はサインインに使用できなくなりました。独自のセッション管理を行うほとんどのサイトでは、**リフレッシュトークン**を使用してアクセスを延長できるため、しばらくの間サインインしたままになりますが、暗黙的な**OAuth2**フローを使用するサイトはアクセストークンのみを発行します。このアクセス**トークンは1時間後に期限切れ**になるため、PRTクッキーを使用してそのようなサイトにサインインすると、1時間後に再度ログアウトされます。これはまた、何らかの理由でデバイスへのアクセスを失った場合、Azure ADへのアクセスも失われることを意味します。

### パブリッククライアントでのPRTクッキーの使用 <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Azure PowerShellモジュールなど、他のAzure ADアプリケーションでSSOを使用できるかどうかが気になりました。`Connect-AzureAD`コマンドレットを実行すると、ログインを促すポップアップボックスが開き、SSOは行われません。~~なぜこれが起こるのかは確信がありませんが、もしかするとまだサポートされていないのかもしれません~~ [cnotinさんが指摘](https://twitter.com/cnotin/status/1285734903389265922?s=20)してくれたように、`-AccountId`パラメータを指定するとSSOが行われますが、それがなくても`x-ms-RefreshTokenCredential` HTTPヘッダーにはPRTクッキーが含まれています：

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

それでも**SSOは行われず、PRTクッキーが存在しているにもかかわらず**です。これは、`prompt=login`パラメータによって、ユーザーを直接サインインさせるのではなく、ログインプロンプトが表示されるように明示的に強制されるためです。PowerShellモジュールが使用するフレームワークは何かはわかりませんが、ドキュメントで言及されているWAMフレームワーク（ユーザーエージェントはInternet Explorerを指している？）に関連していると思います。HTTPリクエストで`prompt`パラメータを削除すると、認証コードを取得できます：

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

このコードは[OAuth2認証コードフロー](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow)で使用され、**アクセストークンとリフレッシュトークンを取得**するために使用できます。Azure AD PowerShellモジュールは_パブリック_アプリケーションであるため、この認証コードを使用してアクセスとリフレッシュトークンを要求する際には秘密が関与しません。これは、バックエンドがなく、これらのクライアントが直接さまざまなAPIと通信するため、モバイルアプリやネイティブアプリにも当てはまります。これは同じページで[文書化](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token)されています。この例では、デフォルトでかなりの権限を持つAzure PowerShellモジュールを使用していますが、他にもあります。これらのいくつかは、私の[BlueHatトーク](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf)のスライド24で説明しています。また、ROADreconを使用して**パブリッククライアントを見つける**こともできます。第一者アプリケーション（同じテナント内に存在するアプリケーション）の場合、これは概要の列として表示されます。テナント内にないがサービスプリンシパルを持つアプリケーション（Office 365アプリケーションのほとんど）の場合、ApplicationRefsテーブルのデータベースでパブリッククライアントを見つけることができます：

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

取得した認証コードを正しいエンドポイント（`https://login.microsoftonline.com/Common/oauth2/token`）に送信することで、アクセストークンとリフレッシュトークンの両方を取得できます。通常、リフレッシュトークンはアプリに送信されずにWAMによって保護されていますが、自分でリクエストを送信することで、問題なく両方のトークンを取得できます：

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

結果のJSONレスポンス：

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## トークンのクレームとその意味 <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

このプロセスによって発行されるアクセストークンとリフレッシュトークンは、PRTが持っていたのと同じクレームを持ちます。したがって、SSOを使用するアプリでMFA認証が行われた場合、**PRTにはMFAクレームが含まれます**[ドキュメントによると](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim)。これは、ほとんどの場合、この方法で取得した**リフレッシュトークン**にも**MFAクレームが含まれる**ことを意味し、MFAを要求する条件付きアクセスポリシーを満たします。さらに、PRTはAzure ADに参加しているデバイスに発行されるため、PRTクッキーを使用して取得したトークンにもデバイスIDが含まれ、準拠またはハイブリッドデバイスを要求するポリシーを満たします：

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

簡単に言うと、ログイン保護がいかに強固であっても、SSO機能を持つマシンでコード実行を行う攻撃者は、**そのSSOを利用して、最も厳しい条件付きアクセスポリシーを満たすトークンを取得することができます**。実際、私がこれまでテストしていたマシンは、認証にFIDO2を持つYubiKeyを使用しています。しかし、リフレッシュトークンが取得された後、攻撃者はハードウェアセキュリティトークンを所持していなくても、ユーザーのデータ（例えばメールやOneDriveファイル）にアクセスできます。これは、**リフレッシュトークンがデバイス上の暗号的なものにはもはや結びついていない**ため、持続性の方法を提供します。適切なアプリケーションIDを持っていれば、Office 365のAPIにアクセスできるため、これらのAPIに対する完全な権限を持ついくつかのデフォルトアプリケーションがあります。リフレッシュトークンはデフォルトで90日間有効ですが、使用すると新しいリフレッシュトークンが発行され、有効期限が延長されます。したがって、このトークンを一度手に入れると、数週間ごとにトークンを更新する限り、アクセスを維持することができます。パブリッククライアントに発行されるリフレッシュトークンの寿命を制限するプレビューの設定オプションが[以前は存在しました](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes)が、それはもはやサポートされていません。[サインイン頻度](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime)の設定がこれとどのように関連しているかはわかりませんが、そのようなポリシーを使用するとリフレッシュトークンの有効性が制限されると思います。もう少し興味深い観察：

* **PRTは、それが属する**デバイスがAzure ADで**無効になると機能しなくなります**。
* PRTを使用して取得した**リフレッシュトークンは、デバイスが無効になっても有効です**。唯一の例外は、デバイスが無効になった場合、管理されているか準拠しているデバイスを要求する条件付きアクセスポリシーを**もはや通過しない**ことです。
* **リフレッシュトークンを取得する**ことはサインインと見なされ、Azure ADのサインインログに**記録されます**。しかし、**リフレッシュトークンを更新してアクセストークンを取得する**ことはサインインとは見なされず、サインインログには記録されません。
* 特定のIPを信頼された場所として関与させ、これ以外からのログインを拒否するポリシーがある場合、新しいアクセストークンを要求する際にリフレッシュトークンを使用すると、これがトリガーされます。

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## 攻撃

侵害されたデバイスからPRTトークンを取得し、Azureにアクセスする方法については、このページを確認してください：

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)です。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有してください**。

</details>
