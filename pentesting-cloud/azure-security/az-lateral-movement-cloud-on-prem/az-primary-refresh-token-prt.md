# Az - Primary Refresh Token (PRT)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Post copied from** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)

## Basic Information

A **Primary Refresh Token** can be compared to a long-term **persistent Ticket Granting Ticket (TGT)** in Active Directory. It is a token that enables users to **sign in once** on their Azure AD connected device and then **automatically sign in to Azure AD connected resources**.&#x20;

A Primary Refresh Token can be used to **authenticate to any application**. This is why Microsoft has applied extra protection to this token. The most important protection is that on devices with a **TPM**, the cryptographic keys are stored within that TPM, making it under most circumstances **not possible to recover the actual keys from the OS itself**. There is some quite extensive documentation about the Primary Refresh Token [available here](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token). I do suggest you read the whole article as it has quite some technical details, but for the purpose of this post, here are the most important points:

* If a TPM is present, the keys required to request or use the PRT are **protected by the TPM** and can‚Äôt be extracted under normal circumstances.
* **A PRT can get updated with an MFA claim when MFA is used on the device**, which enables SSO to resources requiring MFA afterwards.
* The **PRT contains the device ID** and is thus **tied to the device** object in Azure AD, this can be used to match the tokens against Conditional Access policies requiring compliant devices.
* The **PRT is invalidated when the device is disabled** in Azure AD and can‚Äôt be used any more to request new tokens at that point.
* During SSO the **PRT is used to request refresh and access tokens**. The refresh tokens are kept by the **CloudAP plug-in and encrypted with DPAPI**, the access tokens are passed to the requesting application.

Something to note on this is that quite a few of these protections use the **TPM**, which is **optional** in a Hybrid join. If there is no TPM the **keys are stored in software**. In this scenario it is possible to **recover them** from the OS with the right privileges. Another thing of note that warrants further research is the **Session key** which is mentioned several times throughout the [PRT documentation](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token), which is decrypted using the transport key and then stored into the TPM. Unless this is a single step taking place entirely within the TPM, this could provide a **brief window in which the session key is unencrypted in memory**, at which point it could be intercepted by an attacker already on the system. The number of opportunities to intercept this key could increase if the session key is renewed or changed at certain points in time.

## Single Sign On <a href="#single-sign-on" id="single-sign-on"></a>

As described in the PRT documentation, the PRT enables **single sign-on to Azure AD resources**. In Edge this is done natively (as expected), but **Chrome does not do this natively**, it uses a Chrome extension from Microsoft to enable this capability.

### PRT by the Chrome Extension <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Let‚Äôs start with the [Chrome extension](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en) t**hat Microsoft provides for SSO on Windows 10**. Once the extension is installed and you browse to an Azure AD connected application such as office.com, the sign-in process doesn‚Äôt prompt for anything but just continues straight to your account. Since Chrome extensions are written in JavaScript, you can just load the code in your favourite editor. For reference, the extensions are saved in `C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`. In its manifest, the permission `nativeMessaging` is declared, with the `background.js` script indeed using the `sendNativeMessage` function to the `com.microsoft.browsercore` namespace.

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

According to the [documentation](https://developer.chrome.com/extensions/nativeMessaging) this requires a registry key in `HKCU\Software\Google\Chrome\NativeMessagingHosts`, which is indeed present for the `com.microsoft.browsercore` name we saw in the extension. It points us to `C:\Windows\BrowserCore\manifest.json`, which contains a reference to which extensions are allowed to call the `BrowserCore.exe` binary. Note that `C:\Windows\BrowserCore` is the location in recent insider builds of Windows 10, in older versions it is located in `C:\Program Files\Windows Security\BrowserCore`.

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

And the `manifest.json`:

```json
{
  "name": "com.microsoft.browsercore",
  "description": "BrowserCore",
  "path": "BrowserCore.exe",
  "type": "stdio",
  "allowed_origins": [
    "chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
    "chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
  ]
}
```

To see what is sent to this process, I signed in a couple of times while Process Monitor from Sysinternals was running, which captured the process command line:

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```

As we see Chrome is using named pipes to feed information to `stdin` and another pipe to read `stdout`. I figured the best way to see what is sent over these named pipes was to try and intercept or monitor the traffic. I couldn‚Äôt find an open source tool that easily allowed monitoring of named pipes, so I had to opt for the commercial Pipe Monitor from [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html) (they do offer an evaluation version which I used for this). This worked pretty well and after clearing the cookies and signing back in to Office.com I saw the named pipe communication show up:

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

As already mentioned in the `nativeMessaging` documentation, the first few bytes are the total length of the message and the rest is the data (in JSON) transferred to the native component. The JSON is as follows:

```json
{
   "method":"GetCookies",
   "uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
   "sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```

It then gets back a similar JSON response containing the refresh token cookie, which is (like other tokens in Azure AD) a JSON Web Token (JWT):

```json
{
   "response":[
      {
         "name":"x-ms-RefreshTokenCredential",
         "data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
         "p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
         "flags":8256
      }
   ]
}
```

When we decode this JWT, we see it contains the PRT itself and a nonce, which ties the cookie to the current login that is being performed:

```json
{
  "refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
  "is_primary": "true",
  "request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```

Whereas most JWTs in Azure are signed with a key that is managed by Azure AD, in this case the JWT containing the **PRT is signed by the Session key that is in the devices TPM**. The PRT itself is an **encrypted blob** and can‚Äôt be decrypted by any keys on the device, because this contains the identity claims that are managed by Azure AD.

### The login process

The primary domain where all important authentication happens in Azure AD is `login.microsoftonline.com`. This is the domain where **credentials are sent and tokens are requested and renewed**.&#x20;

This request does not yet contain the PRT cookie, but since it uses the Chrome user agent, we are greeted by a ‚ÄúRedirecting‚Äù page which contains JavaScript code to interact with the Chrome extension.\


<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

When we look at the URL which is sent from the extension to the native component, this URL consists of the URL we were visiting, plus the **`sso_nonce`** parameter (which is passed to the extension via JavaScript on the page). This nonce is then **reflected back into the token**, essentially binding the signed JWT with PRT to this specific login. I‚Äôm not sure how the login page handles state and where/if it stores this nonce, but it won‚Äôt accept a JWT with a different nonce.

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### Getting rid of the nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

Now that we figured out how we can interact with `BrowserCore.exe`, I wrote a small tool in Python which spawns the process and writes the JSON directly to it‚Äôs `stdin` and `stdout`. It then reads the reply and decodes that, allowing us to request PRT cookies for an arbitrary URL.

```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```

Playing around with this a bit I noticed that most parameters in the URL are not required to get a valid PRT cookie. For example, a URL with `https://login.microsoftonline.com/?sso_nonce=aaaaa"` is enough to get a valid signed PRT cookie with the nonce `aaaaa`.

In my testing, the **PRT cookie expired after about 35 minutes**, after which it couldn‚Äôt be used any more to sign in. Most sites that do do their own session management will leave you signed in for a while since it can use the **refresh token** to extend the access, but sites that use the implicit **OAuth2** flow only give out an access token. This access **token expires after an hour**, meaning that if you use the PRT cookie to sign in on such a site, you will be logged out again after an hour. This also means that if you lose your access to the device for whatever reason, the access to Azure AD will also be lost.

### Using the PRT cookie with public clients <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

I was curious if we could use SSO with other Azure AD applications, such as the Azure PowerShell module. When we run the `Connect-AzureAD` cmdlet, a pop-up box opens prompting us to log in, and no SSO takes place. ~~I‚Äôm not sure why this is, maybe it is not supported yet~~ As [pointed out by @cnotin](https://twitter.com/cnotin/status/1285734903389265922?s=20) SSO does take place if the `-AccountId` parameter is specified, but even without it there is a PRT cookie included in the `x-ms-RefreshTokenCredential` HTTP header:

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

Yet **there is no SSO taking place, despite there being a PRT cookie**. This is caused by the `prompt=login` parameter, which explicitly force the login prompt to appear instead of signing in the user directly. I‚Äôm not sure what framework the PowerShell modules use, but I assume it is related to the WAM framework mentioned in the documentation (the user agent points to Internet Explorer?). When we remove the `prompt` parameter in the HTTP request, we do get an authorization code:

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

This code is used in the [OAuth2 authorization code flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), and we can use it to **obtain an access token and refresh token**. Because the Azure AD PowerShell module is a _public_ application, there is no secret involved in requesting the access and refresh token using this authorization code. This is the case for all mobile and native apps, since there is no way to securely store such a secret as there is no backend in place and these clients talk directly to the various API‚Äôs. This is also [documented](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token) on the same page. In this example I‚Äôm using the Azure PowerShell module because it has quite some permissions by default, but there are others. I‚Äôve described some of these in my [BlueHat talk](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf) on slide 24. You can also **find public clients using ROADrecon**. For first-party applications (applications that exist in the same tenant), this is shown as a column in the overview. For applications not in your tenant, but that do have a service principal (such as most of the Office 365 applications), you can find public clients in the database in the ApplicationRefs table:

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

By sending the obtained authorization code to the correct endpoint (`https://login.microsoftonline.com/Common/oauth2/token`) we obtain both an access token and a refresh token. Even though the refresh token is normally not sent to the app but protected by the WAM, by sending the request ourselves we can obtain both tokens without issue:

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

Resulting JSON response:

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## Token claims and implications <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

The access tokens and refresh tokens issued by this process will have the same claims as the PRT had. So if MFA authentication was performed in an app that uses SSO, the **PRT will contain the MFA claim** [as per the documentation](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim). This means that in most cases, the **refresh token** obtained by this manner will **include the MFA claim** and thus will satisfy Conditional Access policies that require MFA. Furthermore, since the PRT is issued to an Azure AD joined device, the tokens that we get by using the PRT cookie also contain the device ID, making it satisfy policies that require a compliant or Hybrid device:

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

So in short, no matter how strong the login protection, once an attacker gains code execution on a machine with SSO capabilities, they can **profit from that SSO to acquire a token that satisfies even the strictest Conditional Access policies**. In fact, the machine on which I‚Äôve been testing this so far is using a YubiKey with FIDO2 to authenticate. Yet after the refresh token is obtained, an attacker can access the users data such as email or OneDrive files without being in possession of the hardware security token. This offers a way of persistence since the **refresh token is no longer tied to anything cryptographicly on the device**, and with the right application ID most of the Office 365 APIs can be accessed since there are several default applications that have full permissions on those APIs. The refresh token is valid for 90 days by default, but if you use it you are issued a new refresh token which has an extended validity. So once you have this token the access can be kept as long as you refresh the token every few weeks. There [used to be](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes) a configuration option in preview which could limit the lifetime of a refresh token issued to public clients but that is no longer supported. I‚Äôm not sure how setting the [sign-in frequency](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime) ties in with all this, but my assumption is that using such a policy would limit the validity of refresh tokens. A few more interesting observations:

* The **PRT will stop working** when the **device** it belongs to is **disabled** in Azure AD.
* The **refresh token obtained using the PRT stays valid even if the device is disabled**. The only exception is that when the device is disabled it will **no longer pass Conditional Access policies** that require a managed or compliant device.
* **Obtaining a refresh token** counts as a sign-in and is **logged in** the sign-in log of Azure AD. **Refreshing** the **refresh token and obtaining an access token** with it however does **not count as a sign-in** and is not logged in the Sign-in log.
* If there are policies that involve a specific IP as trusted location, and deny logins from outside these, this will still trigger when the refresh token is used to request a new access token.

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## Attack

Check how to obtain a PRT token from a compromised device and use it to access Azure in this page:

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
