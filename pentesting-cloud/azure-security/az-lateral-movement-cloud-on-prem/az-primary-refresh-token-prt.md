# Az - Primary Refresh Token (PRT)

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Post copiado de** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) aunque otro post que explica lo mismo se puede encontrar en [**https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30**](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)

## Información Básica

Un **Primary Refresh Token** puede compararse con un **Ticket Granting Ticket (TGT) persistente a largo plazo** en Active Directory. Es un token que permite a los usuarios **iniciar sesión una vez** en su dispositivo conectado a Azure AD y luego **iniciar sesión automáticamente en recursos conectados a Azure AD**.&#x20;

Un Primary Refresh Token puede usarse para **autenticarse en cualquier aplicación**. Por eso Microsoft ha aplicado protecciones adicionales a este token. La protección más importante es que en dispositivos con un **TPM**, las claves criptográficas se almacenan dentro de ese TPM, lo que hace que bajo la mayoría de las circunstancias **no sea posible recuperar las claves reales desde el propio SO**. Hay documentación bastante extensa sobre el Primary Refresh Token [disponible aquí](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token). Te sugiero que leas el artículo completo ya que tiene bastantes detalles técnicos, pero para el propósito de este post, aquí están los puntos más importantes:

* Si hay un TPM presente, las claves requeridas para solicitar o usar el PRT están **protegidas por el TPM** y no pueden ser extraídas bajo circunstancias normales.
* **Un PRT puede actualizarse con una afirmación de MFA cuando se usa MFA en el dispositivo**, lo que permite SSO a recursos que requieren MFA después.
* El **PRT contiene el ID del dispositivo** y por lo tanto está **vinculado al objeto del dispositivo** en Azure AD, esto puede usarse para hacer coincidir los tokens con políticas de Acceso Condicional que requieren dispositivos compatibles.
* El **PRT se invalida cuando el dispositivo se deshabilita** en Azure AD y no puede usarse más para solicitar nuevos tokens en ese punto.
* Durante el SSO, el **PRT se usa para solicitar tokens de actualización y acceso**. Los tokens de actualización son mantenidos por el **plug-in de CloudAP y cifrados con DPAPI**, los tokens de acceso se pasan a la aplicación solicitante.

Algo a tener en cuenta es que varias de estas protecciones usan el **TPM**, que es **opcional** en una unión híbrida. Si no hay TPM, las **claves se almacenan en software**. En este escenario es posible **recuperarlas** del SO con los privilegios adecuados. Otro punto a investigar más a fondo es la **clave de sesión** que se menciona varias veces a lo largo de la [documentación de PRT](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token), que se descifra usando la clave de transporte y luego se almacena en el TPM. A menos que este sea un paso único que ocurre enteramente dentro del TPM, esto podría proporcionar una **breve ventana en la que la clave de sesión está desencriptada en memoria**, momento en el cual podría ser interceptada por un atacante ya en el sistema. El número de oportunidades para interceptar esta clave podría aumentar si la clave de sesión se renueva o cambia en ciertos momentos.

## Single Sign On <a href="#single-sign-on" id="single-sign-on"></a>

Como se describe en la documentación de PRT, el PRT permite **single sign-on a recursos de Azure AD**. En Edge esto se hace de forma nativa (como se esperaba), pero **Chrome no lo hace de forma nativa**, utiliza una extensión de Chrome de Microsoft para habilitar esta capacidad.

### PRT por la Extensión de Chrome <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Empecemos con la [extensión de Chrome](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en) que Microsoft proporciona para SSO en Windows 10. Una vez instalada la extensión y cuando navegas a una aplicación conectada a Azure AD como office.com, el proceso de inicio de sesión no solicita nada, sino que continúa directamente a tu cuenta. Dado que las extensiones de Chrome están escritas en JavaScript, puedes cargar el código en tu editor favorito. Para referencia, las extensiones se guardan en `C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`. En su manifiesto, se declara el permiso `nativeMessaging`, con el script `background.js` usando efectivamente la función `sendNativeMessage` al espacio de nombres `com.microsoft.browsercore`.

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

Según la [documentación](https://developer.chrome.com/extensions/nativeMessaging), esto requiere una clave de registro en `HKCU\Software\Google\Chrome\NativeMessagingHosts`, que de hecho está presente para el nombre `com.microsoft.browsercore` que vimos en la extensión. Nos señala a `C:\Windows\BrowserCore\manifest.json`, que contiene una referencia a qué extensiones están permitidas para llamar al binario `BrowserCore.exe`. Nota que `C:\Windows\BrowserCore` es la ubicación en versiones recientes de Windows 10, en versiones anteriores se encuentra en `C:\Program Files\Windows Security\BrowserCore`.

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

Y el `manifest.json`:
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
Para ver qué se envía a este proceso, inicié sesión un par de veces mientras Process Monitor de Sysinternals estaba en ejecución, lo que capturó la línea de comandos del proceso:

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Como vemos, Chrome está utilizando tuberías con nombre para alimentar información a `stdin` y otra tubería para leer `stdout`. Pensé que la mejor manera de ver qué se envía a través de estas tuberías con nombre era intentar interceptar o monitorear el tráfico. No pude encontrar una herramienta de código abierto que permitiera fácilmente el monitoreo de tuberías con nombre, así que tuve que optar por el Monitor de Tubos comercial de [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html) (ofrecen una versión de evaluación que utilicé para esto). Esto funcionó bastante bien y después de borrar las cookies y volver a iniciar sesión en Office.com, vi aparecer la comunicación de la tubería con nombre:

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

Como ya se mencionó en la documentación de `nativeMessaging`, los primeros bytes son la longitud total del mensaje y el resto son los datos (en JSON) transferidos al componente nativo. El JSON es el siguiente:
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
Luego recibe una respuesta JSON similar que contiene la cookie del token de actualización, que es (como otros tokens en Azure AD) un JSON Web Token (JWT):
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
Al decodificar este JWT, vemos que contiene el PRT en sí y un nonce, que vincula la cookie al inicio de sesión actual que se está realizando:
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Mientras que la mayoría de los JWT en Azure están firmados con una clave que es gestionada por Azure AD, en este caso el JWT que contiene el **PRT está firmado por la clave de sesión que está en el TPM del dispositivo**. El PRT en sí es un **blob cifrado** y no puede ser descifrado por ninguna clave en el dispositivo, porque esto contiene las afirmaciones de identidad que son gestionadas por Azure AD.

### El proceso de inicio de sesión

El dominio principal donde ocurre toda la autenticación importante en Azure AD es `login.microsoftonline.com`. Este es el dominio donde se **envían las credenciales y se solicitan y renuevan los tokens**.

Esta solicitud aún no contiene la cookie PRT, pero dado que utiliza el agente de usuario de Chrome, nos recibe una página de "Redireccionamiento" que contiene código JavaScript para interactuar con la extensión de Chrome.

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

Cuando observamos la URL que se envía desde la extensión al componente nativo, esta URL consiste en la URL que estábamos visitando, más el parámetro **`sso_nonce`** (que se pasa a la extensión a través de JavaScript en la página). Este nonce se **refleja de vuelta en el token**, vinculando esencialmente el JWT firmado con PRT a este inicio de sesión específico. No estoy seguro de cómo la página de inicio de sesión maneja el estado y dónde, si es que lo hace, almacena este nonce, pero no aceptará un JWT con un nonce diferente.

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### Deshacerse del nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

Ahora que descubrimos cómo podemos interactuar con `BrowserCore.exe`, escribí una pequeña herramienta en Python que inicia el proceso y escribe el JSON directamente en su `stdin` y `stdout`. Luego lee la respuesta y la decodifica, permitiéndonos solicitar cookies PRT para una URL arbitraria.
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
Jugando un poco con esto, noté que la mayoría de los parámetros en la URL no son necesarios para obtener una cookie PRT válida. Por ejemplo, una URL con `https://login.microsoftonline.com/?sso_nonce=aaaaa"` es suficiente para obtener una cookie PRT firmada válida con el nonce `aaaaa`.

En mis pruebas, la **cookie PRT expiró después de unos 35 minutos**, después de lo cual no se pudo utilizar más para iniciar sesión. La mayoría de los sitios que realizan su propia gestión de sesiones te mantendrán conectado durante un tiempo, ya que pueden usar el **token de actualización** para extender el acceso, pero los sitios que utilizan el flujo implícito de **OAuth2** solo entregan un token de acceso. Este token de acceso **expira después de una hora**, lo que significa que si usas la cookie PRT para iniciar sesión en un sitio de este tipo, se cerrará la sesión después de una hora. Esto también significa que si pierdes el acceso al dispositivo por cualquier motivo, también se perderá el acceso a Azure AD.

### Uso de la cookie PRT con clientes públicos <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Tenía curiosidad por saber si podríamos usar SSO con otras aplicaciones de Azure AD, como el módulo de PowerShell de Azure. Cuando ejecutamos el cmdlet `Connect-AzureAD`, se abre una ventana emergente que nos pide iniciar sesión, y no se realiza SSO. ~~No estoy seguro de por qué es esto, tal vez no se admite todavía~~ Como [señaló @cnotin](https://twitter.com/cnotin/status/1285734903389265922?s=20) SSO sí se realiza si se especifica el parámetro `-AccountId`, pero incluso sin él hay una cookie PRT incluida en el encabezado HTTP `x-ms-RefreshTokenCredential`:

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

Sin embargo, **no se realiza SSO, a pesar de que hay una cookie PRT**. Esto es causado por el parámetro `prompt=login`, que fuerza explícitamente la aparición del mensaje de inicio de sesión en lugar de iniciar sesión directamente al usuario. No estoy seguro de qué marco utilizan los módulos de PowerShell, pero asumo que está relacionado con el marco WAM mencionado en la documentación (¿el agente de usuario apunta a Internet Explorer?). Cuando eliminamos el parámetro `prompt` en la solicitud HTTP, obtenemos un código de autorización:

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

Este código se utiliza en el [flujo de código de autorización OAuth2](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), y podemos usarlo para **obtener un token de acceso y un token de actualización**. Debido a que el módulo de PowerShell de Azure AD es una aplicación _pública_, no hay ningún secreto involucrado en la solicitud del token de acceso y actualización utilizando este código de autorización. Esto es así para todas las aplicaciones móviles y nativas, ya que no hay forma de almacenar de manera segura dicho secreto, ya que no hay un backend en su lugar y estos clientes hablan directamente con las diversas API. Esto también está [documentado](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token) en la misma página. En este ejemplo estoy usando el módulo de PowerShell de Azure porque tiene bastantes permisos por defecto, pero hay otros. He descrito algunos de estos en mi [charla de BlueHat](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf) en la diapositiva 24. También puedes **encontrar clientes públicos usando ROADrecon**. Para aplicaciones de primera parte (aplicaciones que existen en el mismo inquilino), esto se muestra como una columna en la vista general. Para aplicaciones que no están en tu inquilino, pero que tienen un principal de servicio (como la mayoría de las aplicaciones de Office 365), puedes encontrar clientes públicos en la base de datos en la tabla ApplicationRefs:

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

Al enviar el código de autorización obtenido al punto final correcto (`https://login.microsoftonline.com/Common/oauth2/token`) obtenemos tanto un token de acceso como un token de actualización. Aunque normalmente el token de actualización no se envía a la aplicación sino que está protegido por el WAM, al enviar la solicitud nosotros mismos podemos obtener ambos tokens sin problemas:

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

Respuesta JSON resultante:

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## Reclamaciones de tokens e implicaciones <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

Los tokens de acceso y actualización emitidos por este proceso tendrán las mismas reclamaciones que tenía el PRT. Entonces, si se realizó la autenticación MFA en una aplicación que utiliza SSO, el **PRT contendrá la reclamación MFA** [según la documentación](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim). Esto significa que, en la mayoría de los casos, el **token de actualización** obtenido de esta manera **incluirá la reclamación MFA** y, por lo tanto, satisfará las políticas de Acceso Condicional que requieren MFA. Además, dado que el PRT se emite a un dispositivo unido a Azure AD, los tokens que obtenemos al usar la cookie PRT también contienen el ID del dispositivo, lo que los hace satisfacer políticas que requieren un dispositivo compatible o híbrido:

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

En resumen, no importa cuán fuerte sea la protección de inicio de sesión, una vez que un atacante obtiene ejecución de código en una máquina con capacidades de SSO, pueden **aprovechar ese SSO para adquirir un token que satisface incluso las políticas de Acceso Condicional más estrictas**. De hecho, la máquina en la que he estado probando esto hasta ahora está utilizando un YubiKey con FIDO2 para autenticarse. Sin embargo, después de obtener el token de actualización, un atacante puede acceder a los datos del usuario, como el correo electrónico o los archivos de OneDrive, sin estar en posesión del token de seguridad de hardware. Esto ofrece una forma de persistencia ya que el **token de actualización ya no está vinculado criptográficamente al dispositivo**, y con el ID de aplicación correcto se puede acceder a la mayoría de las API de Office 365, ya que hay varias aplicaciones predeterminadas que tienen permisos completos en esas API. El token de actualización es válido por 90 días por defecto, pero si lo usas se te emite un nuevo token de actualización que tiene una validez extendida. Entonces, una vez que tienes este token, el acceso se puede mantener siempre y cuando actualices el token cada pocas semanas. [Solía haber](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes) una opción de configuración en vista previa que podría limitar la vida útil de un token de actualización emitido a clientes públicos, pero eso ya no se admite. No estoy seguro de cómo la configuración de la [frecuencia de inicio de sesión](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime) se relaciona con todo esto, pero mi suposición es que usar tal política limitaría la validez de los tokens de actualización. Algunas observaciones más interesantes:

* El **PRT dejará de funcionar** cuando el **dispositivo** al que pertenece esté **deshabilitado** en Azure AD.
* El **token de actualización obtenido usando el PRT sigue siendo válido incluso si el dispositivo está deshabilitado**. La única excepción es que cuando el dispositivo está deshabilitado, **ya no pasará las políticas de Acceso Condicional** que requieren un dispositivo administrado o compatible.
* **Obtener un token de actualización** cuenta como un inicio de sesión y se **registra en** el registro de inicio de sesión de Azure AD. **Actualizar** el **token de actualización y obtener un token de acceso** con él, sin embargo, **no cuenta como un inicio de sesión** y no se registra en el registro de inicio de sesión.
* Si hay políticas que involucran una IP específica como ubicación de confianza y niegan los inicios de sesión desde fuera de estas, esto aún se activará cuando se use el token de actualización para solicitar un nuevo token de acceso.

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## Ataque

Consulta cómo obtener un token PRT de un dispositivo comprometido y usarlo para acceder a Azure en esta página:

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

## [Roadtx](https://github.com/dirkjanm/ROADtools)

Esta herramienta permite realizar varias acciones como registrar una máquina en Azure AD para obtener un PRT, y usar PRTs (legítimos o robados) para acceder a recursos de varias maneras diferentes. Estos no son ataques directos, pero facilita el uso de PRTs para acceder a recursos de diferentes maneras. Encuentra más información en:

{% content-ref url="az-roadtx-authentication.md" %}
[az-roadtx-authentication.md](az-roadtx-authentication.md)
{% endcontent-ref %}

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
