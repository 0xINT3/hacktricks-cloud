# Az - Phishing Primary Refresh Token (Microsoft Entra)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Post copied form** [**https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/**](https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/)

## Basic Information

**Primary Refresh Tokens** are used for Single Sign On on devices that are Azure AD/Microsoft Entra joined, registered or hybrid joined. They can be used both in browser sign-in flows to web applications and for signing in to mobile and desktop applications running on the device.

Note that Primary Refresh tokens can be used to **request an access token to access the data**, but Access Tokens cannot be used to request a Primary Refresh Token.

To obtain a Primary Refresh Token you need to start with a device identity, and then use the users credentials to request a PRT. This limits how these powerful tokens can be issued and makes it harder for attackers to obtain them.

You can find more information about PRTs in:

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

## How the Flow Works

If one sets up a new Windows installation, usually it is only needed to authenticate once during the setup process, and this is interesting, since at the moment we start the setup the device is not yet joined or registered in Azure AD, but at the end we have a PRT that is used for SSO, and even meets the requirements to provision WHFB keys.

The process starts by signing in to a **specific application**, which gives Windows an **access token** and a **refresh token**. The access tokens can be used to **join the device to Azure AD** and **set up the device identity**. After the device registration, the **refresh token** which was issued without a device, is used with the **new device identity to request a Primary Refresh Token**.

{% hint style="info" %}
Therefore, it's possible to use a regular refresh token, that is not tied to a device but is **tied to a specific app**, to first **register a device** and then **request a more powerful token** that can be used in any sign-in scenario.
{% endhint %}

The ‚Äúupgrade‚Äù from normal refresh token to primary refresh token is not possible with every refresh token. It requires a specific application ID (client ID) in the sign-in flow. Windows uses the client ID `29d9ed98-a469-4536-ade2-f981bc1d605e` (Microsoft Authentication Broker) and resource `https://enrollment.manage.microsoft.com/` for this request. We can emulate this flow with the roadtx `gettokens` command, which supports several different authentication flows:

<figure><img src="../../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

If there is a policy that requires MFA to sign in, we can instead use the `interactiveauth` module:

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The resulting refresh token (which is cached in the `.roadtools_auth` file) can be used to request a token for the device registration service, where we can create the device:

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Now that we have a device identity, we can combine this with the same refresh token to obtain a PRT (both refresh tokens shortened for readability):

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Tokens resulting from the authentication will contain the same authentication method claims as used during the registration, so **any MFA usage will be transferred to the PRT**. The PRT that we get can be used in any authentication flow, so we can expand the scope of our limited refresh token to any possible app.

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We can also use this to sign in to browser flows:

<figure><img src="../../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Provisioning Windows Hello for Business keys <a href="#provisioning-windows-hello-for-business-keys" id="provisioning-windows-hello-for-business-keys"></a>

If you set up Windows and WHFB is enabled for your device, it will use the **same session to provision the WHFB key for the newly set up device**. To do this, we will need an access token with the `ngcmfa` (new generation credentials MFA) claim. As long as we did the **MFA authentication within the last 10 minutes**, the **PRT** from the **previous** step is all we need. We can ask **Azure AD to give us a token for the device registration** service that contains this claim, without requiring further user interaction. To do this, we use the `prtenrich` command from **roadtx**, which will ask for this token.

<figure><img src="../../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

With this new access token, we can provision the new WHFB key. This key can be used to also request new PRTs in the future, without needing access to the users password.

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

## Phishing for Primary Refresh Tokens <a href="#phishing-for-primary-refresh-tokens" id="phishing-for-primary-refresh-tokens"></a>

Now that we know how the process works, we can change the approach to make it usable for phishing. Phishing PRTs directly is not possible, since this requires an existing device identity to be used during the flow. We **cannot trick users or their endpoints in sending us the required information to directly request a PRT**. We can however use several methods to **ask for a regular refresh token with the right client and resource**, to then use that to **register a device and ask for a PRT**.

### Device code phishing <a href="#device-code-phishing" id="device-code-phishing"></a>

In the authentication step above, we used a username and password to authenticate. However, we can also use the **device code flow for this**. While Windows does not use this flow for the registration/join process, it is a **valid OAuth flow** which will give us the same **refresh token:**

<figure><img src="../../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

As you can see, the device code flow asks users to **enter a code on their own device and complete the authentication**, which will provide the tokens on the device it was initiated. This flow is also suitable for phishing, because if we can **convince our victim to perform the authentication with a device code, we will obtain tokens on their behalf**. This is not a new technique, but has been described by several people in the past. There are also several tool kits that **make the whole process easier**. If you want to read up on this technique, here are some references:

* [https://aadinternals.com/post/phishing/](https://aadinternals.com/post/phishing/)
* [https://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html](https://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html)
* [https://github.com/secureworks/squarephish](https://github.com/secureworks/squarephish)
* [https://www.blackhillsinfosec.com/dynamic-device-code-phishing/](https://www.blackhillsinfosec.com/dynamic-device-code-phishing/)

So let us assume we **convince a user to authenticate, and we receive the refresh token**. We can now use this **refresh token** to:

* **Register or join a device to Azure AD** if we don‚Äôt already have access to a device in the tenant.
* Use the **refresh token to ask for a PRT**.
* If the user performed ‚Äúfresh‚Äù MFA when authenticating with the device code flow, we can also **register WHFB credentials on their account for persistence**.

There are a few caveats to this, which you have to take into account if you are performing this attack:

* The **device code is only valid for 15 minutes** after you initiate the device code flow, which adds extra restrictions if you want to use this for phishing. Some tools account for this by only creating the device code once the user interacts with the email, for example via a QR code.
* **Registering or joining devices could be restricted in the tenant to only specific users**. In general, joining devices is restricted more often than registering them. Unless there are specific policies that require a certain device status, there won‚Äôt be a practical difference in the usability of the token.
* **Registering WHFB credentials is only possible if the user actively performed MFA when using the device code**. If they use the device code from an existing session their managed device, the MFA claim will be passed on to the refresh token and is most likely not recent enough to provision a WHFB key. In my testing, the cached sign-in status will only be used if the user has an existing session on an unmanaged device, and on browsers that signed in using SSO it will not automatically use the cached login.

The video below shows the attack as a proof of concept. In practical scenarios, you could use your preferred device code phishing framework or method to do the phishing part.

{% embed url="https://dirkjanm.io/assets/raw/prtphish.mp4" %}

The video above uses the [deviceCode2WinHello](https://github.com/kiwids0220/deviceCode2WinHello) script that automates all these steps, written by [Kai](https://twitter.com/mhskai2017) from SpecterOps (see conclusions at the end of the blog). It also uses the `roadtx keepassauth` module to do the authentication, in reality you would have to convince your victim to do the authentication, but this was easier for the demonstration.

### Credential phishing <a href="#credential-phishing" id="credential-phishing"></a>

It is also possible to perform the phishing attack using credential phishing methods, for example with evilginx as framework. If we use a Microsoft 365 phishlet to sign in, for example [this one](https://github.com/BakkerJan/evilginx3/blob/main/microsoft365.yaml) by Jan Bakker, we will obtain the session cookies for the victim. These session cookies can be used with roadtx to ask for the correct tokens, and from there on the attack is the same:

<figure><img src="../../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

## Prevention and detection <a href="#prevention-and-detection" id="prevention-and-detection"></a>

There are not many ways to prevent these attacks. Device code phishing is one of the few methods that is not prevented by requiring a certain MFA strength, since users perform this authentication against the legit Microsoft domains. In addition, there is unfortunately no way to block certain OAuth flows such as the device code flow. The credential phishing approach described above is easier to prevent, since this will happen on a fake website which will prevent some MFA methods from working.

The only real effective way to block this attack is to require a device to be managed via MDM or MAM, by having a Conditional Access policy in place that requires a compliant or hybrid joined device. Complying with this policy would require the newly registered device to also be enrolled in Intune. Provided Intune is locked down sufficiently to block people from enrolling non-corporate or fake devices, our newly registered device won‚Äôt be able to become compliant and meet the requirements of these policies. Note that the device registration flow itself is not blocked by policies requiring compliant devices, since this flow is by definition excluded from these policies (you cannot already have a compliant device during device registration). So, if policies are in place that require a compliant or hybrid joined device, it is still possible to obtain a PRT. The PRT can however not be used to authenticate or to enroll the WHFB keys since that would require the device to be compliant or hybrid joined.

Detection of this technique is fortunately easier. Windows will not use the Device Code flow to register or join itself to Azure AD, but it will interactively prompt the user to authenticate. Since the authentication flow is shown in the Sign-in logs, it is quite easy to write detection queries based on the app ID and the authentication flow. An example KQL query would look something like this:

```
SigninLogs 
| where AppId == "29d9ed98-a469-4536-ade2-f981bc1d605e" //Broker app client id
    and AuthenticationProtocol == "deviceCode"
```

During my discussions with Microsoft on this topic, I was informed that in some cases the device code flow is used legitimately by the broker application, so this query could yield some false positives. If you find some legit matches with this query, feel free to reach out so we can see if it is possible to fine-tune it to exclude legitimate cases.

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
