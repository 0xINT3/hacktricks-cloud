# Az - Phishing de Token de Actualización Primario (Microsoft Entra)

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Publicación copiada de** [**https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/**](https://dirkjanm.io/phishing-for-microsoft-entra-primary-refresh-tokens/)

## Información Básica

Los **Primary Refresh Tokens** se utilizan para Single Sign On en dispositivos que están unidos, registrados o unidos de forma híbrida a Azure AD/Microsoft Entra. Se pueden utilizar tanto en flujos de inicio de sesión en el navegador para aplicaciones web como para iniciar sesión en aplicaciones móviles y de escritorio que se ejecutan en el dispositivo.

Ten en cuenta que los Primary Refresh Tokens se pueden utilizar para **solicitar un token de acceso para acceder a los datos**, pero los Access Tokens no se pueden utilizar para solicitar un Primary Refresh Token.

Para obtener un Primary Refresh Token necesitas comenzar con una identidad de dispositivo y luego usar las credenciales del usuario para solicitar un PRT. Esto limita cómo se pueden emitir estos potentes tokens y dificulta que los atacantes los obtengan.

Puedes encontrar más información sobre los PRTs en:

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

## Cómo Funciona el Flujo

Si se configura una nueva instalación de Windows, generalmente solo es necesario autenticarse una vez durante el proceso de configuración, y esto es interesante, ya que en el momento en que comenzamos la configuración el dispositivo aún no está unido o registrado en Azure AD, pero al final tenemos un PRT que se utiliza para SSO, e incluso cumple con los requisitos para aprovisionar las llaves WHFB.

El proceso comienza al iniciar sesión en una **aplicación específica**, lo que proporciona a Windows un **token de acceso** y un **token de actualización**. Los tokens de acceso se pueden utilizar para **unir el dispositivo a Azure AD** y **configurar la identidad del dispositivo**. Después del registro del dispositivo, el **token de actualización**, que se emitió sin un dispositivo, se utiliza con la **nueva identidad del dispositivo para solicitar un Primary Refresh Token**.

{% hint style="info" %}
Por lo tanto, es posible utilizar un token de actualización regular, que no está vinculado a un dispositivo pero sí está **vinculado a una aplicación específica**, para primero **registrar un dispositivo** y luego **solicitar un token más poderoso** que se puede utilizar en cualquier escenario de inicio de sesión.
{% endhint %}

La "actualización" de token de actualización normal a Primary Refresh Token no es posible con cada token de actualización. Requiere una ID de aplicación específica (client ID) en el flujo de inicio de sesión. Windows utiliza el client ID `29d9ed98-a469-4536-ade2-f981bc1d605e` (Microsoft Authentication Broker) y el recurso `https://enrollment.manage.microsoft.com/` para esta solicitud. Podemos emular este flujo con el comando `gettokens` de roadtx, que admite varios flujos de autenticación diferentes:

<figure><img src="../../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

Si hay una política que requiere MFA para iniciar sesión, en su lugar podemos utilizar el módulo `interactiveauth`:

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

El token de actualización resultante (que se almacena en caché en el archivo `.roadtools_auth`) se puede utilizar para solicitar un token para el servicio de registro de dispositivos, donde podemos crear el dispositivo:

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ahora que tenemos una identidad de dispositivo, podemos combinarla con el mismo token de actualización para obtener un PRT (ambos tokens de actualización acortados para facilitar la lectura):

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Los tokens resultantes de la autenticación contendrán los mismos reclamos de método de autenticación que se usaron durante el registro, por lo que **cualquier uso de MFA se transferirá al PRT**. El PRT que obtenemos se puede utilizar en cualquier flujo de autenticación, por lo que podemos ampliar el alcance de nuestro token de actualización limitado a cualquier aplicación posible.

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

También podemos usar esto para iniciar sesión en flujos de navegador:

<figure><img src="../../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Aprovisionamiento de llaves Windows Hello for Business <a href="#provisioning-windows-hello-for-business-keys" id="provisioning-windows-hello-for-business-keys"></a>

Si configuras Windows y WHFB está habilitado para tu dispositivo, utilizará **la misma sesión para aprovisionar la llave WHFB para el dispositivo recién configurado**. Para hacer esto, necesitaremos un token de acceso con el reclamo `ngcmfa` (nueva generación de credenciales MFA). Mientras hayamos realizado la **autenticación MFA en los últimos 10 minutos**, el **PRT** del **paso anterior** es todo lo que necesitamos. Podemos pedirle a **Azure AD que nos dé un token para el servicio de registro de dispositivos** que contenga este reclamo, sin requerir más interacción del usuario. Para hacer esto, usamos el comando `prtenrich` de **roadtx**, que solicitará este token.

<figure><img src="../../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Con este nuevo token de acceso, podemos aprovisionar la nueva llave WHFB. Esta llave se puede utilizar para solicitar nuevos PRTs en el futuro, sin necesidad de acceso a la contraseña del usuario.

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

## Phishing de Primary Refresh Tokens <a href="#phishing-for-primary-refresh-tokens" id="phishing-for-primary-refresh-tokens"></a>

Ahora que sabemos cómo funciona el proceso, podemos cambiar el enfoque para hacerlo utilizable para phishing. No es posible hacer phishing de PRTs directamente, ya que esto requiere una identidad de dispositivo existente que se utilice durante el flujo. **No podemos engañar a los usuarios o sus endpoints para que nos envíen la información requerida para solicitar directamente un PRT**. Sin embargo, podemos utilizar varios métodos para **pedir un token de actualización regular con el cliente y recurso correctos**, para luego usar eso para **registrar un dispositivo y solicitar un PRT**.

### Phishing de código de dispositivo <a href="#device-code-phishing" id="device-code-phishing"></a>

En el paso de autenticación anterior, utilizamos un nombre de usuario y contraseña para autenticarnos. Sin embargo, también podemos usar el **flujo de código de dispositivo para esto**. Aunque Windows no utiliza este flujo para el proceso de registro/unión, es un **flujo OAuth válido** que nos dará el mismo **token de actualización:**

<figure><img src="../../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

Como puedes ver, el flujo de código de dispositivo pide a los usuarios que **ingresen un código en su propio dispositivo y completen la autenticación**, lo que proporcionará los tokens en el dispositivo en el que se inició. Este flujo también es adecuado para phishing, porque si podemos **convencer a nuestra víctima de realizar la autenticación con un código de dispositivo, obtendremos tokens en su nombre**. Esta no es una técnica nueva, pero ha sido descrita por varias personas en el pasado. También hay varios kits de herramientas que **facilitan todo el proceso**. Si quieres leer más sobre esta técnica, aquí hay algunas referencias:

* [https://aadinternals.com/post/phishing/](https://aadinternals.com/post/phishing/)
* [https://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html](https://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html)
* [https://github.com/secureworks/squarephish](https://github.com/secureworks/squarephish)
* [https://www.blackhillsinfosec.com/dynamic-device-code-phishing/](https://www.blackhillsinfosec.com/dynamic-device-code-phishing/)

Así que supongamos que **convencemos a un usuario de autenticarse y recibimos el token de actualización**. Ahora podemos usar este **token de actualización** para:

* **Registrar o unir un dispositivo a Azure AD** si aún no tenemos acceso a un dispositivo en el tenant.
* Utilizar el **token de actualización para solicitar un PRT**.
* Si el usuario realizó una autenticación MFA "fresca" al autenticarse con el flujo de código de dispositivo, también podemos **registrar credenciales WHFB en su cuenta para persistencia**.

Hay algunas advertencias a esto, que debes tener en cuenta si estás realizando este ataque:

* El **código de dispositivo solo es válido durante 15 minutos** después de iniciar el flujo de código de dispositivo, lo que agrega restricciones adicionales si quieres usar esto para phishing. Algunas herramientas tienen en cuenta esto al crear el código de dispositivo solo una vez que el usuario interactúa con el correo electrónico, por ejemplo, a través de un código QR.
* **Registrar o unir dispositivos podría estar restringido en el tenant solo a usuarios específicos**. En general, unir dispositivos se restringe con más frecuencia que registrarlos. A menos que haya políticas específicas que requieran un cierto estado del dispositivo, no habrá una diferencia práctica en la usabilidad del token.
* **Registrar credenciales WHFB solo es posible si el usuario realizó activamente MFA al usar el código de dispositivo**. Si usan el código de dispositivo desde una sesión existente en su dispositivo administrado, el reclamo MFA se transferirá al token de actualización y lo más probable es que no sea lo suficientemente reciente como para aprovisionar una llave WHFB. En mis pruebas, el estado de inicio de sesión en caché solo se utilizará si el usuario tiene una sesión existente en un dispositivo no administrado, y en los navegadores que iniciaron sesión usando SSO no se utilizará automáticamente el inicio de sesión en caché.

El video a continuación muestra el ataque como una prueba de concepto. En escenarios prácticos, podrías usar tu marco de phishing de código de dispositivo preferido o método para hacer la parte de phishing.

{% embed url="https://dirkjanm.io/assets/raw/prtphish.mp4" %}

El video anterior utiliza el script [deviceCode2WinHello](https://github.com/kiwids0220/deviceCode2WinHello) que automatiza todos estos pasos, escrito por [Kai](https://twitter.com/mhskai2017) de SpecterOps (ver conclusiones al final del blog). También utiliza el módulo `roadtx keepassauth` para hacer la autenticación, en realidad tendrías que convencer a tu víctima para que haga la autenticación, pero esto fue más fácil para la demostración.

### Phishing de credenciales <a href="#credential-phishing" id="credential-phishing"></a>

También es posible realizar el ataque de phishing utilizando métodos de phishing de credenciales, por ejemplo con evilginx como marco. Si usamos un phishlet de Microsoft 365 para iniciar sesión, por ejemplo [este](https://github.com/BakkerJan/evilginx3/blob/main/microsoft365.yaml) de Jan Bakker, obtendremos las cookies de sesión de la víctima. Estas cookies de sesión se pueden utilizar con roadtx para solicitar los tokens correctos, y a partir de ahí el ataque es el mismo:

<figure><img src="../../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

## Prevención y detección <a href="#prevention-and-detection" id="prevention-and-detection"></a>

No hay muchas formas de prevenir estos ataques. El phishing de código de dispositivo es uno de los pocos métodos que no se previene al requerir una cierta fuerza de MFA, ya que los usuarios realizan esta autenticación contra los dominios legítimos de Microsoft. Además, desafortunadamente no hay forma de bloquear ciertos flujos OAuth como el flujo de código de dispositivo. El enfoque de phishing de credenciales descrito anteriormente es más fácil de prevenir, ya que esto ocurrirá en un sitio web falso que evitará que algunos métodos de MFA funcionen.

La única forma realmente efectiva de bloquear este ataque es requerir que un dispositivo sea administrado a través de MDM o MAM, teniendo una política de Acceso Condicional en su lugar que requiera un dispositivo compatible o unido de forma híbrida. Cumplir con esta política requeriría que el dispositivo recién registrado también esté inscrito en Intune. Siempre que Intune esté lo suficientemente bloqueado para evitar que las personas inscriban dispositivos no corporativos o falsos, nuestro dispositivo recién registrado no podrá volverse compatible y cumplir con los requisitos de estas políticas. Ten en cuenta que el flujo de registro del dispositivo en sí no está bloqueado por políticas que requieren dispositivos compatibles, ya que este flujo está por definición excluido de estas políticas (no puedes tener ya un dispositivo compatible durante el registro del dispositivo). Por lo tanto, si hay políticas en vigor que requieren un dispositivo compatible o unido de forma híbrida, todavía es posible obtener un PRT. Sin embargo, el PRT no se puede utilizar para autenticarse o para inscribir las llaves WHFB ya que eso requeriría que el dispositivo sea compatible o unido de forma híbrida.

Afortunadamente, la detección de esta técnica es más fácil. Windows no utilizará el flujo de Código de Dispositivo para registrarse o unirse a Azure AD, sino que pedirá al usuario que se autentique de forma interactiva. Dado que el flujo de autenticación se muestra en los registros de inicio de sesión, es bastante fácil escribir consultas de detección basadas en la ID de la aplicación y el flujo de autenticación. Un ejemplo de consulta KQL podría verse así:
```
SigninLogs
| where AppId == "29d9ed98-a469-4536-ade2-f981bc1d605e" //Broker app client id
and AuthenticationProtocol == "deviceCode"
```
Durante mis conversaciones con Microsoft sobre este tema, me informaron que en algunos casos el flujo de código de dispositivo se utiliza legítimamente por la aplicación intermediaria, por lo que esta consulta podría generar algunos falsos positivos. Si encuentras coincidencias legítimas con esta consulta, no dudes en contactarme para que podamos ver si es posible ajustarla para excluir casos legítimos.

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
